<p>I'm getting a segfault when I run this. It looks like the debug prints, but when I debug it I just get an endless loop of backtrace. If anyone can help point me in the right direction, I'd appreciate it. I'd also appreciate, if possible any tips/tricks for cleaning up this grammar.</p>  <p>Thanks!</p>  <pre><code>//code here: /*** *I-EBNF parser * *This defines a grammar for BNF. */  //Speeds up compilation times. //This is a relatively small grammar, this is useful. #define BOOST_SPIRIT_NO_PREDEFINED_TERMINALS #define BOOST_SPIRIT_QI_DEBUG  #include &lt;boost/config/warning_disable.hpp&gt; #include &lt;boost/spirit/include/qi.hpp&gt; #include &lt;boost/spirit/include/phoenix_operator.hpp&gt; #include &lt;boost/fusion/adapted.hpp&gt; #include &lt;boost/fusion/support.hpp&gt; #include &lt;vector&gt; #include &lt;string&gt; #include &lt;iostream&gt;  namespace Parser {  namespace qi = boost::spirit::qi; namespace ascii = boost::spirit::ascii;  enum class RHSType {     Terminal, Identifier }; struct RHS {     RHSType type;     std::string value; }; struct Rule {     std::string identifier; //lhs     std::vector&lt;RHS&gt; rhs; }; }  //expose our structs to fusion: BOOST_FUSION_ADAPT_STRUCT(     Parser::RHS,     (Parser::RHSType, type)     (std::string, value) ) BOOST_FUSION_ADAPT_STRUCT(     Parser::Rule,     (std::string, identifier)     (std::vector&lt;Parser::RHS&gt;, rhs) )  namespace Parser { typedef std::vector&lt;Rule&gt; RuleList;  //our grammar definition template &lt;typename Iterator&gt; struct Grammar: qi::grammar&lt;Iterator, std::list&lt;Rule&gt;, ascii::space_type&gt; {     Grammar(): Grammar::base_type(rules)     {         qi::char_type char_;          letter = char_("a-zA-Z");         digit = char_('0', '9');         symbol = char_('[') | ']' | '[' | ']' | '(' | ')' | '&lt;' | '&gt;' | '\'' | '\"' | '=' | '|' | '.' | ',' | ';';         character = letter | digit | symbol | '_';         identifier = letter &gt;&gt; *(letter | digit | '_');         terminal = (char_('\'') &gt;&gt; character &gt;&gt; *character &gt;&gt; char_('\'')) | (char_('\"') &gt;&gt; character &gt;&gt; *character &gt;&gt; char_('\"'));         lhs = identifier;         rhs = terminal | identifier | char_('[') &gt;&gt; rhs &gt;&gt; char_(']') | char_('{') &gt;&gt; rhs &gt;&gt; char_('}') | char_('(') &gt;&gt; rhs &gt;&gt; char_(')') | rhs &gt;&gt; char_('|') &gt;&gt; rhs | rhs &gt;&gt; char_(',') &gt;&gt; rhs;         rule = identifier &gt;&gt; char_('=') &gt;&gt; rhs;         rules = rule &gt;&gt; *rule;     }  private:     qi::rule&lt;Iterator, char(), ascii::space_type&gt; letter, digit, symbol, character;     qi::rule&lt;Iterator, std::string(), ascii::space_type&gt; identifier, lhs, terminal;     qi::rule&lt;Iterator, RHS, ascii::space_type&gt; rhs;     qi::rule&lt;Iterator, Rule, ascii::space_type&gt; rule;     qi::rule&lt;Iterator, std::list&lt;Rule&gt;, ascii::space_type&gt; rules; };  }  int main() {     Parser::Grammar&lt;std::string::const_iterator&gt; parser;     boost::spirit::ascii::space_type space;     std::string input;     std::vector&lt;std::string&gt; output;     bool result;      while (std::getline(std::cin, input))         {             if (input.empty())                 {                     break;                 }             std::string::const_iterator it, itEnd;             it = input.begin();             itEnd = input.end();             result = phrase_parse(it, itEnd, parser, space, output);             if (result &amp;&amp; it == itEnd)                 {                     std::cout &lt;&lt; "success" &lt;&lt; std::endl;                 }         }      return 0; } </code></pre>  <hr>  <p>ยน cross posted from the [spirit-general] mailing list: <a href="http://boost.2283326.n4.nabble.com/parser-segfault-tips-tricks-td4680336.html" rel="nofollow">http://boost.2283326.n4.nabble.com/parser-segfault-tips-tricks-td4680336.html</a></p>