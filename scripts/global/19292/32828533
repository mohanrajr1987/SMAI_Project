<p>I'm making a hash table in C whose keys are of the type char*. I'm storing the key in the table itself for reasons outside the scope of this problem. The hash table is working for the most part, except for the following issue: when the table size is over 2112 elements and I try to initialize the keys as NULL pointers, I run into a segmentation fault.</p>  <p>Here is the definition of the hashTable:</p>  <pre><code>typedef struct hash_table {   uint32_t size;  // # of elements the table can store   uint32_t count; // # of elements in the table   char **keys;    // The pointer to the first key. Each key is a char*   int32_t *vals;  // The pointer to the first val. } hashTable; </code></pre>  <p>and here is where I initialize the table with NULL pointers as keys:</p>  <pre><code>// Declare the pointer to the hash table hashTable *symbolTable = malloc(sizeof(hashTable));  // Set the hash table properties symbolTable-&gt;size = 7699; symbolTable-&gt;count = 0; symbolTable-&gt;keys = malloc(sizeof(symbolTable-&gt;keys[0]) * symbolTable-&gt;size); symbolTable-&gt;vals = malloc(sizeof(symbolTable-&gt;vals[0]) * symbolTable-&gt;size);  // Initialize the keys to be NULL pointers. int i; for (i = 0; i &lt; symbolTable-&gt;size; i++) {   char **cp = symbolTable-&gt;keys + i * sizeof(symbolTable-&gt;keys[0]);   *cp = NULL; } </code></pre>  <p>When I run the program, I get a segmentation fault in the for loop when i==2111.</p>  <p>I am relatively new to dynamic memory allocation in C, and have been stuck on this problem for some time. If anybody has any insight or advice I'd greatly appreciate it.</p>