<p>I have a problem where I have to copy a structure and add it to new memory then free the old memory. Then I have to increment to create space for new memory and add again. I thought I had the logic correct but I keep getting a segmentation fault. I can't figure out where I am going wrong.</p>  <p>Here is a copy of my structure:</p>  <pre><code>struct childrensBook *book = (struct childrensBook *) malloc(sizeof(struct childrensBook));     //Structure of book #1  book-&gt;title = (char *)malloc(100);                  //allows memmory of 100 characters                                                   book-&gt;author = (char *)malloc(100);             //allows memmory of 100 characters   book-&gt;publisher = (char *)malloc(100);              //allows memmory of 100 characters   book-&gt;copyright = 0; book-&gt;price = 0; </code></pre>  <p>Here is a copy of my add function:</p>  <pre><code>int addRecord()  {     int headptr = 0;     struct childrensBook *book = malloc(sizeof(struct   childrensBook));            //get book structure     struct childrensBook *book1 = malloc(sizeof(struct childrensBook));         //create structure book1     memcpy(book-&gt;title, "We're Going on a Bear Hunt", 26);                      //populate fields of book      memcpy(book-&gt;author, "Michael Rosen", 13);                                  //populate fields of book      memcpy(book-&gt;publisher, "Little Simon", 12);                                //populate fields of book      book-&gt;copyright = 1989;                                                 //populate fields of book      book-&gt;price = 7.99;                                                     //populate fields of book      memcpy(book1, book, sizeof *book1);                     //copy fields of book to book 1     free(book); } </code></pre>  <p>And here is my call to function:</p>  <pre><code>else if(x==4) {     addRecord();     fprintf(stderr, "You have added the record: %s\n", book-&gt;title);     free(book);     moveptr++;   //here to incrememnt for new space. This is a globaal variable } </code></pre>