<p>I have been playing around with file writing functions to study their properties in more detail, along with some other things as well (however what I was doing is ultimately irrelevant),  and while I was doing that I encountered a segmentation fault. But not just the everyday type of segfault (dereferencing to unallocated space or something), the segfault is somehow caused by the declaration of a character array. In the code char name[10]. The declaration of char name[10] results in segmentation fault, and I do not understand why. Commenting this declaration removes the issue. What is going on here? </p>  <p>The code I wrote is given below: </p>  <pre><code>#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;errno.h&gt;  int main(int argc, char *argv[]){  //char name[10]; //strcpy(name, "George"); //printf("%s\n", name);  //if(argc == 2){  //char *myname = "George";      FILE *file = fopen("Readmystuff" , "rt");//fopen(argv[1],"rt");      if(file == NULL)         printf("Could not open file: %s\n", strerror(errno));      char *str, *cr;     int maxsize = 200;      cr = fgets(str, maxsize, file);       int fcl = fclose(file);       printf("\n");         int strl = strlen(str);      if(fcl == 0)         printf("File closed succesfully\ncr: %c\nstr: %s\nTotal string size - 1 (for null): %i\n", *cr, str, strl);     else         printf("File did not close"); //} //else     //printf("There must be one argument, argv[1] = the filename, for the code to work\n");  return 0; </code></pre>  <p>}</p>