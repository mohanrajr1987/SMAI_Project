<p>I have the following code in C, trying to develop an Operating System simulation:</p>  <p>Queue.c:</p>  <pre><code>typedef enum {running,readyproc,waiting,suspended}status;  typedef struct pcb {    long pid;    char* pname;    long priority;    long sleepperiod;    long* context;    status stat;   }PCB;  typedef enum {ready, timer, suspend} queuetype; typedef struct {    int size;    int capacity;    PCB ** data;    queuetype qt; }Queue;  void queue_init(Queue *q, queuetype qt){    q-&gt;size =0;    q-&gt;capacity = QUEUE_INITIAL_CAPACITY ;//100    q-&gt;data = (PCB **)calloc(q-&gt;capacity,sizeof(PCB*));    q-&gt;qt = qt; }  PCB* queue_pop (Queue* q){    PCB* toReturn;    int i;    toReturn = q-&gt;data[0];    for (i=0;i&lt;q-&gt;size;i++){       q-&gt;data[i]=q-&gt;data [i+1];    }   free(q-&gt;data[q-&gt;size]);   q-&gt;size--;   printf ("toReturn id:%ld pname: %s\n", toReturn-&gt;pid, toReturn-&gt;pname);   return toReturn; } </code></pre>  <p>Knowing that the queue gets initialized and filled with PCBs. I do always get a segafault on calling:</p>  <pre><code>PCB* pcb = queue_pop(&amp;queue); </code></pre>  <p>EDIT: Here is the function that would fill the queue:</p>  <pre><code>void queue_append(Queue *q, PCB* value) {    q-&gt;data[q-&gt;size++] = value; } </code></pre>  <p>EDIT2: the printf before the return in <code>queue_pop</code> returns this:</p>  <pre><code>toReturn id: 2 pname: test1c_a </code></pre>  <p>which corresponds to what I want to pop from that queue.</p>