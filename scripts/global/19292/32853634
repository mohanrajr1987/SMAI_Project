<p>I am trying to implement a spellchecker, and one step is to load a dictionary into a trie structure. I have used GDB to determine that, from my understanding, I am getting a segmentation fault every time I try to assign <code>current-&gt;children</code> to a value. Full code at the bottom, but the method in question:</p>  <pre><code>bool load(const char* dictionary) {     FILE* dic = fopen(dictionary, "r");      if(dic == false)     {         return false;     }      root = calloc(27, sizeof(node));     node* current = NULL;     /**for(int i=0;i&lt;27;i++)     {         current-&gt;children[i]=NULL;     }*/ //this will be the location of the segmentation fault if uncommented     int a = 0;      while((a = fgetc(dic)) != EOF)     {         if (a == '\n')         {             //this is the end of a word             if(!current-&gt;is_word)             {                 //duplicate case                 current-&gt;is_word = true;                 wordcounter++;             }             current = root;                 }         else         {             if(current-&gt;children[a-'a'] == NULL)             {                 current-&gt;children[a-'a'] = calloc(27,sizeof(node));             }             current = current-&gt;children[a-'a'];         }     }     if(current!= root &amp;&amp; !current-&gt;is_word)     {         current-&gt;is_word = true;         wordcounter++;     }      fclose(dic);     return true; } </code></pre>  <p>There is commented code there that I tried to implement after checking a couple other answers on stackoverflow, but that just causes the segmentation fault to occur at that <code>for</code> loop. Otherwise, it occurs at the <code>if(current-&gt;children[a-'a']==NULL){...}</code></p>  <p>What's happening here? I thought <code>calloc()</code> automatically set the assigned memory to 0? What memory am I touching that I'm not supposed to? </p>  <p>Full .c below: </p>  <pre><code>#include &lt;stdbool.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;ctype.h&gt;  #include "dictionary.h"  typedef struct node {     bool is_word;     struct node* children[27]; } node;  node* root; int wordcounter=0;    //Returns true if word is in dictionary else false.  bool check(const char* word) {     node* current = root;     int b = 0;      while(word[b] != '\n')     {         int letter = tolower(word[b]);          if(letter == '\'')         {             return false;         }          if(current-&gt;children[letter-'a'] != NULL)         {             current = current-&gt;children[letter-'a'];             b++;         }         else         {             return false;         }     }      if(current-&gt;is_word == true)     {         return true;     }        return false; }    // Loads dictionary into memory.  Returns true if successful else false. bool load(const char* dictionary) {     FILE* dic = fopen(dictionary, "r");      if(dic == false)     {         return false;     }       root = calloc(27, sizeof(node));     node* current = NULL;     /**for(int i=0;i&lt;27;i++)     {         current-&gt;children[i]=NULL;     }*/     int a = 0;      while((a = fgetc(dic)) != EOF)     {         if (a == '\n')         {             //this is the end of a word             if(!current-&gt;is_word)             {                 //duplicate case                 current-&gt;is_word = true;                 wordcounter++;             }             current = root;                 }         else         {             if(current-&gt;children[a-'a'] == NULL)             {                 current-&gt;children[a-'a'] = calloc(27,sizeof(node));             }             current = current-&gt;children[a-'a'];         }     }     if(current!= root &amp;&amp; !current-&gt;is_word)     {         current-&gt;is_word = true;         wordcounter++;     }      fclose(dic);     return true; }   //Returns number of words in dictionary if loaded else 0 if not yet loaded.  unsigned int size(void) {     return wordcounter; }    //Unloads dictionary from memory.  Returns true if successful else false.  void memFree(node* current) {     for(int i = 0; i &lt; 27; i++)     {         if(current-&gt;children[i] !=NULL)         {             memFree(current-&gt;children[i]);         }     }     free(current); }  bool unload(void) {     memFree(root);         return true; } </code></pre>