<p>I'm working on a C++ homework assignment in which we have to build a hash table of singly linked lists. I have written my code on a Mac - it compiles fine and generates the expected output perfectly. However, when I run the program in Linux I get segfaults (core dumped). When debugging with gdb, I get the message  </p>  <pre><code>Program received signal SIGSEGV, Segmentation fault. __strcmp_sse2 () at ../sysdeps/x86_64/multiarch/../strcmp.S:210 210 ../sysdeps/x86_64/multiarch/../strcmp.S: No such file or directory. </code></pre>  <p>I read on other posted questions on this website that in this case gdb is misleading, and that the problem is not related to the "strcmp" function. However, I'm unable to see where the problem in my code is. If anyone could point me in the right direction, it would be much appreciated. TIA.</p>  <pre><code>//string_set.cpp  #include &lt;iostream&gt; #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt;  #include "string_set.h"  using namespace std;  string_set::string_set() {      for (int i = 0; i &lt; HASH_TABLE_SIZE; i++) { //initializing empty hash table         hash_table[i] = NULL;     } //end for      iterator_index = 0;     iterator_node = hash_table[iterator_index]; }  void string_set::add(const char *s) {      int hash_val = hash_function(s);      if (contains(s) == 1) {         throw duplicate_exception();     } //end if      node *a = new node;     if (a==NULL) {         throw memory_exception();     } //end if     a-&gt;s = new char[strlen(s) + 1];     if (a == NULL) {         delete a;         throw memory_exception();     } //end if     strcpy(a-&gt;s, s);      a-&gt;next = hash_table[hash_val];     hash_table[hash_val] = a;      if (contains(s) == 0) {         throw memory_exception();     } //end if     else {         reset();     } //end else  }  void string_set::remove(const char *s) {      if (contains(s) == 0) {         throw not_found_exception();     } //end if      int hash_val = hash_function(s);      node *prev = new node;     prev = hash_table[hash_val];     node *ptr = new node;     ptr = hash_table[hash_val];      while (strcmp(ptr-&gt;s, s) != 0) { //          prev = ptr;         ptr = ptr-&gt;next;     } //end while     if (prev == ptr) { //if node to be deleted is first in list         hash_table[hash_val] = ptr-&gt;next;     } //end if      delete ptr-&gt;s;     prev-&gt;next = ptr-&gt;next;     delete ptr;      reset();  }  int string_set::contains(const char *s) {      int hash_val = hash_function(s);      node *ptr = new node;     ptr = hash_table[hash_val];      while (ptr != NULL) {         if (strcmp(s, ptr-&gt;s) == 0) { //              delete ptr;             return 1;         } //end if         else {             ptr = ptr-&gt;next;         } //end else     } //end while      return 0; }  void string_set::reset() {      iterator_index = 0;     iterator_node = hash_table[iterator_index];  }  const char *string_set::next() {      if (iterator_node != NULL) {         char copy[strlen(iterator_node-&gt;s) + 1];         strcpy(copy, iterator_node-&gt;s);         iterator_node = iterator_node-&gt;next;         return copy;     } //end if      while (iterator_index &lt; HASH_TABLE_SIZE - 1) {         while (iterator_node == NULL) {             ++iterator_index;             iterator_node = hash_table[iterator_index];             if ((iterator_index == HASH_TABLE_SIZE - 1) &amp;&amp; (iterator_node == NULL)) {                 return NULL;             }         } //end nested while         char copy[strlen(iterator_node-&gt;s) + 1];         strcpy(copy, iterator_node-&gt;s);         iterator_node = iterator_node-&gt;next;         return copy;      } //end while      return NULL;  }  string_set::~string_set() {      reset();      node *ptr = new node;     ptr = iterator_node;      while (ptr != NULL) {         delete ptr-&gt;s;         next();         ptr = iterator_node;     } //end while      delete ptr; }  int string_set::hash_function(const char *s) {      int sum = 0;      for (unsigned int ind = 0; ind &lt; strlen(s); ind++) { //summing elements in string s         sum += s[ind];         sum = sum % HASH_TABLE_SIZE;     } //end for      return sum % HASH_TABLE_SIZE; } </code></pre>  <p>string_set.h</p>  <pre><code>using namespace std;  class string_set { public: /*Purpose     initialize the set to contain no elements * Preconditions     none * Exceptions     none */ string_set();  /*Purpose *   add s to the set *   if s is successfully added, reset the iterator * Preconditions *   s is a legal string * Exceptions *   if s is already present then throw duplicate_exception *   else if s there is not enough memory to add s then throw memory_exception */ void add(const char *s);  /*Purpose *   remove s from the set *   if s is successfully removed, reset the iterator * Preconditions *   s is a legal string * Exceptions *   if s is not present then throw not_found_exception */ void remove(const char *s);  /*Purpose *   return 1 if s is in the set and 0 otherwise * Preconditions *   s is a legal string * Exceptions *   none */ int contains(const char *s);  /*Purpose *   reset the iterator to the first element * Preconditions *   none * Exceptions *   none */ void reset();  /*Purpose *   return a pointer to the next set element *   return NULL if no more elements remain * Preconditions *   none * Exceptions *   none */ const char *next();  /*Purpose *   delete all dynamically allocated memory * Preconditions *   none * Exceptions *   none */ ~string_set(); private: /*Purpose *   return the hash value h associated with s *   h must consist of: (sum of the characters in s) mod HASH_TABLE_SIZE * Preconditions *   s is a legal string * Exceptions *   none * Examples *   hash_function("a") returns 97 *   hash_function("ab") returns 95 *   hash_function("ba") returns 95 *   hash_function("") returns 0 */ int hash_function(const char *s);  enum {HASH_TABLE_SIZE = 100};  class node {     public:     char *s;     node *next; };  // hash_table[i] is the head of a linked list of nodes node *hash_table[HASH_TABLE_SIZE];  // iterator position int iterator_index; // index in hash_table node *iterator_node; // node in hash_table[iterator_index]; };  class duplicate_exception { }; class memory_exception { }; class not_found_exception { }; </code></pre>