<p>I'm trying to teach myself how to make a library in which I can #include as a native library (such as #include ).</p>  <p>For this exercise I have built myself a general purpose coordinate class (as I use my coordinate class frequently I figured this was a good place to start).</p>  <p>So I have a coordinate.h and coordinate.cpp that I built with: g++ -g -fPIC -shared coordinate.cpp -o coordinate.so</p>  <p>I copied this .so file into my /usr/lib/ directory, and then copied my .h file into /usr/include/</p>  <p>Then I have a test program called driver.cpp.  I #included "#include ".  Compiled the program using: g++ -g driver.cpp</p>  <p>/tmp/ccRrEGy2.o: In function <code>main': driver.cpp:(.text+0x2a): undefined reference to</code>Coordinate::Coordinate(int, int)' driver.cpp:(.text+0x3b): undefined reference to <code>operator&lt;&lt;(std::ostream&amp;, Coordinate&amp;)' driver.cpp:(.text+0x59): undefined reference to</code>operator>>(std::istream&amp;, Coordinate&amp;)' driver.cpp:(.text+0x6a): undefined reference to `operator&lt;&lt;(std::ostream&amp;, Coordinate&amp;)' collect2: error: ld returned 1 exit status</p>  <p>The compilation fails to link.  All my experience in the past with compiling programs with a non-native library such as libgcrypt require I add a link flag in this case "-lgcrypt".  I've never built a custom made library before so this is brand new territory and I'm not exactly sure how to ask Google the right questions to get the answer I need.</p>  <p>Can anyone provide some guidance on this as to how I can link my .so to my executable?</p>