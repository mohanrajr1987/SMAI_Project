<p>I have two .dlls, where one of them have to interchange data between two or more explicitly loaded instances. Second of them has a sending mode and listening mode from library with shared memory segment.</p>  <p>It looks like following:</p>  <pre><code>#pragma data_seg("sh")  float Highs[20][100] = {0}; float Lows[20][100] = {0}; int HighCount[20][100] = {0}; int LowCount[20][100] = {0}; int HStackTip[20] = {0}; int LStackTip[20] = {0}; float AloneHighs[20][100] = {0}; float AloneLows[20][100] = {0}; int AloneHighCount[20][100] = {0}; int AloneLowCount[20][100] = {0}; BOOL isCompletelySent[20] = {FALSE};  #pragma data_seg() #pragma comment(linker, "/SECTION:sh,RWS") </code></pre>  <p>Where first (or only) array index is channel, it allows up to 20 independent pairs (sender-listener). In each variable exists setter and getter, like this</p>  <pre><code>    extern "C" __declspec(dllexport) void __stdcall SetDataSendingFinished(int channel) {     isCompletelySent[channel] = 1; } extern "C" __declspec(dllexport) BOOL __stdcall IsDataComplete(int channel) {     return isCompletelySent[channel]; } extern "C" __declspec(dllexport) void __stdcall SetHigh(int channel, float value, int count) {     Highs[channel][HStackTip[channel]] = value;     HighCount[channel][HStackTip[channel]] = count;     AloneHighs[channel][HStackTip[channel]] = value;     AloneHighCount[channel][HStackTip[channel]] = count;     HStackTip[channel]++; } </code></pre>  <p><strong>But, my problem appears while I try to set the data (its ok), and, from second instance which is "listening" mode (it have to actively call getter, but it does not matter at this time) to obtain it, I receive zeroes, or values which was initialized to, without any change.</strong></p>  <p>Very verbose log for my debugging demonstrates it well:</p>  <p>Sending instance have a task reset (put zeroes) on whole variable set on its channel, then put some Highs (value of High and count of Highs), as well as Lows, then set a flag signalising all data sent and is complete.</p>  <p>Log looks ok, also in case when I try to call its getter (HStack tip: getter value, Lows: getter value, for example):</p>  <pre><code>Chart:  #2 | Study: PrecHLCD | Library on channel 0 reset. HStack tip: 0 | 2015-09-17  16:31:03 Chart:  #2 | Study: PrecHLCD | High set | 2015-09-17  16:31:03 Chart:  #2 | Study: PrecHLCD | Low set | 2015-09-17  16:31:03 Chart:  #2 | Study: PrecHLCD | Finish flag set: 1. Stack tips Lows: 1, Highs: 1 | 2015-09-17  16:31:03 </code></pre>  <p>But, when I try to get the same data (as I expecting from shared segment library it will be), I recveive only zeroes, or (as I tried) firstly initialized values, as log said:</p>  <pre><code>Chart:  #1 | Study: PrecHLCD | loop. On channel 0 data sending status: 0 (HST 0, LST 0) | 2015-09-17  16:31:26 </code></pre>  <p>Functions from shared lib is imported as normally:</p>  <pre><code>    #pragma comment(lib, "C:\\SierraChart\\Data\\IntercomSingleton.lib")      extern "C" __declspec(dllimport) void __stdcall SetHigh(int channel, float value, int count);     extern "C" __declspec(dllimport) void __stdcall SetLow(int channel, float value, int count);     extern "C" __declspec(dllimport) void __stdcall ResetLibrary(int channel);     extern "C" __declspec(dllimport) int __stdcall BroadcastedHighs(int channel, float value); . . . </code></pre>  <p>Can you anybody tell me whats wrong? Thanks a lot</p>  <p>P.S. important note: This kind of library I used early, with less setters/getters, and worked well, dealed data as it may and I was happy, but something happens and I am unable to find what and why, I m worried about it second day</p>