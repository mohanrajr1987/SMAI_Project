<p>For test purposes I write CPU stress program: it just do N for-loops in M threads. I run this program with large number of threads, say 200. But in Task Manager I see that threads counter not exceed some little value, say 9 and a Thread.Start methods <em>waits for finish previous running threads</em>.</p>  <p>This behavior seems like a ThreadPool behavior, but I expect that regular <code>System.Threading.Thread</code> must start anyway without waiting for some reason.</p>  <p>Code below will reproduce this issue and have an option for workaround:</p>  <pre><code>using System; using System.Diagnostics; using System.Threading;  namespace HeavyLoad {     class Program     {         static long s_loopsPerThread;         static ManualResetEvent s_startFlag;          static void Main(string[] args)         {             long totalLoops = (long)5e10;             int threadsCount = 200;               s_loopsPerThread = totalLoops / threadsCount;              Thread[] threads = new Thread[threadsCount];              var watch = Stopwatch.StartNew();             for (int i = 0; i &lt; threadsCount; i++)             {                 Thread t = new Thread(IntensiveWork);                 t.IsBackground = true;                 threads[i] = t;             }             watch.Stop();             Console.WriteLine("Creating took {0} ms", watch.ElapsedMilliseconds);              // *** Comment out s_startFlag creation to change the behavior ***             // s_startFlag = new ManualResetEvent(false);              watch = Stopwatch.StartNew();             foreach (var thread in threads)             {                 thread.Start();             }             watch.Stop();             Console.WriteLine("Starting took {0} ms", watch.ElapsedMilliseconds);              if (s_startFlag != null)                 s_startFlag.Set();              watch = Stopwatch.StartNew();             foreach (var thread in threads)             {                 thread.Join();             }             watch.Stop();             Console.WriteLine("Waiting took {0} ms", watch.ElapsedMilliseconds);              Console.ReadLine();         }          private static void IntensiveWork()         {             if (s_startFlag != null)                 s_startFlag.WaitOne();              for (long i = 0; i &lt; s_loopsPerThread; i++)             {                 // hot point             }         }     } } </code></pre>  <p><strong>Case 1:</strong> If s_startFlag creation is commented, then starting threads immediately begins a high intensive CPU work. In this case I have a small concurrency (around 9 threads) and all the time I hold on thread starting code:</p>  <pre><code>Creating took 0 ms Starting took 4891 ms Waiting took 63 ms </code></pre>  <p><strong>Case 2:</strong> But if I create s_startFlag, all new threads will wait until it will be set. In this case I successfully start all 200 threads concurrently and get expected values: little time for a start and much time for a work and number of threads in Task Manager is 200+:</p>  <pre><code>Creating took 0 ms Starting took 27 ms Waiting took 4733 ms </code></pre>  <p><strong>Why threads refuse start in first case? What kind of limitation I exceed?</strong></p>  <p>System:</p>  <ul> <li>OS: Windows 7 Professional</li> <li>Framework: NET 4.6</li> <li>CPU: Intel Core2 Quad Q9550 @ 2.83GHz</li> <li>RAM: 8 Gb</li> </ul>