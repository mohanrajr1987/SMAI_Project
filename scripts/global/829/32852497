<p>I am triggering a custom event on an element using jQuery and I want the event handler to be able to pass data (in the form of an object) back to the method that called it. The trigger and the handler are in different scopes and files and cannot be merged or shared in a conventional manner. (The trigger method is part of a utility library I am writing and the event handler is part of my front-end view template).</p>  <p><strong>I know this code doesn't work,</strong> but I am writing it to kind of illustrate what I am hoping to try. The pattern is based of of work I have done in .NET.</p>  <pre><code>var data = { foo: 'bar' } element.trigger('some-event', data) if(data.foo != 'bar')     alert('someone changed foo!') </code></pre>  <p>And the handler...</p>  <pre><code>element.bind('some-event', function(event, data) {     if(some_condition)         data.foo = 'biz' }); </code></pre>  <p>The specific implementation is not terrible important to me as long as I don't have rearrange my code to stick both the <code>trigger</code> and the <code>bind</code> in the same scope.</p>  <p>How do I get return value back from my event handler?</p>  <hr>  <h2>EDIT</h2>  <p>To provide a little more context, the triggering method is responsible for obtaining and processing data, and finally rendering it out as markup to the page. Before it does that, it raises the custom event with the same processed <code>data</code> object so that other components of the app can have the chance to do something with the processed data. </p>  <p>In certain cases, it would be beneficial for the event handlers to modify that set of data, or event signal to the triggering method that the data has already been handled and does not need additional processing or rendering.</p>  <p>Something like below. In this example, the handler might change the way the data is displayed based upon some property value. It may also choose to render the data out a different way (e.g. <code>input</code>) rather than the default rendering in the triggering function (e.g. <code>label</code>). </p>  <p>This implementation is an example, but the end goals of returning an object from the handler, or modifying the data in the handler such that the triggering method can access it are common to my actual project.</p>  <pre><code>var data = load_data(); element.trigger('loading_data', data); if(data.abort_render!==true) {     element.append('&lt;label&gt;Foo&lt;/label&gt;')     element.append('&lt;span&gt;' + data.foo + '&lt;/span&gt;') } </code></pre>  <p>And the handler...</p>  <pre><code>element.bind('loading-data', function(event, data) {     if(data.is_password == true)     {         data.foo = '*******'   //changed property persisted to triggering method and processed normally     }     if(data.type == 'abc')     {         element.append('&lt;input value="' + data.foo + '"/&gt;');         data.abort_render = true;   //signals to the triggering method that it should not render the data to the page     } } </code></pre>