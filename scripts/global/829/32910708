<p>I'm trying to get a proof of concept down for a feature I need in my code.  In the real application, I have a Dependency Injection container, and children sometimes need to 'new up' an object, and I need the DI container to return that object.  So I'm using an event with a callback that lets the child get that instatiated object.</p>  <p>The problem is, I'd like one event, but allow it to return whichever object the caller specifies.  I'm not sure how to get that strongly typed object back (without casting).  I feel like it should be possible.  If that's confusing enough, here's my example:</p>  <pre><code>class Program {     public static event EventHandler&lt;MyEventArgs&gt; MyEvent;     public static void Main()     {         MyEvent += (sender, args) =&gt;         {             Console.WriteLine("Event Fired");             args.Callback("hello");         };           MyEvent(null, new MyEventArgs(obj =&gt; Console.WriteLine($"How do I get {obj} strongly typed")));          Console.Read();     } } </code></pre>  <p>and the event args:</p>  <pre><code>public class MyEventArgs {     public Action&lt;object&gt; Callback { get; set; }      public MyEventArgs(Action&lt;object&gt; callback)     {         Callback = callback;     } } </code></pre>  <p>I'm stuck, because <code>MyEventArgs</code> can't take a type parameter, as I would really like just one event to handle any return object type.  Is it possible to get a strongly typed object through the callback?  </p>  <p>Again, I could send the <code>Type</code> through as a parameter, and cast it, but I feel like this should be do-able.  It's entirely possible that this is impossible, too.</p>  <p>Thanks for any guidance.</p>