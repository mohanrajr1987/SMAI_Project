<p>A pair of <code>printf()</code> debugging statements reveals that a pointer to a double that I am passing is, when dereferenced at the receiving end, coming out as a different value — but only under Microsoft Visual Studio (version 9.0). The steps are quite simple:</p>  <pre><code>    double rho=0;       /* distance from the Earth */     /* ... */     for (pass = 0; pass &lt; 2; pass++) {         /* ... */         rho = sqrt(rsn*rsn+rp*rp-2*rsn*rp*cpsi*cos(ll));         printf("\nrho from sqrt(): %f\n", rho);         /* ... */     }     /* ... */     cir_sky (np, lpd, psi, rp, &amp;rho, lam, bet, lsn, rsn, op);     /* ... */ } /* ... */ static void cir_sky ( /* ... */ double *rho,        /* dist from earth: in as geo, back as geo or topo */ /* ... */) {     /* ... */     printf("\nDEBUG1: *rho=%f\n", *rho); </code></pre>  <p>The entire C file is here:</p>  <p><a href="https://github.com/brandon-rhodes/pyephem/blob/9cd81a8a7624b447429b6fd8fe9ee0d324991c3f/libastro-3.7.7/circum.c#L366">https://github.com/brandon-rhodes/pyephem/blob/9cd81a8a7624b447429b6fd8fe9ee0d324991c3f/libastro-3.7.7/circum.c#L366</a></p>  <p>I would have expected that the value displayed in the first <code>printf()</code> would be the same as that displayed by the second, since passing a pointer to a double should not result in a different value. And under GCC they are, in fact, always the same value. Under Visual Studio 32-bit compilation they are always the same. But when this code is compiled with Visual Studio under a 64-bit architecture, the two double values are different!</p>  <p><a href="https://ci.appveyor.com/project/brandon-rhodes/pyephem/build/1.0.18/job/4xu7abnl9vx3n770#L573">https://ci.appveyor.com/project/brandon-rhodes/pyephem/build/1.0.18/job/4xu7abnl9vx3n770#L573</a></p>  <pre><code>rho from sqrt(): 0.029624  DEBUG1: *rho=0.000171 </code></pre>  <p>This is disconcerting. I wondered: does the code between where <code>rho</code> is computed and where the pointer is finally passed somehow destroy the value by bad pointer arithmetic? So I added one last <code>printf()</code>, right above the  <code>cir_sky()</code> call, to see if the value has already been altered by that point or whether it is altered in the course of the call itself:</p>  <pre><code>    printf("\nrho about to be sent: %f\n", rho);     cir_sky (np, lpd, psi, rp, &amp;rho, lam, bet, lsn, rsn, op); </code></pre>  <p>Here is that line in the context of the whole file:</p>  <p><a href="https://github.com/brandon-rhodes/pyephem/blob/28ba4bee9ec84f58cfffabeda87cc01e972c86f6/libastro-3.7.7/circum.c#L382">https://github.com/brandon-rhodes/pyephem/blob/28ba4bee9ec84f58cfffabeda87cc01e972c86f6/libastro-3.7.7/circum.c#L382</a></p>  <p>And guess what?</p>  <p><strong>Adding the <code>printf()</code> fixed the bug — the pointer passed to <code>rho</code> can now be dereferenced to the correct value!</strong></p>  <p>As can be seen here:</p>  <p><a href="https://ci.appveyor.com/project/brandon-rhodes/pyephem/build/1.0.19/job/s3nh90sk88cpn2ee#L567">https://ci.appveyor.com/project/brandon-rhodes/pyephem/build/1.0.19/job/s3nh90sk88cpn2ee#L567</a></p>  <pre><code>rho from sqrt(): 0.029624  rho about to be sent: 0.029624  DEBUG1: *rho=0.029624 </code></pre>  <p>I am mystified.</p>  <p>What edge case of the C standard am I running into here? Why does merely using the value <code>rho</code> in the top-level scope of this function force the Microsoft compiler to correctly preserve its value? Is the problem that <code>rho</code> is both set and used inside of a block, and Visual Studio does not deign to preserve its value outside of that block because of a quirk of the C standard that I have never quite internalized?</p>  <p>You can see the entire build output at the AppVeyor link above. The particular compilation step for this C file, in case the problem might be how Visual Studio is invoked or the compile options, is:</p>  <pre><code>C:\Program Files (x86)\Microsoft Visual Studio 9.0\VC\Bin\amd64\cl.exe /c /nologo /Ox /MD /W3 /GS- /DNDEBUG -Ilibastro-3.7.7 -IC:\Python27-x64\include -IC:\Python27-x64\PC /Tclibastro-3.7.7\circum.c /Fobuild\temp.win-amd64-2.7\Release\libastro-3.7.7\circum.obj circum.c libastro-3.7.7\circum.c(126) : warning C4244: '=' : conversion from 'double' to 'float', possible loss of data  libastro-3.7.7\circum.c(127) : warning C4244: '=' : conversion from 'double' to 'float', possible loss of data libastro-3.7.7\circum.c(139) : warning C4244: '=' : conversion from 'double' to 'float', possible loss of data  libastro-3.7.7\circum.c(140) : warning C4244: '=' : conversion from 'double' to 'float', possible loss of data  libastro-3.7.7\circum.c(295) : warning C4244: '=' : conversion from 'double' to 'float', possible loss of data  libastro-3.7.7\circum.c(296) : warning C4244: '=' : conversion from 'double' to 'float', possible loss of data libastro-3.7.7\circum.c(729) : warning C4244: '=' : conversion from 'double' to 'float', possible loss of data  libastro-3.7.7\circum.c(730) : warning C4244: '=' : conversion from 'double' to 'float', possible loss of data </code></pre>  <p>None of those warnings are, from what I can see, for code involved in this particular puzzle — and even if they were, all they would signify is that a float value might become less precise (from about 15 digits of decimal precision to 7), not that it could change completely.</p>  <p>Here, again, are the outputs of the two compilation-and-test runs, the first of which failed and the second of which — because of the <code>printf()</code>? — succeeded:</p>  <p><a href="https://ci.appveyor.com/project/brandon-rhodes/pyephem/build/1.0.18/job/4xu7abnl9vx3n770">https://ci.appveyor.com/project/brandon-rhodes/pyephem/build/1.0.18/job/4xu7abnl9vx3n770</a></p>  <p><a href="https://ci.appveyor.com/project/brandon-rhodes/pyephem/build/1.0.19/job/s3nh90sk88cpn2ee">https://ci.appveyor.com/project/brandon-rhodes/pyephem/build/1.0.19/job/s3nh90sk88cpn2ee</a></p>  <p>Both are for exactly the same architecture, according to AppVeyor:</p>  <pre><code>Environment: PYTHON=C:\Python27-x64, PYTHON_VERSION=2.7.x, PYTHON_ARCH=64, WINDOWS_SDK_VERSION=v7.0 </code></pre>