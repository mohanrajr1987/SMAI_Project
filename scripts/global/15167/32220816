<p>I've attempted numerous mappings to try and achieve an "Adjacency Table" for the common BOM [bill of materials] pattern with Fluent Nhibernate without any luck [I'm using MS SQL Server 2012]. I've managed to achieve a self-referencing type, during my trials, but I wish to have an adjacent table for Quantity etc.</p>  <p>Basically, I wish to replicate the following MS Sample AdventureWorks tables here:</p>  <p><a href="http://i.stack.imgur.com/jiSsu.png" rel="nofollow"><img src="http://i.stack.imgur.com/jiSsu.png" alt="enter image description here"></a></p>  <p>The following is what I currently have, but I don't believe it's right - for instance, nhibernate ignores the renaming of the FK relationship and uses it's automated derivative [see. 'Pic: 2].</p>  <pre><code>public class ProductMap : ClassMap&lt;ProductPartRecord&gt; {     public ProductMap()     {         Table("ProductPartRecord");         Id(x =&gt; x.Id).GeneratedBy.Native();         Map(x =&gt; x.ProductNumber);         Map(x =&gt; x.Name);          //Relationships:         // [Product]---&lt;[Stock]         HasMany(x =&gt; x.Stock)             .ForeignKeyConstraintName("FK_Product_Stock")             .Inverse()             .Cascade.All();          // [Product]---&lt;[ProductComponents]         HasMany(x =&gt; x.ProductComponents)             .ForeignKeyConstraintName("FK_Product_ProductComponents")             .Inverse()             .Cascade.All();         // [Product]---&lt;[ProductComponents]         HasMany(x =&gt; x.Components)             .ForeignKeyConstraintName("FK_Product_ProductComponentsTwo")             .Inverse()             .Cascade.All();     } </code></pre>  <p>.</p>  <pre><code>public class ProductComponentMap : ClassMap&lt;ProductComponentPartRecord&gt; {     public ProductComponentMap()     {          Table("ProductComponentPartRecord");         Id(x =&gt; x.Id).GeneratedBy.Native();          Map(x =&gt; x.Misc);          References(x =&gt; x.ProductPartRecord);         //This appears to work [two relations to the same ProductTable for BOM]         References(x =&gt; x.Component);     } } </code></pre>  <p>Models:</p>  <pre><code>public class ProductPartRecord : ContentPartRecord {     public virtual string ProductNumber { get; set; }     public virtual string Name { get; set; }      public virtual IList&lt;ProductComponentPartRecord&gt; ProductComponents { get; set; }     public virtual IList&lt;ProductComponentPartRecord&gt; Components { get; set; } //?      public virtual IList&lt;StockPartRecord&gt; Stock { get; set; }     public ProductPartRecord() {         ProductComponents = new List&lt;ProductComponentPartRecord&gt;();         Components = new List&lt;ProductComponentPartRecord&gt;(); //?         Stock = new List&lt;StockPartRecord&gt;();     } } </code></pre>  <p>.</p>  <pre><code>public class ProductComponentPartRecord : ContentPartRecord {     public virtual string Misc { get; set; }     public virtual ProductPartRecord ProductPartRecord { get; set; }     public virtual ProductPartRecord Component { get; set; } } </code></pre>  <p>The Result, note the FK relation Name at the bottom?... <strong>Pic 2:</strong> <a href="http://i.stack.imgur.com/C9KGQ.png" rel="nofollow"><img src="http://i.stack.imgur.com/C9KGQ.png" alt="enter image description here"></a></p>  <p>So can anyone shed some light on what is the correct way to map such relations in Fluent Nhibernate?</p>