<p>In our application we have base classes for entities like this:</p>  <pre><code>public abstract class Entity : IEntity {     public virtual int Id { get; set; }     public virtual byte[] Version { get; set; } }  public abstract class EntityWithValidity : Entity, ICloneable {     [Required]     public virtual string LogicalId { get; set; }      [Required]     public virtual DateTime ValidFrom { get; set; }      public virtual DateTime? ValidTo { get; set; } } </code></pre>  <p>So, we like to implement a logic for the entities that entities can have validities in the past or in the future, based on the ValidFrom and ValidTo fields. The logical entity is identified by the LogicalId, but it's properties and relationships can change over time, and we want to keep track of those changes.</p>  <p>So, we have two concrete entities, EntityA and EntityB, both inheriting from EntityWithValidity.</p>  <pre><code>public class EntityA : EntityWithValidity {     private IList&lt;EntityB&gt; bs;      public EntityA()     {         this.bs = new List&lt;EntityB&gt;();     }      public virtual IReadOnlyList&lt;EntityB&gt; Bs     {         get { return this.bs.ToList().AsReadOnly(); }         set { this.bs = new List&lt;EntityB&gt;(value); }     } } </code></pre>  <p>And EntityB exactly symmetrically.</p>  <p>For mappings, we use Fluent NHibernate with automappings. And we have some overrides like this:</p>  <pre><code>    public void Override(AutoMapping&lt;EntityA&gt; mapping)     {         mapping.HasManyToMany(x =&gt; x.Bs)             .Inverse()             .PropertyRef("LogicalId")             .Access.CamelCaseField(Prefix.None);     } </code></pre>  <p>And:</p>  <pre><code>    public void Override(AutoMapping&lt;EntityB&gt; mapping)     {         mapping.HasManyToMany(x =&gt; x.As)             .ChildPropertyRef("LogicalId")             .Access.CamelCaseField(Prefix.None);     } </code></pre>  <p>For simple scenarios, our entities and mappings are working exactly like we want them to. The mappings seem to work logically the way we want, and we are able to navigate the relationships in code in either direction.</p>  <p><strong>The problem:</strong>  If we are trying to navigate the <strong>same</strong> relationship in <strong>both</strong> directions within the <strong>same</strong> stateful session, then NHibernate crashes with this kind of stack trace:</p>  <pre><code>11:55:58.018 System.Collections.Generic.KeyNotFoundException: The given key was not present in the dictionary. at System.Collections.Generic.Dictionary`2.get_Item(TKey key) at NHibernate.Persister.Entity.AbstractEntityPersister.LoadByUniqueKey(String propertyName, Object uniqueKey, ISessionImplementor session) at NHibernate.Type.EntityType.LoadByUniqueKey(String entityName, String uniqueKeyPropertyName, Object key, ISessionImplementor session) </code></pre>  <p>At some point I was thinking if the issue we have is related to the issue reported here: <a href="https://nhibernate.jira.com/browse/NH-2180" rel="nofollow">NH-2180</a>. At least it has the same stack trace. However, changing the FetchMode doesn't have any effect in our case.</p>  <p>When going in with debugger to see what happens, I can see that the session contains a PersistenceContext, and in there you have a collection CollectionsByKey. In there I can see that for some loaded collections NHibernate is using the primary key Id as the key, but in other cases it is using the LogicalId as the key. I think this is fundamentally wrong. The LogicalId that we have is NOT unique. Also looking at the stack trace and NHibernate sources, NHibernate is going to a branch where it is assuming that the key we use in the mapping is Unique, but it is not. (It is NOT configured as unique, it just seems that this branch is some kind of "fall back option" when NHibernate cannot figure out any other strategy.)</p>  <p>So, any help to the situation? Can anybody come up with a mapping that would enable us to do what we are trying to do, and have NHibernate support that in a robust way?</p>  <p>Thanks!</p>