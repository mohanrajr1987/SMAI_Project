<p>I'm having problems developing a sane set of Fluent NHibernate mappings for the following model structure:</p>  <pre><code>public class BaseLookup {     public virtual int Id {get; set;}     public virtual string Code {get; set;}     public virtual string Value {get; set;}     public virtual bool Active {get; set;} } public class Subdivision : BaseLookup { } public class AvisCode : BaseLookup { } public class District : BaseLookup { } /*etc.*/ </code></pre>  <p>These lookups all share properties, but otherwise have no relationship to each other. These tables have special semantic meanings for reports and will be referenced specifically in stored procedures, so I don't wish to mash them into a common 'lookups' table that would require me to use a discriminator. That seems to eliminate Table-per-Hierarchy and Table-per-Sublass strategies in my mappings. I'm also having difficulty employing Table-per-Concrete-Class because each lookup has its own identity column - I do not want to have to assign an Id manually in the application, and there's no requirement for Id's to be unique across all these tables.</p>  <p>My mappings, at the moment, look like this, and are identical for each superclass of BaseLookup:</p>  <pre><code>public class AvisCodeMap : ClassMap&lt;AvisCode&gt; {     public AvisCodeMap()     {         Schema(Schemas.pva.ToString());         Id(x =&gt; x.Id).GeneratedBy.Identity();         Map(x =&gt; x.Code).Not.Nullable();         Map(x =&gt; x.Value).Not.Nullable();     } } </code></pre>  <p>Is there no mapping convention that allows me to extract the repetitive mappings to a block of re-usable code?</p>