<p>I'm wanting to use extension methods for adding features to the domain model, to only have one aggregate root for retrieving associated entities, like this:</p>  <pre><code>public class User {     public ICollection&lt;Invoice&gt; Invoices {get; set;} } </code></pre>  <p>It's populated in an injectable interface</p>  <pre><code>public interface ICurrentUserService {     public User GetCurrentUser(); } </code></pre>  <p>And then, for example in a controller (not really in my case, this is a quick sample for SO, controllers still use services), I would want to do this:</p>  <p><code>var invoice = _currentUserService.GetCurrentUser().Invoices.Specific(id);  var mapped = _mappingEngine.Map&lt;InvoiceModel&gt;(invoice);  return View(mapped); </code></p>  <p><code>Specific(id)</code> being an extension method:</p>  <pre><code>public static Invoice Specific(this ICollection&lt;Invoice&gt; invoices, Guid id) {     return invoices.SingleOrDefault(i =&gt; i.Id == id); } </code></pre>  <p>This sort of approach however causes several issues, the most concerning being that on the first access of the collection, even if all you do is a <code>LINQ</code> operation that doesn't enumerate the items, the entire list of children is loaded (unless <code>ExtraLazy</code> is specified and you're only doing a <code>Count()</code>). What I would like to happen, is for the proxy to remain a proxy until it actually has to get the final item/collection (as some extension methods alike this would involve returning a collection).</p>  <p>What I'd like to happen, is until <code>SingleOrDefault</code> gets called in the extension method, the database wouldn't be queried, and when it does get queried, the query would be in style of <code>'where InvoiceId = ? and UserId = ?'</code>, rather than the where being done in memory after the whole collection is loaded.</p>  <p>Is this doable in (fluent) <code>NHibernate</code> or am I trying to achieve a pipe dream? I'm simply trying out an approach with this project here, to give the domain model a really fluent syntax.</p>