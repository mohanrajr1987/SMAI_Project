<p>I am facing a small problem in synchronizing my Tkinter scrollbar with two listboxes widgets. When content in two listboxes are not same I face this error otherwise, if length is same then there is no problem. Below is my short code: </p>  <pre><code>try:     # Python2     import Tkinter as tk except ImportError:     # Python3     import tkinter as tk  class App(object):     def __init__(self,master):         scrollbar = tk.Scrollbar(master, orient='vertical')         self.lb1 = tk.Listbox(master, yscrollcommand=scrollbar.set)         self.lb2 = tk.Listbox(master, yscrollcommand=scrollbar.set)         scrollbar.config(command=self.yview)         scrollbar.pack(side='right', fill='y')         self.lb1.pack(side='left', fill='both', expand=True)         self.lb2.pack(side='left', fill='both', expand=True)      def yview(self, *args):         """connect the yview action together"""         self.lb1.yview(*args)         self.lb2.yview(*args)   root = tk.Tk() # use width x height + x_offset + y_offset (no spaces!) root.geometry("320x180+130+180") root.title("connect 2 listboxes to one scrollbar")  app = App(root)  # load the list boxes for the test for n in range(64+26, 64, -1): #listbox 1     app.lb1.insert(0, chr(n)+'ell')  for n in range(70+30, 64, -1):         app.lb2.insert(0, chr(n)+'ell') #listbox 2  root.mainloop() </code></pre>  <p><strong>What I want</strong></p>  <p>I know the error is obvious since both lists have unmatched lengths. What I want is on running above code the scrollbar should follow right synchronizing from first word i.e. <code>Aell</code> to last word which is <code>Zell</code> by order given in both lists. </p>  <p>The approach in my mind is to always scroll both lists with respect to length of shortest list (left side one in my case) so that I can at least match all possible points.  </p>  <p>Lastly, I am only facing this error when I am dragging slider up and down for scrolling. But when I am simply momentarily pressing and releasing the up and down arrows on scrollbar then everything works fine. </p>  <p><strong>What I tried</strong> </p>  <p>Apart from reading online, I also tried introducing events and bindings in following manner hoping to restrict the scrolling step wise, but no change.</p>  <pre><code>self.lb1.bind('&lt;Up&gt;', lambda event: self.scroll_listboxes(-1)) self.lb2.bind('&lt;Up&gt;', lambda event: self.scroll_listboxes(-1)) self.lb1.bind('&lt;Down&gt;', lambda event: self.scroll_listboxes(1)) self.lb2.bind('&lt;Down&gt;', lambda event: self.scroll_listboxes(1))  def scroll_listboxes(self, yFactor): #function runs when a listbox has focus and the Up or Down arrow  #keys are pressed     self.listbox1.yview_scroll(yFactor, "units")     self.listbox2.yview_scroll(yFactor, "units") </code></pre>  <p><strong>P.S.</strong></p>  <p>I just thought upon something, but really not sure if that's all the way correct. Since the lengths are unmatched, scrolling action varies for both list boxes. So is it possible to somehow force the scrolling action of shortest list on another list? This way another list with more contents wont be able to move freely and will have to follow scrolling pattern just as shortest content list box.</p>