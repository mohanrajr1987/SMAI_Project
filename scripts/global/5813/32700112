<p>My python code looks like this:</p>  <pre><code>def test():     pipe = sp.Popen( ["test.sh"], stdin=sp.PIPE)     data = "".join([chr((s)%17) for s in range(0,33)])     os.write(pipe.stdin.fileno(), data)     pipe.stdin.write("endoffile")  if __name__ == "__main__":     test() </code></pre>  <p>It calls the following simple bash shell script which simply writes stdin to a file (script is called test.sh)</p>  <pre><code>#!/bin/bash VALUE=$(cat)  echo "$VALUE" &gt;&gt; /tmp/test.txt </code></pre>  <p>When I run the python code I expect test.txt to contain the values 0x01..0x10 two times, and after that the string "endoffile"</p>  <p>However here's a hexdump of the file:</p>  <pre><code>0000000: 0102 0304 0506 0708 090a 0b0c 0d0e 0f10  ................ 0000010: 0102 0304 0506 0708 090a 0b0c 0d0e 0f65  ...............e 0000020: 6e64 6f66 6669 6c65 0a                   ndoffile. </code></pre>  <p>It appears that a byte is missing (0x10).</p>  <p>What am I missing here?</p>  <p>--- Update</p>  <p>Changing the test() function to:</p>  <pre><code>def test():     pipe = sp.Popen( ["test.sh"], stdin=sp.PIPE)     data = "".join([chr((s)%16+1) for s in range(0,32)])     os.write(pipe.stdin.fileno(), data)     pipe.stdin.write("endoffile") </code></pre>  <p>Seems to solve that. It seems to be related to having chr(0) sent to pipe.</p>