<p>I've spent the better part of a week searching for an answer to this (I thought) simple question, and while I've found many others with it, I have not yet found a clear answer, or even anything I could get to work.</p>  <p>My question is this:  How can I invoke a child process, and read silently from its stdout pipe into a string, array, or something in the parent process without spawning a floating console window?</p>  <p>So far I have this code borrowed and tweaked slightly:</p>  <pre><code>wls EXEC(string comm) {     wls _internal;     FILE* pipe = popen(comm.c_str(), "r");      if (!pipe)         return _internal;     char buffer[8192];      while (!feof(pipe))         if (fgets(buffer, 8192, pipe) != NULL)             _internal.push_back(ATS(buffer).substr(0, ATS(buffer).size() - 1));     pclose(pipe);     return _internal; } </code></pre>  <p>Important background info:</p>  <p><code>wls</code> is the result of <code>typedef vector&lt;string&gt; wls;</code></p>  <p><code>ATS</code> is a template function I use to pass all sorts of things in and get back a string</p>  <p>Now, this function <em>works</em> perfectly, if we're talking function vs. form.  It runs the child process, and I get back an array of strings - one for each line of the child process's output.  However, every time it runs, it makes a command prompt window open.  I understand that there is no way to avoid this with popen, so I have turned to CreateProcess().  I have not however managed to create an equivilant function to the one above using CreateProcess, and this is what I would like to do.</p>  <p>Could anyone possibly lend a hand?  It would be much appreciated, and you would be creating the definitive guide for doing this anywhere on the internet if you are successful :)</p>