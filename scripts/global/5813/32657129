<p>I am just putting the code here for the execute procedure There exists a structure which contains a member <code>char* command_list[MAXCOMMANDS][MAXARGUMENTS]</code></p>  <p>The first position of each row in this member contains the command and the rest of the items in the row are arguments</p>  <p>I have made the execute procedure which on giving the input <code>ls | wc</code> gives **</p>  <blockquote>   <p>DUP2 HERE : Bad file descriptor</p> </blockquote>  <p>Structure below</p>  <pre><code>struct command {     ifstream input;     ofstream output;          int num_commands=-1;     int num_args[MAXCOMMANDS]={0};      char* command_list[MAXCOMMANDS][MAXARGS];                   //command and their arguments storage     vector&lt;string&gt; pr_operator;                         //Pipe or redirection operators storage      bool background_task;     bool append;  }; </code></pre>  <p>Execute function below</p>  <pre><code>int execute() {     pid_t pid,wpid;     int status;       int num_pipes=count_pipes();          int pfds[2*num_pipes];      for(int i=0;i&lt;num_pipes;i++)     {         if(pipe(pfds+2*i)&lt;0)         {             perror("Cannot Pipe");             exit(1);         }     }      for(int i=0,j=0;i&lt;=s.num_commands;i++,j+=2)     {         pid=fork();          if(pid==0)         {             if(i&gt;0)                                  //if not first command             {                 if(dup2(pfds[j-2],0)&lt;0)                     {perror("DUP2 HERE");exit(1);}                  close(pfds[j-2]);                 close(pfds[j-1]);                }              if(i&lt;s.num_commands)         // if not last command             {                 if(dup2(pfds[j+1],1)&lt;0)                     {perror("DUP2");exit(1);}                 close(pfds[j+1]);                 close(pfds[j]);             }               if(execvp(s.command_list[i][0],s.command_list[i])==-1)             {                 perror("My Shell");                 exit(1);             }          }         else if(pid&lt;0)         {             perror("My Shell");             exit(1);         }         else         {                for(int k=0;k&lt;2*num_pipes;k++)                 close(pfds[k]);              for(int k=0;k&lt;num_pipes+1;k++)                 wait(&amp;status);          }      }      return 1;  } </code></pre>