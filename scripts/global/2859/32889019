<p>I am using independence log4j.properties file:</p>  <pre><code>log4j.rootLogger=DEBUG, console, DebugAppender  log4j.appender.console=org.apache.log4j.ConsoleAppender log4j.appender.console.layout=org.apache.log4j.PatternLayout log4j.appender.console.layout.conversionPattern=%d %p [%c] - &lt;%m&gt;%n log4j.appender.console.Target=System.out   #Debug logging log4j.appender.DebugAppender=org.apache.log4j.RollingFileAppender log4j.appender.DebugAppender.Threshold=DEBUG log4j.appender.DebugAppender.File=vertx3.log log4j.appender.DebugAppender.MaxFileSize=5MB log4j.appender.DebugAppender.MaxBackupIndex=5 log4j.appender.DebugAppender.layout=org.apache.log4j.PatternLayout log4j.appender.DebugAppender.layout.ConversionPattern=%d %p [%c] - &lt;%m&gt;%n    log4j.additivity.com.mycompany=false log4j.additivity.io.netty=false log4j.additivity.org.springframework=false  log4j.logger.com.mycompany=DEBUG, console, DebugAppender  log4j.logger.org.springframework=INFO, console, DebugAppender log4j.logger.org.neo4j.jdbc.level=DEBUG, console, DebugAppender log4j.logger.org.apache=ERROR, console, DebugAppender log4j.logger.io.netty=INFO, console, DebugAppender log4j.logger.org.vertx=INFO, console, DebugAppender log4j.logger.com.hazelcast=DEBUG, console, DebugAppender </code></pre>  <p>when I look at vertx3.log I do see the Spring loggings. But I cant see hazelcast loggings.</p>  <p>However on console I can see hazelcast loggings:</p>  <pre><code>Oct 01, 2015 4:07:31 PM com.hazelcast.config.AbstractXmlConfigHelper WARNING: Name of the hazelcast schema location incorrect using default Oct 01, 2015 4:07:32 PM com.hazelcast.instance.DefaultAddressPicker INFO: [LOCAL] [dev] [3.5] Prefer IPv4 stack is true. Oct 01, 2015 4:07:32 PM com.hazelcast.instance.DefaultAddressPicker INFO: [LOCAL] [dev] [3.5] Picked Address[192.168.2.172]:5703, using socket ServerSoc  .. </code></pre>  <p>I also tried to run the process with:</p>  <pre><code>-Dlog4j.configuration=local/log4j.properties -Dlog4j.debug -Dorg.vertx.logger-delegate-factory-class-name=io.vertx.core.logging.SLF4JLogDelegateFactory </code></pre>  <p>Didnt really work.</p>  <p>Hazelcat config file:</p>  <pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;hazelcast xsi:schemaLocation="http://www.hazelcast.com/schema/config hazelcast-config-3.2.xsd"            xmlns="http://www.hazelcast.com/schema/config"            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;     &lt;properties&gt;         &lt;property name="hazelcast.mancenter.enabled"&gt;false&lt;/property&gt;         &lt;property name="hazelcast.memcache.enabled"&gt;false&lt;/property&gt;         &lt;property name="hazelcast.rest.enabled"&gt;false&lt;/property&gt;         &lt;property name="hazelcast.wait.seconds.before.join"&gt;0&lt;/property&gt;         &lt;property name="hazelcast.logging.type"&gt;Log4j&lt;/property&gt;     &lt;/properties&gt;      &lt;group&gt;         &lt;name&gt;dev&lt;/name&gt;         &lt;password&gt;dev-pass&lt;/password&gt;     &lt;/group&gt;     &lt;management-center enabled="false"&gt;http://localhost:8080/mancenter&lt;/management-center&gt;     &lt;network&gt;         &lt;port auto-increment="true" port-count="10000"&gt;5701&lt;/port&gt;         &lt;outbound-ports&gt;             &lt;!--             Allowed port range when connecting to other nodes.             0 or * means use system provided port.             --&gt;             &lt;ports&gt;0&lt;/ports&gt;         &lt;/outbound-ports&gt;         &lt;join&gt;             &lt;multicast enabled="false"&gt;                 &lt;multicast-group&gt;224.2.2.3&lt;/multicast-group&gt;                 &lt;multicast-port&gt;54327&lt;/multicast-port&gt;             &lt;/multicast&gt;             &lt;tcp-ip enabled="false"&gt;                 &lt;interface&gt;192.168.1.28&lt;/interface&gt;             &lt;/tcp-ip&gt;             &lt;aws enabled="false"&gt;                 &lt;access-key&gt;&lt;/access-key&gt;                 &lt;secret-key&gt;&lt;/secret-key&gt;                 &lt;!--optional, default is us-east-1 --&gt;                 &lt;region&gt;us-west-2&lt;/region&gt;                 &lt;!--optional, default is ec2.amazonaws.com. If set, region shouldn't be set as it will override this property --&gt;                 &lt;host-header&gt;ec2.amazonaws.com&lt;/host-header&gt;                 &lt;!-- optional, only instances belonging to this group will be discovered, default will try all running instances --&gt;                 &lt;security-group-name&gt;hazelcast-sg&lt;/security-group-name&gt;                 &lt;tag-key&gt;type&lt;/tag-key&gt;                 &lt;tag-value&gt;hz-nodes&lt;/tag-value&gt;             &lt;/aws&gt;         &lt;/join&gt;         &lt;interfaces enabled="false"&gt;             &lt;interface&gt;10.10.1.*&lt;/interface&gt;         &lt;/interfaces&gt;         &lt;ssl enabled="false"/&gt;         &lt;socket-interceptor enabled="false"/&gt;         &lt;symmetric-encryption enabled="false"&gt;             &lt;!--                encryption algorithm such as                DES/ECB/PKCS5Padding,                PBEWithMD5AndDES,                AES/CBC/PKCS5Padding,                Blowfish,                DESede             --&gt;             &lt;algorithm&gt;PBEWithMD5AndDES&lt;/algorithm&gt;             &lt;!-- salt value to use when generating the secret key --&gt;             &lt;salt&gt;thesalt&lt;/salt&gt;             &lt;!-- pass phrase to use when generating the secret key --&gt;             &lt;password&gt;thepass&lt;/password&gt;             &lt;!-- iteration count to use when generating the secret key --&gt;             &lt;iteration-count&gt;19&lt;/iteration-count&gt;         &lt;/symmetric-encryption&gt;     &lt;/network&gt;     &lt;partition-group enabled="false"/&gt;     &lt;executor-service name="default"&gt;         &lt;pool-size&gt;16&lt;/pool-size&gt;         &lt;!--Queue capacity. 0 means Integer.MAX_VALUE.--&gt;         &lt;queue-capacity&gt;0&lt;/queue-capacity&gt;     &lt;/executor-service&gt;     &lt;map name="subs"&gt;          &lt;!--             Number of backups. If 1 is set as the backup-count for example,             then all entries of the map will be copied to another JVM for             fail-safety. 0 means no backup.         --&gt;         &lt;backup-count&gt;1&lt;/backup-count&gt;         &lt;!--       Maximum number of seconds for each entry to stay in the map. Entries that are       older than &lt;time-to-live-seconds&gt; and not updated for &lt;time-to-live-seconds&gt;       will get automatically evicted from the map.       Any integer between 0 and Integer.MAX_VALUE. 0 means infinite. Default is 0.     --&gt;         &lt;time-to-live-seconds&gt;0&lt;/time-to-live-seconds&gt;         &lt;!--       Maximum number of seconds for each entry to stay idle in the map. Entries that are       idle(not touched) for more than &lt;max-idle-seconds&gt; will get       automatically evicted from the map. Entry is touched if get, put or containsKey is called.       Any integer between 0 and Integer.MAX_VALUE. 0 means infinite. Default is 0.     --&gt;         &lt;max-idle-seconds&gt;0&lt;/max-idle-seconds&gt;         &lt;!--             Valid values are:             NONE (no eviction),             LRU (Least Recently Used),             LFU (Least Frequently Used).             NONE is the default.         --&gt;         &lt;eviction-policy&gt;NONE&lt;/eviction-policy&gt;         &lt;!--             Maximum size of the map. When max size is reached,             map is evicted based on the policy defined.             Any integer between 0 and Integer.MAX_VALUE. 0 means             Integer.MAX_VALUE. Default is 0.         --&gt;         &lt;max-size policy="PER_NODE"&gt;0&lt;/max-size&gt;         &lt;!--             When max. size is reached, specified percentage of             the map will be evicted. Any integer between 0 and 100.             If 25 is set for example, 25% of the entries will             get evicted.         --&gt;         &lt;eviction-percentage&gt;25&lt;/eviction-percentage&gt;         &lt;!--             While recovering from split-brain (network partitioning),             map entries in the small cluster will merge into the bigger cluster             based on the policy set here. When an entry merge into the             cluster, there might an existing entry with the same key already.             Values of these entries might be different for that same key.             Which value should be set for the key? Conflict is resolved by             the policy set here. Default policy is PutIfAbsentMapMergePolicy             There are built-in merge policies such as             com.hazelcast.map.merge.PassThroughMergePolicy; entry will be added if there is no existing entry for the key.             com.hazelcast.map.merge.PutIfAbsentMapMergePolicy ; entry will be added if the merging entry doesn't exist in the cluster.             com.hazelcast.map.merge.HigherHitsMapMergePolicy ; entry with the higher hits wins.             com.hazelcast.map.merge.LatestUpdateMapMergePolicy ; entry with the latest update wins.         --&gt;         &lt;merge-policy&gt;com.hazelcast.map.merge.LatestUpdateMapMergePolicy&lt;/merge-policy&gt;      &lt;/map&gt;      &lt;!-- Used internally in Vert.x to implement async locks --&gt;     &lt;semaphore name="__vertx.*"&gt;         &lt;initial-permits&gt;1&lt;/initial-permits&gt;     &lt;/semaphore&gt;  &lt;/hazelcast&gt; </code></pre>  <p>Any idea?</p>