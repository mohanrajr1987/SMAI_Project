<p>Here is my problem:</p>  <p>I have a function, that gets for example some arguments:</p>  <pre><code>import argparse  default_1 = 1 default_2 = [12, 34]  parser = argparse.ArgumentParser() parser.add_argument("I", type=int) parser.add_argument("N") parser.add_argument("P", nargs='?', default=default_2) parser.add_argument("C", nargs='?', type=int, default=default_1) args = parser.parse_args()  def testfunc(I, N, ARG1=default_1, ARG2=default_2):     print(I, N, ARG1, ARG2)  testfunc(args.I, args.N, ARG1=args.C, ARG2=args.P) </code></pre>  <p>When I call it from the shell with </p>  <pre><code>&gt;&gt;&gt; python3.2 test.py 2 foo 2 foo 1 [12,34] </code></pre>  <p>which is what I expected. But if I add a <code>C 5</code> parameter:</p>  <pre><code>&gt;&gt;&gt; python3.2 test.py 2 foo C 5 3 foo 5 C </code></pre>  <p>instead of </p>  <pre><code>3 foo 5 [12, 34] </code></pre>  <p>which is certainly because I f**ked something up with the argparse. </p>  <p>The next odd thing is, when I call this function (<code>python3.2 test2.py</code>) from my other file <code>test2.py</code> like this:</p>  <pre><code>from test.py import testfunc testfunc(2, 'bar') </code></pre>  <p>returns me:</p>  <pre><code>usage: test2.py [-h] I N [P] [C] test2.py: error: too few arguments </code></pre>  <p>Update #1: When I remove <code>args = parser.parse_args()</code> (or comment it) in the <code>test.py</code> file, the <code>import testfunc</code> works. Why is that so?</p>  <p>Update #2: I came closer to the core of the problem (that's what I want to think at least ...) - with (in the <code>test.py</code>):</p>  <pre><code>import sys print(sys.argv[0]) </code></pre>  <p>I get <code>test2.py</code> as output, where I thought I would get <code>test.py</code> - so the argparser from the included function still thinks there are command line arguments being shovled it's way. How do I prevent that from happening?</p>