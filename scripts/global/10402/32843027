<p>I am studying C with a textbook, and it has of course a lot of example source code for me to practice.</p>  <p>I had no problem with managing these code files when I was just studying with gcc, a text editor and terminal.</p>  <p>And now I wanted to use an IDE so I can get hints before compiling each source code, so downloaded one and trying to put every code file into a single project template the IDE offers.</p>  <p>The code files are usually short, and always have main function for each, so creating a project and importing all of them prevented me from compiling: I have multiple main function which I should have not.</p>  <p>Here is an example so I can describe what the problem I have:</p>  <p>I now started 7th chapter in the book, so I created a project named 'ch7'. And I have currently two example codes. The project can't be compiled with all the codes at once, so I commented every main function in each of the examples and made a new main.c, containing the main function part from the examples.</p>  <p>example code 1 (find.c) - has 6 functions, including 1 main function (I made it so it's now in comment block)</p>  <pre><code>#include &lt;stdio.h&gt; #include &lt;string.h&gt;  int NUM_ADS = 7; char *ADS[] = { ... };     int sports_no_bieber(char* s) { ... } int sports_or_workout(char* s) { ... } int ns_theater(char* s) { ... } int arts_theater_or_dining(char* s) { ... } void find(int (match)(char*) ) { ... } /* int main() { ... } */ </code></pre>  <p>example code 2 (test_drive.c) - has 7 functions and 1 structure, including 1 main function.</p>  <pre><code>#include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt;  int compare_scores(const void* score_a, const void* score_b) { ... } int compare_scores_desc(const void* score_a, const void* score_b) { ... } typedef struct { ... } rectangle; int compare_areas(const void* rect_a, const void* rect_b) { ... } int compare_names(const void* name_a, const void* name_b) { ... } int compare_areas_desc(const void* rect_a, const void* rect_b) { ... } int compare_names_desc(const void* name_a, const void* name_b) { ... } /* int main() { ... } */ </code></pre>  <p>I commented the main function for each codes because I wanted to use them in a new main.c:</p>  <pre><code>#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt;  #include "find.c" #include "test_drive.c" // this list will grow as I make more example codes and include them like this. // And yes, I know this part brings problem. I shouldn't directly include code files like this.  int main(int argc, char** argv) {     /*     statements for main function in example code 1;     */      statements for main function in example code 2;     // this part is uncommented, because I am testing this one.      /*     statements for other example codes will be here after...     */     return(EXIT_SUCCESS); } </code></pre>  <p>This of course returned compile errors: multiple definition of the functions.</p>  <p>I know I can make a header and put function declarations for every function existing in all the example codes, and then include that header to my new main.c.</p>  <p>But is this the only way to manage all example codes in a single project in an IDE? The files I've shown here is only two, but a header for them should have 11 function declarations. And I have lot more example codes, from chapter 1 to 6, including about 30 c files (and much more total amount of functions in each c file of course), some h, csv and txt files for specific example source codes. </p>  <p>If I have to make a header for all of them, it wouldn't be only consuming lots of time but also will force me to add another few lines to the header every time I write a new code as I keep studying. </p>  <p>It seems much ineffective compared with just writing a code file in a text editor, opening terminal and calling gcc to compile it.</p>  <p>So I think there should be much effective way to manage such example code files in a single place, which shouldn't only be a 'project'. I want to find a way in which I can get advantages of using IDE while code file management doesn't go too complicated.</p>