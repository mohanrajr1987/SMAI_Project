<p>I'm trying to implement a sorted hash map and I have one problem. Let me describe the situation first, so that one will understand what's going on.</p>  <p>I defined an interface called <code>Map</code>. It looks like this</p>  <pre><code>public interface Map&lt;K extends Comparable&lt;K&gt;, V&gt;  {         /*** STATE INFORMATION ***/ public boolean isEmpty(); public int size(); public boolean contains(K key);         /*** MAIN OPERATIONS ***/ public void insert(K key, V value); public V get(K key); public V delete(K key); </code></pre>  <p>}</p>  <p>And I also defined a class called <code>SortedMap</code> which implements this interface. In this class I have a nested static class called <code>Item</code> which acts as wrapper. Here it is</p>  <pre><code>private static class Item&lt;K extends Comparable&lt;K&gt;, V&gt; implements Comparable&lt;Item&lt;K, V&gt;&gt; {     private K key;     private V value;      Item(K key, V value) {         this.key = key;         this.value = value;     }      @Override     public String toString() { return String.format("%s=%s", key.toString(), value.toString()); }      public int compareTo(Item&lt;K, V&gt; item) {         if (key.compareTo(item.key) &gt; 0) return 1;         else if (key.compareTo(item.key) &lt; 0) return -1;         else return 0;     } } </code></pre>  <p>And to store objects of this class I use a red black BST as an underlying storage system. </p>  <pre><code>private RedBlackBST&lt;Item&lt;K, V&gt;&gt; storage = new RedBlackBST&lt;&gt;(); </code></pre>  <p>My red black BST can store only one item (<code>Item&lt;K, V&gt;</code> in this case) per node, which itself stores two others. </p>  <pre><code>public final class RedBlackBST&lt;T extends Comparable&lt;T&gt;&gt; { private Node&lt;T&gt; root; ......... // All the rest of it } </code></pre>  <p>As you all know a map cannot have duplicate keys, so in my <code>insert()</code> method I first have to check whether it already contains that key and when I delegate this task to my red black BST <code>storage.contains()</code> I can't pass it a key only, I have to pass <code>Item</code>. This is where the problem arises.  Is there a way to solve this problem without creating yet another red black tree that might look something like this <code>Tree&lt;K, V&gt;</code>?</p>