<p>In Herb Sutter's <a href="http://www.gotw.ca/publications/mill09.htm"><code>When Is a Container Not a Container?</code></a>, he shows an example of taking a pointer into a container:</p>  <pre><code>  // Example 1: Is this code valid? safe? good?   //   vector&lt;char&gt; v;    // ...    char* p = &amp;v[0];    // ... do something with *p ... </code></pre>  <p>Then follows it up with an "improvement":</p>  <pre><code>  // Example 1(b): An improvement   //               (when it's possible)   //   vector&lt;char&gt; v;    // ...    vector&lt;char&gt;::iterator i = v.begin();    // ... do something with *i ... </code></pre>  <p>But doesn't really provide a convincing argument:</p>  <blockquote>   <p>In general, it's not a bad guideline to prefer using iterators instead   of pointers when you want to point at an object that's inside a   container. After all, iterators are invalidated at mostly the same   times and the same ways as pointers, and one reason that iterators   exist is to provide a way to "point" at a contained object. So, if you   have a choice, prefer to use iterators into containers.</p>      <p>Unfortunately, you can't always get the same effect with iterators   that you can with pointers into a container. There are two main   potential drawbacks to the iterator method, and when either applies we   have to continue to use pointers:</p>      <ol>   <li><p>You can't always conveniently use an iterator where you can use a pointer. (See example below.)</p></li>   <li><p>Using iterators might incur extra space and performance overhead, in cases where the iterator is an object and not just a bald   pointer.</p></li>   </ol> </blockquote>  <p>In the case of a vector, the iterator is just a RandomAccessIterator. For all intents and purposes this is a thin wrapper over a pointer. One implementation even acknowledges this:</p>  <pre><code>   // This iterator adapter is 'normal' in the sense that it does not    // change the semantics of any of the operators of its iterator    // parameter.  Its primary purpose is to convert an iterator that is    // not a class, e.g. a pointer, into an iterator that is a class.    // The _Container parameter exists solely so that different containers    // using this template can instantiate different types, even if the    // _Iterator parameter is the same. </code></pre>  <p>Furthermore, the implementation stores a member value of type <code>_Iterator</code>, which is <code>pointer</code> or <code>T*</code>. In other words, just a pointer. Furthermore, the <code>difference_type</code> for such a type is <code>std::ptrdiff_t</code> and the operations defined are just thin wrappers (i.e., <code>operator++</code> is <code>++_pointer</code>, <code>operator*</code> is <code>*_pointer</code>) and so on.</p>  <p>Following Sutter's argument, this iterator class provides no benefits over pointers, only drawbacks. Am I correct?</p>