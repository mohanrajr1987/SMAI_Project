<p>I am trying to use <code>tbb::parallel_sort</code> to sort 2 arrays at the same time. Intel's documentation here says <a href="https://software.intel.com/en-us/node/506167" rel="nofollow">https://software.intel.com/en-us/node/506167</a> <code>The requirements on the iterator and sequence are the same as for std::sort.</code>. This doesn't seem to be the case. My custom iterator works perfectly fine with <code>std::sort</code> but produces a compilation error with <code>tbb::parallel_sort</code>. Please see the code bellow:</p>  <pre><code>int main()//needs boost and tbb to compile {     int values_size = 6;     int nums1[] = {5, 8, 7, 89, 56, 4};     int nums2[] = {2, 1, 1, 4, 9, 2};      //WORKS!     std::sort(do_dual_sort.make_iter(nums1, nums2),      do_dual_sort.make_iter(nums1+values_size, nums2+values_size),     do_dual_sort.make_comp_desc(nums1, nums2));      //DOESN'T COMPILE     tbb::parallel_sort(do_dual_sort.make_iter(nums1, nums2),      do_dual_sort.make_iter(nums1+values_size, nums2+values_size),     do_dual_sort.make_comp_desc(nums1, nums2));      for(unsigned int i = 0; i &lt; values_size; i++) cout &lt;&lt; "nums1[" &lt;&lt; i &lt;&lt; "] " &lt;&lt; nums1[i] &lt;&lt; " | nums2[" &lt;&lt; i &lt;&lt; "] "  &lt;&lt; nums2[i] &lt;&lt; "\n";     return 0; }  class dual_sort { public:     template &lt;class T, class T2&gt;     struct helper_type {         public:             typedef boost::tuple&lt;typename iterator_traits&lt;T&gt;::value_type, typename iterator_traits&lt;T2&gt;::value_type&gt; value_type;             typedef boost::tuple&lt;typename iterator_traits&lt;T&gt;::value_type&amp;, typename iterator_traits&lt;T2&gt;::value_type&amp;&gt; ref_type;     };      template &lt;typename T1, typename T2&gt;     class dual_iterator : public boost::iterator_facade&lt;dual_iterator&lt;T1, T2&gt;,                                                         typename helper_type&lt;T1, T2&gt;::value_type,                                                         boost::random_access_traversal_tag,                                                         typename helper_type&lt;T1, T2&gt;::ref_type&gt; {     public:         explicit dual_iterator(T1 iter1, T2 iter2) : mIter1(iter1), mIter2(iter2) {}         typedef typename iterator_traits&lt;T1&gt;::difference_type difference_type;     private:         void increment() { ++mIter1; ++mIter2; }         void decrement() { --mIter1; --mIter2; }         bool equal(dual_iterator const&amp; other) const { return mIter1 == other.mIter1; }         typename helper_type&lt;T1, T2&gt;::ref_type dereference() const { return (typename helper_type&lt;T1, T2&gt;::ref_type(*mIter1, *mIter2)); }         difference_type distance_to(dual_iterator const&amp; other) const { return other.mIter1 - mIter1; }         void advance(difference_type n) { mIter1 += n; mIter2 += n; }          T1 mIter1;         T2 mIter2;         friend class boost::iterator_core_access;     };      template &lt;typename T1, typename T2&gt;     dual_iterator&lt;T1, T2&gt; make_iter(T1 t1, T2 t2) { return dual_iterator&lt;T1, T2&gt;(t1, t2); }      template &lt;class T1, class T2&gt; struct iter_comp_desc {         typedef typename helper_type&lt;T1, T2&gt;::value_type T;         bool operator()(const T&amp; t1, const T&amp; t2) const { return get&lt;0&gt;(t1) &gt; get&lt;0&gt;(t2); }         bool operator()(const char*&amp; t1, const char*&amp; t2) const { return strcmp(get&lt;0&gt;(t1), get&lt;0&gt;(t2)) == 1; }     };      template &lt;class T1, class T2&gt; iter_comp_desc&lt;T1, T2&gt; make_comp_desc(T1 t1, T2 t2) { return iter_comp_desc&lt;T1, T2&gt;(); }  } do_dual_sort; </code></pre>  <p>The compilation error I am getting is:</p>  <pre><code>error C2512: 'dual_sort::dual_iterator&lt;T1,T2&gt;' : no appropriate default constructor available with [     T1=int *,     T2=int * ] tbb44_20150728oss\include\tbb/parallel_sort.h(201) : see reference to function template instantiation 'void tbb::internal::parallel_quick_sort&lt;RandomAccessIterator,Compare&gt;(RandomAccessIterator,RandomAccessIterator,const Compare &amp;)' being compiled with [     RandomAccessIterator=dual_sort::dual_iterator&lt;int *,int *&gt;,     Compare=dual_sort::iter_comp_desc&lt;int *,int *&gt; ] main.cpp(1125) : see reference to function template instantiation 'void tbb::parallel_sort&lt;dual_sort::dual_iterator&lt;T1,T2&gt;,dual_sort::iter_comp_desc&lt;T1,T2&gt;&gt;(RandomAccessIterator,RandomAccessIterator,const Compare &amp;)' being compiled with [     T1=int *,     T2=int *,     RandomAccessIterator=dual_sort::dual_iterator&lt;int *,int *&gt;,     Compare=dual_sort::iter_comp_desc&lt;int *,int *&gt; ] </code></pre>  <p><strong>Edit</strong>: The compiler I used is <code>Visual Studio 2012</code>. You can try to replace some boost functions with <code>std</code> ones to get it work on <code>g++</code>.</p>