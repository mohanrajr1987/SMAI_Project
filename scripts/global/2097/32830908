<p>Say I have two classes defined as such:</p>  <pre><code>namespace DecaveNamespace {     class MyElt1 {         public:             list&lt;MyElt2&gt;::iterator elt2;     }      class MyElt2 {         public:             list&lt;MyElt1&gt;iterator elt1;     } } </code></pre>  <p>In other words, for all intents and purposes, each class has a pointer to an element of the other class that is encapsulated as an iterator.</p>  <p>Now, say that I do some logic in a function somewhere and I want to update a pointer in <code>MyElt1</code> to point to a different instance of the class <code>MyElt2</code>. In other words:</p>  <pre><code>// ... some logic MyElt1 some_elt_1 = some_logic(); MyElt2 some_elt_2 = some_logic_2();  some_elt_1.elt2 = &amp;some_elt_2; </code></pre>  <p>If I try to do the above, I get the above compiler error:</p>  <pre><code>/usr/include/c++/4.8.2/bits/stl_list.h:125:12: note:   no known conversion for argument 1 from ‘DecaveNamespace::MyElt2*’ to ‘std::_List_iterator&lt;DecaveNamespace::MyElt2&gt;&amp;&amp;’ </code></pre>  <p>So clearly the issue is that I'm passing the wrong address back to the reference to the iterator. But then how do I update <code>MyElt1</code>'s pointer to point to a new object?</p>