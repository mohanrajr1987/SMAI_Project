<p>A "Singular Iterator" is <a href="http://en.cppreference.com/w/cpp/concept/Iterator" rel="nofollow">defined as</a> an: </p>  <blockquote>   <p>iterators that are not associated with any sequence. A null pointer, as well as a default-constructed pointer (holding an indeterminate value) is singular</p> </blockquote>  <p>My question <strong>1</strong> would be: <strong>Is a default constructed iterator considered a "Singular Iterator"?</strong></p>  <p>Secondly, I have been <a href="http://stackoverflow.com/questions/32748870/visual-studio-const-iterator-assignment-error#comment53340001_32748870">told here</a> that:</p>  <blockquote>   <p>Results of most expressions are undefined for singular values; the only exceptions are destroying an iterator that holds a singular value, the assignment of a non-singular value to an iterator that holds a singular value, and, for iterators that satisfy the DefaultConstructible requirements, using a value-initialized iterator as the source of a copy or move operation.</p> </blockquote>  <p>Question <strong>2</strong> is: <strong>Does working with a result that is "undefined" constitute Undefined Behavior?</strong> It would seem that if that were true this would be Undefined Behavior:</p>  <pre><code>void* foo = nullptr; auto bar = foo; </code></pre>  <p>But <a href="http://ideone.com/m272Wh" rel="nofollow">it runs fine</a>.</p>  <hr>  <p>My deeper motivation for asking this question is in the case where I have a struct like this:</p>  <pre><code>struct Foo {     vector&lt;int*&gt;::const_iterator; }; </code></pre>  <p>I want to know if it is undefined behavior to do this, where <code>assigned</code> is a value constructed <code>Foo</code> object:</p>  <pre><code>Foo unasigned;  assigned = unassigned; </code></pre>  <p>If the answers to questions <strong>1</strong> and <strong>2</strong> are "yes" then by invoking the default assignment operator I am introducing undefined behavior :( </p>