<p>I need to get the cartesian product of iterables, like <code>itertools.product</code> gives me, but for optimization reasons I want those pairs/combinations with the lowest sum of indices to appear first.</p>  <p>So, for example, if I have two lists, <code>a = [1, 2, 3, 4, 5]</code> and <code>b = ['a', 'b', 'c', 'd', 'e']</code>, <code>itertools.product</code> gives me:</p>  <pre><code>&gt;&gt;&gt; list(itertools.product(a, b)) [(1, 'a'), (1, 'b'), (1, 'c'), (1, 'd'), (1, 'e'), (2, 'a'), (2, 'b'), (2, 'c'), (2, 'd'), (2, 'e'), (3, 'a'), (3, 'b'), (3, 'c'), (3, 'd'), (3, 'e'), (4, 'a'), (4, 'b'), (4, 'c'), (4, 'd'), (4, 'e'), (5, 'a'), (5, 'b'), (5, 'c'), (5, 'd'), (5, 'e')] </code></pre>  <p>Instead, I would want to see <code>(2, 'a')</code> before <code>(1, 'c')</code>. The exact order, between e.g. <code>(1, 'b')</code> and <code>(2, 'a')</code>, is unimportant.</p>  <hr>  <p>Currently, I am sorting a list based on the product of the index ranges:</p>  <pre><code>&gt;&gt;&gt; sorted(list(itertools.product(range(len(a)), range(len(b)))), lambda a, b: sum(a) - sum(b)) [(0, 0), (0, 1), (1, 0), (0, 2), (1, 1), (2, 0), (0, 3), (1, 2), (2, 1), (3, 0), (0, 4), (1, 3), (2, 2), (3, 1), (4, 0), (1, 4), (2, 3), (3, 2), (4, 1), (2, 4), (3, 3), (4, 2), (3, 4), (4, 3), (4, 4)] </code></pre>  <p>Then using that to index the lists. However, this takes too much memory with long lists. I need some kind of generator with the same calling convention as <code>itertools.product</code>, but I cannot figure out the way to iterate so that I get both the ordering and all the possible pairs exactly once.</p>