<p>I've a linked list with some elements.</p>  <pre><code> { (?i), \\d+, \\., \\d+, (?i), \\d+, \\. } </code></pre>  <p>Now, while iterating, I need to find out if three consecutive values are <code>"\\d+", "\\.", "\\d+"</code>, if yes, I need to merge them into one node with value <code>"\\d+\\.\\d+"</code>. So, my previous list should look like the below after the said operation.</p>  <pre><code>{(?i), \\d+\\.\\d+, (?i), \\d+, \\.} </code></pre>  <p>But, as java doesn't expose linked list's internal node class there is no way for me to look ahead more than one node at a time. I could get it working with the following code, but it looks ugly to me. I'm wondering if there is any clean way of achieving the same.</p>  <pre><code>LinkedList&lt;String&gt; l = new LinkedList&lt;&gt;(); //this can be ArrayList aswell.  l.add("(?i)"); l.add("\\d+"); l.add("\\."); l.add("\\d+"); l.add("(?i)"); l.add("\\d+"); l.add("\\."); System.out.println(l.toString()); List&lt;Integer&gt; indexesToBeRemoved = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; l.size(); i++) {     int j = i;     if ("\\d+".equals(l.get(j))) {         j++;         if (j &lt; l.size() &amp;&amp; "\\.".equals(l.get(j))) {             j++;             if (j &lt; l.size() &amp;&amp; "\\d+".equals(l.get(j))) {                 l.set(i, "\\d+\\.\\d+");                 indexesToBeRemoved.add(j);                 indexesToBeRemoved.add(--j);             }         }      } }  for (int i : indexesToBeRemoved) {     l.remove(i); }  System.out.println(l.toString());  O/P: [(?i), \d+, \., \d+, (?i), \d+, \.] [(?i), \d+\.\d+, (?i), \d+, \.] </code></pre>