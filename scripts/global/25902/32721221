<p>I've recently realised that in my projects it's often necessary to react to keyboard events, usually adjusting some layout or making some other changes. In order to achieve this I have to complete 3 steps each time:</p>  <ul> <li>Register a VC as an observer for keyboard notifications;</li> <li>Create a couple of corresponding methods to handle notifications;</li> <li>Finally remove VC from observers list at appropriate time (dealloc,willDissappear, etc.); </li> </ul>  <p>I started to think, how can I make this steps into a simple reusable instrument.</p>  <p>The most obvious solution is to subclass a UIViewController, add all three steps to it, and then just override handling methods. This will work, but it's not very flexible. What if I want to stop observing at different point? Another argument against a superclass is that most of my controllers already have 2 parent classes before UIViewController. One for scrolling management and another one for tableView management. Is this a good practice to have such a subclass tree? Any disadvantages?</p>  <p>Second solution that comes to mind is a EventManager class that takes blocks to complete event handling. Here's the code for it:</p>  <p><strong>.h</strong></p>  <pre><code>#import &lt;Foundation/Foundation.h&gt; @import UIKit;  @interface NKKeyboardEventsManager : NSObject  @property (nonatomic, assign, getter=isObserving) BOOL observing;  +(instancetype)managerWithShowBlock:(void (^)(CGFloat kbHeight))showBlock hideBlock:(void (^)(void))hideBlock ; - (void)startEventsObserving; - (void)stopEventsObserving;  @end </code></pre>  <p><strong>.m</strong></p>  <pre><code>@interface NKKeyboardEventsManager ()  @property (nonatomic, copy) void (^showBlock)(CGFloat kbHeight); @property (nonatomic, copy) void (^hideBlock)(void);  @end  @implementation NKKeyboardEventsManager  + (instancetype)managerWithShowBlock:(void (^)(CGFloat kbHeight))showBlock hideBlock:(void (^)(void))hideBlock {      NKKeyboardEventsManager *manager = [super new];      if (manager) {         manager.showBlock = showBlock;         manager.hideBlock = hideBlock;          [manager startEventsObserving];     }      return manager; }  - (void)startEventsObserving {      if (self.isObserving) return;      self.observing = YES;      [[NSNotificationCenter defaultCenter] addObserver:self                                              selector:@selector(_handleKeyboardWillShow:) name:UIKeyboardWillShowNotification object:nil];     [[NSNotificationCenter defaultCenter] addObserver:self                                              selector:@selector(_handleKeyboardWillHide:) name:UIKeyboardWillHideNotification object:nil];   }  - (void)stopEventsObserving {     [[NSNotificationCenter defaultCenter] removeObserver:self];  }   #pragma mark - Private   - (void)_handleKeyboardWillShow:(NSNotification *)paramNotification  {      NSDictionary* info = [paramNotification userInfo];     CGFloat kbHeightNew = [[info objectForKey:UIKeyboardFrameEndUserInfoKey] CGRectValue].size.height;      if (self.showBlock) {         self.showBlock(kbHeightNew);     }  }  - (void)_handleKeyboardWillHide:(NSNotification *)paramNotification  {     if (self.hideBlock) {         self.hideBlock();     }  }  @end </code></pre>  <p>It works okish, not to much boilerplate code:</p>  <pre><code>#import "NKKeyboardEventsManager.h"  @interface ViewController ()  @property (nonatomic, weak) IBOutlet NSLayoutConstraint *textViewBottomConstraint; @property (nonatomic, strong) NKKeyboardEventsManager *keyboardManager;  @end  @implementation ViewController  - (void)viewWillAppear:(BOOL)animated {      [super viewWillAppear:animated];        __weak typeof(self) weakSelf = self;      self.keyboardManager = [NKKeyboardEventsManager managerWithShowBlock:^(CGFloat kbHeight) {          weakSelf.textViewBottomConstraint.constant = kbHeight + 20;         [weakSelf.view layoutIfNeeded];       } hideBlock:^{          weakSelf.textViewBottomConstraint.constant = 20;         [weakSelf.view layoutIfNeeded];       }];   }  - (void)viewWillDisappear:(BOOL)animated {      [super viewWillDisappear:animated];      [self.keyboardManager stopEventsObserving];  } </code></pre>  <p>But this solution comes with some blocks problem. Everything within the block is captured by the block, and the block itself is captured by the manager which is captured by the VC. I'm walking on a thin ice of retain cycles. This is why I had to set manager to nil to break the cycle.</p>  <blockquote>   <p><strong>UPDATE:</strong>   I incorporated a tip from @Ben Pious to use <code>weakSelf</code> inside the block.</p> </blockquote>  <p>I'm looking for any suggestions to both solutions. Both do not seem great to me. Throw anything, some minor tweaks or a completely new approach, like some clever #define macro with block parameters or something.</p>