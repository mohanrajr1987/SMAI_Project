<p>I have a solution split into two projects : A class library containing all of my model classes (lets call it <strong>Business</strong>), and an ASP.Net MVC project.</p>  <p>My <strong>Business</strong> classes are meant to be generic and work for multiple types of projects. For this reason, they don't contain any <strong>data annotations</strong>/<strong>associations</strong> to other classes, only <strong>member variables</strong>/<strong>properties</strong>/<strong>constructors</strong>.</p>  <p>Using the code-first approach, how should I design my ASP.Net models to work with my <strong>Business</strong> models.</p>  <p>My initial taught was setting my <strong>Business</strong> classes as partial classes and then overwrite my properties by adding the necessary <strong>data annotations</strong>/<strong>associations</strong>. I can't do that because we are dealing with two separate projects.</p>  <p>I was also thinking that I could use <strong>inheritance</strong>. My ASP.Net models could inherit from the Business classes and I could add my <strong>data annotations</strong>/<strong>associations</strong> on top of that. This seems a bit messy and illogical though, as I would need to define all of my constructors in this new subclass.</p>  <p>Is there a smart way of doing this in a cleanly?</p>  <p>EDIT :</p>  <p>My <strong>Business</strong> classes have validations by throwing exceptions in the property setters. My first design was to create my own custom <strong>data annotation</strong> that will catch the exceptions thrown by my setters : </p>  <pre><code>public class SetterBasedValidation : ValidationAttribute     {         string m_errorMessage = null;         public SetterBasedValidation(string errorMessage)         {             m_errorMessage = errorMessage;         }          protected override ValidationResult IsValid(object value, ValidationContext validationContext)         {             try             {                 Type type = validationContext.ObjectType;                 PropertyInfo property = type.GetProperty(validationContext.MemberName);                 property.SetValue(validationContext.ObjectInstance, value);             }             catch (Exception)             {                 return new ValidationResult(m_errorMessage);             }              return ValidationResult.Success;         }     } </code></pre>  <p>I would then need a way to use my custom data annotation in my ASP.Net model class. This would give me the result I want : </p>  <ul> <li>Keep my Business classes generic</li> <li>Use the validations from my setters</li> <li>Use data annotations</li> </ul>