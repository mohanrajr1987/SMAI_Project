<p>I've got a BuildingAudit class in my EF code first. This audit is associated with a Building. Each building can only ever have one active audit. But I track changes to the audit via a revision column on the class, which is a non null integer.</p>  <p>Every time I run an EF query. The revision always comes back as 1, even when my query includes a check for revision is equal to something other than 1. I don't understand. There is nothing in the mapping that would cause this, nothing in the POCO that would override that value after query. How can this be happening?</p>  <p>Here is my code:</p>  <pre><code>BuildingAudit buildingAudit = null;         if (revision == null)         {             buildingAudit = _buildingAuditService.CustomQuery().Where(x =&gt; x.BuildingId == selectedBuilding.Id).OrderByDescending(x =&gt; x.Revision).FirstOrDefault();         }         else         {             buildingAudit = _buildingAuditService.CustomQuery().FirstOrDefault(x =&gt; x.BuildingId == selectedBuilding.Id &amp;&amp; x.Revision == revision);         } </code></pre>  <p>For those wondering the CustomQuery() merely generically exposes EF's Context.Set as queryable :</p>  <pre><code>public virtual IQueryable&lt;TClass&gt; Query()     {         return Context.Set&lt;TClass&gt;().AsQueryable();     } </code></pre>  <p>Also my POCO:</p>  <pre><code> public class BuildingAudit : Entity {     public Guid BuildingId { get; set; }     public virtual Building Building { get; set; }      public virtual ICollection&lt;AuditCategory&gt; AuditCategories { get; set; }      public Guid Auditor { get; set; }     public virtual User Auditor { get; set; }      public bool IsComplete { get; set; }     public int Revision { get; set; }      public BuildingAudit()     {         InitializeCollections();     }      private void InitializeCollections()     {         AuditCategories = new Collection&lt;AuditCategory&gt;();     } } </code></pre>  <p>And entity which this class inherits from just has this:</p>  <pre><code>public abstract class Entity {     public Guid Id { get; set; }     public DateTime DateCreated { get; set; }     public DateTime DateModified { get; set; }     public string CreatedBy { get; set; }     public string LastModifiedBy { get; set; }     public bool Active { get; set; } } </code></pre>  <p>So nothing wonky there. Yet every time I debug this query, it will go to the else statement, the revision supplied in the .Where is NOT 1 so for instance 2. Yet when the object is returned, it has a revision of 1!</p>  <p>Anyone have any idea?</p>  <p>Here are some pictures, I have to crop to hide some sensitive information, but they are from one debug run through the above pasted code:</p>  <p><a href="http://i.stack.imgur.com/VHwId.png" rel="nofollow"><img src="http://i.stack.imgur.com/VHwId.png" alt="enter image description here"></a></p>  <p>That's from checking the revision value in the else statement, clearly showing to return audits where revision = 2 for the selected building. Then:</p>  <p><a href="http://i.stack.imgur.com/ssOH9.png" rel="nofollow"><img src="http://i.stack.imgur.com/ssOH9.png" alt="enter image description here"></a></p>  <p>The returned object property has revision 1...It should also be noted that I can save values other than 1 and the database properly reflects that, but I can't seem to query anything other than 1.</p>  <p><strong>ANSWER:</strong></p>  <pre><code>if (revision == null)         {             assessment = _hazardAssessmentService.CustomQuery().Where(x =&gt; x.LaboratoryId == selectedLab.Id).OrderByDescending(x =&gt; x.Revision).FirstOrDefault();         }         else         {             int rev = (int) revision;             assessment = _hazardAssessmentService.CustomQuery().FirstOrDefault(x =&gt; x.LaboratoryId == selectedLab.Id &amp;&amp; x.Revision == rev);         } </code></pre>  <p>revision is nullable int in this function, but on the POCO is a plain int. Converting revision to a plain int made this stop happening. I am checking if it's null and it never would be at this part in the if, but not sure why that would cause EF to break without notifying of any error.</p>