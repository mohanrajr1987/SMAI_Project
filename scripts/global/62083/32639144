<p>I have a detail view corresponding to a user entity. Each user entity has one or more comment entities, which is represented on the detail view as a grid.</p>  <p><a href="http://i.stack.imgur.com/LhnGb.png" rel="nofollow"><img src="http://i.stack.imgur.com/LhnGb.png" alt="Detail view with grid"></a></p>  <p>So following EF convention, the user model has a UserComments member to represent the relation:</p>  <pre><code>public partial class User {     public int UserID { get; set; }     public string FirstName { get; set; }     public string LastName { get; set; }     public virtual ICollection&lt;UserComments&gt; UserComments { get; set; }     //.... } </code></pre>  <p>When it came time to create the user comments grid in the user detail view, I realized that the grid does not properly bind to an ICollection (couldn't add new rows to the grid). After some digging, I found that I needed to use an ObservervableColletion. Ok, so I converted my ICollection into an ObserverableCollection.... </p>  <pre><code>public class UserDetailViewModel {      public virtual User UserData { get; set; }       private ObservableCollection&lt;UserComments&gt; _UserComments;         public ObservableCollection&lt;UserComment&gt; UserComments {         get { return _UserComments; }     }      public void Load(int UserID)     {         this.UserData = UserRepo.Find(UserID);               this._UserComments = new ObservableCollection&lt;UserComment&gt;(UserData.UserComments);     }  } </code></pre>  <p>Cool. I can add rows to the grid now. But...</p>  <p>At this point, I've realized I've lost EF change tracking by converting User.UserComments to an ObservableCollection and have no easy way of getting the modifed/new comments back into EF.</p>  <p>So have I approached this all wrong? Is there a better way of updating the related data?</p>