<p>I'm developing a solution where I send a POST request from the first server to the second server using cURL.</p>    <pre class="lang-php prettyprint-override"><code>function sendIcuCurlRequest($identity, $action, $payload){     $url = '-- Removed --';      $data = array(         'identity' =&gt; $identity,         'action' =&gt; $action,         'payload' =&gt; $payload     );     $fields = http_build_query($data);      $ch = curl_init();      curl_setopt($ch, CURLOPT_URL, $url);     curl_setopt($ch, CURLOPT_POST, count($data));     curl_setopt($ch, CURLOPT_POSTFIELDS, $fields);     curl_setopt($ch, CURLOPT_FORBID_REUSE, 1);     curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);      $result = curl_exec($ch);     curl_close($ch);      return $result; } </code></pre>  <p>On the second server where the cURL request is picked up, ZeroMQ sends the data using <code>SOCKET_PUSH</code> to the WebSocket server (WebSocket server is on the second server).</p>  <pre class="lang-php prettyprint-override"><code>if(isset($_POST['identity'], $_POST['action'], $_POST['payload'])){     $identity = $_POST['identity'];     $action = $_POST['action'];     $payload = $_POST['payload'];      $context = new ZMQContext();     $socket = $context-&gt;getSocket(ZMQ::SOCKET_PUSH, 'ICU push');     $socket-&gt;connect('tcp://127.0.0.1:21002');     $socket-&gt;send(json_encode(array('identity' =&gt; $identity, 'message' =&gt; formatRequest($action, $payload))));     exit; } else {     echo "Invalid request";     exit; } </code></pre>  <p>The WebSocket server then makes a RPC Call to the Client.</p>  <pre class="lang-php prettyprint-override"><code>public function onNewRequest($request){     $requestData = json_decode($request, true);     echo "Outgoing new request for Charge Point: ".var_export($request, true)."\n";      // Check if is valid Station     if(!array_key_exists($requestData['identity'], $this-&gt;stations)){         echo "Identity {$requestData['identity']} not found.\n";         return;     }      $station = $this-&gt;stations[$requestData['identity']];     $res = $station-&gt;send(json_encode($requestData['message']));     file_put_contents(dirname(__FILE__).'/../../logs/broadcast-'.date('Ymd').'.log', print_r($res, true)."\n\n", FILE_APPEND); } </code></pre>  <p>The Client after some thinking sends a CallResult to an <code>onCallResult</code> method with the response. (<strong>Note:</strong> I've modified Ratchet's WAMP core so it would be possible to receive CallResults from the Client)</p>  <pre class="lang-php prettyprint-override"><code>public function onCallResult(ConnectionInterface $conn, $id, array $params){     $url = $conn-&gt;WebSocket-&gt;request-&gt;getUrl();      echo "URL path -- ".$url."\n";     echo "IP -- ".$conn-&gt;remoteAddress."\n";     echo "Incoming call result (ID: $id)\n";     echo "Payload -- ".var_export($params, true)."\n"; } </code></pre>  <p><strong>Now to the fun part</strong> Now that I have the response from the Client, I would like to send that response back with cURL using the same connection the initial request came through.</p>  <p>I am thinking that with cURL alone I wouldn't be able to achieve this (I found that there is a new method like <code>curl_pause</code> but that is for 5.5 and up. Current server is running 5.4).</p>  <p>I did also find that ZeroMQ has a socalled <code>REQ</code> and <code>REP</code> but I can't quite figure out if that will serve the prupose on getting it work like this.</p>  <p>What would be the best for me to send a cURL response back to the initial request that came?</p>