<p>I'm using x:Bind (compiled binding) in my UWP app to bind a TextBlock to an integer property in the ViewModel which is converted to a string by a value converter. I am using a method in the ViewModel on the worker thread to set the properties and call the PropertyChanged event. However, I am getting an exception (specifically, it's in the XamlBindingSetters class in the MainPage.g.cs file) saying, "The application called an interface that was marshalled for a different thread." <a href="http://stackoverflow.com/questions/8994714/updating-bound-properties-from-a-background-thread">According to this post</a>, this should work just fine in WPF; has this ease of functionality been removed in WinRT/UWP or am I doing something wrong?</p>  <p>Here's exactly what I'm doing.</p>  <p>My property is defined like this:</p>  <pre><code>private int myProperty;      public int MyProperty     {         get { return myProperty; }         set         {             Set(ref myProperty, value);         }     } </code></pre>  <p>The Set method is part of the Template 10 library and is defined:</p>  <pre><code>public bool Set&lt;T&gt;(ref T storage, T value, [CallerMemberName]string propertyName = null)       {           if (object.Equals(storage, value))               return false;           storage = value;           RaisePropertyChanged(propertyName);           return true;       }  </code></pre>  <p>Nothing wrong there from what I can see; it just makes sure the new value is different than the old value and then calls RaisePropertyChanged(propertyName) which makes sure the app is actually running (not in design mode) and then raises the PropertyChanged event.</p>  <p>I set my property from a worker thread: </p>  <pre><code>MyProperty = newValue; </code></pre>  <p>and when it gets to the XamlBindingSetters class:</p>  <pre><code>internal class XamlBindingSetters     {         public static void Set_Windows_UI_Xaml_Controls_TextBlock_Text(global::Windows.UI.Xaml.Controls.TextBlock obj, global::System.String value, string targetNullValue)         {             if (value == null &amp;&amp; targetNullValue != null)             {                 value = targetNullValue;             }             obj.Text = value ?? global::System.String.Empty;         }     }; </code></pre>  <p>it breaks on that last line (obj.Text = ...) and tells me that the application called an interface that was marshalled for a different thread. What am I doing wrong?</p>