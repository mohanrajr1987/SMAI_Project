<p>I have a <code>SurfaceView</code> that that the user can draw multiple bitmaps to and modify (stickers). The stickers are held in a <code>LinkedList</code> that is iterated on <code>MotionEvent.ACTION_DOWN</code> to find which sticker is being touched by the user:</p>  <pre><code>private void setActiveSticker(float x, float y) {     Iterator&lt;Sticker&gt; stickersDesc = mStickers.descendingIterator();     while (stickersDesc.hasNext()) {         Sticker sticker = stickersDesc.next();         if (sticker.collider(x, y)) {             mActiveSticker = sticker;             mMode = MODE_DRAG;             break;         }         mStickers.remove(mActiveSticker);         mStickers.add(mActiveSticker);     } } </code></pre>  <p>This <code>LinkedList</code> is also iterated to draw each one to the <code>Canvas</code> of the <code>SurfaceView</code> as they are manipulated:</p>  <pre><code>@Override public void draw (Canvas canvas) {     super.draw(canvas);      canvas.drawBitmap(mBitmap, mMatrix, mPaint);      for (Sticker sticker : mStickers) {         sticker.draw(canvas);     } } </code></pre>  <p>And this is where I get a <code>ConcurrentModificationException</code>:</p>  <pre><code>09-28 08:56:41.769  19832-24370/com.example.ex E/AndroidRuntimeï¹• FATAL EXCEPTION: Thread-5279 Process: com.example.ex, PID: 19832 java.util.ConcurrentModificationException         at java.util.LinkedList$LinkIterator.next(LinkedList.java:124)         at com.example.ex.utilities.DrawingSurface.draw(DrawingSurface.java:133)         at com.example.ex.utilities.DrawingThread.onSurfaceUpdate(DrawingThread.java:95)         at com.example.ex.utilities.DrawingThread.run(DrawingThread.java:46) </code></pre>  <p>The <code>draw()</code> method of the <code>SurfaceView</code> is called by a separate <code>Thread</code>:</p>  <pre><code>public class DrawingThread extends Thread {     volatile boolean mRunning = false;      private long mRefreshRate;     private DrawingSurface mSurface;      public DrawingThread (DrawingSurface surface, long time) {         super();         mSurface = surface;         mRefreshRate = time;     }      public void setRunning (boolean run) {         mRunning = run;     }      @Override     public void run() {         while (mRunning) {             try {                 sleep(mRefreshRate);                 onSurfaceUpdate();             } catch (InterruptedException exception) {                 exception.printStackTrace();             }         }     }      public void onSurfaceChanged(Configuration config, Point fit, float ratio) {         float width, height;         if (config.orientation == Configuration.ORIENTATION_LANDSCAPE) {             width = fit.y * ratio;             height = fit.y;         } else if (config.orientation == Configuration.ORIENTATION_PORTRAIT) {             width = fit.x;             height = fit.x / ratio;         } else {             width = fit.x;             height = fit.x / ratio;         } mSurface.getHolder().setFixedSize((int) width, (int) height);     }      private void onSurfaceUpdate() {         Canvas canvas = null;          try {             canvas = mSurface.getHolder().lockCanvas();             synchronized (mSurface.getHolder()) {                 mSurface.draw(canvas);             }         } finally {             if (canvas != null) {                 mSurface.getHolder().unlockCanvasAndPost(canvas);             }         }     } } </code></pre>  <p>I have tried pausing the thread before the <code>LinkedList</code> is iterated in <code>setActiveSticker()</code> and resuming after the loop is finished in an attempt to avoid the both modifications from happening at the same time. Even though that does not seem to be recommended. I would like to know how I can iterate the <code>LinkedList</code> without this error, or if there is a better way of achieving the same functionality.</p>