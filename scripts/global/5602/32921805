<p>Using C I'm storing a large amount of data in a linked list structure. Some items in the linked list point to the same malloc'd data and this is causing issues when it comes to free-ing the linked list structure. I could solve the issue by copying the data as it's inserted into the linked list structure, but this has bigger implications for my program.</p>  <p>That said: the fact that I'm running into this issue suggests I have a design problem. As such, I'm looking for strategies and suggestions to help deal with this problem.</p>  <p>Here's some code that highlights the issue (and yes, I know that I shouldn't be blindly casting <code>malloc</code> like this):</p>  <pre><code>char *val = (char *)malloc(sizeof(256)); strcpy(val, "Dummy value");  LinkedListItem *itemB = (LinkedListItem *)malloc(sizeof(LinkedListItem)); itemB-&gt;value = val; itemB-&gt;next = NULL;  LinkedListItem *itemA = (LinkedListItem *)malloc(sizeof(LinkedListItem)); itemA-&gt;value = val; itemA-&gt;next = itemB;  LinkedListItem *cur = itemA; while(cur) {     free(cur-&gt;value); // the crash will occur here, when performing a double free on itemB's value pointer     cur-&gt;value = NULL;      cur = cur-&gt;next; } </code></pre>  <p>I've seen many references to a 'safe' version of free that essentially NULL's the pointer after free-ing it, like so:</p>  <pre><code>void free_generic(void **pp) {     assert(pp);      if(pp != NULL)     {         free(*pp);         *pp = NULL;     } }  while(cur) {     free_generic(&amp;cur-&gt;value);     cur = cur-&gt;next; } </code></pre>  <p>But this seems to have no effect. Any suggestions?</p>