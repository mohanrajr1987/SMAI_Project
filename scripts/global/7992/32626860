<p>I stumbled upon the behavior that bitwise or arithmetic operations are not allowed on primitive types smaller than 32 bit, but the respective assignment operations are in fact allowed:</p>  <pre><code>short BitwiseAnd(short a, short b) { return a &amp; b; }         // error short BitwiseAndAssignment(ref short a, short b) { a &amp;= b; } // works  short Add(short a, short b) { return a + b; }                // error short AddAssignment(ref short a, short b) { a += b; }        // works </code></pre>  <p>The same behavior holds for other short primitive types like <code>byte</code>, <code>sbyte</code>, and <code>ushort</code>.</p>  <p>I understand that arithmetic and logical operations are defined for 32-bit and larger types (<code>int</code>, <code>long</code>...) because it's what the processor provides (<a href="http://stackoverflow.com/questions/941584/byte-byte-int-why">see this question</a>), and shorter types are widened and can be casted back to 8 or 16 bit. However, is there a reason why this would work in an assignment operator? First I assumed that behind the scenes, the <code>short</code>s are casted to <code>int</code>, but then you would have an assignment/return value <code>short value = (some int)</code>, which should yield an error since the cast is not implicit.</p>  <p><em>On a different note</em>: I tried out some code in Visual Studio's immediate window, but there, a lot more code seems to work. The immediate window probably does some implicit casting which would usually be explicit. E.g., <code>short a = (int)5;</code> is allowed in the immediate window. So that's not helping.</p>