<p>History: Why we can overload -> and not . operator? Both are member access operator and has same significance. </p>  <p>I have read some reference from </p>  <p><a href="http://www.stroustrup.com/bs_faq2.html#overload-dot" rel="nofollow">http://www.stroustrup.com/bs_faq2.html#overload-dot</a></p>  <p>AND</p>  <p><a href="http://stackoverflow.com/questions/2938545/why-can-operator-be-overloaded-manually">Why can operator-&gt; be overloaded manually?</a></p>  <p>But still my doubts remains the same why we can overload .operator while not ->? </p>  <p>Is it because -> operator implicitly gets the reference of the returning pointer and thus making the call as the chain calls</p>  <pre><code>struct X {     int foo; };  struct Y {     X x;     X* operator-&gt;() { return &amp;x; } };  struct Z {     Y y;     Y&amp; operator-&gt;() { return y; } };  Z z; z-&gt;foo = 42;          // Works!   </code></pre>  <p><strong>z->foo = 42; This call is converted to ((z.operator()).opeartor()).operator() and thus value of foo is set to 42.</strong></p>  <p>Question:- If I take this point I still have two more points,</p>  <p>1) why can't .(dot) operator works this way?</p>  <p>2) What if -> operator do not returns the reference to the class Y? Will it be a compilation error in that case?</p>