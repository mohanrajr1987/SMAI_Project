<p>I would like to have a shared object, something like <a href="https://docs.python.org/2/library/multiprocessing.html#proxy-objects" rel="nofollow">Manager</a> from <code>multiprocessing</code>. Once object is changed in the <code>child</code> I'd like to be able to see these changes via object's attributes in the <code>parent</code>. My custom object is more complex than just a plain <code>python</code> list, but following example illustrates my problem quite well:</p>  <pre><code>import gevent, gipc  def main():     shared_object = []     p = gipc.start_process(target=child, args=(shared_object, ))     wg = gevent.spawn(watcher_greenlet, shared_object)     try:         p.join()     except KeyboardInterrupt:         wg.kill(block=True)         p.terminate()     p.join()  def watcher_greenlet(shared_object):     while True:         gevent.sleep(2)         print "Shared object in the parent process:", shared_object  def child(shared_object):     while True:         gevent.sleep(2)         shared_object.append(1)         print "Shared object has changed in the child process:", shared_object  if __name__ == "__main__":     main() </code></pre>  <p>And the output:</p>  <pre><code>Shared object in the parent process: [] Shared object has changed in the child process: [1] Shared object in the parent process: [] Shared object has changed in the child process: [1, 1] Shared object in the parent process: [] Shared object has changed in the child process: [1, 1, 1] Shared object in the parent process: [] Shared object has changed in the child process: [1, 1, 1, 1] </code></pre>  <p>Obviously parent has no idea what's happening with the list in it's child...</p>  <p><strong><em>EDIT</em></strong></p>  <p>Apparently <code>BaseManager</code> works with <a href="https://gehrcke.de/gipc" rel="nofollow">gipc</a> as well. Now I'm just unsure whether it's safe to mix <code>gipc</code> with the machinery from standard <code>multiprocessing</code> package?</p>  <blockquote>   <p>Direct usage of Pythonâ€™s multiprocessing package in the context of a gevent-powered application may raise problems and most likely breaks the application in various subtle ways. gipc is developed with the motivation to solve many of these issues transparently.</p> </blockquote>  <pre><code>import gevent, gipc from multiprocessing.managers import BaseManager  BaseManager.register('test', list) manager = BaseManager() manager.start()  def main():     shared_object = manager.test()     p = gipc.start_process(target=child, args=(shared_object, ))     wg = gevent.spawn(watcher_greenlet, shared_object)     try:         p.join()     except KeyboardInterrupt:         wg.kill(block=True)         p.terminate()     p.join()  def watcher_greenlet(shared_object):     while True:         gevent.sleep(2)         print "Shared object in the parent process:", shared_object  def child(shared_object):     while True:         gevent.sleep(2)         shared_object.append(1)         print "Shared object has changed in the child process:", shared_object  if __name__ == "__main__":     main() </code></pre>  <p>Output:</p>  <pre><code>Shared object in the parent process: [] Shared object has changed in the child process: [1] Shared object in the parent process: [1] Shared object has changed in the child process: [1, 1] Shared object in the parent process: [1, 1] Shared object has changed in the child process: [1, 1, 1] Shared object in the parent process: [1, 1, 1] Shared object has changed in the child process: [1, 1, 1, 1] </code></pre>