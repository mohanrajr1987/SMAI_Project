<p>The code you see above is just a sample but it works to reproduce this error:</p>  <blockquote>   <p><code>sqlalchemy.exc.IntegrityError: (raised as a result of Query-invoked autoflush; consider using a session.no_autoflush block   if this flush is occurring prematurely) (sqlite3.IntegrityError) NOT   NULL constraint failed: X.nn [SQL: 'INSERT INTO "X" (nn, val) VALUES   (?, ?)'] [parameters: (None, 1)]</code></p> </blockquote>  <p>A mapped instance is still added to a session. The instance whant to know (which means query on the database) if other instances its own type exists having the same values. There is a second attribute/column (<code>_nn</code>). It is specified to <code>NOT NULL</code>. But by default it is <code>NULL</code>.</p>  <p>When the instance (like in the sample) is still added to the session a call to <code>query.one()</code> invoke a auto-flush. This flush create an <code>INSERT</code> which tries to store the instance. This fails because <code>_nn</code> is still null and violates the <code>NOT NULL</code> constraint.</p>  <p>That is what I understand currently. But the question is why does it invoke an auto-flush? Can I block that?</p>  <pre><code>#!/usr/bin/env python3  import os.path import os import sqlalchemy as sa  import sqlalchemy.orm as sao import sqlalchemy.ext.declarative as sad from sqlalchemy_utils import create_database  _Base = sad.declarative_base() session = None   class X(_Base):     __tablename__ = 'X'      _oid = sa.Column('oid', sa.Integer, primary_key=True)     _nn = sa.Column('nn', sa.Integer, nullable=False) # NOT NULL!     _val = sa.Column('val', sa.Integer)      def __init__(self, val):         self._val = val      def test(self, session):         q = session.query(X).filter(X._val == self._val)         x = q.one()         print('x={}'.format(x))  dbfile = 'x.db'  def _create_database():     if os.path.exists(dbfile):         os.remove(dbfile)      engine = sa.create_engine('sqlite:///{}'.format(dbfile), echo=True)     create_database(engine.url)     _Base.metadata.create_all(engine)     return sao.sessionmaker(bind=engine)()   if __name__ == '__main__':     session = _create_database()      for val in range(3):         x = X(val)         x._nn = 0         session.add(x)     session.commit()      x = X(1)     session.add(x)     x.test(session) </code></pre>  <p>Of course a solution would be to <em>not</em> add the instance to the session before <code>query.one()</code> was called. This work. But in my real (but to complex for this question) use-case it isn't a nice solution.</p>