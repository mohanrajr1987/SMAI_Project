<p>Here's the final error message : </p>  <blockquote>   <p>Couldn't call Doctrine_Core::set(), second argument should be an   instance of Doctrine_Collection when setting many-to-many references.</p> </blockquote>  <p>Log :</p>  <pre><code>Aug 08 00:36:17 symfony [info] {Doctrine_Connection_Mysql} exec : SET NAMES 'UTF8' - () Aug 08 00:36:17 symfony [info] {Doctrine_Connection_Statement} execute : SELECT u.id AS u__id, u.nom AS u__nom, u.logo AS u__logo, u.email_contact AS u__email_contact, u.url_redirection AS u__url_redirection, u.restricted AS u__restricted, u.created_at AS u__created_at, u.updated_at AS u__updated_at, u.slug AS u__slug FROM univers u WHERE (u.slug = ?) LIMIT 1 - (atlantic) Aug 08 00:36:17 symfony [info] {sfPatternRouting} Match route "recherche_avancee" (/searchadv) for /searchadv with parameters array (  'univers_id' =&gt; '2',  'module' =&gt; 'recherche',  'action' =&gt; 'rechercheAvancee',) Aug 08 00:36:17 symfony [info] {sfFilterChain} Executing filter "sfRenderingFilter" Aug 08 00:36:17 symfony [info] {sfFilterChain} Executing filter "GlobalSessionFilter" Aug 08 00:36:17 symfony [info] {sfFilterChain} Executing filter "UniversFilter" Aug 08 00:36:17 symfony [info] {Doctrine_Connection_Statement} execute : SELECT u.id AS u__id, u.nom AS u__nom, u.logo AS u__logo, u.email_contact AS u__email_contact, u.url_redirection AS u__url_redirection, u.restricted AS u__restricted, u.created_at AS u__created_at, u.updated_at AS u__updated_at, u.slug AS u__slug FROM univers u WHERE (u.restricted = ?) - (1) Aug 08 00:36:17 symfony [info] {sfFilterChain} Executing filter "sfExecutionFilter" Aug 08 00:36:17 symfony [info] {rechercheActions} Call "rechercheActions-&gt;executeRechercheAvancee()" Aug 08 00:36:17 symfony [info] {Doctrine_Connection_Statement} execute : SELECT i.id AS i__id, i.reference AS i__reference, i.art_code AS i__art_code, i.commentaire AS i__commentaire, i.image AS i__image, i.marque_id AS i__marque_id, i.article_type_id AS i__article_type_id, i.reference_fournisseur AS i__reference_fournisseur, i.historique AS i__historique, i.article_id AS i__article_id, i.reference_client AS i__reference_client, i.domaine_id AS i__domaine_id, i.migration_id AS i__migration_id, i.date_validite AS i__date_validite, i.list_pays AS i__list_pays, i.type AS i__type, i.created_at AS i__created_at, i.updated_at AS i__updated_at, f.id AS f__id, f.reference AS f__reference, f.nom AS f__nom, f.lang AS f__lang, f.article_id AS f__article_id, i2.id AS i2__id, i2.nom AS i2__nom, i2.lang AS i2__lang, f2.id AS f2__id, f2.reference AS f2__reference, f2.nom AS f2__nom, f2.lang AS f2__lang, f2.produit_id AS f2__produit_id, f2.domaine_id AS f2__domaine_id, f2.marque_id AS f2__marque_id FROM item i INNER JOIN flat_search_article f ON i.id = f.article_id INNER JOIN item_translation i2 ON i.id = i2.id INNER JOIN flat_search_article_produit f3 ON (f.id = f3.article_id) INNER JOIN flat_search_produit f2 ON f2.id = f3.produit_id WHERE (i2.lang = :lang AND f.lang = :lang AND (f.reference LIKE :kwa OR f.nom LIKE :kwa) AND f2.lang = :lang AND (f2.reference LIKE :kwp OR f2.nom LIKE :kwp) AND (i.type = 1)) - (fr, %ALLUM%, %IDRA%) Aug 08 00:36:17 symfony [warning] {sfWebDebugLogger}  Warning at /home/david/public_html/symfony-1.3.11/lib/exception/sfException.class.php on line 103 (ob_start(): function '' not found or invalid function name) Aug 08 00:36:17 symfony [notice] {sfWebDebugLogger}  Notice at /home/david/public_html/symfony-1.3.11/lib/exception/sfException.class.php on line 103 (ob_start(): failed to create buffer) Aug 08 00:36:17 symfony [warning] {sfWebDebugLogger}  Warning at /home/david/public_html/symfony-1.3.11/lib/exception/sfException.class.php on line 105 (Cannot modify header information - headers already sent by (output started at /home/david/public_html/symfony-1.3.11/lib/exception/sfException.class.php:103)) Aug 08 00:36:17 symfony [err] {Doctrine_Record_Exception} Couldn't call Doctrine_Core::set(), second argument should be an instance of Doctrine_Collection when setting many-to-many references. </code></pre>  <p>The schema : </p>  <pre><code>FlatSearchArticle:   tableName: flat_search_article   columns:     id:                   { type: integer, primary: true, autoincrement: true }     reference:            { type: string(255) }     nom:                  { type: string(255) }     lang:                 { type: string(2) }     article_id:           { type: integer }   relations:     Item:                 { type: one, local: article_id, foreign: id, onDelete: cascade, foreignAlias: FlatSearchArticles }     FlatSearchProduits:   { type: many, class: FlatSearchProduit, refClass: FlatSearchArticleProduit, local: article_id, foreign: produit_id }   indexes:     unique_flat_search_article:       fields: [article_id, lang]       type: unique  FlatSearchProduit:   tableName: flat_search_produit   columns:     id:                   { type: integer, primary: true, autoincrement: true }     reference:            { type: string(255) }     nom:                  { type: string(255) }     lang:                 { type: string(2) }     produit_id:           { type: integer }     domaine_id:           { type: integer }     marque_id:            { type: integer }   relations:     Item:                 { type: one, local: produit_id, foreign: id, onDelete: cascade, foreignAlias: FlatSearchProduits }     Marque:               { type: one, local: marque_id, foreign: id, onDelete: cascade }     DomaineActivite:      { type: one, local: domaine_id, foreign: id, onDelete: cascade }     FlatSearchArticles:   { type: many, class: FlatSearchArticle, refClass: FlatSearchArticleProduit, local: produit_id, foreign: article_id }   indexes:     unique_flat_search_produit:       fields: [produit_id, lang]       type: unique  FlatSearchArticleProduit:   tableName: flat_search_article_produit   columns:     article_id:             { type: integer }     produit_id:             { type: integer }   relations:     FlatSearchArticle:      { type: one, local: article_id, foreign: id, onDelete: cascade }     FlatSearchProduit:      { type: one, local: produit_id, foreign: id, onDelete: cascade } </code></pre>  <p>The function called : </p>  <pre><code>public function search ($keywords_article, $lang, $keywords_produit = '', $limit = 0, $offset = 0) {     $q = $this-&gt;createQuery('a')         -&gt;innerJoin('a.FlatSearchArticles fa')         -&gt;innerJoin('a.Translation t')         -&gt;where('t.lang = :lang')         -&gt;addWhere('fa.lang = :lang')         -&gt;addWhere('fa.reference LIKE :kwa OR fa.nom LIKE :kwa');      if ('' != $keywords_produit)         $q-&gt;innerJoin('fa.FlatSearchProduits fp')             -&gt;addWhere('fp.lang = :lang')             -&gt;addWhere('fp.reference LIKE :kwp OR fp.nom LIKE :kwp');      if (0 != $limit)         $q-&gt;limit($limit);      if (0 != $offset)         $q-&gt;offset($offset);      return $q-&gt;execute(array(         ':lang' =&gt; $lang,         ':kwa' =&gt; '%' . $keywords_article . '%',         ':kwp' =&gt; '%' . $keywords_produit . '%'     )); } </code></pre>  <p>Thanks for your support, David.</p>