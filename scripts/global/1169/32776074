<p>I have a resource that need to be a different color depending on where it is used, so I use this attached property:</p>  <pre><code>public static class AssetProperties {     public static Brush GetFillBrush(DependencyObject obj)     {         return (Brush)obj.GetValue(FillBrushProperty);     }      public static void SetFillBrush(DependencyObject obj, Brush value)     {         obj.SetValue(FillBrushProperty, value);     }      public static readonly DependencyProperty FillBrushProperty =         DependencyProperty.RegisterAttached("FillBrush",         typeof(Brush),         typeof(AssetProperties),         new FrameworkPropertyMetadata(new BrushConverter().ConvertFrom("#FFE41300"), FrameworkPropertyMetadataOptions.Inherits)); } </code></pre>  <p>We define the symbol and use it something like this in a window or user control (this is of course a lot simplified, the resource is for example defined in a separate file) :</p>  <pre><code>&lt;Grid&gt;     &lt;Grid.Resources&gt;         &lt;ResourceDictionary&gt;                             &lt;Rectangle x:Key="SomeColorfulSymbol" x:Shared="False" Width="10" Height="10"                      Fill="{Binding (main:AssetProperties.FillBrush), RelativeSource={RelativeSource Self}}" /&gt;         &lt;/ResourceDictionary&gt;     &lt;/Grid.Resources&gt;      &lt;ContentControl Content="{StaticResource SomeColorfulSymbol}" main:AssetProperties.FillBrush="Blue"/&gt;      &lt;/Grid&gt; </code></pre>  <p>This works as intended, a nice blue rectangle appears. Without setting the attached property, the rectangle is the default red of the FillBrush attached property.</p>  <p>The problem is when we try to use the symbol inside a custom user control defined like this:</p>  <p>OuterControl.xaml:</p>  <pre><code>&lt;UserControl x:Class="AttachedPropertyResourceTest.OuterControl"              xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"              xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"              xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"               xmlns:d="http://schemas.microsoft.com/expression/blend/2008"              mc:Ignorable="d"               d:DesignHeight="300" d:DesignWidth="300"&gt;     &lt;Grid&gt;         &lt;StackPanel&gt;             &lt;TextBlock Text="Some title"/&gt;             &lt;ContentControl Content="{Binding InnerContent, RelativeSource={RelativeSource FindAncestor, AncestorType=UserControl}}"/&gt;         &lt;/StackPanel&gt;     &lt;/Grid&gt; &lt;/UserControl&gt; </code></pre>  <p>OuterControl.xaml.cs:</p>  <pre><code>[ContentProperty("InnerContent")] public partial class OuterControl {     public FrameworkElement InnerContent     {         get { return (FrameworkElement)GetValue(InnerContentProperty); }         set { SetValue(InnerContentProperty, value); }     }      public static readonly DependencyProperty InnerContentProperty =         DependencyProperty.Register("InnerContent", typeof(FrameworkElement), typeof(OuterControl), new FrameworkPropertyMetadata(null));      public OuterControl()     {         InitializeComponent();     } } </code></pre>  <p>Now if I wrap the ContentControl in the above snippet like this instead:</p>  <pre><code>&lt;main:OuterControl&gt;     &lt;ContentControl Content="{StaticResource SomeColorfulSymbol}"/&gt; &lt;/main:OuterControl&gt; </code></pre>  <p>it looks good in the VS designer, a title plus a rectangle that is the default red of FillBrush. In runtime however we only get the title. The rectangle gets no color (UnsetValue) and we get this binding error:</p>  <blockquote>   <p>System.Windows.Data Error: 40 : BindingExpression path error:   '(main:AssetProperties.FillBrush)' property not found on 'object'   ''Rectangle' (Name='')'.   BindingExpression:Path=(main:AssetProperties.FillBrush);   DataItem='Rectangle' (Name=''); target element is 'Rectangle'   (Name=''); target property is 'Fill' (type 'Brush')</p> </blockquote>  <p>If I add an invisible instance of the symbol before the wrapped one, it works again, i.e., a red rectangle appears:</p>  <pre><code>&lt;ContentControl Content="{StaticResource SomeColorfulSymbol}" Visibility="Collapsed"/&gt; &lt;main:OuterControl&gt;     &lt;ContentControl Content="{StaticResource SomeColorfulSymbol}"/&gt; &lt;/main:OuterControl&gt; </code></pre>  <p>One problem is that the attached property is not registered, when I put a breakpoint on the RegisterAttached method it is not called without the extra invisible ContentControl. This is however only a part of the problem, for example forcing the registration like this does not work:</p>  <pre><code>&lt;StackPanel&gt;     &lt;TextBlock Text="I'm red!" Background="{Binding (main:AssetProperties.FillBrush), RelativeSource={RelativeSource Self}}"/&gt;     &lt;main:OuterControl&gt;         &lt;ContentControl Content="{StaticResource SomeColorfulSymbol}"/&gt;     &lt;/main:OuterControl&gt; &lt;/StackPanel&gt; </code></pre>  <p>The text "I'm red" is actually red and the attached property is registered, but we get the exact same binding error. </p>  <p>I also tried without the <code>ContentProperty["InnerContent"]</code>, setting the InnerContent attribute explicitly in xaml, with the same result.</p>  <p>Could someone shed some light on this?</p>  <p>Maybe using a control template instead of OuterControl wouldn't have this problem (?), but there is a lot of behavior associated with OuterControl and I would prefer this approach.</p>