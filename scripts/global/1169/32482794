<p>I have a UserControl that contains a ListBox and I want to track the SelectedItems of that listbox. The UserControl has a DP "SelectedItemsList" that is defined like this</p>  <pre><code>public static DependencyProperty SelectedItemsListProperty = DependencyProperty.Register(   "SelectedItemsList",   typeof (IList),   typeof (MyListControl),   new FrameworkPropertyMetadata(null,      OnSelectedItemsChanged)); </code></pre>  <p>In the listbox' Item "SelectionChanged" event, I want to save the selected items to the DP. This is triggered whenever I change the selection in the listbox.</p>  <pre><code>private void OnItemSelectionChanged(object sender, SelectionChangedEventArgs e) {   SelectedItemsList = this.myListBox.SelectedItems; } </code></pre>  <p>In my view that contains the "MyListControl" I create a binding to my viewmodel that want to use the selected items.</p>  <pre><code> &lt;controls:MyListControl    Source="{Binding SomeItemsList, UpdateSourceTrigger=PropertyChanged}"   SelectedItemsList="{Binding SelectedItems, UpdateSourceTrigger=PropertyChanged}"/&gt; </code></pre>  <p>My problem is, that the DP SelectedItemsList never gets updated. The PropertyChangeCallback "OnSelectedItemsChanged" of the DP is only triggered when I initially load the lists content. The value of the SelectedItemsList is always null.</p>  <p>I am aware that this question is similar to <a href="http://stackoverflow.com/questions/6584463/dependency-property-callback-does-not-work">Dependency property callback does not work</a>, but the answers posted there do not solve my problem.</p>  <p>What am I missing here?</p>  <p>Thanks,</p>  <p>Edit (2015-09-10):  Thank you all for your comments. I found a solution that fits my needs:</p>  <p>First of all I created a custom listbox control that provided the list of selected items in a dependency property (very similar to <a href="http://stackoverflow.com/questions/22868445/wpf-binding-selecteditems-in-mvvm">WPF Binding SelectedItems in MVVM</a>).</p>  <pre><code> public class CustomListBox : ListBox  {     public static readonly DependencyProperty SelectedItemsListProperty =          DependencyProperty.Register("SelectedItemsList",          typeof (IList),          typeof (CustomListBox),          new PropertyMetadata(null));      public CustomListBox()     {        SelectionChanged += OnSelectionChanged;     }     public IList SelectedItemsList    {        get { return (IList)GetValue(SelectedItemsListProperty); }        set { SetValue(SelectedItemsListProperty, value); }    }     void OnSelectionChanged(object sender, SelectionChangedEventArgs e)    {       this.SelectedItemsList= new ArrayList(this.SelectedItems);    }      }    </code></pre>  <p>I am not happy yet with the "new ArrayList"-part, but if in my viewmodel's property setter I want to check for equality, SelectedItemsList can not be a reference of SelectedItems. The previous and the new value would always be the same.</p>  <p>Then I reduced the item selection parts of my UserControl "MyListControl" simply to the dependency property itself:</p>  <pre><code>public static DependencyProperty SelectedItemsProperty =  DependencyProperty.Register(   "SelectedItems",   typeof (IList),   typeof (MyListControl),   new FrameworkPropertyMetadata(null));   public IList SelectedItems {   get   {     return (IList)GetValue(SelectedItemsProperty);   }   set   {     SetValue(SelectedItemsProperty, value);   } } </code></pre>  <p>and modified the xaml of the MyListControl:</p>  <pre><code>  &lt;controls:CustomListBox          SelectionMode="Extended"         ItemsSource="{Binding RelativeSource={RelativeSource AncestorType={x:Type controls:MyListControl}},        Path=Source, UpdateSourceTrigger=PropertyChanged}"                   SelectedItemsList="{Binding RelativeSource={RelativeSource AncestorType={x:Type controls:MyListControl}},        Path=SelectedItems, UpdateSourceTrigger=PropertyChanged, Mode=TwoWay}"        &gt; </code></pre>  <p>The property in my ViewModel looks like</p>  <pre><code>public IList SelectedObjects {   get { return _selectedObjects; }   set { if (this._selectedObjects != value)         {           this._selectedObjects = value;           OnPropertyChanged(SelectedObjectsProperty);         }        }  } </code></pre>  <p>It was important that the type of this property is IList, otherwise the value in the setter would always be null. </p>  <p>And in the view's xaml</p>  <pre><code>&lt;controls:MyListControl   Source="{Binding CurrentImageList, UpdateSourceTrigger=PropertyChanged}"   SelectedItems="{Binding SelectedObjects, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}"  /&gt; </code></pre>