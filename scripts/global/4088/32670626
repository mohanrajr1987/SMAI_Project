<p>Giving a <code>uint8_t</code> buffer of <code>x</code> length, I am trying to come up with a function or a macro that can remove nth bit (or n to n+i), then left-shift the remaining bits.</p>  <p>example #1:</p>  <p>for input <code>0b76543210 0b76543210 ...</code> then output should be <code>0b76543217 0b654321 ...</code></p>  <p>example #2: if the input is:</p>  <pre><code>uint8_t input[8] = {     0b00110011,     0b00110011,     ... }; </code></pre>  <p>the output without the first bit, should be</p>  <pre><code>uint8_t output[8] = {     0b00110010,     0b01100100,     ... }; </code></pre>  <p>I have tried the following to remove the first bit, but it did not work for the second group of bits.</p>  <pre><code>/* A macro to extract (a-b) range of bits without shifting */ #define BIT_RANGE(N,x,y) ((N) &amp; ((0xff &gt;&gt; (7 - (y) + (x))) &lt;&lt; ((x)))) void removeBit0(uint8_t *n) {     for (int i=0; i &lt; 7; i++) {         n[i] = (BIT_RANGE(n[i], i + 1, 7)) &lt;&lt; (i + 1) |                (BIT_RANGE(n[i + 1], 1, i + 1)) &lt;&lt; (7 - i); /* This does not extract the next element bits */     }     n[7] = 0; } </code></pre>  <p><a href="http://i.stack.imgur.com/EawST.png" rel="nofollow"><img src="http://i.stack.imgur.com/EawST.png" alt="bits"></a> <strong>Update #1</strong> In my case, the input will be uint64_t number, then I will use <code>memmov</code> to shift it one place to the left.</p>  <p><strong>Update #2</strong> The solution can be in C/C++, assembly(x86-64) or inline assembly.</p>