<p>I am attempting to write a C-language function for Postgres that takes an integer array in and converts the integers to a bitstring representing the morton encoding (z-curve encoding) of the integers in the array. Two parameters are passed in: first the actual array, and second, the number of bits to use from each integer, starting with the least significant bit (max possible is 31 since we must use unsigned integers). I am using an implementation (see comment in code) that I have tested outside of Postgres and I know works.</p>  <p>The code (without some obviously necessary checks for negativeness in integers, size bounds, etc.):</p>  <pre><code>#include &lt;postgres.h&gt; #include &lt;utils/array.h&gt; #include &lt;utils/varbit.h&gt; #include &lt;fmgr.h&gt; #include &lt;limits.h&gt;  #ifdef PG_MODULE_MAGIC PG_MODULE_MAGIC; #endif  #define MC_SEGMENT(bit, dim, ndim)  ((((bit)*(ndim)) + dim) / CHAR_BIT) #define MC_SEGMENTBIT(bit, dim, ndim)   ((((bit)*(ndim)) + dim) % CHAR_BIT)  Datum pg_morton_encode_integer(PG_FUNCTION_ARGS); PG_FUNCTION_INFO_V1(pg_morton_encode_integer); Datum pg_morton_encode_integer(PG_FUNCTION_ARGS) {     ArrayType   *input_vector;     int32       *toencode;     int     i, n, rlen, len;     int16       num_bits_per;     VarBit      *result;     int     mask;     int     ipad;     char        tempvalue;      int     bit;     int     dim;     int     num_bits;     int     num_bytes;      /* Ensure first argument is not null. */     if (PG_ARGISNULL(0))     {         ereport(ERROR, (errmsg("First operand must be non-null")));     }     /* Ensure second argument is not null. */     if (PG_ARGISNULL(1))     {         ereport(ERROR, (errmsg("Second operand must be non-null")));     }      /* Get input array and its length (first argument). */     input_vector    = PG_GETARG_ARRAYTYPE_P(0);     n       = (ARR_DIMS(input_vector))[0]; ereport(NOTICE, (errmsg("n=%d", n) ));     toencode    = (int32 *)ARR_DATA_PTR(input_vector);      /* Get number of bits per dimensions (second argument). */     num_bits_per    = PG_GETARG_INT16(1);      /* Allocated the VarBit. */     len     = n*num_bits_per;     rlen        = VARBITTOTALLEN(len);     result      = palloc0(rlen);     SET_VARSIZE(result, rlen);     VARBITLEN(result)                 = len;      /* Perform the morton encoding. */     num_bits        = num_bits_per*n;     num_bytes       = (num_bits/8) + (num_bits % 8 == 0 ? 0 : 1);      /*** TESTED THIS CODE, IT WORKS, BUT NOT IN POSTGRES. :( ***/     for (bit = 0; bit &lt; num_bits_per; ++bit)     for (dim = 0; dim &lt; n; ++dim)     {         tempvalue             = VARBITS(result)[MC_SEGMENT(bit, dim, n)];         tempvalue             |= (char)              (((toencode[dim] &amp; (1 &lt;&lt; bit)) &gt;&gt; bit)               &lt;&lt; MC_SEGMENTBIT(bit, dim, n));         VARBITS(result)[MC_SEGMENT(bit, dim, n)]             = tempvalue; ereport(NOTICE, (errmsg("[%d,%d]=%d:%x", MC_SEGMENT(bit, dim, n), MC_SEGMENTBIT(bit,dim,n), (((toencode[dim] &amp; (1 &lt;&lt; bit)) &gt;&gt; bit)), (int)tempvalue)) );     }     /*** END OF TESTED CODE. ***/     PG_RETURN_VARBIT_P(result); } </code></pre>  <p>Makefile:</p>  <pre><code>MODULE_big = pgmorton OBJS = pgmorton.o PGXS := $(shell pg_config --pgxs) include $(PGXS) </code></pre>  <p>Make instructions (in directory where code and Makefile reside):</p>  <pre><code>make install </code></pre>  <p>Once installed, run this from a postgres shell to make the function useable:</p>  <pre><code>DROP FUNCTION IF EXISTS pg_morton_encode_integer(integer[], smallint); CREATE FUNCTION pg_morton_encode_integer(integer[], smallint) RETURNS varbit   AS 'pgmorton', 'pg_morton_encode_integer'   LANGUAGE C STRICT; </code></pre>  <p>Some examples producing obviously erroneous input:</p>  <pre><code>SELECT pg_morton_encode_integer('{2147483647, 2147483647, 2147483647}'::integer[], 31::smallint); -- gives '111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100011' instead of '111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111' SELECT pg_morton_encode_integer('{2147483647, 2147483647}'::integer[], 2::smallint); -- gives '0000' instead of '1111' </code></pre>  <p>I am doing all of this on OS X Yosemite with Postgres.app version 9.4.2.0, with default clang compiler.</p>  <p>EDIT: As noted in a comment to my question below, the bytes needed to be written in a different order because Postgres normalizes bitstring byte-order by making the most significant byte first. I've also additionally discovered that bitstrings of length <code>n</code> bits where <code>n</code> is not a multiple of 8 (CHAR_BIT, the number of bits in a byte) lose the least significant bits from the least significant byte. For example, if my bitstring is 14 bits, then 2 bytes (16 bits) are needed to store the bitstring, with byte zero being most significant and byte 1 being least. We lose bits 0 and 1 (the two least significant bits) from the least significant byte, namely byte 1. (The following diagram has B for bits used and X for bits truncated to make the above clear).</p>  <pre><code>byte 0            byte 1 ================================= 7 6 5 4 3 2 1 0 | 7 6 5 4 3 2 1 0 B B B B B B B B | B B B B B B X X </code></pre>  <p>It should also be noted that truncated bits can only have zeroes written to them, otherwise you risk Postgres crashing. :)</p>  <p>Here is the updated code fixing the first problem (the second regarding bit truncation I still haven't solved), noting the lines that changed with in-code comments below:</p>  <pre><code>#include &lt;postgres.h&gt; #include &lt;utils/array.h&gt; #include &lt;utils/varbit.h&gt; #include &lt;fmgr.h&gt; #include &lt;limits.h&gt;  #ifdef PG_MODULE_MAGIC PG_MODULE_MAGIC; #endif  #define MC_SEGMENT(bit, dim, ndim)  ((((bit)*(ndim)) + dim) / CHAR_BIT) #define MC_SEGMENTBIT(bit, dim, ndim)   ((((bit)*(ndim)) + dim) % CHAR_BIT)  Datum pg_morton_encode_integer(PG_FUNCTION_ARGS); PG_FUNCTION_INFO_V1(pg_morton_encode_integer); Datum pg_morton_encode_integer(PG_FUNCTION_ARGS) {     ArrayType   *input_vector;     int32       *toencode;     int     i, n, rlen, len;     int16       num_bits_per;     VarBit      *result;     int     mask;     int     ipad;     char        tempvalue;      int     bit;     int     dim;     int     num_bits;     int     num_bytes;      /* Ensure first argument is not null. */     if (PG_ARGISNULL(0))     {         ereport(ERROR, (errmsg("First operand must be non-null")));     }     /* Ensure second argument is not null. */     if (PG_ARGISNULL(1))     {         ereport(ERROR, (errmsg("Second operand must be non-null")));     }      /* Get input array and its length (first argument). */     input_vector    = PG_GETARG_ARRAYTYPE_P(0);     n       = (ARR_DIMS(input_vector))[0]; ereport(NOTICE, (errmsg("n=%d", n) ));     toencode    = (int32 *)ARR_DATA_PTR(input_vector);      /* Get number of bits per dimensions (second argument). */     num_bits_per    = PG_GETARG_INT16(1);      /* Allocated the VarBit. */     len     = n*num_bits_per;     rlen        = VARBITTOTALLEN(len);     result      = palloc0(rlen);     SET_VARSIZE(result, rlen);     VARBITLEN(result)                 = len;      /* Perform the morton encoding. */     num_bits        = num_bits_per*n;     num_bytes       = (num_bits/8) + (num_bits % 8 == 0 ? 0 : 1);      /*** TESTED THIS CODE, IT WORKS, BUT NOT IN POSTGRES. :( ***/     for (bit = 0; bit &lt; num_bits_per; ++bit)     for (dim = 0; dim &lt; n; ++dim)     {         // CHANGE!         tempvalue             = VARBITS(result)[num_bytes - 1 - MC_SEGMENT(bit, dim, n)];         tempvalue             |= (char)              (((toencode[dim] &amp; (1 &lt;&lt; bit)) &gt;&gt; bit)               &lt;&lt; MC_SEGMENTBIT(bit, dim, n));         // CHANGE!         VARBITS(result)[num_bytes - 1 - MC_SEGMENT(bit, dim, n)]             = tempvalue; ereport(NOTICE, (errmsg("[%d,%d]=%d:%x", MC_SEGMENT(bit, dim, n), MC_SEGMENTBIT(bit,dim,n), (((toencode[dim] &amp; (1 &lt;&lt; bit)) &gt;&gt; bit)), (int)tempvalue)) );     }     /*** END OF TESTED CODE. ***/     PG_RETURN_VARBIT_P(result); } </code></pre>