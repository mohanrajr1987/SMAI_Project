<p>I am writing a simple BigInteger type in Delphi. This type consist of an array of unsigned 32 bit integers (I call them limbs), a count (or size) and a sign bit. The value in the array is interpreted as absolute value, so this is a sign-magnitude representation. This has several advantages, but one disadvantage.</p>  <p>The bitwise operations like <code>and</code>, <code>or</code>, <code>xor</code> and <code>not</code> have two's complement semantics. This is no problem if both <code>BigInteger</code>s have positive values, but the magnitudes of negative <code>BigInteger</code>s must be converted to two's complement by negation. This can be a performance problem, since if we do, say</p>  <pre><code>C := -A and -B; </code></pre>  <p>then I must negate the magnitudes of <code>A</code> and <code>B</code> before the <code>and</code> operation can be performed. Since the result is supposed to be negative too, I must negate the result too to get a positive magnitude again. For large <code>BigInteger</code>s, negating up to three values can be a considerable performance cost.</p>  <p>Mind you, I know how to do this and the results are correct, but I want to avoid the slowness caused by the necessary negations of large arrays.</p>  <p>I know of a few shortcuts, for instance</p>  <pre><code>C := not A; </code></pre>  <p>can be achieved by calculating</p>  <pre><code>C := -1 - A; </code></pre>  <p>which is what I do, and the result is fine. This makes <code>not</code> as performant as addition or subtraction, since it avoids the negation before (and after) the operation. </p>  <h2>Question</h2>  <p>My question is: are there similar laws I can use to avoid negating the magnitudes of "negative" <code>BigInteger</code>s? I mean something like the calculation of <code>not</code> by using subtraction?</p>  <p>I mean simple or not-so-simple laws like</p>  <pre><code>not A and not B = not (A or B) // = is Pascal for == not A or not B = not (A and B) </code></pre>  <p>but then for -A and/or -B, etc. I do know that</p>  <pre><code>(-A and -B) &lt;&gt; -(A or B) // &lt;&gt; is Pascal for != </code></pre>  <p><strong><em>is not true</em></strong>, but perhaps there is something similar?</p>  <p><strong>I simply can't find any such laws that relate to <em>negative</em> values and bitwise operations, if they exist at all. Hence my question.</strong></p>