<p>N non-negative integers a1, a2, ..., an. We will call a sequence of indexes i1, i2, ..., ik (1 ≤ i1 &lt; i2 &lt; ... &lt; ik ≤ n) a group of size k.</p>  <p>How many groups exists such that <code>ai1 &amp; ai2 &amp; ... &amp; aik = 0 (1 ≤ k ≤ n).</code></p>  <p>Operation x &amp; y denotes bitwise AND operation of two numbers.<a href="http://codeforces.com/contest/449/problem/D" rel="nofollow">Problem</a></p>  <p>Approach: use inclusion-exclusion principle in this problem.</p>  <p>Let <strong>f(x) be the count of number i where Ai&amp;x = x.</strong></p>  <p>Let <strong>g(x) be the number of 1 in the binary respresentation of x</strong>. Then the answer equals to .</p>  <pre><code>(-1)^g(x)*2^f(x) </code></pre>  <p><strong>Code:</strong> </p>  <pre><code>for(int i=0;i&lt;20;i++) {         for(int j=0;j&lt;(1&lt;&lt;20);j++) {             if(0 == (j &amp; (1&lt;&lt;i))) {                 cnt[j | (1&lt;&lt;i)] += cnt[j];             }         }     } </code></pre>  <p>And finally:</p>  <pre><code>for(int i=0;i&lt;(1&lt;&lt;20);i++) {         int mask = 20 % 2;         for(int j=0;j&lt;20;j++) if(i &amp; (1&lt;&lt;j)) mask ^= 1;          if(mask == 0) ret = (ret + pows[cnt[i]]) % MOD;         else ret = (ret + MOD - pows[cnt[i]]) % MOD;     } </code></pre>  <p>Why This Thing  <code>cnt[j | (1&lt;&lt;i)] += cnt[j]</code> and  How the Second loop is working and How inclusion-exclusion principle is applied is in the last loop. I could not imagine the set formation i.e. How A intersection B is pictured</p>