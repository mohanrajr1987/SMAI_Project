<p>I didn't study IT, and only very recently came across <a href="http://www.mkyong.com/java/java-and-0xff-example/" rel="nofollow">bit shifts</a> and an application for <a href="http://www.cs.cornell.edu/~tomf/notes/cps104/twoscomp.html" rel="nofollow">two's complement</a>. So, can you please use simple English in your explanations and assume I know hardly anything about IP addresses, bit operations, and Java datatypes?</p>  <p>Today, I found the following piece of code (abbreviated):</p>  <pre><code>long m = (-1) &lt;&lt; (byte) 16; </code></pre>  <p>Now, this is for IP subnet masking. I know I need to start out with 4 blocks of 8 bits (i.e. 4 bytes), and all bits have to be "switched on": <code>11111111 11111111 1111111 1111111</code> Next, zeros are shifted in from the right, in this case 16 bits' worth; so we get <code>11111111 11111111 00000000 0000000</code>, the mask.</p>  <p>But I do have a few questions:</p>  <ol> <li>Does the <code>16</code> have to be of type <code>byte</code> for this to work?</li> <li>The result is of type <code>long</code>. When the expression above runs, <code>-1</code> gets converted into - effectively - 4x8bit blocks. How does Java know it needs 32 positions/bits (an IP address' length), and not, say, 16, or 8, when applying two's complement? (I'm guessing that has to do with the <code>long</code> datatype?)</li> <li>Why is two's complement applied to <code>-1</code> to begin with? (Google gives you <code>-0b1</code> if you ask it what <code>-1</code> is in binary. I first thought it might be to do with overflow, but it isn't, is it...?)</li> <li>Really, what datatypes does the compiler convert this to while it's running the code, to make it all work?</li> </ol>  <p><em>UPDATE:</em> The <code>16</code> is produced at runtime by a method; I just put a constant in here as an example. In hindsight probably a bad idea...</p>