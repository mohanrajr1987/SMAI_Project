<p>I was recently playing around with bit fields in C, and apparently, the bits are ordered from low to high, although Google does not support this thesis (e.g. <a href="https://en.wikipedia.org/wiki/Bit_numbering" rel="nofollow">Wikipedia</a>.)</p>  <p>Take the following code (<a href="http://ideone.com/UwWfJM" rel="nofollow">http://ideone.com/UwWfJM</a>):</p>  <pre><code>#include &lt;stdio.h&gt;  struct bits {     unsigned char a : 1;     unsigned char b : 1;     unsigned char c : 1;     unsigned char d : 1;     unsigned char e : 1;     unsigned char f : 1;     unsigned char g : 1;     unsigned char h : 1; };  int main(int argc, char **argv) {     unsigned char c = 33;     struct bits *b = (struct bits *) &amp;c;      printf("dec: %u\n", c);     printf("bits: %x", b-&gt;a);     printf("%x", b-&gt;b);     printf("%x", b-&gt;c);     printf("%x", b-&gt;d);     printf("%x", b-&gt;e);     printf("%x", b-&gt;f);     printf("%x", b-&gt;g);     printf("%x\n", b-&gt;h);      return 0; } </code></pre>  <p>The output is</p>  <pre><code>dec: 33 bits: 10000100 </code></pre>  <p>...although I had expected the bit ordering to be the other way around (i.e. <code>00100001</code>, with the MSB in the first place and the LSB in the last place).</p>  <p>Can somebody explain this behaviour?<br> Furthermore, can I assume that the mapping will always be in this direction?</p>  <p><em>Note:</em> I am <em>not</em> asking about endianness, which is about the <em>byte</em> order. The background of my question is that I tried to map a buffer to a struct. The buffer contained a UDP message, consisting of a "bit mapping" (i.e. "bit at position <em>x</em> means this, bits at position <em>y</em> to <em>z</em> mean that, and so on).</p>  <p>Thanks!</p>