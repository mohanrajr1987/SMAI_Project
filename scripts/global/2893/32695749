<p>Setup: Spring application deployed on Weblogic 12c, using JNDI lookup to get a datasource to the Oracle Database.</p>  <p>We have multiple services which will be polling the database regularly for new jobs. In order to prevent two services picking the same job we are using a native <code>SELECT FOR UPDATE</code> query in a CrudRepository. The application then takes the resulting job and updates it to <code>PROCESSING</code> instead of <code>WAITING</code> using the <code>CrusRepository.save()</code> method.</p>  <p>The problem is that I can't seem to get the <code>save()</code> to work within the <code>FOR UPDATE</code> transaction (at least this is my current working theory of what goes wrong), and as a result the entire polling freezes until the default 10 minute timeout occurs. I have tried putting <code>@Transactional</code> (with various propagation flags) basically everywhere, but I'm not able to get it to work (<code>@EnableTransactionManagement</code> is activated and working).</p>  <p>Obviously there must be some basic knowledge I'm missing. Is this even a possible setup? Unfortunately, just using <code>@Transactional</code> with a non-native CrudRepository <code>SELECT</code> query is not possible, as it apparently first makes a <code>SELECT</code> to see if the row is locked or not, and only <em>then</em> makes a new <code>SELECT</code> that locks it. Another service could very well pick up the same job in the meanwhile, which is why we need it to lock immediately.</p>  <hr>  <p>Update in relation to @M. Deinum's comment.: I should perhaps also mention that it's a setup wherein the central component that's doing the polling is a library used by all the other services (therefore the library has @SpringBootApplication, as does each service using it, so double component scanning is certainly present). Furthermore, the service has two separate classes for polling depending on the type of service, with a lot of common code, shared in an AbstractTransactionHelper class. Below I've aggregated some code for the sake of brevity.</p>  <p>The library's main class:</p>  <pre><code>@SpringBootApplication @EnableTransactionManagement @EnableJpaRepositories public class JobsMain {  public static void initializeJobsMain(){     PersistenceProviderResolverHolder.setPersistenceProviderResolver(new PersistenceProviderResolver() {          @Override         public List&lt;PersistenceProvider&gt; getPersistenceProviders() {             return Collections.singletonList(new HibernatePersistenceProvider());         }          @Override         public void clearCachedProviders() {             //Not quite sure what this should do...         }     }); }  @Bean public JtaTransactionManager transactionManager(){     return new WebLogicJtaTransactionManager(); }  public DataSource dataSource(){     final JndiDataSourceLookup dsLookup = new JndiDataSourceLookup();     dsLookup.setResourceRef(true);     DataSource dataSource = dsLookup.getDataSource("Jobs");     return dataSource; }  } </code></pre>  <p>The repository (we're returning a set with only one job as we had some other issues when returning a single object):</p>  <pre><code>public interface JobRepository extends CrudRepository&lt;Job, Integer&gt; {  @Query(value = "SELECT * FROM JOB WHERE JOB.ID IN "                     + "(SELECT ID FROM "                         + "(SELECT * FROM JOB WHERE "                             + "JOB.STATUS = :status1 OR "                             + "JOB.STATUS = :status2 "                         + "ORDER BY JOB.PRIORITY ASC, JOB.CREATED ASC) "                     + "WHERE ROWNUM &lt;= 1) "                 + "FOR UPDATE", nativeQuery = true) public Set&lt;Job&gt; getNextJob(@Param("status1") String status1, @Param("status2") String status2); </code></pre>  <p>The transaction handling class:</p>  <pre><code>@Service public class JobManagerTransactionHelper extends AbstractTransactionHelper{  @Transactional @Override public QdbJob getNextJobToProcess(){         Set&lt;Job&gt; jobs = null;         try {             jobs = jobRepo.getNextJob(Status.DONE.name(), Status.FAILED.name());         } catch (Exception ex) {             logger.error(ex);         }     return extractSingleJobFromSet(jobs); } </code></pre>  <hr>  <p>Update 2: Some more code.</p>  <p>AbstractTransactionHelper:</p>  <pre><code>@Service public abstract class AbstractTransactionHelper {  @Autowired QdbJobRepository jobRepo;  @Autowired ArchivedJobRepository archive;  protected Job extractSingleJobFromSet(Set&lt;Job&gt; jobs){     Job job = null;     if(jobs != null &amp;&amp; !jobs.isEmpty()){         for(job job : jobs){             if(this instanceof JobManagerTransactionHelper){                 updateJob(job);             }             job = job;         }     }     return job; }  protected void updateJob(Job job){     updateJob(job, Status.PROCESSING, null); }  protected void updateJob(Job job, Status status, String serviceMessage){     if(job != null){         if(status != null){             job.setStatus(status);         }         if(serviceMessage != null){             job.setServiceMessage(serviceMessage);            }         saveJob(job);     } }  protected void saveJob(Job job){     jobRepo.save(job);     archive.save(Job.convertJobToArchivedJob(job)); } </code></pre>  <hr>  <p>Update 4: Threading. newJob() is implemented by each service that uses the library.</p>  <pre><code>@Service public class JobManager{  @Autowired private JobManagerTransactionHelper transactionHelper;  @Autowired JobListener jobListener;  @Autowired Config config;  protected final AtomicInteger atomicThreadCounter = new AtomicInteger(0);  protected boolean keepPolling;     protected Future&lt;?&gt; futurePoller; protected ScheduledExecutorService pollService; protected ThreadPoolExecutor threadPool;  public boolean start(){     if(!keepPolling){         ThreadFactory pollServiceThreadFactory = new ThreadFactoryBuilder()             .setNamePrefix(config.getService() + "ScheduledPollingPool-Thread").build();         ThreadFactory threadPoolThreadFactory = new ThreadFactoryBuilder()                             .setNamePrefix(config.getService() + "ThreadPool-Thread").build();         keepPolling = true;         pollService = Executors.newSingleThreadScheduledExecutor(pollServiceThreadFactory);         threadPool = (ThreadPoolExecutor)Executors.newFixedThreadPool(getConfig().getThreadPoolSize(), threadPoolThreadFactory);         futurePoller = pollService.scheduleWithFixedDelay(getPollTask(), 0, getConfig().getPollingFrequency(), TimeUnit.MILLISECONDS);         return true;     }else{         return false;     } }  protected Runnable getPollTask() {     return new Runnable(){         public void run(){             try{                 while(atomicThreadCounter.get() &lt; threadPool.getMaximumPoolSize() &amp;&amp;                          threadPool.getActiveCount() &lt; threadPool.getMaximumPoolSize() &amp;&amp;                          keepPolling == true){                     Job job = transactionHelper.getNextJobToProcess();                     if(job != null){                         threadPool.submit(getJobHandler(job));                         atomicThreadCounter.incrementAndGet();//threadPool.getActiveCount() isn't updated fast enough the first loop                     }else{                         break;                     }                 }             }catch(Exception e){                 logger.error(e);             }         }     }; }  protected Runnable getJobHandler(final Job job){     return new Runnable(){         public void run(){             try{                 atomicThreadCounter.decrementAndGet();                 jobListener.newJob(job);             }catch(Exception e){                 logger.error(e);             }         }     }; } </code></pre>