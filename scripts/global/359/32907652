<p>Till now I've used very simple User-Role version and controlled permissions per Visibility / IsEnabled / Command.CanExecute with converters:  </p>  <pre><code> &lt;TabItem Visibility="{Binding UserRole, Converter={StaticResource PackerVisible}}" &gt;... </code></pre>  <p>My converter looks like:</p>  <pre><code> &lt;conv:UserVisibilityConverter x:Key="PackerVisible" Allow="Packer,Lagerleiter,Entwickler" /&gt; </code></pre>  <p>It's relative easy if you have not much roles, but even so you have no good overview: who will get access to this or other UI elements.</p>  <p>One more bad thing is that UserRoles (stored in DB) used here as strings - <code>Allow="Role1, Role2, Role3"</code>.  </p>  <p>And in my new project I have more roles/permissions, what makes this solution more ugly.</p>  <p>I've searched and found nothing how to implement it much better. A bit better is maybe to use enum for role names in code, but how to synchronise enum with database?</p>  <p>Other solutions i've found (<a href="http://stackoverflow.com/questions/14135953/assign-ui-permissions-wpf-dynamically">solution1</a>, <a href="http://www.codeproject.com/Articles/278199/Implement-UI-Element-Authorization-in-WPF" rel="nofollow">solution2</a>) are better, because they don't need converters, but permissions are set again as strings in XAML:</p>  <pre><code>// AuthToVisibility &lt;Image ... Visibility="{op:AuthToVisibility "CanView"}" /&gt;  // AutoToEnabled &lt;MenuItem IsEnabled="{op:AuthToEnabled "CanClose"}"&gt;...&lt;/MenuItem&gt; </code></pre>  <p>What is the best way to handle permissions stored in the database towards UI? Is there any pattern?</p>