<p>Recently I came across with a builder pattern that intrigued me.</p>  <p>So, I have an <code>EntityBuilder</code> which builds an <code>Entity</code>, but it doesn't return the entity. Here is the method signature:</p>  <pre><code>public void build(); </code></pre>  <p>Instead, inside the <code>build()</code> method, it delivers the new object created, the <code>Entity</code>, to a <code>CacheImplementation</code> instance to store it.  Note: the <code>CacheImpl</code> is injected in the builder's constructor.</p>  <pre><code>public void build(){     //create new entity     cacheImplementation.add(entity); } </code></pre>  <p>Does this sounds like best practice?</p>  <h1>Later edit 0</h1>  <pre><code>public interface EntityBuilder {      void setProperty0(PropertyObject propertyObject0);     void setProperty1(PropertyObject propertyObject1);     void setProperty2(PropertyObject propertyObject2);     //...      void build(); }  public class EntityBuilderImpl implements EntityBuilder {      PropertyObject propertyObject0;     PropertyObject propertyObject1;     PropertyObject propertyObject2;     //...      // setters for all properties     @Override     public void build(){         //create new entity         cacheImplementation.add(entity);     } } </code></pre>  <p>The builder is used in the following way:</p>  <pre><code>public class EntityProcessor{   private EntityBuilderFactory entityBuilderFactory;//initialized in constructor    void process(EntityDetails entityDetails){        EntityBuilder entityBuilder = this.entityBuilderFactory.getNewEntitytBuilder();        //..        // entityBuilder.set all properties from entityDetails        entityBuilder.build();   } } </code></pre>  <p>Note: the cacheImpl instance just stores the entities in a <code>List&lt;&gt;</code> which is accesses every N seconds.</p>