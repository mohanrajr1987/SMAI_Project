<p>This is largely an <em>'am I doing it right / how can I do this better'</em> kind of topic, with some concrete questions at the end. If you have other advice / remarks on the text below, even if I didn't specifically ask those questions, feel free to comment.</p>  <hr>  <p>I have a MySQL table for users of my app that, along with a set of fixed columns, also has a text column containing a JSON config object. This is to store variable configuration data that cannot be stored in separate columns because it has different properties per user. There doesn't need to be any lookup / ordering / anything on the configuration data, so we decided this would be the best way to go.</p>  <p>When querying the database from my Node.JS app (running on Node 0.12.4), I assign the JSON text to an object and then use Object.defineProperty to create a getter property that parses the JSON string data when it is needed and adds it to the object.</p>  <p>The code looks like this:</p>  <pre><code>user =      uid: results[0].uid     _c: results[0].user_config # JSON config data as string  Object.defineProperty user, 'config',     get: -&gt;         @c = JSON.parse @_c if not @c?         return @c </code></pre>  <p><strong>Edit:</strong> above code is Coffeescript, here's the (approximate) Javascript equivalent for those of you who don't use Coffeescript:</p>  <pre><code>var user = {     uid: results[0].uid,     _c: results[0].user_config // JSON config data as string };  Object.defineProperty(user, 'config', {     get: function() {         if(this.c === undefined){             this.c = JSON.parse(this._c);         }         return this.c;     } }); </code></pre>  <p>I implemented it this way because parsing JSON blocks the Node event loop, and the config property is only needed about half the time (this is in a middleware function for an express server) so this way the JSON would only be parsed when it is actually needed. The config data itself can range from 5 to around 50 different properties organised in a couple of nested objects, not a huge amount of data but still more than just a few lines of JSON.</p>  <p>Additionally, there are three of these JSON objects (I only showed one since they're all basically the same, just with different data in them). Each one is needed in different scenarios but all of the scenarios depend on variables (some of which come from external sources) so at the point of this function it's impossible to know which ones will be necessary.</p>  <p>So I had a couple of questions about this approach that I hope you guys can answer.</p>  <ul> <li><p>Is there a negative performance impact when using <code>Object.defineProperty</code>, and if yes, is it possible that it could negate the benefit from not parsing the JSON data right away?</p></li> <li><p>Am I correct in assuming that not parsing the JSON right away will actually improve performance? We're looking at a continuously high number of requests and we need to process these quickly and efficiently.</p></li> <li><p>Right now the three JSON data sets come from two different tables JOINed in an SQL query. This is to only have to do one query per request instead of up to four. Keeping in mind that there are scenarios where none of the JSON data is needed, but also scenarios where all three data sets are needed (and of course scenarios inbetween), could it be an improvement to only get the required JSON data from its table, at the point when one of the data sets is actually needed? I avoided this because I feel like waiting for four separate SELECT queries to be executed would take longer than waiting for one query with two JOINed tables.</p></li> <li><p>Are there other ways to approach this that would improve the general performance even more? (I know, this one's a bit of a subjective question, but ideas / suggestions of things I should check out are welcome). I'm not looking to spin off parsing the JSON data into a separate thread though, because as our service runs on a cluster of virtualised single-core servers, creating a child process would only increase overall CPU usage, which at high loads would have even more negative impact on performance.</p></li> </ul>  <p><em>Note: when I say performance it mainly means fast and efficient throughput rates. We prefer a somewhat larger memory footprint over heavier CPU usage.</em></p>