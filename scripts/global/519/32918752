<p>I have an app where I would like the user to take a video using UIImagePickerController.</p>  <p>Then I create a watermark on top of the recorded video and export it with AVAssetExportSession.</p>  <p>I'm guessing that I need to use a CGAffineTransformScale and then another transform to get the export to the right size, but I'm new to transforming.</p>  <p>What kind of transform could I use to crop the video to the size of the UIImagePickerController's view?</p>  <pre><code>func imagePickerController(picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [String : AnyObject]) {          let videoPath = info[UIImagePickerControllerMediaURL] as! NSURL          let stringVideoPath = videoPath.path          //add watermark starting here          let videoAsset = AVURLAsset(URL: videoPath)         let mixComposition = AVMutableComposition()         let compositionVideoTrack = mixComposition.addMutableTrackWithMediaType(AVMediaTypeVideo, preferredTrackID: kCMPersistentTrackID_Invalid)         let clipVideoTrack = videoAsset.tracksWithMediaType(AVMediaTypeVideo)[0]         do {         try compositionVideoTrack.insertTimeRange(CMTimeRangeMake(kCMTimeZero, videoAsset.duration), ofTrack: clipVideoTrack, atTime: kCMTimeZero)         } catch {             print("error")         }           compositionVideoTrack.preferredTransform = clipVideoTrack.preferredTransform           //create the watermark image         let myImage = UIImage(named: "watermarkImage.png")         let aLayer = CALayer()         aLayer.contents = myImage?.CGImage         aLayer.frame = CGRectMake(5, 25, 100, 60)         aLayer.opacity = 1.0          //sort layer         let videoSize = clipVideoTrack.naturalSize         let parentLayer = CALayer()         let videoLayer = CALayer()         parentLayer.frame = CGRectMake(0, 0, videoSize.height, videoSize.width)         videoLayer.frame = CGRectMake(0, 0, videoSize.height, videoSize.width)         parentLayer.addSublayer(videoLayer)         parentLayer.addSublayer(aLayer)          //create composition and add instructions to insert the layer          let videoComp = AVMutableVideoComposition()         videoComp.renderSize = CGSize(width: videoSize.height, height: videoSize.width)         videoComp.frameDuration = CMTimeMake(1, 30)         videoComp.animationTool = AVVideoCompositionCoreAnimationTool(postProcessingAsVideoLayer: videoLayer, inLayer: parentLayer)          //instructions         let mainInstruction = AVMutableVideoCompositionInstruction()         mainInstruction.timeRange = CMTimeRangeMake(kCMTimeZero, mixComposition.duration)         let videoTrack = mixComposition.tracksWithMediaType(AVMediaTypeVideo)[0]             let layerInstruction = AVMutableVideoCompositionLayerInstruction(assetTrack: videoTrack)  //I'm guessing I would have something like let zoomTransform = CGAffineTransformScale(compositionVideoTrack.preferredTransform, 1, 1) and then apply that transform below instead of compositionVideoTrack.preferredTransform   layerInstruction.setTransform(compositionVideoTrack.preferredTransform, atTime: kCMTimeZero)           mainInstruction.layerInstructions = [layerInstruction]          videoComp.instructions = [mainInstruction]          let assetExport = AVAssetExportSession(asset: mixComposition, presetName: AVAssetExportPresetMediumQuality)         assetExport?.videoComposition = videoComp         let exportPath = NSTemporaryDirectory().stringByAppendingString("TestVideo.mp4")         let exportURL = NSURL(fileURLWithPath: exportPath)          if NSFileManager.defaultManager().fileExistsAtPath(exportPath) {             do { try NSFileManager.defaultManager().removeItemAtPath(exportPath)} catch{}         }          assetExport?.outputFileType = AVFileTypeMPEG4         assetExport?.outputURL = exportURL         assetExport?.shouldOptimizeForNetworkUse = true         assetExport?.exportAsynchronouslyWithCompletionHandler({ () -&gt; Void in             print("done")             UISaveVideoAtPathToSavedPhotosAlbum(exportURL.path!, self, nil, nil)         })          picker.dismissViewControllerAnimated(true, completion: nil)         picker.view.superview?.removeFromSuperview()      } </code></pre>