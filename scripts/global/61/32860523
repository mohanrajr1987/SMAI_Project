<p>I'm working on the "buddy-allocation" for a memory management project in C (see <a href="http://pages.cs.wisc.edu/~remzi/OSTEP/vm-freespace.pdf" rel="nofollow">page 14 of this .pdf</a>).</p>  <p>I'd like to find the "buddy" of a given address, knowing that the two buddies are only one-bit-different (the size of the chunk tells us which bit changes). For example, if one of the two 32-bits buddy chunks has the binary address 0b110<strong>0</strong>10100, the second one will be located at 0b110<strong>1</strong>10100 (the 6th bit from the right changes, as 32=2⁶-¹).</p>  <p>I'd like to implement that in C, without exponentiation algorithms because I'm trying to make my program as fast-executing as possible. At best I'd use a tool to manipulate bits, if that exists. Any hints?</p>  <p>EDIT: the type of the addresses is <strong>void*</strong>. With the solutions posted below, <em>gcc</em> won't let me compile.</p>  <p>EDIT2: I've tried the answers posted below with the XOR operator, but I can't compile because of the type of the addresses. Here's what I've tried :</p>  <p><code>void* ptr1 = mmap(NULL, 640000, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_FILE | MAP_PRIVATE, -1, 0);     printf("%p\n", ptr1);     void* ptr2 = ptr1+0x15f6d44;     printf("%p\n", ptr2);     void* ptr3 = (void*)(ptr2-ptr1);     printf("%p\n", ptr3);     void* ptr4 = ptr3 ^ (1 &lt;&lt; 6);     printf("%p\n", ptr4);</code></p>  <p>and the <em>gcc</em> error : <code>invalid operands to binary ^ (have ‘void *’ and ‘int’) </code></p>