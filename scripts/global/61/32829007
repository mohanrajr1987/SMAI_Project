<p>I tried to simulate a railway station with 3 rails and several trains which are arriving and leaving at a certain time. Every train should represent a single child process. Every single rail should be in a "Shared Memory Segment". (not quite sure if i did that right). My main problem is, that the next process is starting, if the previous has finished. But trains should also arrive if there is a unused rail.</p>  <p>E.g. </p>  <p>t = 0: train A arrives at rail 1 and stays for 8s</p>  <p>t = 1: train B arrives but rail 1 is already in use (for 7s more seconds), so train B goes to rail 2.</p>  <p><div class="snippet" data-lang="js" data-hide="false"> <div class="snippet-code"> <pre class="snippet-code-js lang-js prettyprint-override"><code>#iclude &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;sys/ipc.h&gt; #include &lt;sys/shm.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/wait.h&gt; #include &lt;sys/sem.h&gt; #include &lt;semaphore.h&gt; #include &lt;time.h&gt; #define PROCESS_MAX 7 // there are 7 trains   int rail[2]; // rail 0,1,2 int ankunftszeit[PROCESS_MAX] = {0, 0, 2, 3, 5, 5, 6}; // arrival time int aufenthalt[PROCESS_MAX] = {8, 4, 3, 7, 3, 5, 2}; // residence time  void* shm_p;  int shmid;   union semun { 	int val; 	struct semid_ds *buf; 	short *array; } arg;   void terminate() {     /* ...      * more text     */ ... 	printf("parent exiting.\n"); 	exit(EXIT_SUCCESS); }  void train_implement(int index) { 	sleep(ankunftszeit[index]); 	srand (time(NULL)); 	int random; 	random = rand() % 3;   	printf(" %d Sekunden nach Start: Zug %d faehrt auf Gleis %d ein\n", ankunftszeit[index], index+1, random); 	sleep(aufenthalt[index]); 	printf(" %d Sekunden nach Start: Zug %d verlaesst den Bahnhof auf Gleis %d \n", aufenthalt[index], index+1, random); }  int main(void) {	 	int semid; 	pid_t pid; 	struct sembuf ops[2]; 	 	if ((semid = semget(5, 1, IPC_CREAT | 0666)) &lt; 0) { 		perror("semget failed"); 		exit(EXIT_FAILURE); 	} 	 	if ((shmid = shmget(5, sizeof(int), IPC_CREAT | 0666)) &lt; 0) { 		perror("shmget failed"); exit(EXIT_FAILURE); 	} 	 	if ((shm_p = shmat(shmid, NULL, 0 )) == (char *) -1) { 		perror("shmat failed"); 		exit(EXIT_FAILURE); 	} 	shm_p = &amp;rail[0]; 	 	ops[0].sem_num = 0; 	ops[0].sem_flg = 0; 	 	 	/* initialize */ 	arg.val = 1; 	if (semctl( semid, 0, SETVAL, arg) &lt; 0 ) { 		perror("semctl SETVAL failed"); 	} 		 	 	for (int index = 0; index &lt; PROCESS_MAX; index++) {  // PROCESS_MAX = 7 		if ((pid = fork()) == -1) { 			perror("fork failed"); 			exit(EXIT_FAILURE); 		} else if (pid == 0) { 			 			 			 			for (int i = 0; i &lt;= 2; i++) { 				ops[i].sem_op = -1;			 				if (semop(semid, ops, 1) &lt; 0) {	// when semaphore is 0 it waits until it's &gt; 0 					perror("semop P() failed");		// then it decrements it 					exit(EXIT_FAILURE); 				} 				 				 				train_implement(index); 			 				ops[i].sem_op = 1;			 				if (semop(semid, ops, 1) &lt; 0) {	// increments semaphore (1 again now -&gt; free) 					perror("semop V() failed"); 					exit(EXIT_FAILURE); 				} 			 				exit(EXIT_SUCCESS); 			} 		} 	} 	while (wait(NULL) &gt; 0);	// wait for all child processes to finish 	terminate(); 	 }</code></pre> </div> </div> </p>  <p>I hope you can help me, or give me some hints. Thanks</p>