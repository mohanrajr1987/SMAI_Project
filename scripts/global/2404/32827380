<p>Is it possible to force a annotation processor to RERUN after all other processors have generated their code? Basically what I'm running into right now is that Android Databinding is generating a type parameter for one of my classes causing the inherited class from its super not to propagate properly on the first pass of my processor. Any help would be much appreciated!</p>  <p>Thanks</p>  <p>Annotation:</p>  <pre><code>@Inherited     @Retention(RetentionPolicy.CLASS)     @Target(ElementType.TYPE)     public @interface ContainsViewModel{      } </code></pre>  <p>Example:</p>  <pre><code>@ContainsViewModel public class MyActivity extends ViewModelActivity&lt;MyViewModel, GeneratedClass&gt;{  //The GeneratedClass in this case is a SubClass of ViewDataBinding for the Android databinding library         @InjectHere public void injectMethod(MyViewModel injected){       } } </code></pre>  <p>In the above example, the GeneratedClass will cause this class to never show up in </p>  <pre><code>public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {         roundEnv.getElementsAnnotatedWith(ViewModelView.class)// does not have MyActivity } </code></pre>  <p>This seems to be because the GeneratedClass never gets generated until the last pass of my process. I can tell by doing, </p>  <pre><code>roundEnv.getRootElements() </code></pre>  <p>However, when I finally see the GeneratedClass show up, the roundEnv refuses to provide any elements with my ContainsViewModel annotation. Any ideas as to go about dealing with this? Thanks.</p>