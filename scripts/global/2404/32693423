<p>I have a framework where all objects with a certain framework annotation have to be considered to also have the <code>@Conditional</code> Spring annotation to work. I would rather abstract Spring and also simplify the API for my consumers. For example, my consumer has classes <code>FooOne</code> and <code>FooTwo</code> which have annotation <code>Bar</code> - I want <code>FooOne</code> and <code>FooTwo</code> to automatically be considered to have a <code>@Conditional(Baz.class)</code> annotation.</p>  <pre><code>@Bar("blahblah") @Conditional(Baz.class) // I want this to be implicit public class FooOne {     // stuff }  @Bar("blahblahblah") @Conditional(Baz.class) // I want this to be implicit public class FooTwo {     // stuff }  @Retention(RetentionPolicy.RUNTIME) @Inherited @Configuration //@Conditional(Baz.class) - see second bullet below public @interface Bar {     // stuff }  public class Baz implements Condition {     @Override     public boolean matches(ConditionContext conditionContext, AnnotatedTypeMetadata annotatedTypeMetadata) {         Map&lt;String,Object&gt; barMetaData = annotatedTypeMetadata.getAnnotationAttributes("Bar");         // do stuff         return something;     } } </code></pre>  <p>I had two ideas:</p>  <ul> <li>Add the <code>@Conditional</code> annotation on a base class (<code>BaseBar</code>) and my framework consumers (<code>FooOne</code>, <code>FooTwo</code>) should inherit from the base class. But the <code>@Conditional</code> annotation is not inherited (as specified in the JavaDoc) so Spring won't bother reading the <code>@Conditional</code> annotation on the base class.</li> <li>Use the <code>@Conditional</code> annotation as a meta-annotation on one of my existing annotations (e.g. <code>Bar</code>) applied to this class. In this case, Spring is reading the <code>@Conditional</code> annotation but the <code>AnnotatedTypeMetaData</code> passed into the <code>Condition</code> now represents the (meta-)annotations on the annotation (<code>Bar</code>) rather than on the class itself (<code>FooOne</code>, <code>FooTwo</code>). This is not helpful to me as I need to read the actual class annotations within the <code>Condition</code> (reading the metadata of <code>Bar</code> within <code>Baz</code>).</li> </ul>  <p>Is there any way to get around this - any other options available? For example, is there any way to get access to those class annotations when <code>@Conditional</code> is used as a meta-annotation? Or is there any way to wrap <code>@Conditional</code> to make it inherited? Or any way to extend Spring's <code>@Conditional</code>-resolving code to make it more suitable for this use-case?</p>