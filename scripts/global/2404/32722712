<p>Suppose I have a class <code>com.example.Foo</code> and another class <code>com.sample.Bar</code> which needs to know the fully-qualified name of <code>Foo</code>. If I am a Java novice I might put:</p>  <pre><code>public class Bar {     private String fooName = "com.example.Foo";     //... } </code></pre>  <p>However, if I refactored <code>Foo</code> to change the name or package, the changes would not be reflected in <code>Bar</code>, unless the IDE is really clever. So it's better to do something like this:</p>  <pre><code>import com.example.Foo;  public class Bar {     private String fooName = Foo.class.getName();     // ... } </code></pre>  <p>This way, if I refactor <code>Foo</code>, then the change should be picked up by <code>Bar</code>.</p>  <p>Now consider methods. If I have a method name in class <code>Foo</code> and the name needs to be known by <code>Bar</code>, it seems the best I can do is:</p>  <pre><code>public class Bar {     private String bazName = Foo.class.getMethod("bazMethod", Qux.class);     // ... } </code></pre>  <p>But I haven't actually achieved anything - I still have a string literal "bazMethod" which won't be refactored if the real <code>bazMethod</code> gets renamed.</p>  <p>What I really want to do is something like:</p>  <pre><code>public class Bar {     private String bazName = tellMeTheMethodName((new Foo()).bazMethod(null));     // ... } </code></pre>  <p>Not sure if this is possible somehow and if there is any way around it.</p>  <p>Now comes the real problem - even if you can sort that out as above, the real thing I am trying to access is an annotation attribute/element name. But annotations are abstract and cannot even be instantiated. So is this possible?</p>