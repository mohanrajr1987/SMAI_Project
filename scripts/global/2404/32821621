<p>I have a class that uses a Hibernate session to call a stored procedure via a JPA @NamedNativeQuery using an in memory H2 database for testing (the actual database is MySQL).  The stored procedure inserts a record into a database table and then returns that row.  </p>  <p>However during testing, on converting to the JPA @Entity, I am seeing an H2 database error: <strong>org.h2.jdbc.JdbcSQLException: Column "Id" not found</strong>.  </p>  <p>I've documented a cut down version of the code below.</p>  <p>As far as I can tell I think it has something to do with the H2 interpretation of the @Id annotation, but don't understand why, so any help would be gratefully appreciated...</p>  <p><strong>NB - I have searched Stack overflow fairly extensively, including the issue relating to the use of double quotes for column specification, but don't think that this relates to my situation...</strong></p>  <p><strong>Table</strong></p>  <pre><code>CREATE TABLE History.Status_Report ( Id INT NOT NULL AUTO_INCREMENT, Unique_Users INT NOT NULL, PRIMARY KEY (Id)  ); </code></pre>  <p><strong>Stored Procedure</strong></p>  <pre><code>CREATE PROCEDURE History.Status_Reporting(reporting_date DATE)            BEGIN      INSERT INTO history.status_report (Unique_Users) VALUES (10); SELECT *      FROM History.Status_Report WHERE Id = LAST_INSERT_ID(); END; </code></pre>  <p><strong>Entity</strong>     package com.test;</p>  <pre><code>import javax.persistence.Column; import javax.persistence.Entity; import javax.persistence.GeneratedValue; import javax.persistence.Id; import javax.persistence.NamedNativeQuery; import javax.persistence.Table; import java.io.Serializable;  @NamedNativeQuery(name = "callStatusReporting", query = "CALL Status_Reporting(:reporting_date)", resultClass = StatusReportEntity.class) @Entity @Table(name = "Status_Report", catalog = "History") public class StatusReportEntity implements Serializable {      private static final long serialVersionUID = 1L;     @Id     @GeneratedValue     @Column(name = "Id")     protected Integer id;     @Column(name = "Unique_Users")     protected int uniqueUsers;      public Integer getId() {         return this.id;     }      public int getUniqueUsers() {         return this.uniqueUsers;     } } </code></pre>  <p><strong>Class under test</strong></p>  <pre><code>package com.test;  import org.hibernate.Query; import org.hibernate.Session;  public class MyListener {      public StatusReportEntity doRequest(Date reportDate) {         Session session = HibernateUtil.openSession(); // returns a MySQL session or H2 if testing…                 try {             Query query = session.getNamedQuery("callStatusReporting").setParameter("reporting_date", reportDate);;             StatusReportEntity statusReportEntity = (StatusReportEntity) query.uniqueResult();             return statusReportEntity;         } catch (Exception e) {             System.err.println(e);         } finally {             session.close();             return null;         }     } </code></pre>  <p><strong>H2 Aliases</strong></p>  <p>To enable testing using H2, There is also a file to specify the necessary aliases:</p>  <pre><code>CREATE SCHEMA IF NOT EXISTS History; CREATE ALIAS IF NOT EXISTS Status_Reporting FOR "com.test.StoredProcs.statusReporting"; </code></pre>  <p><strong>Test Class to be used by Alias</strong></p>  <p>And a test class to return a default result from the SP call:</p>  <pre><code>package com.test;  import com.test.StatusReportEntity;  public class StoredProcs {      public static StatusReportEntity statusReporting(Date reportingDate) {         StatusReportEntity statusReportEntity = StatusReportEntity.builder().withId(1).withUniqueUsers(10).build();         return statusReportEntity;     } } </code></pre>  <p><strong>Test Class</strong></p>  <pre><code>package com.test;  import com.test.MyListener; import java.util.Calendar; import org.junit.Test; import static org.junit.Assert.*;  public class MyListenerTest {      private MyListener listener;      @Test     public void listenerReturnsLatestData() throws Exception {         MyListener myListener = new MyListener();         assertNotNull(myListener.statusReporting(Calendar.getInstance().getTime()));     } } </code></pre>