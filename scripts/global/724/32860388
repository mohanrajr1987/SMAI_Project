<p>Editor FooEdit (let's call it) uses <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa365512%28v=vs.85%29.aspx" rel="nofollow">ReplaceFile</a>() when saving to ensure that the save operation is effectively atomic, and that if anything goes wrong then the original file on disc is preserved. (The other important benefit of ReplaceFile() is continuity of file identity - creation date and other metadata.)</p>  <p>FooEdit also keeps open a handle to the file with a sharing mode of just FILE_SHARE_READ, so that other processes can open the file but can't write to it while it while FooEdit has it open for writing.</p>  <p>"Obviously", this handle has to be closed briefly while the ReplaceFile operation takes place, and this allows a race in which another process can potentially open the file with write access before FooEdit re-establishes it's FILE_SHARE_READ lock handle.</p>  <p>(If FooEdit doesn't close its FILE_SHARE_READ handle before calling ReplaceFile(), then ReplaceFile() fails with a sharing violation.)</p>  <p>I'd like to know what is the simplest way to resolve this race. The options seem to be either to find another way to lock the file that is compatible with ReplaceFile() (I don't see how this is possible) or to replicate all the behaviour of ReplaceFile(), but using an existing file handle to access the destination file rather than a path. I'm a bit stuck on how all of the operations of ReplaceFile() could be carried out atomically from user code (and reimplementing ReplaceFile() seems a bad idea anyway).</p>  <p>This must be a common problem, so probably there's an obvious solution that I've missed.</p>  <p>(This question seems related but has no answer: <a href="http://stackoverflow.com/questions/32532399">Transactionally write a file change on Windows</a>.)</p>  <hr>  <p>Here's a minimal verifiable example showing what I am trying to achieve (updated 13:18 30/9/2015 UTC). You must supply three file names as command line arguments, all on the same volume. The first must already exist.</p>  <p>I always get a sharing violation from ReplaceFile().</p>  <pre><code>#include &lt;Windows.h&gt; #include &lt;stdio.h&gt; #include &lt;assert.h&gt; int main(int argc, char *argv[]) {   HANDLE lock;   HANDLE temp;   DWORD  bytes;    if (argc != 4)   {     puts("First argument is the project file. Second argument is the temporary file.");     puts("The third argument is the backup file.");   }    /* Open and lock the project file to make sure no one else can modify it */   lock = CreateFile(argv[1], GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_DELETE, NULL, OPEN_EXISTING, 0, 0);   assert(lock != INVALID_HANDLE_VALUE);    /* Save to the temporary file. */   temp = CreateFile(argv[2], GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_DELETE, NULL, CREATE_ALWAYS, 0, 0);   assert(temp != INVALID_HANDLE_VALUE);   WriteFile(temp, "test", 4, &amp;bytes, NULL);   /* Keep temp open so that another process can't modify the file. */    if (!ReplaceFile(argv[1], argv[2], argv[3], 0, NULL, NULL))   {     if (GetLastError() == ERROR_SHARING_VIOLATION)       puts("Sharing violation as I expected");     else       puts("Something went wrong");   }   else     puts("ReplaceFile worked - not what I expected");    /* If it worked the file referenced by temp would now be called argv[1]. */   CloseHandle(lock);   lock = temp;    return EXIT_SUCCESS; } </code></pre>  <hr>  <p>Thanks to Hans Passant, who provided some valuable clarifying thoughts in an answer now deleted. Here's what I discovered while following up his suggestions:</p>  <p>It seems ReplaceFile() allows <em>lpReplacedFileName</em> to be open FILE_SHARE_READ | FILE_SHARE_DELETE, but <em>lpReplacementFileName</em> can't be. (And this behaviour doesn't seem to depend on whether <em>lpBackupFileName</em> is supplied.) So it's perfectly possible to replace a file that another process has open even if that other process doesn't allow FILE_SHARE_WRITE, which was Hans' point.</p>  <p>But FooEdit is trying to ensure no other process can open the file with GENERIC_WRITE <em>in the first place</em>. To ensure in FooEdit that there's no race where another process can open the replacement file with GENERIC_WRITE, it seems that FooEdit has to keep hold <em>continuously</em> of a FILE_SHARE_READ | FILE_SHARE_DELETE handle to <em>lpReplacementFileName</em>, which then precludes use of ReplaceFile().</p>