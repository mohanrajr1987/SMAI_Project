<p>I have a small application written in C for Linux on ARM which sets up a signal handler for the SIGTRAP signal and is supposed to catch the <code>bkpt</code> instruction (via the <code>TRAP_HWBKPT</code> code) and effectively skip it.</p>  <p>The handler simply notifies from where the breakpoint was raised and uses an inline epilogue to to redirect codeflow to 4 bytes (due to ARM's RISC architecture) after the breakpoint address (which is the next instruction). I know there should still be some register saving but that's not the problem for now.</p>  <p>What seems to happen is that the first call to a breakpoint-containing function goes fine but the second call doesn't get caught by the custom <code>sigtrap_handler</code> anymore and is passed to the default handler instead (causing the process to terminate):</p>  <p>Does anyone know why this happens and how to fix this so i can achieve the goal of calling the handler for every <code>bkpt</code> instruction and continuing execution as normal?</p>  <pre><code>$ gcc -o break break.c $ ./break START ENTER [0]! SIGTRAP at 0x856c EXIT [0]! ENTER [1]! Trace/breakpoint trap </code></pre>  <p>This is the code in question:</p>  <pre><code>#include &lt;sys/types.h&gt; #include &lt;signal.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt;  #ifndef TRAP_BRANCH     #define TRAP_BRANCH 3 #endif  #ifndef TRAP_HWBKPT     #define TRAP_HWBKPT 4 #endif  static void sigtrap_handler(int sig, siginfo_t* siginfo, void* ptr) {     switch(siginfo-&gt;si_code)     {         case TRAP_HWBKPT:         {             printf("SIGTRAP at %p\n", (void*)siginfo-&gt;si_addr);              asm volatile("sub sp, r11, #4\n\t"                          "pop {r11}\n\t"                          "sub sp, #4\n\t"                          "mov pc, %0"                          :                          : "r" (siginfo-&gt;si_addr + 4) // Proceed to instruction directly after breakpoint                         );         }break;          // misc. SIGTRAP codes (fallthrough)         case TRAP_BRKPT:         case TRAP_TRACE:         case TRAP_BRANCH:         default:         {             exit(-1);         }break;     } }  void dummy_routine(int n) {     printf("ENTER [%d]!\n", n);      // Breakpoint     asm volatile("bkpt");      printf("EXIT [%d]!\n", n);     return; }  int main (int argc, char *argv[]) {     int i;     struct sigaction act;      // Set up sigtrap handler     memset (&amp;act, 0, sizeof(act));     act.sa_sigaction = sigtrap_handler;     act.sa_flags = SA_SIGINFO;      if (sigaction(SIGTRAP, &amp;act, 0)) {         perror("Error: sigaction");         return 1;     }      printf("START\n");      // Trigger routine containing breakpoint multiple times     for(i = 0; i &lt; 2; i++)     {         dummy_routine(i);     }      printf("END\n");      return 0; } </code></pre>