<p>I've been debugging this for many hours now.  My application is an embedded program running on the CC2650 ARM M3 processor using the TI RTOS.</p>  <p>This line of c generates an ARM hard_fault exception (LD - link register set to 0xFFFFFFFD):</p>  <pre><code>leaseStartMessageForReplay = *leaseStartMessage; </code></pre>  <p>The code simply dereferences the <code>leaseStartMessage</code> struct pointer and copies the full struct content (2 words) to the <code>leaseStartMessageForReplay</code> struct. (Thats the intension at least).</p>  <p>The actual assembly for that line looks like this: <a href="http://i.stack.imgur.com/OlvIa.jpg" rel="nofollow"><img src="http://i.stack.imgur.com/OlvIa.jpg" alt="assembly"></a></p>  <p>The assembly seems correct: 1st line loads R0 with the address of <code>leaseStartMessage</code>. 2nd line loads R2 with the address of the <code>leaseStartMessageForReplay</code>. 3rd line load the two words located at address-R0 into R0 and R2. 4th line stores the two words in R0 and R2 at address-R1.</p>  <p>The hard_fault exception happens on the 3rd line. The registers R0, R1, R2 have these values just before executing the 3rd instruction: <a href="http://i.stack.imgur.com/Yd4eb.jpg" rel="nofollow"><img src="http://i.stack.imgur.com/Yd4eb.jpg" alt="enter image description here"></a></p>  <p>As can be seen the two address pointers R0 and R1 are initialized and I have verified that they contain the correct addresses.</p>  <p>Any help on how to debug this would be greatly appreciated.</p>