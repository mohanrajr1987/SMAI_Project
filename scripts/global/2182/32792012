<p>Here's what I mean. I'm practicing my object-oriented Javascript (I learn by practice), created the following class for fun</p>  <pre><code>function Funcstack ( )  {       this.stack = []; // stack/array of functions w/ no params        this.pushFunction = function ( f )        {          // f: function w/ no params          this.stack.push(f);       }        this.popFunction = function ( f )       {         // f: function w/ no params              var n = this.stack.length;           if (n &gt; 0) this.stack.splice(n - 1, 1);       }       this.executeFunctions = function ( )        {           // execute functions from top to bottom of stack           for ( var i = (this.stack.length - 1); i &gt;= 0; --i )           {              var thisfunc = this.stack[i];                  thisfunc();           }       } }  var fs = new Funcstack(); fs.pushFunction(function() { console.log('z'); }); fs.pushFunction(function() { console.log('y'); }); fs.pushFunction(function() { console.log('x'); }); fs.executeFunctions(); // should print 'xyz' </code></pre>  <p>and was surprised that it worked. The main reason is because I thought that, for example, in </p>  <pre><code>      this.pushFunction = function ( f )        {          // f: function w/ no params          this.stack.push(f);       } </code></pre>  <p>the body of the function wouldn't recognize <code>this.stack</code> because <code>this</code> in the particular context refers to the invoking function <code>pushFunction</code> which doesn't have a member named <code>stack</code>! So am I correct in thinking that it looked up the scope chain? That seems to contradict the whole idea of <code>this</code>, though ... What's the point of it?</p>