<p>This is similar to, but not quite the same as <a href="http://stackoverflow.com/questions/28250680/how-do-i-access-previous-promise-results-in-a-then-chain">How do I access previous promise results in a .then() chain?</a></p>  <p>I have a situation where I am making two async requests in parallel, followed by a third async request which depends on the success of the first two, and finally passing the results of the second async request to the function callback.</p>  <p>As of now I understand how to do this in two ways (.catch statements and function signatures omitted for brevity):</p>  <ol> <li><p>Using scope closure (my current implementation)</p>  <pre><code>var foo; Promise.join(promiseA, promiseB, function(resultsA, resultsB) {   foo = resultsB;   return promiseC; }) .then(function() {   // foo is accessible here   callback(null, foo); }); </code></pre></li> <li><p>Using Promise.bind, but have to use Promise.map instead of Promise.join</p>  <pre><code>var targetIndex = 1; Promise.resolve(promises)   .bind({})   .map(function(response, index) {     if (index === targetIndex) {       this.foo = response;     }   })   .then(function() {     return promiseC;   })   .then(function() {     // this.foo is accessible here     callback(null, this.foo);   }); </code></pre></li> </ol>  <p>As you can tell, option 2 is rather ugly since I have to manually check if the index parameter of the mapper matches the index of the promise result that I care about. Option 1 uses scope closure, which I understand is undesirable in most cases (but seems to be my best option at this point).</p>  <p>What I would really like to do is something like:</p>  <pre><code>Promise.bind({})   .join(promiseA, promiseB, function(resultsA, resultsB) {      this.foo = resultsB;      return promiseC;   })   .then(function() {     // I WISH this.foo WAS ACCESSIBLE HERE!     callback(null, this.foo);   }); </code></pre>  <p>Is there a way for me to utilize Promise.join instead of Promise.map to avoid using a scope closure in this situation?</p>