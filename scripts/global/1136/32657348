<p>I'm hoping to scale 12MP images from a machine vision camera using <a href="http://www.lwjgl.org/" rel="nofollow">LWJGL 3</a> and an SWT GLCanvas.</p>  <p>Scaling is obviously computationally intensive so I'd like to get the GPU to take care of this for me, but I am very unfamiliar with OpenGL. Further, every example I've looked at for LWJGL appears to be for much older versions of LWJGL or use deprecated methods; it appears LWJGL has undergone radical changes throughout its life.</p>  <p>I've provided a sample class which should describe how I'm desiring to implement this functionality, but I need help filling in the blanks (preferably using modern OpenGL and LWJGL 3):</p>  <pre class="lang-java prettyprint-override"><code>import org.eclipse.swt.SWT; import org.eclipse.swt.layout.FillLayout; import org.eclipse.swt.opengl.GLCanvas; import org.eclipse.swt.opengl.GLData; import org.eclipse.swt.widgets.Composite; import org.lwjgl.opengl.GLContext;  public class LiveCameraView extends Composite {   private GLCanvas canvas;    public LiveCameraView(Composite parent, int style)   {     super(parent, style);     this.setLayout(new FillLayout());      GLData data = new GLData();     data.doubleBuffer = true;      canvas = new GLCanvas(this, SWT.NONE, data);   }    public void updateImage(byte[] bgrPixels, int imageWidth, int imageHeight)   {     canvas.setCurrent();     GLContext.createFromCurrent();      /*      * STEP 1: Translate pixels into a GL texture from the 3-byte BGR byte[]      * buffer.      */      /*      * STEP 2: Now that the GPU has the full sized image, we'll get the GPU to      * scale the image appropriately.      */     double scalingFactor = getScalingFactor(imageWidth, imageHeight);      canvas.swapBuffers();   }    private double getScalingFactor(int originalWidth, int originalHeight)   {     int availableWidth = canvas.getBounds().width;     int availableHeight = canvas.getBounds().height;      // We can either scale to the available width or the available height, but     // in order to guarantee that the whole image is visible we choose the     // smaller of the two scaling factors.     double scaleWidth = (double) availableWidth / (double) originalWidth;     double scaleHeight = (double) availableHeight / (double) originalHeight;     double scale = Math.min(scaleWidth, scaleHeight);      return scale;   }  } </code></pre>  <p>In a separate thread new images are being acquired from the camera continuously. Ideally that thread will asynchronously invoke the <code>updateImage(...)</code> method and provide the raw BGR data of the most recent image.</p>  <p>I believe this should be achievable using the outlined paradigm, but I could be way off base. I appreciate any good direction.</p>  <p>As a final note, this question arose from my initial question asked here: <a href="http://stackoverflow.com/questions/32641831/implementation-paradigm-for-efficiently-streaming-zoomable-images-from-machine-v?noredirect=1#comment53153908_32641831">My initial question concerning the general paradigm</a></p>