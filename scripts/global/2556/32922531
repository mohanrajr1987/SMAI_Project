<p>Stacked people. </p>  <p>Iam trying to implement an observer(esque?) pattern for my program. I have a component which stores what functions should be called if an event occours. My prolem is that i dont know how should i erase my function from the container, if the need arises. Tried storing the functions by reference, but iam not sure how to do that(or if thats possible.)</p>  <pre><code>#include &lt;map&gt; #include &lt;vector&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;functional&gt; using namespace std;  enum class EVENT_TYPE{      anEvent  };  class EventableComponent{     map&lt;EVENT_TYPE, vector&lt;function&lt;void()&gt;&gt;&gt; listeners; public:     void trigger(EVENT_TYPE _et){         for(auto&amp; it : listeners[_et]){             it();         }     }      void registerListener(EVENT_TYPE _et, function&lt;void()&gt; _fn){         listeners[_et].push_back(_fn);     };      void removeListener(EVENT_TYPE _et, function&lt;void()&gt; _fn){         //error C2678: binary '==' : no operator found which takes a left-hand operand of type 'std::function&lt;void (void)&gt;'          //(or there is no acceptable conversion)                 listeners[_et].erase(remove(listeners[_et].begin(), listeners[_et].end(), _fn), listeners[_et].end());     }; };  int main(){     EventableComponent ec;      // this would become a member function for a class  somewhere down the line     auto fn = [](){cout &lt;&lt; "Hello.\n"; };      ec.registerListener(EVENT_TYPE::anEvent, fn);     ec.trigger(EVENT_TYPE::anEvent);      ec.removeListener(EVENT_TYPE::anEvent, fn);     ec.trigger(EVENT_TYPE::anEvent);      cin.get();     return 0; }; </code></pre>