<p>I am trying to create a game using Haskell + Netwire 5 (+ SDL). Now I am working on the output part, where I would like to create wires that read in some game state and output the SDL surfaces to be blitted on screen. </p>  <p>However, the problem is that SDL surfaces are contained in <code>IO</code> monad, so any function that creates such surfaces must have type <code>a -&gt; IO b</code>. Of course, <code>arr</code> does not construct a <code>Wire</code> from <code>a -&gt; m b</code>. However, since the type signature of a wire is <code>(Monad m, Monoid e) =&gt; Wire s e m a b</code>, it looks quite like a Kleisi Arrow, but I cannot find a suitable constructor for making such a wire.</p>  <p>I am new to FRP and Arrows, and have not programmed a lot in Haskell, so this may not be the best way to implement the graphics output. If I am wrong from the beginning, please let me know.</p>  <p>Some SDL functions related:</p>  <pre><code>createRGBSurfaceEndian :: [SurfaceFlag] -&gt; Int -&gt; Int -&gt; Int -&gt; IO Surface  fillRect :: Surface -&gt; Maybe Rect -&gt; Pixel -&gt; IO Bool  blitSurface :: Surface -&gt; Maybe Rect -&gt; Surface -&gt; Maybe Rect -&gt; IO Bool  flip :: Surface -&gt; IO () </code></pre>  <h1>Update 1</h1>  <p>This code type checks, but now I am trying to interface it with SDL for testing</p>  <pre><code>wTestOutput :: (Monoid e) =&gt; Wire s e IO () SDL.Surface wTestOutput = mkGen_ $ \a -&gt; (makeSurf a &gt;&gt;= return . Right)     where       makeSurf :: a -&gt; IO SDL.Surface       makeSurf _ = do         s &lt;- SDL.createRGBSurfaceEndian [SDL.SWSurface] 800 600 32         SDL.fillRect s (Just testRect) (SDL.Pixel 0xFF000000)         return s       testRect = SDL.Rect 100 100 0 0 </code></pre>