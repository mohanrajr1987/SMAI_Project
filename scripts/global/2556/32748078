<p>Since my <a href="http://stackoverflow.com/questions/32257728/trying-simple-approach-to-opp-inheritance-in-javascript-es5">last question</a>, I've been studying Javascript's prototype model and trying to get rid of the OOP vision I <em>inherited</em> from other languages (pun slightly intended).</p>  <p>I went back to basics and read Crookford's <a href="http://shop.oreilly.com/product/9780596517748.do" rel="nofollow">Javascript: The Good Parts</a>, along with <a href="https://github.com/getify/You-Dont-Know-JS" rel="nofollow">You Don't Know JS</a> material and decided to stick with the so called <strong>behaviour delegation</strong>.</p>  <p>Restructuring my previous example implementing behaviour delegation and namespacing, I wrote:</p>  <pre><code>var GAME = {};  (function(namespace) {     var Warrior = {};      Warrior.init = function(weapon) {         this.setWeapon(weapon);     };      Warrior.getWeapon = function() {       return this.weapon;     };      Warrior.setWeapon = function(value) {       this.weapon = value || "Bare hands";     };      namespace.Warrior = namespace.Warrior || Warrior; })(GAME);  (function(namespace) {     var Archer = Object.create(namespace.Warrior);      Archer.init = function(accuracy) {         this.setWeapon("Bow");         this.setAccuracy(accuracy);     };      Archer.getAccuracy = function() {         return this.accuracy;     };      Archer.setAccuracy = function(value) {       this.accuracy = value;     };      namespace.Archer = namespace.Archer || Archer; })(GAME); </code></pre>  <p>So, everytime I copy a new Archer object:</p>  <pre><code>var archer1 = Object.create(GAME.Archer); </code></pre>  <p>only this object will be created, conserving memory.</p>  <p>But what if I don't want to expose "accuracy" attribute? The attribute would only increase by calling a "training()" method or something similar. I tried to use <code>var accuracy</code> inside the anonymous function, but it turns into kind of static variable, all instances of Archer would share the same value.</p>  <p>The question: <strong>Is there any way to set a variable as private while still keeping behaviour-delegation/prototypal pattern?</strong></p>  <p>I do know of <strong>functional pattern</strong> as well, Here I succesfully achieved variable privacy, at the cost of memory. By going functional, every new "archer" instance  generates a new "Warrior" and then a new "Archer". Even considering that Chrome and Firefox have different optmizations, testings on both report that the Delegation/Prototypal pattern is more efficient:</p>  <p><a href="http://jsperf.com/delegation-vs-functional-pattern" rel="nofollow">http://jsperf.com/delegation-vs-functional-pattern</a></p>  <p>If I go with the pure-object delegation pattern, should I just forget the classic encapsulation concept and accept the free changing nature of properties?</p>