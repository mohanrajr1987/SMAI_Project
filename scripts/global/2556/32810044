<p>I'm trying to create a new implementation of the <code>elem</code> function in Haskell using the <code>foldr</code> function.</p>  <p>So far I have this:</p>  <pre><code>count :: Eq a =&gt; a -&gt; [a] -&gt; Integer count x (y:ys) = foldl (\counter y -&gt; if y == x then counter + 1 else counter) 0 ys count _ [] = 0  elem' :: Eq a =&gt; a -&gt; [a] -&gt; Bool elem' x (y:ys) = foldr (\i elem-&gt; if (count x (y:ys)) &gt; 0 then True else False) False ys elem' _ [] = False </code></pre>  <p>The <code>count</code> function is counting the number of occurances of x (another function I wrote) using <code>foldl</code>. This works fine for finite lists, but the problem is that I want to take advantage of the <code>foldr</code> lazy computation of an infinite list. If I try to use an infinite list as input the program hangs forever. </p>  <p>Basically I want to "break out" once I find any instance of x in the list and return true, otherwise return false.</p>  <p>Thanks for the help.</p>