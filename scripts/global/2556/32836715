<p>Suppose in C, we have following struct: </p>  <pre><code>struct MyData {     char key1[20];     long key2;     ...  /* some data */ }; </code></pre>  <p>Essentially, in addition to some data, we have two keys: key1 and key2. Suppose we need to manage a bunch of objects of <em>MyData</em> in two different ways, for example, to quickly find corresponding object based on either key1 or key2 (but not both). One way to meet this requirement is to build two different RB-trees (or hash-tables) according to the two keys, respectively. In C/C++, the data need not to be duplicated since we only need to record the pointers of objects.</p>  <p>In above hypothetical example, the key point is that we have a bunch of data with same type and we can organized it through two different data structures without duplicating the data in imperative language. I am wondering how pure functional programming can efficiently meet this requirement without duplicating data. To make it more general or challenging, the two data structures may not be of same type. For example, one could be rb-tree and the other could be hash-table. </p>  <p>If possible, please layout your solution in Haskell. </p>  <p>PS: As a newbie to functional programming, I couldn't help wondering how to achieve some tricks from imperative programming in a pure functional programming. I know sometimes it doesn't make sense at all. If someone feels this question is also pointless, please layout the detail reasoning. </p>  <p>Thanks </p>