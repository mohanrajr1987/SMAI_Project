<p>In our NodeJS application, we define custom error classes by extending the default Error object:</p>  <pre><code>"use strict"; const util = require("util");  function CustomError(message) {     Error.call(this);     Error.captureStackTrace(this, CustomError);     this.message = message; }  util.inherits(CustomError, Error); </code></pre>  <p>This allows us to <code>throw CustomError("Something");</code> with the stack trace showing up correctly, and both <code>instanceof Error</code> and <code>instanceof CustomError</code> working correctly.</p>  <p>However, for returning errors in our API (over HTTP), we want to convert the error to JSON. Calling <code>JSON.stringify()</code> on an Error results in <code>"{}"</code>, which is obviously not really descriptive for the consumer.</p>  <p>To fix this, I thought of overriding <code>CustomError.prototype.toJSON()</code>, to return an object literal with the error name and message. <code>JSON.stringify()</code> would then just stringify this object and all would work great:</p>  <pre><code>// after util.inherits call  CustomError.prototype.toJSON = () =&gt; ({     name    : "CustomError",     message : this.message }); </code></pre>  <p>However, I quickly saw that this throws a <code>TypeError: Cannot assign to read only property 'toJSON' of Error</code>. Which might make sense as I'm trying to write to the prototype. So I changed the constructor instead:</p>  <pre><code>function CustomError(message) {     Error.call(this);     Error.captureStackTrace(this, CustomError);     this.message = message;     this.toJSON = () =&gt; ({         name    : "CustomError",         message : this.message     }); } </code></pre>  <p>This way (I expected), the CustomError.toJSON function would be used and the CustomError.prototype.toJSON (from Error) would be ignored.</p>  <p>Unfortunately, this just throws the error upon object construction: <code>Cannot assign to read only property 'toJSON' of CustomError</code>.</p>  <p>Next I tried removing <code>"use strict";</code> from the file, which <em>sort of</em> solved the problem in that no error was being thrown anymore, although the <code>toJSON()</code> function was not used by <code>JSON.stringify()</code> at all.</p>  <p>At this point I'm just desperate and just try random things. Eventually I end up with using <code>Object.defineProperty()</code> instead of directly assigning to <code>this.toJSON</code>:</p>  <pre><code>function CustomError(message) {     Error.call(this);     Error.captureStackTrace(this, CustomError);     this.message = message;     Object.defineProperty(this, "toJSON", {         value: () =&gt; ({             name    : "CustomError",             message : this.message         })     }); </code></pre>  <p>This works perfectly. In strict mode, no errors are being called, and <code>JSON.stringify()</code> returns <code>{"name:" CustomError", "message": "Something"}</code> like I want it to.</p>  <p>So although it works as I want it to now, I still want to know:</p>  <ol> <li>Why does this work exactly? I expect it to be the equivalent to <code>this.toJSON = ...</code> but apparently it is not.</li> <li>Should it work like this? I.e. is it safe to depend on this behaviour?</li> <li>If not, how should I override the toJSON method correctly? (if possible at all)</li> </ol>