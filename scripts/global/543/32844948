<p>I've recently read how <code>std::move</code> can speed up code by just moving the values instead of copying them. So I made a test program to compare the speed using <code>std::vector</code>.</p>  <p>The code:</p>  <pre><code>#include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;stdint.h&gt;  #ifdef WIN32 #include &lt;Windows.h&gt; #else #include &lt;sys/time.h&gt; #include &lt;ctime&gt; #endif #undef max  // Returns the amount of milliseconds elapsed since the UNIX epoch. Works on both // windows and linux.  uint64_t GetTimeMs64() { #ifdef _WIN32     // Windows     FILETIME ft;     LARGE_INTEGER li;      // Get the amount of 100 nano seconds intervals elapsed since January 1, 1601 (UTC) and copy it     // to a LARGE_INTEGER structure.     GetSystemTimeAsFileTime(&amp;ft);     li.LowPart = ft.dwLowDateTime;     li.HighPart = ft.dwHighDateTime;      uint64_t ret = li.QuadPart;     ret -= 116444736000000000LL; // Convert from file time to UNIX epoch time.     ret /= 10000; // From 100 nano seconds (10^-7) to 1 millisecond (10^-3) intervals      return ret; #else     // Linux     struct timeval tv;      gettimeofday(&amp;tv, NULL);      uint64 ret = tv.tv_usec;     // Convert from micro seconds (10^-6) to milliseconds (10^-3)     ret /= 1000;      // Adds the seconds (10^0) after converting them to milliseconds (10^-3)     ret += (tv.tv_sec * 1000);      return ret; #endif }  static std::vector&lt;std::string&gt; GetVec1() {     std::vector&lt;std::string&gt; o(100000, "abcd");     bool tr = true;     if (tr)         return std::move(o);     return std::move(std::vector&lt;std::string&gt;(100000, "abcd")); }  static std::vector&lt;std::string&gt; GetVec2() {     std::vector&lt;std::string&gt; o(100000, "abcd");     bool tr = true;     if (tr)         return o;     return std::vector&lt;std::string&gt;(100000, "abcd"); }  int main() {     uint64_t timer;     std::vector&lt;std::string&gt; vec;      timer = GetTimeMs64();     for (int i = 0; i &lt; 1000; ++i)         vec = GetVec1();     std::cout &lt;&lt; GetTimeMs64() - timer &lt;&lt; " timer 1(std::move)" &lt;&lt; std::endl;     timer = GetTimeMs64();     for (int i = 0; i &lt; 1000; ++i)         vec = GetVec2();     std::cout &lt;&lt; GetTimeMs64() - timer &lt;&lt; " timer 2(no move)" &lt;&lt; std::endl;     std::cin.get();     return 0; } </code></pre>  <p>I got the following results:</p>  <p><strong>Release (x86) /O2. <code>tr = true</code></strong></p>  <blockquote>   <p>4376 timer 1(std::move)</p>      <p>4191 timer 2(no move)</p> </blockquote>  <p><strong>Release (x86) /O2. <code>tr = false</code></strong></p>  <blockquote>   <p>7311 timer 1(std::move)</p>      <p>7301 timer 2(no move)</p> </blockquote>  <p>The results between the 2 timers are really close and don't really differ that much. I already assumed this is because of <strong>Return value optimization (RVO)</strong> which means that my returns by value are already moved by the compiler without me knowing, right?</p>  <p>So then I ran new tests without any optimizations to make sure I was right. The results:</p>  <p><strong>Release (x86) /Od. <code>tr = true</code></strong></p>  <blockquote>   <p>40860 timer 1(std::move)</p>      <p>40863 timer 2(no move)</p> </blockquote>  <p><strong>Release (x86) /Od. <code>tr = false</code></strong></p>  <blockquote>   <p>83567 timer 1(std::move)</p>      <p>82075 timer 2(no move)</p> </blockquote>  <p>Now even though the difference between /O2 and /Od is really significant, the difference between no move or <code>std::move</code> (and even between <code>tr</code> being <code>true</code> or <code>false</code>) is minimal.</p>  <p>Does this mean that even though optimizations are disabled, the compiler is allowed to apply <code>RVO</code> or is <code>std::move</code> not as fast as I thought I'd be?</p>