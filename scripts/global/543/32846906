<p>When I compile my code for my STM32F429 CPU everything works fine when I use the <code>-O0</code> flag but as soon as I use a higher optimization <code>(-O1, -O2, and -O3)</code> the code breaks.<br> I'm using the CMSIS+HAL libraries from ST and some basic code.  </p>  <p>The problem is that even though <code>*uart_irq</code> is defined as <code>volatile</code> the <code>if (uart_irq &amp;&amp; uart_irq-&gt;SOURCE == IRQ_SOURCE_UART)</code> in the main loop is <strong>never evaluated</strong>.<br> I have tried to define <code>uart_irq</code> as a <code>volatile void *</code> without success.<br> The only thing that work is if <code>uart_irq</code> is defined as a <code>volatile uint32_t</code> and the integer is cast to a <code>irq_instance</code> when used as the compiler wont remove that during optimization.  </p>  <p>I would be happy if anybody would shed some light on the problem.  </p>  <ul> <li>Is this supposed to be the standard behavior?</li> <li>Is this a known bug in the compiler?</li> </ul>  <p>main.h</p>  <pre><code>#define API_COMMAND_SIZE 6 typedef struct irq_instance_s {     uint8_t SOURCE;     uint8_t TYPE;        uint8_t *CONTEXT;       uint8_t SIZE;  } irq_instance; extern volatile irq_instance *uart_irq; </code></pre>  <p>main.c<br> The <code>receive</code> pointer is freed inside <code>hande_command</code></p>  <pre><code>#include "main.h volatile irq_instance *uart_irq = 0;  int main(void) {     uint8_t *receive  = 0;     &lt;Initialize stuff&gt;      /* Initialize first UART recieve */     receive = malloc(API_COMMAND_SIZE);     while (HAL_UART_Receive_IT(&amp;huart1, receive, API_COMMAND_SIZE) == HAL_BUSY);     /* Program Main loop */     while(1) {         if (uart_irq &amp;&amp; uart_irq-&gt;SOURCE == IRQ_SOURCE_UART) { /* &lt;---- Problem is here */             handle_interrupt(uart_irq);             free((void *)uart_irq);             uart_irq = 0;         }      } } </code></pre>  <p>stm32f4xx_it.c<br> The <code>HAL_UART_RxCpltCallback</code> are called after each successful UART receive. </p>  <pre><code>#include "main.h"  void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) {     uint8_t *receive  = 0;     uart_irq          = calloc(1, sizeof(irq_instance));     uart_irq-&gt;SOURCE  = IRQ_SOURCE_UART;     uart_irq-&gt;CONTEXT = huart-&gt;pRxBuffPtr - huart-&gt;RxXferSize;     uart_irq-&gt;SIZE    = huart-&gt;RxXferSize;     uart_irq-&gt;TYPE    = IRQ_TYPE_COMMAND;      receive = malloc(API_COMMAND_SIZE);     while (HAL_UART_Receive_IT(&amp;huart1, receive, API_COMMAND_SIZE) == HAL_BUSY); } </code></pre>