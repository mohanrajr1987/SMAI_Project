<p>This is the code which I'm using at present. How do I optimise it and make it faster? Maximum length of the string is 1000. This code works but takes too much time. How do I optimise this to finish the operations faster?</p>  <pre><code>#include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #define MAX_CHAR 256  struct SuffixTreeNode  {     struct SuffixTreeNode *children[MAX_CHAR];     struct SuffixTreeNode *suffixLink;     int start;     int *end;     int suffixIndex; };  typedef struct SuffixTreeNode Node;  char text[100]; //Input string Node *root = NULL; //Pointer to root node  Node *lastNewNode = NULL; Node *activeNode = NULL;  int activeEdge = -1; int activeLength = 0;  int remainingSuffixCount = 0; int leafEnd = -1; int *rootEnd = NULL; int *splitEnd = NULL; int size = -1; //Length of input string  Node *newNode(int start, int *end) {     Node *node =(Node*) malloc(sizeof(Node));     int i;     for (i = 0; i &lt; MAX_CHAR; i++)         node-&gt;children[i] = NULL;     node-&gt;suffixLink = root;     node-&gt;start = start;     node-&gt;end = end;     node-&gt;suffixIndex = -1;     return node; }  int edgeLength(Node *n) {     if(n == root)         return 0;     return *(n-&gt;end) - (n-&gt;start) + 1; }  int walkDown(Node *currNode) {     if (activeLength &gt;= edgeLength(currNode))     {         activeEdge += edgeLength(currNode);         activeLength -= edgeLength(currNode);         activeNode = currNode;         return 1;     }     return 0; }  void extendSuffixTree(int pos) {     leafEnd = pos;     remainingSuffixCount++;     lastNewNode = NULL;     while(remainingSuffixCount &gt; 0) {          if (activeLength == 0)             activeEdge = pos;           if (activeNode-&gt;children[text[activeEdge]] == NULL)         {             activeNode-&gt;children[text[activeEdge]] =                 newNode(pos, &amp;leafEnd);             if (lastNewNode != NULL)             {                 lastNewNode-&gt;suffixLink = activeNode;                 lastNewNode = NULL;             }         }         else         {             Node *next = activeNode-&gt;children[text[activeEdge]];             if (walkDown(next))//Do walkdown             {                 //Start from next node (the new activeNode)                 continue;             }             if (text[next-&gt;start + activeLength] == text[pos])             {                 if(lastNewNode != NULL &amp;&amp; activeNode != root)                 {                     lastNewNode-&gt;suffixLink = activeNode;                     lastNewNode = NULL;                 }                 activeLength++;                 break;             }              splitEnd = (int*) malloc(sizeof(int));             *splitEnd = next-&gt;start + activeLength - 1;             Node *split = newNode(next-&gt;start, splitEnd);             activeNode-&gt;children[text[activeEdge]] = split;             split-&gt;children[text[pos]] = newNode(pos, &amp;leafEnd);             next-&gt;start += activeLength;             split-&gt;children[text[next-&gt;start]] = next;             if (lastNewNode != NULL)             {                 lastNewNode-&gt;suffixLink = split;             }             lastNewNode = split;         }         remainingSuffixCount--;         if (activeNode == root &amp;&amp; activeLength &gt; 0)          {             activeLength--;             activeEdge = pos - remainingSuffixCount + 1;         }         else if (activeNode != root)          {             activeNode = activeNode-&gt;suffixLink;         }     } }  void print(int i, int j) {     int k;     for (k=i; k&lt;=j; k++)         printf("%c", text[k]); }  void setSuffixIndexByDFS(Node *n, int labelHeight) {     if (n == NULL) return;      if (n-&gt;start != -1) //A non-root node     {     }     int leaf = 1;     int i;     for (i = 0; i &lt; MAX_CHAR; i++)     {         if (n-&gt;children[i] != NULL)         {             leaf = 0;             setSuffixIndexByDFS(n-&gt;children[i], labelHeight +                     edgeLength(n-&gt;children[i]));         }     }     if (leaf == 1)     {         n-&gt;suffixIndex = size - labelHeight;     } }  void freeSuffixTreeByPostOrder(Node *n) {     if (n == NULL)         return;     int i;     for (i = 0; i &lt; MAX_CHAR; i++)     {         if (n-&gt;children[i] != NULL)         {             freeSuffixTreeByPostOrder(n-&gt;children[i]);         }     }     if (n-&gt;suffixIndex == -1)         free(n-&gt;end);     free(n); }  void buildSuffixTree() {     size = strlen(text);     int i;     rootEnd = (int*) malloc(sizeof(int));     *rootEnd = - 1;     root = newNode(-1, rootEnd);      activeNode = root; //First activeNode will be root     for (i=0; i&lt;size; i++)         extendSuffixTree(i);     int labelHeight = 0;     setSuffixIndexByDFS(root, labelHeight); }  void doTraversal(Node *n, int labelHeight, int* maxHeight,         int* substringStartIndex) {     if(n == NULL)     {         return;     }     int i=0;     if(n-&gt;suffixIndex == -1) //If it is internal node     {         for (i = 0; i &lt; MAX_CHAR; i++)         {             if(n-&gt;children[i] != NULL)             {                 doTraversal(n-&gt;children[i], labelHeight +                         edgeLength(n-&gt;children[i]), maxHeight,                         substringStartIndex);             }         }     }     else if(n-&gt;suffixIndex &gt; -1 &amp;&amp;             (*maxHeight &lt; labelHeight - edgeLength(n)))     {         *maxHeight = labelHeight - edgeLength(n);         *substringStartIndex = n-&gt;suffixIndex;     } }  void getLongestRepeatedSubstring() {     char a[1000];     int b = 0;     int maxHeight = 0;     int substringStartIndex = 0;     doTraversal(root, 0, &amp;maxHeight, &amp;substringStartIndex);     int k;     for (k=0; k&lt;maxHeight; k++)     {         b++;     }     printf("%d", b);     if(k == 0);     printf("\n"); }  int main() {     int t;     scanf("%d", &amp;t);     while(t--)     {            char* a[100];         scanf("%s", a);         strcat(a,"$");         strcpy(text, a);         buildSuffixTree();         getLongestRepeatedSubstring();         freeSuffixTreeByPostOrder(root);     }     return 0; } </code></pre>