<p>I have a UICollectionView which displays a horizontal list of data items:</p>  <p><a href="http://i.stack.imgur.com/0mSVn.png" rel="nofollow"><img src="http://i.stack.imgur.com/0mSVn.png" alt="Initial"></a></p>  <p>Once I use my app one of these list items changes its contents (the label is offscreen and changes from “Local” to “London”), causing the width of its cell to change as I call <code>reloadData</code> on the collection view.</p>  <p>But then, for some reason, the first cell moves:</p>  <p><a href="http://i.stack.imgur.com/tMifl.png" rel="nofollow"><img src="http://i.stack.imgur.com/tMifl.png" alt="enter image description here"></a></p>  <p>Everything else is in the position I’d expect.</p>  <p>I’ve implemented <code>collectionView:layout:insetForSectionAtIndex:</code> so the first and last items are aligned to the centre when scrolled to the beginning or end of the collection view.</p>  <pre><code>func collectionView(collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, insetForSectionAtIndex section: Int) -&gt; UIEdgeInsets {     let owner = UIView()      //  Get first cell size      let firstCell = NSBundle.mainBundle().loadNibNamed("CategoryCollectionViewCell", owner: owner, options: nil).first as! CategoryCollectionViewCell      let firstCategory = categoryForIndexPath(NSIndexPath(forItem: 0, inSection: section))     let firstTitle = titleForCategory(firstCategory)      firstCell.textLabel.text = firstTitle     firstCell.layoutIfNeeded()      let firstCellWidth = firstCell.contentView.systemLayoutSizeFittingSize(UILayoutFittingCompressedSize).width      //  Get last cell size      let lastCell = NSBundle.mainBundle().loadNibNamed("CategoryCollectionViewCell", owner: owner, options: nil).first as! CategoryCollectionViewCell      let lastCategory = categoryForIndexPath(NSIndexPath(forItem: categoriesCollectionView.numberOfItemsInSection(section) - 1, inSection: section))     let lastTitle = titleForCategory(lastCategory)      lastCell.textLabel.text = lastTitle     lastCell.layoutIfNeeded()      let lastCellWidth = lastCell.contentView.systemLayoutSizeFittingSize(UILayoutFittingCompressedSize).width      //  Work out insets      let leftInset: CGFloat = fabs(categoriesCollectionView.bounds.width - firstCellWidth * CGFloat(categoriesCollectionView.numberOfItemsInSection(section))) * 0.5;     let rightInset: CGFloat = fabs(categoriesCollectionView.bounds.width - lastCellWidth * CGFloat(categoriesCollectionView.numberOfItemsInSection(section))) * 0.5;      return UIEdgeInsets(top: 0, left: leftInset - rightInset, bottom: 0, right: rightInset) } </code></pre>  <p>I’ve also implemented <code>collectionView:layout:sizeForItemAtIndexPath:</code> to size the cells appropriately:</p>  <pre><code>func collectionView(collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, sizeForItemAtIndexPath indexPath: NSIndexPath) -&gt; CGSize {     let owner = UIView()      //  Get first cell size      let cell = NSBundle.mainBundle().loadNibNamed("CategoryCollectionViewCell", owner: owner, options: nil).first as! CategoryCollectionViewCell      let category = categoryForIndexPath(indexPath)     let title = titleForCategory(category)      cell.textLabel.text = title     cell.layoutIfNeeded()      return cell.contentView.systemLayoutSizeFittingSize(UILayoutFittingCompressedSize) } </code></pre>  <p>I’ve tried calling <code>invalidateLayout</code> on the collection view’s layout too, but no luck.</p>