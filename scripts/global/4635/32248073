<p>I have a view as below:</p>  <pre><code>CREATE VIEW V1  AS    SELECT         T1.Col1, F1.Col1, T1.Col2, T2.Col2...     FROM         T1     INNER JOIN         T2 ON T1.Col2 = T2.Col1     CROSS APPLY         UDF(T1.Col1, T2.Col2) F1 </code></pre>  <p>The inner join returns million records. Here, in this case, I know the exact value of <code>T1.Col1</code> which will be passed from the application. </p>  <p>Is there a way to rewrite the above view so that the cross apply can be applied to only the filtered records (based on <code>T1.Col1</code> value) instead of processing all records and then filter later? Current view doesn't return any value even after 20 minutes, whereas when I pass the values directly to the UDF, it returns the output in less than a second.</p>  <p><strong>Updated:</strong> Below is the structure of the UDF and I have update the question based on the comments below:</p>  <p><code>CREATE FUNCTION [dbo].[UDF](@Col1 INT, @Col2 INT)<br> RETURNS @TBL TABLE(Col1 int, Col2 int, Col3 VARCHAR(10), Col4 int) AS DECLARE CURSOR1 CURSOR FOR<br> SELECT DISTINCT Col1 FROM TBL1 WHERE Col2 = @Col1 AND Col3 = @Col2<br> OPEN CURSOR1<br>    FETCH NEXT FROM CURSOR1 INTO @Col1<br>    WHILE (@@FETCH_STATUS = 0)<br>    BEGIN    DECLARE CURSOR2 CURSOR FOR...    INSERT INTO @TBLVAR     SELECT * FROM SRCTBL1 WHERE    CLOSE CURSOR2   DEALLOCATE CURSOR2   DECLARE CURSOR3 CURSOR FOR...    INSERT INTO @TBLVAR     SELECT * FROM SRCTBL2 WHERE    CLOSE CURSOR3   DEALLOCATE CURSOR3   DECLARE CURSOR4 CURSOR FOR...    INSERT INTO @TBLVAR    SELECT * FROM SRCTBL3 WHERE    CLOSE CURSOR4   DEALLOCATE CURSOR4 CLOSE CURSOR1 DEALLOCATE CURSOR2    SELECT Col1, Col2, Col3, Col4</code></p>