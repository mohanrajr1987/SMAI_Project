<p>I'm using <a href="http://bunkat.github.io/later/" rel="nofollow">later.js</a> to put together a system that triggers an external tone generator multiple times a day. Everything is working perfectly, but I'd like to gather up all of the schedules the user has set and work out which one will run next.</p>  <p>As I parse each cron expression, I store the resulting 'schedule' that later.js returns in an associative array called "schedules", with the key being a short ID (e.g. "lunchtime", "dayend" etc.). Later has an <a href="http://bunkat.github.io/later/occurrences.html#instances" rel="nofollow">"instances" feature</a> which is described as so:</p>  <blockquote>   <p>Instances are individual dates that meet all of the constraints that are imposed by the schedule. Instances can be calculated both forwards and backwards, in any quantity</p> </blockquote>  <p>And the example it gives, shows this:</p>  <pre><code>later.schedule({schedules: [{m: [5]}]}).next(2); </code></pre>  <p>So I tried doing this:</p>  <pre><code>later.schedule(schedule).next(1) </code></pre>  <p>Where "schedule" is the array of schedules I've previously set up using the cron parser, but each time I <code>console.log</code> the next schedule(s), it just shows <code>0</code></p>  <p>So as a backup plan, I used <a href="http://momentjs.com" rel="nofollow">moment()</a> and <a href="https://github.com/harrisiirak/cron-parser" rel="nofollow">cron-parser</a> to loop through the cron expressions, convert them to a <code>moment()</code>, then using the <code>diff</code> feature, work out which job has a diff closest to 0 without going over.</p>  <p>Should later.js be able to do this? Or is there a smaller / faster / smarter way to do this?</p>