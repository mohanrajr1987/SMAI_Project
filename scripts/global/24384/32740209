<p>I'm attempting to refactor code that programmatically creates autolayout constraints on a UIScrollView that is a subview of a UITableViewCell's contentView but am getting some unusual effects.</p>  <p>Code snippet being replaced is:</p>  <pre><code>let scrollViewHorizontalConstraints = NSLayoutConstraint.constraintsWithVisualFormat("H:|[sv]|",options: [], metrics: nil, views: viewDictionary) viewConstraints.appendContentsOf(scrollViewHorizontalConstraints) /// scrollviewConstraints is an array! let scrollViewVerticalConstraints = NSLayoutConstraint.constraintsWithVisualFormat("V:|[sv]|", options: [], metrics: nil, views: viewDictionary) </code></pre>  <p>I should be able to replace this with the new iOS9 UILayoutAnchor API as follows:</p>  <pre><code>scrollView.leftAnchor.constraintEqualToAnchor(contentView.leftAnchor).active = true scrollView.rightAnchor.constraintEqualToAnchor(contentView.rightAnchor).active = true scrollView.topAnchor.constraintEqualToAnchor(contentView.topAnchor).active = true scrollView.bottomAnchor.constraintEqualToAnchor(contentView.bottomAnchor).active = true </code></pre>  <p>However, this code fails (no errors). Constraints are not built correctly - the resulting scrollView matches the height of the superview but not the width despite the fact that it has a subview constrained to the width of the UITableViewCell contentView. The original version works without errors.</p>  <p>Building the same structure inside a standard UIView using the new notation works so I'm suspicious of a bug but any suggestions would be gratefully received.</p>