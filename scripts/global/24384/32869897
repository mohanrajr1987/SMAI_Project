<p>I've implemented a UIScrollView within a UITableViewCell that enables the user to scroll left and right to reveal buttons in the same fashion as the iOS Mail app. The original implementation that set frames and positions explicitly worked well but I've refactored the code to use autolayout throughout. Animation to hide/reveal the 'container' for the buttons on the left (accessory buttons) works well but the animation that brings the scrollview to rest when the right container (edit buttons) slows just before reaching the desired offset before jerking into its final position.</p>  <p>All calculations use the same math just transformed (e.g. + rather than - value, > rather than &lt; in tests) depending on the side the container is located and the values displayed by logging are correct. I can't see any obvious code errors and there are no constraints for the cells set up in IB. Is this a bug or is there something obvious I've missed through staring at the code for the last hour?</p>  <pre><code>class SwipeyTableViewCell: UITableViewCell {      // MARK: Constants     private let thresholdVelocity = CGFloat(0.6)     private let maxClosureDuration = CGFloat(40)      // MARK: Properties     private var buttonContainers = [ButtonContainerType: ButtonContainer]()     private var leftContainerWidth: CGFloat {         return buttonContainers[.Accessory]?.containerWidthWhenOpen ?? CGFloat(0)     }     private var rightContainerWidth: CGFloat {         return buttonContainers[.Edit]?.containerWidthWhenOpen ?? CGFloat(0)     }     private var buttonContainerRightAnchor = NSLayoutConstraint()     private var isOpen = false      // MARK: Subviews     private let scrollView = UIScrollView()       // MARK: Lifecycle methods     override func awakeFromNib() {         super.awakeFromNib()         // Initialization code         scrollView.delegate = self         scrollView.showsHorizontalScrollIndicator = false         scrollView.showsVerticalScrollIndicator = false         contentView.addSubview(scrollView)         scrollView.translatesAutoresizingMaskIntoConstraints = false         scrollView.topAnchor.constraintEqualToAnchor(contentView.topAnchor).active = true         scrollView.leftAnchor.constraintEqualToAnchor(contentView.leftAnchor).active = true         scrollView.rightAnchor.constraintEqualToAnchor(contentView.rightAnchor).active = true         scrollView.bottomAnchor.constraintEqualToAnchor(contentView.bottomAnchor).active = true          let scrollContentView = UIView()         scrollContentView.backgroundColor = UIColor.cyanColor()         scrollView.addSubview(scrollContentView)         scrollContentView.translatesAutoresizingMaskIntoConstraints = false         scrollContentView.topAnchor.constraintEqualToAnchor(scrollView.topAnchor).active = true         scrollContentView.leftAnchor.constraintEqualToAnchor(scrollView.leftAnchor).active = true         scrollContentView.rightAnchor.constraintEqualToAnchor(scrollView.rightAnchor).active = true         scrollContentView.bottomAnchor.constraintEqualToAnchor(scrollView.bottomAnchor).active = true         scrollContentView.widthAnchor.constraintEqualToAnchor(contentView.widthAnchor, constant: 10).active = true         scrollContentView.heightAnchor.constraintEqualToAnchor(contentView.heightAnchor).active = true          buttonContainers[.Accessory] = ButtonContainer(type: .Accessory, scrollContentView: scrollContentView)         buttonContainers[.Edit] = ButtonContainer(type: .Edit, scrollContentView: scrollContentView)         for bc in buttonContainers.values {             scrollContentView.addSubview(bc)             bc.widthAnchor.constraintEqualToAnchor(contentView.widthAnchor).active = true             bc.heightAnchor.constraintEqualToAnchor(scrollContentView.heightAnchor).active = true             bc.topAnchor.constraintEqualToAnchor(scrollContentView.topAnchor).active = true             bc.containerToContentConstraint.active = true         }          scrollView.contentInset = UIEdgeInsetsMake(0, leftContainerWidth, 0, rightContainerWidth)     }       func closeContainer() {         scrollView.contentOffset.x = CGFloat(0)     }  }   extension SwipeyTableViewCell: UIScrollViewDelegate {      func scrollViewWillEndDragging(scrollView: UIScrollView, withVelocity velocity: CGPoint,         targetContentOffset: UnsafeMutablePointer&lt;CGPoint&gt;) {             let xOffset: CGFloat = scrollView.contentOffset.x             isOpen = false             for bc in buttonContainers.values {                 if bc.isContainerOpen(xOffset, thresholdVelocity: thresholdVelocity, velocity: velocity) {                     targetContentOffset.memory.x = bc.offsetRequiredToOpenContainer()                     NSLog("Target offset \(targetContentOffset.memory.x)")                     isOpen = true                     break /// only one container can be open at a time so cn exit here                 }             }             if !isOpen {                 NSLog("Closing container")                 targetContentOffset.memory.x = CGFloat(0)                 let ms: CGFloat = xOffset / velocity.x  /// if the scroll isn't on a fast path to zero, animate it closed                 if (velocity.x == 0 || ms &lt; 0 || ms &gt; maxClosureDuration) {                     NSLog("Animating closed")                     dispatch_async(dispatch_get_main_queue()) {                         scrollView.setContentOffset(CGPointZero, animated: true)                     }                 }             }     }  /** Defines the position of the container view for buttons assosicated with a SwipeyTableViewCell  - Edit:      Identifier for a UIView that acts as a container for buttons to the right of the cell - Accessory: Identifier for a UIView that acts as a container for buttons to the left of the vell */ enum ButtonContainerType {     case Edit, Accessory }  extension ButtonContainerType {     func getConstraints(scrollContentView: UIView, buttonContainer: UIView) -&gt; NSLayoutConstraint {         switch self {         case Edit:             return buttonContainer.leftAnchor.constraintEqualToAnchor(scrollContentView.rightAnchor)         case Accessory:             return buttonContainer.rightAnchor.constraintGreaterThanOrEqualToAnchor(scrollContentView.leftAnchor)         }     }       func containerOpenedTest() -&gt; ((scrollViewOffset: CGFloat, containerFullyOpenWidth: CGFloat, thresholdVelocity: CGFloat, velocity: CGPoint) -&gt; Bool) {         switch self {         case Edit:             return {(scrollViewOffset: CGFloat, containerFullyOpenWidth: CGFloat, thresholdVelocity: CGFloat, velocity: CGPoint) -&gt; Bool in                 (scrollViewOffset &gt; containerFullyOpenWidth || (scrollViewOffset &gt; 0 &amp;&amp; velocity.x &gt; thresholdVelocity))             }         case Accessory:             return {(scrollViewOffset: CGFloat, containerFullyOpenWidth: CGFloat, thresholdVelocity: CGFloat, velocity: CGPoint) -&gt; Bool in                 (scrollViewOffset &lt; -containerFullyOpenWidth || (scrollViewOffset &lt; 0 &amp;&amp; velocity.x &lt; -thresholdVelocity))             }         }     }       func transformOffsetForContainerSide(containerWidthWhenOpen: CGFloat) -&gt; CGFloat {         switch self {         case Edit:             return containerWidthWhenOpen         case Accessory:             return -containerWidthWhenOpen         }     } }   /// A UIView subclass that acts as a container for buttongs associated with a SwipeyTableCellView class ButtonContainer: UIView {      private let scrollContentView: UIView     private let type: ButtonContainerType      private let maxNumberOfButtons = 3     let buttonWidth = CGFloat(65)     private var buttons = [UIButton]()     var containerWidthWhenOpen: CGFloat { //        return CGFloat(buttons.count) * buttonWidth         return buttonWidth // TODO: Multiple buttons not yet implements - this will cause a bug!!     }     var containerToContentConstraint: NSLayoutConstraint {         return type.getConstraints(scrollContentView, buttonContainer: self)     }     var offsetFromContainer = CGFloat(0) {         didSet {             let delta = abs(oldValue - offsetFromContainer)             containerToContentConstraint.constant = offsetFromContainer             if delta &gt; (containerWidthWhenOpen * 0.5) { /// this number is arbitary - can it be more formal?                 animateConstraintWithDuration(0.1, delay: 0, options: UIViewAnimationOptions.CurveEaseOut, completion: nil) /// ensure large changes are animated rather than snapped             }         }     }       // MARK: Initialisers      init(type: ButtonContainerType, scrollContentView: UIView) {         self.type = type         self.scrollContentView = scrollContentView         super.init(frame: CGRectZero)         backgroundColor = UIColor.blueColor()         translatesAutoresizingMaskIntoConstraints = false     }       required init?(coder aDecoder: NSCoder) {         fatalError("init(coder:) has not been implemented")     }       // MARK: Public methods      func isContainerOpen(scrollViewOffset: CGFloat, thresholdVelocity: CGFloat, velocity: CGPoint) -&gt; Bool {         let closure = type.containerOpenedTest()         return closure(scrollViewOffset: scrollViewOffset, containerFullyOpenWidth: containerWidthWhenOpen, thresholdVelocity: thresholdVelocity, velocity: velocity)     }       func offsetRequiredToOpenContainer() -&gt; CGFloat {         return type.transformOffsetForContainerSide(containerWidthWhenOpen)     } } </code></pre>