<p>I've registered a MySQL data source as follows:</p>  <pre><code>val driver = "com.mysql.jdbc.Driver" val url = "jdbc:mysql://address=(protocol=tcp)(host=myhost)(port=3306)(user=)(password=)/dbname"  val jdbcDF = sqlContext.load("jdbc", Map(   "url" -&gt; url,   "driver" -&gt; driver,   "dbtable" -&gt; "videos"))  jdbcDF.registerTempTable("videos") </code></pre>  <p>and then executed the following Spark SQL query:</p>  <pre><code>select    uploader, count(*) as items from    videos_table where    publisher_id = 154 group by    uploader order by    items desc </code></pre>  <p>This call actually executes the following query on the MySQL server:</p>  <pre><code>SELECT uploader,publisher_id FROM videos WHERE publisher_id = 154 </code></pre>  <p>and then loads the data to the Spark cluster and performs the group-by as a Spark operation. </p>  <p>This behavior is problematic due to the excess network traffic created by not performing the group-by on the MySQL server. Is there a way to force the DataFrame to run the literal query on the MySQL server?</p>