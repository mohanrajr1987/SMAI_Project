<p>I have the following use case for a music service app I am working on (back end cassandra).</p>  <p>My music datastore will have artist, genre, year,the song name, number of views, track length, byte encoded content. I want to be able to filter by artist; artist and genre; artist, genre and year. Also I want the song names to appear as descending sorted by number views.</p>  <p>I have the following table:</p>  <pre><code>MusicStore (   artist text,   genre text,     year text,   songName text,   views bigint   tracklenght bigint,   content text,    PRIMARY KEY ((artist), genre, year, views, songName))   WITH CLUSTERING ORDER BY (year DESC, views DESC, songName ASC); </code></pre>  <p>The immediate problem I am running into:</p>  <p>In my app where I allow search by artist and genre: </p>  <pre><code>select * from MusicStore  where artist='alizee' AND genre='pop' order by views </code></pre>  <p>This query does not work. It says "Orderby currently only supports the ordering of columns following their declared orders in primary key".</p>  <p>It seems orderby is only allowed on the first clustering key.Anything I am missing?</p>  <p>Denormalization is possible for couple use cases, but I will run into the same issue for my app to search artist by genre and year since Cassandra requires where clause keys to be present in primary key and in the same order as the query (genre, then year) and views column being the first clustering key is not possible.  Making views first clustering key would require everything else being partition key and therefore mandatory in the where clause.</p>  <p>Any suggestions on the datamodel? Is there anyway I can avoid this by using column family (with supercolumns) using thrift API? </p>