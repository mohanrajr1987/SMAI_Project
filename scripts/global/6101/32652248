<p>I have a very strange problem. Previously, for bigger projects we used EAR packaging (one EJB + JPA + JAX-WS project with one JSF + JAX-RS project).</p>  <p>No we have a smaller project, where we only needed some (5) services and no UI, so we decided to go with WAR packaging in one project (EJB + JPA + JAX-WS + JAX-RS).</p>  <pre><code>Maven dependencies: &lt;dependency&gt;             &lt;groupId&gt;javax&lt;/groupId&gt;             &lt;artifactId&gt;javaee-web-api&lt;/artifactId&gt;             &lt;version&gt;7.0&lt;/version&gt;         &lt;scope&gt;provided&lt;/scope&gt;     &lt;/dependency&gt;     &lt;dependency&gt;         &lt;groupId&gt;javax&lt;/groupId&gt;             &lt;artifactId&gt;javaee-api&lt;/artifactId&gt;         &lt;version&gt;7.0&lt;/version&gt;         &lt;scope&gt;provided&lt;/scope&gt;     &lt;/dependency&gt;     &lt;dependency&gt;         &lt;groupId&gt;junit&lt;/groupId&gt;         &lt;artifactId&gt;junit&lt;/artifactId&gt;         &lt;version&gt;4.12&lt;/version&gt;         &lt;scope&gt;test&lt;/scope&gt;     &lt;/dependency&gt;     &lt;dependency&gt;         &lt;groupId&gt;javax.ws.rs&lt;/groupId&gt;         &lt;artifactId&gt;javax.ws.rs-api&lt;/artifactId&gt;         &lt;version&gt;2.0.1&lt;/version&gt;         &lt;scope&gt;provided&lt;/scope&gt;     &lt;/dependency&gt;     &lt;dependency&gt;         &lt;groupId&gt;org.eclipse.persistence&lt;/groupId&gt;         &lt;artifactId&gt;org.eclipse.persistence.moxy&lt;/artifactId&gt;         &lt;version&gt;${moxy.version}&lt;/version&gt;     &lt;/dependency&gt;     &lt;dependency&gt;         &lt;groupId&gt;org.slf4j&lt;/groupId&gt;         &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;         &lt;version&gt;1.7.7&lt;/version&gt;         &lt;scope&gt;provided&lt;/scope&gt;     &lt;/dependency&gt;     &lt;dependency&gt;         &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;         &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;         &lt;version&gt;1.1.2&lt;/version&gt;         &lt;scope&gt;provided&lt;/scope&gt;     &lt;/dependency&gt;     &lt;dependency&gt;         &lt;groupId&gt;org.glassfish.jersey.core&lt;/groupId&gt;         &lt;artifactId&gt;jersey-client&lt;/artifactId&gt;         &lt;version&gt;${jersey.version}&lt;/version&gt;         &lt;scope&gt;test&lt;/scope&gt;     &lt;/dependency&gt;     &lt;dependency&gt;         &lt;groupId&gt;org.glassfish.jersey.core&lt;/groupId&gt;         &lt;artifactId&gt;jersey-common&lt;/artifactId&gt;         &lt;version&gt;${jersey.version}&lt;/version&gt;         &lt;scope&gt;test&lt;/scope&gt;     &lt;/dependency&gt;     &lt;dependency&gt;         &lt;groupId&gt;org.glassfish.jersey.media&lt;/groupId&gt;         &lt;artifactId&gt;jersey-media-json-jackson&lt;/artifactId&gt;         &lt;version&gt;${jersey.version}&lt;/version&gt;         &lt;scope&gt;test&lt;/scope&gt;     &lt;/dependency&gt;     &lt;dependency&gt;         &lt;groupId&gt;org.glassfish.jersey.media&lt;/groupId&gt;         &lt;artifactId&gt;jersey-media-moxy&lt;/artifactId&gt;         &lt;version&gt;${jersey.version}&lt;/version&gt;     &lt;/dependency&gt;     &lt;dependency&gt;         &lt;groupId&gt;org.glassfish&lt;/groupId&gt;         &lt;artifactId&gt;jsonp-jaxrs&lt;/artifactId&gt;         &lt;version&gt;1.0&lt;/version&gt;     &lt;/dependency&gt; </code></pre>  <p>So, most of what we do is we create a simple interface:</p>  <pre><code>@WebService @SOAPBinding( style = Style.DOCUMENT ) public interface ILog extends Serializable{     @WebMethod public long createEventLog(EventLog log); } </code></pre>  <p>We put an EJB over it, for implementation:</p>  <pre><code>@Stateless @LocalBean @WebService (endpointInterface = "....interfaces.ILog") public class LogService implements ILog {     public long createEventLog(EventLog log) {         em.persist(log);         em.flush();          return log.getId();     } } </code></pre>  <p>Then we have a JAX-RS class over it, which calls the upper EJB method. </p>  <pre><code>@Path("/log")... </code></pre>  <p>First we create the EJB + WS combos, and create simple test client codes, to make sure they work:</p>  <pre><code>private URL url; private QName qname; private Service wsService; private ILog logService;   @Before public void init() throws MalformedURLException{      url = new URL("http://localhost:8080/LogServiceService/LogService?wsdl");     qname = new QName("http://.../","LogServiceService");     wsService = Service.create(url, qname);     logService = wsService.getPort(ILog.class); } </code></pre>  <p>Everything is rendered / generated for us by glassfish 4.1, so we don't create any more configuration class, or anything (the above code just works...). So this works at this step. After these, we introduced the JAX-RS services (with JSON formatting), that meant the REST services are working, but now I think the above API-s doesn't like each other very much, and now the JAX-WS code isn't working, and giving the following error for all the JAX-WS services:</p>  <pre><code>2015-09-18T14:15:36.712+0200|Severe: Cannot initialize endpoint  : error is : javax.xml.ws.WebServiceException: class ....interfaces.jaxws.CreateEventLog do not have a property of the name arg0 at com.sun.xml.ws.server.sei.EndpointArgumentsBuilder$DocLit.&lt;init&gt;(EndpointArgumentsBuilder.java:610) at com.sun.xml.ws.server.sei.TieHandler.createArgumentsBuilder(TieHandler.java:143) at com.sun.xml.ws.server.sei.TieHandler.&lt;init&gt;(TieHandler.java:115) at com.sun.xml.ws.db.DatabindingImpl.&lt;init&gt;(DatabindingImpl.java:116) at com.sun.xml.ws.db.DatabindingProviderImpl.create(DatabindingProviderImpl.java:74) at com.sun.xml.ws.db.DatabindingProviderImpl.create(DatabindingProviderImpl.java:58) at com.sun.xml.ws.db.DatabindingFactoryImpl.createRuntime(DatabindingFactoryImpl.java:120) at com.sun.xml.ws.server.EndpointFactory.createSEIModel(EndpointFactory.java:521) at com.sun.xml.ws.server.EndpointFactory.create(EndpointFactory.java:300) at com.sun.xml.ws.server.EndpointFactory.createEndpoint(EndpointFactory.java:164) at com.sun.xml.ws.api.server.WSEndpoint.create(WSEndpoint.java:577) at com.sun.xml.ws.api.server.WSEndpoint.create(WSEndpoint.java:560) at com.sun.xml.ws.api.server.WSEndpoint.create(WSEndpoint.java:639) at org.glassfish.webservices.EjbRuntimeEndpointInfo.prepareInvocation(EjbRuntimeEndpointInfo.java:275) at org.glassfish.webservices.EjbRuntimeEndpointInfo.initRuntimeInfo(EjbRuntimeEndpointInfo.java:352) at org.glassfish.webservices.WebServiceEjbEndpointRegistry.registerEndpoint(WebServiceEjbEndpointRegistry.java:127) at com.sun.ejb.containers.BaseContainer.initializeHome(BaseContainer.java:1247) at com.sun.ejb.containers.StatelessSessionContainer.initializeHome(StatelessSessionContainer.java:190) at com.sun.ejb.containers.StatelessContainerFactory.createContainer(StatelessContainerFactory.java:63) at org.glassfish.ejb.startup.EjbApplication.loadContainers(EjbApplication.java:221) at org.glassfish.ejb.startup.EjbDeployer.load(EjbDeployer.java:291) at org.glassfish.ejb.startup.EjbDeployer.load(EjbDeployer.java:99) at org.glassfish.internal.data.ModuleInfo.load(ModuleInfo.java:206) at org.glassfish.internal.data.ApplicationInfo.load(ApplicationInfo.java:313) at com.sun.enterprise.v3.server.ApplicationLifecycle.deploy(ApplicationLifecycle.java:496) at com.sun.enterprise.v3.server.ApplicationLoaderService.processApplication(ApplicationLoaderService.java:406) at com.sun.enterprise.v3.server.ApplicationLoaderService.postConstruct(ApplicationLoaderService.java:243) at org.jvnet.hk2.internal.ClazzCreator.postConstructMe(ClazzCreator.java:329) at org.jvnet.hk2.internal.ClazzCreator.create(ClazzCreator.java:377) at org.jvnet.hk2.internal.SystemDescriptor.create(SystemDescriptor.java:461) at org.glassfish.hk2.runlevel.internal.AsyncRunLevelContext.findOrCreate(AsyncRunLevelContext.java:227) at org.glassfish.hk2.runlevel.RunLevelContext.findOrCreate(RunLevelContext.java:84) at org.jvnet.hk2.internal.Utilities.createService(Utilities.java:2258) at org.jvnet.hk2.internal.ServiceHandleImpl.getService(ServiceHandleImpl.java:105) at org.jvnet.hk2.internal.ServiceHandleImpl.getService(ServiceHandleImpl.java:87) at org.glassfish.hk2.runlevel.internal.CurrentTaskFuture$QueueRunner.oneJob(CurrentTaskFuture.java:1162) at org.glassfish.hk2.runlevel.internal.CurrentTaskFuture$QueueRunner.run(CurrentTaskFuture.java:1147) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615) at java.lang.Thread.run(Thread.java:724) Caused by: javax.xml.bind.JAXBException: arg0 is not a valid property on class ....interfaces.jaxws.CreateEventLog at com.sun.xml.bind.v2.runtime.JAXBContextImpl.getElementPropertyAccessor(JAXBContextImpl.java:969) at com.sun.xml.ws.db.glassfish.JAXBRIContextWrapper.getElementPropertyAccessor(JAXBRIContextWrapper.java:120) at com.sun.xml.ws.server.sei.EndpointArgumentsBuilder$DocLit.&lt;init&gt;(EndpointArgumentsBuilder.java:598) ... 39 more </code></pre>  <p>Now I don't know what could I do to make the two types of Services work together (I wouldn't like to go back to EAR packaging with two projects, this service interface is way too small for that).</p>  <p>Can anyone help me?  Thank You!</p>