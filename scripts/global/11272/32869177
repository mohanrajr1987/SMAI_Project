<p>I created a simple app with Spring Boot and Spring security which contains : </p>  <ul> <li>A login form</li> <li>An "upload" form (with an associated Controller on backend's side)</li> </ul>  <p><strong>Problem</strong> : Spring security has built-in default CSRF protection. It works well with common REST calls but it prevents me from uploading a file : I get this error message : </p>  <blockquote>   <p>Invalid CSRF Token 'null' was found on the request parameter '_csrf' or header 'X-XSRF-TOKEN'.</p> </blockquote>  <p>If I deactivate CSRF protection, I can successfully upload the file.</p>  <p>I created a <a href="https://github.com/ArnaudDenoyelle/sscce-file-upload" rel="nofollow">SSCCE</a> to illustrate the problem. The steps to reproduce are : </p>  <ol> <li>Launch the application (Main class is <code>com.denodev.Application</code>)</li> <li>Connect to <code>localhost:8080</code></li> <li>Authenticate with those credentials :   <ul> <li>Login : <code>user</code></li> <li>Password : <code>password</code></li> </ul></li> <li>When redirected to the "upload" form, try to upload any file.</li> <li>In class <code>Application</code>, feel free to activate/deactivate CSRF protection, restart the app and retry.</li> </ol>  <p>The relevant part of the code is : </p>  <pre><code>@RestController @SpringBootApplication public class Application {    public static void main(String[] args) {     SpringApplication.run(Application.class);   }    @RequestMapping(value = "/upload-file", method = RequestMethod.POST)   @ResponseBody   public String uploadFile(@RequestParam("file") MultipartFile file) {     return "Successfully received file "+file.getOriginalFilename();   }    @Configuration   @Order(SecurityProperties.ACCESS_OVERRIDE_ORDER)   protected static class SecurityConfiguration extends WebSecurityConfigurerAdapter {      @Override     public void configure(HttpSecurity http) throws Exception {       http           .authorizeRequests()           .antMatchers("/", "/**/*.html", "login").permitAll()           .anyRequest().authenticated()           .and()             .formLogin()             .successHandler(successHandler())             .failureHandler(failureHandler())           .and()             .exceptionHandling()             .accessDeniedHandler(accessDeniedHandler())             .authenticationEntryPoint(authenticationEntryPoint())           .and()            //1 : Uncomment to activate csrf protection           .csrf()           .csrfTokenRepository(csrfTokenRepository())           .and()           .addFilterAfter(csrfHeaderFilter(), CsrfFilter.class)            //2 : Uncomment to disable csrf protection           //.csrf().disable()       ;     }      /**      * Return HTTP 200 on authentication success instead of redirecting to a page.      */     private AuthenticationSuccessHandler successHandler() {       return new AuthenticationSuccessHandler() {         @Override         public void onAuthenticationSuccess(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Authentication authentication) throws IOException, ServletException {           httpServletResponse.setStatus(HttpServletResponse.SC_OK);         }       };     }      /**      * Return HTTP 401 on authentication failure instead of redirecting to a page.      */     private AuthenticationFailureHandler failureHandler() {       return new AuthenticationFailureHandler() {         @Override         public void onAuthenticationFailure(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AuthenticationException e) throws IOException, ServletException {           httpServletResponse.setStatus(HttpServletResponse.SC_UNAUTHORIZED);           httpServletResponse.getWriter().write(e.getMessage());         }       };     }      /**      * Return HTTP 403 on "access denied" instead of redirecting to a page.      */     private AccessDeniedHandler accessDeniedHandler() {       return new AccessDeniedHandler() {         @Override         public void handle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AccessDeniedException e) throws IOException, ServletException {           httpServletResponse.setStatus(HttpServletResponse.SC_FORBIDDEN);           httpServletResponse.getWriter().write(e.getMessage());         }       };     }      private AuthenticationEntryPoint authenticationEntryPoint() {       return new AuthenticationEntryPoint() {         @Override         public void commence(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AuthenticationException e) throws IOException, ServletException {           httpServletResponse.setStatus(HttpServletResponse.SC_UNAUTHORIZED);           httpServletResponse.getWriter().write(e.getMessage());         }       };     } </code></pre>  <p><strong>What I tried :</strong> </p>  <p>The <a href="http://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#csrf-multipart" rel="nofollow">Spring security's documentation</a> about Multipart advices to place <code>MultipartFilter</code> before Spring security. It explains well how to do it with a plain old webapp by editing the <code>web.xml</code> file. This is not applicable to Spring Boot and I cannot figure what is the equivalent syntax.</p>  <p>I tried to expose the <code>MultipartFilter</code> with annotations <code>@Bean</code> and <code>Order</code> with several options but I still struggle with it.</p>  <p>Any ideas?</p>