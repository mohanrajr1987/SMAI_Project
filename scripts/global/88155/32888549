<p>I have an angular directive called "show-errors" that I use for form validation.  This will apply the "has-error" css class to the containing div when validation fails.  This works great in most cases, such as when a user leaves the input box (blur) or when the user clicks the continue button (this is a multi-step form).  I trigger validation for all form elements on continue by broadcasting a 'show-errors-check-validity' message.</p>  <pre><code>$rootScope.$broadcast('show-errors-check-validity'); </code></pre>  <p>Here is the directive:</p>  <pre><code>angular     .module('eStoreApp')     .directive('showErrors', showErrors);  function showErrors($log, $rootScope, $timeout) {     return {         restrict: 'A',         require: '^form',         link: function(scope, el, attrs, formCtrl) {             var domElement = el[0].querySelector("[name]");             var angularElement = angular.element(domElement);             var textBoxName = angularElement.attr('name');             var d = new Date();             var time = d.getHours() + ":" + d.getMinutes() + ":" + d.getSeconds();              angularElement.bind('blur', function () {                 $log.debug(time + ': BLUR: Input validation: ' + textBoxName + '.  Valid = ' + !formCtrl[textBoxName].$invalid);                 el.toggleClass('has-error', formCtrl[textBoxName].$invalid);             });              scope.$on('show-errors-check-validity', function() {                 $log.debug(time + ': SHOW-ERRORS: Input validation: ' + textBoxName + '.  Valid = ' + !formCtrl[textBoxName].$invalid);                 el.toggleClass('has-error', formCtrl[textBoxName].$invalid);             });         }     }; } </code></pre>  <p>Here is how it is used in HTML:</p>  <pre><code>&lt;div class="form-group row" show-errors&gt;     &lt;label class="col-sm-2 control-label"&gt;Zip Code&lt;/label&gt;     &lt;div class="col-sm-10"&gt;         &lt;input type="text" name="zip" class="form-control" required ng-model="vm.checkoutData.data.shipping.zip"&gt;         &lt;p class="help-block" ng-if="shippingInformationForm.zip.$error.required"&gt;Zip Code is required.&lt;/p&gt;      &lt;/div&gt; &lt;/div&gt; </code></pre>  <p>This all works fantastic until I try to trigger validation with a promise return, specifically $modal.open().  The user can open a modal that allows them to select a previously saved address which is populated on the form.  When they do this, I want validation to trigger.  Again I'm using the 'show-errors-check-validity' message.  This hits the function in the directive, but the angularjs form $error values have not yet updated.  If I call $rootScope.$digest() I get an error that a digest is in progress.  How would I cause the directive to fire AFTER the angularjs $scope.shippingAddressForm.zip.$invalid has been updated?</p>  <p>The selectAddress() function below is in the controller of the section that contains the shippingAddressForm and all the form elements with the 'show-errors' directive.</p>  <pre><code>function selectAddress() {     var modalInstance = $modal.open({         templateUrl: 'Scripts/Checkout/AddressSelector/addressSelector.html',         controller: 'addressSelectorController',         controllerAs: 'vm',         size: 'sm',         resolve: {             addresses: function() {                 return shippingAddressService.getAll();             }         }     });      modalInstance.result.then(function (selectedAddress) {         vm.checkoutData.data.shipping = selectedAddress;         if (selectedAddress.id) {            $scope.$emit('show-errors-check-validity');         }     }, function() {         $log.info('Modal dismissed.');     }); } </code></pre>