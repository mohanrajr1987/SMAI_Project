<p>I have a commonly reused set of form inputs that are reused throughout my application, so I am trying to encapsulate them in a custom directive. I want to set an <code>ngModel</code> on my directive and have that split up to be editable in several different inputs (some of them are directives themselves) within the main directive.</p>  <p>At the same time, I need the form validation results to be passed up the chain to a parent form so that I can display appropriate messages and styles.</p>  <p><strong>What is the simplest and most idiomatic way to implement this?</strong></p>  <p>These (simplified) templates should give you an example of what I'm going for...</p>  <h2>OuterTemplate.html</h2>  <pre><code>&lt;form name="outerForm"&gt;   &lt;my-directive     ng-model="ctrl.myComplexModel"     name="myDirectiveInstance"     custom-required="ctrl.EnableValidateOne"     toggle-another-validation="ctrl.EnableValidateTwo"&gt;   &lt;/my-directive&gt;   &lt;div ng-messages="outerForm.myDirectiveInstance.$error"&gt;     &lt;ng-message when="customRequired"&gt;This is required.&lt;/ng-message&gt;     &lt;ng-message when="anotherValidation"&gt;This is required.&lt;/ng-message&gt;     &lt;ng-message when="innerValidationOne"&gt;Something wrong with field 1.&lt;/ng-message&gt;     &lt;ng-message when="innerValidationTwo"&gt;Something wrong with field 2.&lt;/ng-message&gt;     &lt;ng-message when="innerValidationThree"&gt;Something wrong with field 3.&lt;/ng-message&gt;     &lt;!-- etc... --&gt;   &lt;/div&gt; &lt;/form&gt; </code></pre>  <h2>myDirectiveTemplate.html</h2>  <pre><code>&lt;div ng-form="myDirectiveForm"&gt;   &lt;div ng-class="{'has-error': myDirectiveForm.fieldOne.$invalid}"&gt;     &lt;ui-select       ng-model="model.fieldOne"       name="fieldOne"       required&gt;     &lt;/ui-select&gt;   &lt;/div&gt;   &lt;div ng-class="{'has-error': myDirectiveForm.fieldTwo.$invalid}"&gt;     &lt;input       type="number"       ng-model="model.fieldTwo"       name="fieldTwo"       ng-pattern="directiveCtrl.someRegEx"       ng-required="directiveCtrl.fieldTwoIsRequired"&gt;   &lt;/div&gt;   &lt;!-- etc... --&gt; &lt;/div&gt; </code></pre>  <p>At the moment, both <code>myDirectiveForm</code> and <code>myDirectiveInstance</code> are publishing themselves as properties of the <code>outerForm</code> <code>FormController</code>. I hoping to make this directive a black box, so the fact that <code>myDirectiveForm</code> is attaching directly to <code>outerForm</code> bothers me and seems to indicate that I'm doing something wrong.</p>  <p>Here's what my directive definition looks like right now.</p>  <h2>myDirective.js</h2>  <pre><code>app.directive('myDirective', function() {   return {     restrict: 'E',     template: 'myDirectiveTemplate.html',     controller: 'MyDirectiveCtrl',     scope: {       model: '=ngModel',       customRequired: '=?',       toggleAnotherValidation: '=?'     },     require: 'ngModel',     link: function(scope, iElem, iAttrs, ngModelController) {        // Black-box the internal validators        // Custom validator to avoid conflicts with ngRequired       ngModelController.$validators.customRequired = function(modelValue, viewValue) {         if(!scope.customRequired)           return true;          // On first digest the field isn't registered on the form controller yet         if(angular.isUndefined(scope.myDirectiveForm.fieldOne))           return true;          return !scope.myDirectiveForm.fieldOne.$error.required;       };        ngModelController.$validators.anotherValidation = function(modelValue, viewValue) {         if(!scope.anotherValidation)           return true;          return scope.passesBusinessRule();       };        ngModelController.$validators.innerValidationOne = function(modelValue, viewValue) {         if(!scope.anotherValidation)           return true;          if(angular.isUndefined(scope.myDirectiveForm.fieldTwo))           return true;          return !scope.myDirectiveForm.fieldTwo.$error.pattern;       };        /* etc... */        // Deep-watching model so that validations will trigger on updates of properties       scope.$watch('model', function() {         ngModelController.$validate();       }, true);     }   }; }); </code></pre>