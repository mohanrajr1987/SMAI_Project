<p>I would like to implement a whitelist approach that will apply an <code>[Authorize(Roles = "Admin")]</code> attribute by default.  Then I would like to specify <code>[AllowAnonymous]</code> or <code>[AllowMember]</code> on whitelisted actions.</p>  <p>So I need to create an attribute similar to <code>AllowAnonymous</code>, but only giving access the "Member" role. (Like <code>AllowAnonymous</code>, it should override any <code>Authorize</code> attributes that may be in effect on controllers as global filters.) </p>  <p>I initially tried to inherit from <code>AllowAnonymousAttribute</code>, but I find it is sealed.  I've googled "Inherit allowanonymous" but the answers find me out of my depth.</p>  <p><em>Am I wise in my approach, and how can I create an attribute such as that?</em></p>  <hr>  <p><strong>Update</strong></p>  <p>Following NightOwl888's advice and some code from <a href="http://stackoverflow.com/questions/13595723/allowanonymous-not-working-with-custom-authorizationattribute">this page</a>, I have: </p>  <ol> <li><p>Created two <code>Attributes</code>, one to allow members, the other the public</p></li> <li><p>Inherited the AuthorizeAttribute to create a new one that I will apply as a global filter</p></li> <li><p>Inserted a couple of methods into the AuthorizeCore() method that check for the attributes and return true</p></li> </ol>  <p>I hope I'm not doing anything daft in the code below... I'd appreciate a heads up (or down) if it looks ok (or not). </p>  <p>Thanks.</p>  <hr>  <pre><code>namespace FP.Codebase.Attributes {     public class AllowPublicAccessAttribute : Attribute     {}        public class AllowMemberAccessAttribute : Attribute     {}        public class MyAuthorizeAttribute : AuthorizeAttribute     {         public override void OnAuthorization(AuthorizationContext filterContext)         {             filterContext.HttpContext.Items["ActionDescriptor"] = filterContext.ActionDescriptor;             base.OnAuthorization(filterContext);         }            private bool IsAllowPublicAccessAttributeAppliedToAction(ActionDescriptor actionDescriptor)         {             return (actionDescriptor.IsDefined(typeof(AllowPublicAccessAttribute), inherit: true)                 || actionDescriptor.ControllerDescriptor.IsDefined(typeof(AllowPublicAccessAttribute), inherit: true));         }            private bool IsAllowMemberAccessAttributeAppliedToAction(ActionDescriptor actionDescriptor)         {             return (actionDescriptor.IsDefined(typeof(AllowMemberAccessAttribute), inherit: true)                 || actionDescriptor.ControllerDescriptor.IsDefined(typeof(AllowMemberAccessAttribute), inherit: true));         }            protected override bool AuthorizeCore(HttpContextBase httpContext)         {             var actionDescriptor = httpContext.Items["ActionDescriptor"] as ActionDescriptor;             if (httpContext == null)             {                 throw new ArgumentNullException("httpContext");             }              IPrincipal user = httpContext.User;              if (IsAllowPublicAccessAttributeAppliedToAction(actionDescriptor))             {                 return true;             }             if (IsAllowMemberAccessAttributeAppliedToAction(actionDescriptor) &amp;&amp; user.IsInRole("Member"))             {                 return true;             }              if (!user.Identity.IsAuthenticated)             {                 return false;             }              var _usersSplit = SplitString(Users);             var _rolesSplit = SplitString(Roles);              if (_usersSplit.Length &gt; 0 &amp;&amp; !_usersSplit.Contains(user.Identity.Name, StringComparer.OrdinalIgnoreCase))             {                 return false;             }              if (_rolesSplit.Length &gt; 0 &amp;&amp; !_rolesSplit.Any(user.IsInRole))             {                 return false;             }              return true;         }            // copied from https://github.com/ASP-NET-MVC/aspnetwebstack/blob/master/src/System.Web.Mvc/AuthorizeAttribute.cs         internal static string[] SplitString(string original)         {             if (String.IsNullOrEmpty(original))             {                 return new string[0];             }              var split = from piece in original.Split(',')                         let trimmed = piece.Trim()                         where !String.IsNullOrEmpty(trimmed)                         select trimmed;             return split.ToArray();         }     } } </code></pre>