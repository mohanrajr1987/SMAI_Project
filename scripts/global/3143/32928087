<p>Coming from a Java background, I understand that this does not compile.</p>    <pre><code>public static class SuperClass {} public static class SubClass extends SuperClass {}  public static &lt;T, U extends T&gt; U returnSub(T sup, U sub) {     return sub; }  public static void main(String[] args) {     SuperClass parent = new SuperClass();     SubClass child = new SubClass();      returnSub(parent, child);     returnSub(child, parent); // Java doesn't like that } </code></pre>  <p>The last line produces a compiler error (EDIT : at least on jdk1.6.0_65) it does :</p>  <blockquote>   <p>Bound mismatch: The generic method returnSub(T, U) of type Test is not applicable for the arguments (Test.SubClass, Test.SuperClass). The inferred type Test.SuperClass is not a valid substitute for the bounded parameter </p> </blockquote>  <p>So, I got surprised, that this seems to work in Scala. I wrote the sample code below (which as far as I can tell, expresses the same "logic") :</p>  <pre><code>class SuperClass class SubClass extends SuperClass  def returnSub[Type, SubType &lt;: Type](supArg: Type, subArg: SubType): SubType = {   subArg }  override def main(args: Array[String]): Unit = {   val parent = new SuperClass()   val child = new SubClass()    val iAmOkWithThat: SubClass = returnSub(parent, child)   val iDontGetThat: SuperClass = returnSub(child, parent) } </code></pre>  <p>I <em>guess</em> the Scala compiler is smart enough to say "OK, <code>child</code> is an instance of <code>SubClass</code>, but I can't invoke <code>returnSub</code> if I say that, so let me try if I consider <code>child</code> as a <code>SuperClass</code> instance, and, well, it works, so let's do that".</p>  <p>Is that what's going on (and if so, can you point to a language specification about that) ? Or maybe my Scala "conversion" is not equivalent to my Java code ?</p>  <p>Thanks!</p>