<p>I am trying to keep in memory a set of data structures identified by the following schema. I have a crude solution, but I'm looking for some better ideas. Performance and reliability is critical important, memory not so much (within reason), since the tables are fairly small (maximum a couple of hundred entries, more likely a few dozens).  I would rather not use an in-memory DB for such a small data set, I think. </p>  <p><a href="http://i.stack.imgur.com/ADJQl.png" rel="nofollow"><img src="http://i.stack.imgur.com/ADJQl.png" alt="enter image description here"></a></p>  <p>What I'm trying to accomplish is the ability to quickly query All B entries based on A.Name, all A entries based on B.Name, or all A entries based on T.Tag (I don't really need all B entries based on T.Tag currently, but could be useful in the future)</p>  <p>Currently I use three tables with duplicate data, and with the synchronization issues that that brings, and when I have a new piece of data, I store it three different ways. I am sure there has to be a better way.</p>  <pre><code>// all A entries matching a tag val Tag2A= new MutableHashMap[String, MutableSet[String]]() with MutableMultiMap[String, String]   // all B entries matching a tag val Tag2B = new MutableHashMap[String, MutableSet[List[Int]]]() with MutableMultiMap[String, List[Int]]  // all Tags matching a A entry val A2Tag = new MutableHashMap[String, MutableSet[String]]() with MutableMultiMap[String, String] </code></pre>  <p>Could someone recommend a more elegant solution?</p>  <p>EDIT: (clarification) My MutableMultiMap and MutableSet are just mutable.MultiMap and mutable.Set aliased at import time.</p>  <p>EDIT2: the tables need to be modifiable (add/remove).</p>