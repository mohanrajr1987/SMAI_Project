<p>I like implicit definitions. They make the code look nice, they make the user feel  some features are naturally available on a class when it's just an implicit definition. Yet, I was thinking about JS prototypes, where you can basically define a method on a class you did not write. But if in the next version this class defines a method with the same signature and makes assumptions on its behaviour, you're screwed.</p>  <p>Scala's implicits enable to do almost the same thing with one major difference : the implicit definitions are scoped, therefore there is no risk for the author of a class to have code injected by an implicit definition in someone else's code. But what about the user's code ? Is it protected from a change in the class he's adding implicits to ?</p>  <p>Let's consider this code :</p>  <pre><code>class HeyMan {     def hello = println("Hello") }  object Main extends App {     val heyMan = new HeyMan      implicit class ImplicitHeyMan(heyMan: HeyMan) {         def hello = println("What's up ?")     }     heyMan.hello // prints Hello } </code></pre>  <p>Pretty bad, isn't it ? To me, the correct behaviour should be that the implicit definition always shades the real definition, so that the user code is protected from the apparition of new methods in the API he's calling into.</p>  <p>What do you think ? Is there a way to make it safe or should we stop using implicits this way ?</p>