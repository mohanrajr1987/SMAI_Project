<p>According to ScalaTest documentation <a href="http://www.scalatest.org/user_guide/using_junit_runner" rel="nofollow">it's possible to use JUnitRunner</a> to run tests. My assumption was, if it runs with JUnitRunner, its callback methods (i.e. methods marked with <code>@Before</code> or <code>@After</code> annotation should work as well. But apparently my assumption was wrong. I've created simple example to demonstrate it:</p>  <pre><code>import org.junit.Before import org.junit.runner.RunWith import org.scalatest.{FunSuite, _} import org.scalatest.junit.JUnitRunner  @RunWith(classOf[JUnitRunner]) class Test extends FunSuite {    @Before   def before() = {     println("before test")   }    test("nothing") {     println("test is started")   } } </code></pre>  <p>If you run this example, you'll see <code>test is started</code> line, but not <code>before test</code>.</p>  <p>I'm aware of ScalaTest lifecycle callbacks, but the thing is I need to make JUnit callbacks work somehow. I want to write a test for Play 2.4 application and the thing it's <code>play.test.WithBrowser</code> class relies on JUnit callbacks. I  found this workaround for the issue:</p>  <pre><code> var testBrowser : TestBrowser = _   before {    new WithBrowser {      override def createBrowser(): Unit = {        super.createBrowser()        testBrowser = browser      }  }.createBrowser() </code></pre>  <p>}</p>  <p>but I believe it's quite ugly and I suspect that there is a better way.  </p>  <p>So, my question is if it's possible to make these JUnit lifecycle callbacks work with ScalaTest? And if it is possible, how to do that? </p>