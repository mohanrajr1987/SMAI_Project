<p>According to following results, generating uniform random integers between two numbers using <code>%</code> operation is almost 3 times faster than using <code>std::uniform_int_distribution</code>: Is there any good reason to use <code>std::uniform_int_distribution</code>?</p>  <p>Code:</p>  <pre><code>#include &lt;iostream&gt; #include &lt;functional&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; #include &lt;random&gt;  #include &lt;cstdio&gt; #include &lt;cstdlib&gt;  using namespace std;  #define N 100000000  int main() {  clock_t tic,toc;  for(int trials=0; trials&lt;3; trials++) {     cout&lt;&lt;"trial: "&lt;&lt;trials&lt;&lt;endl;      // uniform_int_distribution     {         int res = 0;         mt19937 gen(1);         uniform_int_distribution&lt;int&gt; dist(0,999);          tic = clock();         for(int i=0; i&lt;N; i++)         {             int r = dist(gen);             res += r;             res %= 1000;         }         toc = clock();         cout &lt;&lt; "uniform_int_distribution: "&lt;&lt;(float)(toc-tic)/CLOCKS_PER_SEC &lt;&lt; endl;         cout&lt;&lt;res&lt;&lt;" "&lt;&lt;endl;      }      // simple modulus operation     {         int res = 0;         mt19937 gen(1);          tic = clock();         for(int i=0; i&lt;N; i++)         {             int r = gen()%1000;             res += r;             res %= 1000;         }         toc = clock();         cout &lt;&lt; "simple modulus operation: "&lt;&lt;(float)(toc-tic)/CLOCKS_PER_SEC &lt;&lt; endl;         cout&lt;&lt;res&lt;&lt;" "&lt;&lt;endl;      }      cout&lt;&lt;endl; }  } </code></pre>  <p>Output:</p>  <pre><code>trial: 0 uniform_int_distribution: 2.90289 538  simple modulus operation: 1.0232 575   trial: 1 uniform_int_distribution: 2.86416 538  simple modulus operation: 1.01866 575   trial: 2 uniform_int_distribution: 2.94309 538  simple modulus operation: 1.01809 575  </code></pre>