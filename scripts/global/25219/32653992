<p>I have created a <code>UITextField</code> which contains <code>UIPickerView</code> and  <code>UIToolbar</code> to have a nice selection wheel with a "Save" and a "Cancel" button. pickerTextField is defined at the top of my class:</p>  <pre><code>let pickerTextField = UITextField() </code></pre>  <p>The rest is called when a user taps on a <code>SKSpriteNode</code> so I'm tracking the touch by overwriting the <code>touchesBegan</code> function</p>  <pre><code>    override func touchesBegan(touches: Set&lt;NSObject&gt;, withEvent event: UIEvent?) {     if let touch = touches.first as? UITouch {         var touchLocation = touch.locationInNode(self)         let touchedNode = self.nodeAtPoint(touchLocation)         if let name = touchedNode.name         {             if name == "overlay_player"             {                 pickerTextField.frame = CGRectMake(0, 0, view!.bounds.width, view!.bounds.height*0.5)                  let playerCountryPicker = UIPickerView()                 playerCountryPicker.delegate = self                 playerCountryPicker.dataSource = self                 playerCountryPicker.layer.borderColor = UIColor.blackColor().CGColor                 playerCountryPicker.layer.borderWidth = 1                 playerCountryPicker.backgroundColor = UIColor.whiteColor()                 playerCountryPicker.showsSelectionIndicator = true                  var toolBar = UIToolbar()                 toolBar.barStyle = UIBarStyle.Default                 toolBar.translucent = true                 toolBar.tintColor = UIColor(red: 76/255, green: 217/255, blue: 100/255, alpha: 1)                 toolBar.sizeToFit()                  var doneButton = UIBarButtonItem(title: "Done", style: UIBarButtonItemStyle.Plain, target: self, action: "savePickerPlayer:")                 var spaceButton = UIBarButtonItem(barButtonSystemItem: UIBarButtonSystemItem.FlexibleSpace, target: nil, action: nil)                 var cancelButton = UIBarButtonItem(title: "Cancel", style: UIBarButtonItemStyle.Plain, target: self, action: "cancelPickerPlayer:")                 toolBar.setItems([cancelButton, spaceButton, doneButton], animated: false)                 toolBar.userInteractionEnabled = true                  pickerTextField.inputView = playerCountryPicker                 pickerTextField.inputAccessoryView = toolBar                  self.view?.addSubview(pickerTextField)              }         }     }  } </code></pre>  <p>My issue is: When tapping on the <code>SKSpriteNode</code> the code is executed but the text field won't show. But if I tap on any other object (e.g. a second <code>SKSpriteNode</code>) the text field shows up, but without executing the code once more. </p>  <p>From my perspective it seems the view just isn't updated but trying it with</p>  <pre><code>self.view?.setNeedsDisplay() self.view?.setNeedsLayout() self.view?.reloadInputViews() </code></pre>  <p>has no effect whatsoever. I assume I'm missing a simple point here but I'm struggling to find it. Any ideas?</p>  <p>/Edit: Found a work-around I can propose to persons with the same problem (not a solution thought): Replace the <code>UITextField</code> with an <code>UILabel</code>. You need to set <code>yourLabel.userInteractionEnabled = true</code> and instead using <code>UITextField.inputView</code> and <code>UITextField.inputAccessoryView</code> you'll just add the <code>UIToolbar</code> and the <code>UIPickerView</code> as subviews.</p>  <p>You'll have to handle the animations yourself but a simple </p>  <pre><code>class func animateWithDuration(_ duration: NSTimeInterval,                     animations animations: () -&gt; Void) </code></pre>  <p>should do the trick. General question why two actions are needed to show the <code>UITextField</code> is still open.</p>