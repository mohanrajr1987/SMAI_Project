<p>I'm writing a simple class, <code>BooleanChar</code>, to wrap a boolean in a <code>Char</code> for Oracle (because <a href="http://stackoverflow.com/questions/13491508/bool-support-oracle-sql">Oracle is stupid or, TL;DR Oracle SQL does not support booleans</a>).</p>  <p>So, I have model classes (that will use the <code>BooleanChar</code>). I also have projection classes, or objects that map to REST, etc., that will use <code>Boolean</code>.</p>  <p>Example (contrived and simple but to the point):</p>  <pre><code>val first: String = "Fred" val last: String = "Flintstone" val active: BooleanChar = BooleanChar(true)  val m = UserModel(first, last, active) ... // stuff happens and now I want to project it over REST val u = User(m.first, m.last, m.active) </code></pre>  <p>Now, the trick is, I'd like the mapping of <code>m.active</code> (either a <code>BooleanChar</code> on the model, or a <code>Boolean</code> on the projection) to be totally transparent. Hence if these two classes were interchangeable, the above works very nicely, even if:</p>  <pre><code>case class User(first: String, last: String, active: Boolean) </code></pre>  <p>But this all hinges on a magical mapping between the two types of objects, such that <code>a: BooleanChar = b: Boolean</code> in some way. Otherwise, I have to do this all over the place, and it's ugly:</p>  <pre><code>val u = User(first, last, active.map(_.state)) // BooleanChar has a `Boolean` `state` </code></pre>