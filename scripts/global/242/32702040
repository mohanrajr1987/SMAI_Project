<p>I have a bunch of simple classes that are referenced from various other classes. For example,</p>  <pre><code>class Version {     // PK is Major, Minor, Build, Revision     int Major { get; set; }     int Minor { get; set; }     int Build { get; set; }     int Revision { get; set; } }  class DraftArticle {     int Id { get; set; }     string Title { get; set; }     string Description { get; set; }     ICollection&lt;Version&gt; AffectedVersions { get; set; } }  class Article {     int Id { get; set; }     string Title { get; set; }     string Description { get; set; }     ICollection&lt;Version&gt; AffectedVersions { get; set; } }  class DbContext : System.Data.Entity.DbContext {     System.Data.Entity.DbSet&lt;DraftArticle&gt; DraftArticles { get; set; }     System.Data.Entity.DbSet&lt;Article&gt; Articles { get; set; } } </code></pre>  <p>When used as posted above, Entity Framework will create three tables -- [DraftArticles], [Articles], and [Versions] where the [Versions] table will have the following <strong>extra</strong> columns -- [Discriminator], [DraftArticle_Id],  and [Article_Id].</p>  <p>My goal is to separate the Version records for DraftArticles and Articles into separate tables.</p>  <p>I know this <strong>can</strong> be done using <code>inheritance</code> and/or <code>ComplexType</code> but I would like to avoid both of those as it necessitates the need for additional classes.</p>  <p>For example, the following additions and modifications work</p>  <pre><code>// additions class DraftArticleVersion : Version { }  class ArticleVersion : Version { }  // modifications class DraftArticle {     ...     ICollection&lt;DraftArticleVersion&gt; AffectedVersions { get; set; } }  class Article {     ...     ICollection&lt;ArticleVersion&gt; AffectedVersions { get; set; } }  class DbContext : System.Data.Entity.DbContext {     protected override void OnModelCreating(DbModelBuilder modelBuilder) {         modelBuilder.Entity&lt;DraftArticleVersion&gt;().Map(m =&gt; {             m.MapInheritedProperties();             m.ToTable("DraftArticleAffectedVersions");         });          modelBuilder.Entity&lt;DraftArticleVersion&gt;().Map(m =&gt; {             m.MapInheritedProperties();             m.ToTable("ArticleAffectedVersions");         });     }      ... } </code></pre>  <p>In addition, when using a framework like <code>AutoMapper</code> it requires additional (duplicated) mapping definitions.</p>  <p><strong><em>Ideally</em></strong>, what I would love to see is something along the lines of <code>ToTable()</code> being applied at the <strong>Property</strong> level <em>instead</em> of at the <strong>Class</strong> level. For example,</p>  <pre><code>class Version {     // PK is Major, Minor, Build, Revision     ... }  class DraftArticle {     ...     ICollection&lt;Version&gt; AffectedVersions { get; set; } }  class Article {     ...     ICollection&lt;Version&gt; AffectedVersions { get; set; } }  class DbContext : System.Data.Entity.DbContext {     protected override void OnModelCreating(DbModelBuilder modelBuilder) {         // somehow apply .ToTable("DraftArticleAffectedVersions") to DraftArticle.AffectedVersions          // somehow apply .ToTable("ArticleAffectedVersions") to Article.AffectedVersions     }      ... } </code></pre>  <p>Does anybody know if this can be done? Are you aware of any other methods to reusing classes <strong>without</strong> the need to created additional classes and/or mappings?</p>