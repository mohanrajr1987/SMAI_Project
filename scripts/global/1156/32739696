<p>I have a function which looks like this:</p>  <pre><code>void functionname(int a, char* c){ sprintf(c, " ... some text ..."); } </code></pre>  <p>The above statement uses a sprintf to write into the array of 'c'. </p>  <p>For my system i dont think i can use sprint since i am using a different (embedded) OS. </p>  <p>The print function i have uses something which looks like snprintf, and i wonder how i can make this function work with snprintf. </p>  <p>Do i use strlen(c)? what happens when c is empty?, do i use sizeof(c)? </p>  <pre><code>snprintf(c, sizeof(c), " ... text");  </code></pre>  <p>or</p>  <pre><code>snprintf(c, strlen(c), "... text");  </code></pre>  <p>the function calling 'functionname' has a an array which defines the length of c as c[64]. I am afraid calling sizeof(c) will result in the size of the pointer. Also afraid that strlen will cause to return 0 when the array does not contain a string.</p>  <p>So the question is how can i tell snprintf to reach this value of c[64].</p>  <p>How can i get the size of the array the pointer c is pointing towards, and put this answer in the snprintf function. If there is a way to go from sprintf() to snprintf() with the same variables one would provide to sprintf()? in the case that sprint() function targets a char pointer?</p>