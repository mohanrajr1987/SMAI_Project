<p>I currently followed a tutorial on <a href="http://fdietz.github.io/recipes-with-angular-js/common-user-interface-patterns/paginating-through-server-side-data.html" rel="nofollow">server sided pagination</a> and <a href="https://angular-ui.github.io/bootstrap/" rel="nofollow">asynchronous typeahead</a>.</p>  <p>The goal is for the table values to dynamically change/update to reflect the value the user is searching for in the typeahead textbox.</p>  <p>HTML:</p>  <pre><code>&lt;div class="container"&gt;     &lt;div&gt;         &lt;select ng-model="selectedItemvalue"&gt;             &lt;option ng-repeat="sel in selectables" ng-selected="selectedItemvalue == sel" value="{{sel}}"&gt;{{sel}}&lt;/option&gt;         &lt;/select&gt;         &lt;input type="text" ng-model="asyncSelected" placeholder="Edges loaded via $http"                typeahead="address.source +' to ' + address.destination for address in getClient($viewValue)" typeahead-loading="loadingLocations"                typeahead-no-results="noResults" typeahead-wait-ms="250" class="form-control"&gt;         &lt;i ng-show="loadingLocations" class="glyphicon glyphicon-refresh"&gt;&lt;/i&gt;         &lt;div ng-show="noResults"&gt;             &lt;i class="glyphicon glyphicon-remove"&gt;&lt;/i&gt; No Results Found         &lt;/div&gt;     &lt;/div&gt;     &lt;div ng-controller="EController"&gt;         &lt;table class="table table-striped"&gt;             &lt;thead&gt;             &lt;tr&gt;                 &lt;th&gt;Source&lt;/th&gt;                 &lt;th&gt;Destination&lt;/th&gt;                 &lt;th&gt;Status&lt;/th&gt;             &lt;/tr&gt;             &lt;/thead&gt;             &lt;tbody&gt;             &lt;tr ng-repeat="edge in pagedItems"&gt;                 &lt;td&gt;{{edge.source}}&lt;/td&gt;                 &lt;td&gt;{{edge.destination}}&lt;/td&gt;                 &lt;td&gt;{{edge.status}}&lt;/td&gt;             &lt;/tr&gt;             &lt;/tbody&gt;             &lt;tfoot&gt;             &lt;td colspan="3"&gt;                 &lt;div class="pagination"&gt;                     &lt;ul&gt;                         &lt;li ng-class="prevPageDisabled()"&gt;                             &lt;a href ng-click="prevPageFirst()"&gt;««&lt;/a&gt;                         &lt;/li&gt;                         &lt;li ng-class="prevPageDisabled()"&gt;                             &lt;a href ng-click="prevPage()"&gt;« Prev&lt;/a&gt;                         &lt;/li&gt;                         &lt;li ng-repeat="n in range()" ng-class="{active: n == currentPage}" ng-click="setPage(n)"&gt;                             &lt;a href ng-click="setPage(n)"&gt;{{n+1}}&lt;/a&gt;                         &lt;/li&gt;                         &lt;li ng-class="nextPageDisabled()"&gt;                             &lt;a href ng-click="nextPage()"&gt;Next »&lt;/a&gt;                         &lt;/li&gt;                         &lt;li ng-class="nextPageDisabled()"&gt;                             &lt;a href ng-click="nextPageFinal()"&gt;»»&lt;/a&gt;                         &lt;/li&gt;                     &lt;/ul&gt;                 &lt;/div&gt;             &lt;/td&gt;             &lt;/tfoot&gt;         &lt;/table&gt;     &lt;/div&gt;  &lt;/div&gt; </code></pre>  <p>Javascript File:</p>  <pre><code>// Note: you can't use jQuery.noConflict() because it causes problems with utilityBelt // As a result, no purely jquery functions can be used app.controller('EController', function ($scope, $http, $modal, $q, $log) {     $('#loadingModal').modal();     $scope.showHelp = false;      $scope.selectables = ["Any", "S", "D"];     $scope.selectedItemvalue = $scope.selectables[0];      $scope.getClient = function(val) {         return $http.get('/api/paginate/?type='+$scope.selectedItemvalue+'&amp;searchStr='+val+'&amp;offset='+(($scope.currentPage)*$scope.itemsPerPage)+'&amp;limit='+$scope.itemsPerPage)             .then(function(response){                 $scope.pagedItems = response.data.edges;                 $scope.total = response.data.total;                  return response.data.edges;         });     };      $scope.itemsPerPage = 15;     $scope.currentPage = 0;      $scope.range = function() {         var rangeSize = 7;         var ret = [];         var start;          if($scope.currentPage &gt; 0){             start = $scope.currentPage - 1;         }else {             start = $scope.currentPage;         }         if ( start &gt; $scope.pageCount()-rangeSize ) {             start = $scope.pageCount()-rangeSize;         }          for (var i=start; i&lt;start+rangeSize; i++) {             ret.push(i);         }         return ret;     };      $scope.prevPageFirst = function() {         $scope.currentPage = 0;     };      $scope.prevPage = function() {         if ($scope.currentPage &gt; 0) {             $scope.currentPage--;         }     };      $scope.prevPageDisabled = function() {         return $scope.currentPage === 0 ? "disabled" : "";     };      $scope.nextPage = function() {         if ($scope.currentPage &lt; $scope.pageCount() - 1) {             $scope.currentPage++;         }     };      $scope.nextPageFinal = function() {         $scope.currentPage = $scope.pageCount();     };      $scope.nextPageDisabled = function() {         return $scope.currentPage === $scope.pageCount() - 1 ? "disabled" : "";     };      $scope.pageCount = function() {         return Math.ceil($scope.total/$scope.itemsPerPage);     };      $scope.setPage = function(n) {         if (n &gt; 0 &amp;&amp; n &lt; $scope.pageCount()) {             $scope.currentPage = n;         }     };      $scope.getIt = function(offset, iLimit) {         var deferred = $q.defer();         $http.get('/api/paginate/?offset='+offset+'&amp;limit='+iLimit)             .success(function(data, status, headers, config) {                 return deferred.resolve(data);             }).error(function(data, status, headers, config) {                 return deferred.resolve([]);             });         return deferred.promise;     };      $scope.$watch("currentPage", function(newValue, oldValue) {         var o = ($scope.currentPage)*$scope.itemsPerPage;         var l = $scope.itemsPerPage;          var getPromise = $scope.getIt(o, l);         getPromise.then(function(data) {             $scope.pagedItems = data.edges;             $scope.total = data.total;         });     }); }); </code></pre>  <p>In <code>$scope.getClient</code> I tried updating the <code>$scope.pagedItems</code> and <code>$scope.total</code> value thinking it was binded to the grid and would update it, but it didn't work.</p>  <p>If needed, here's how the JSON looks.</p>  <pre><code>{    "edges":[       {          "source":"testSource",          "destination":"testDest",          "status":"Active",          "lastModifier":"George"       },       {          "source":"testSource",          "destination":"testDest2",          "status":"Active",          "lastModifier":"George"       }    ],    "total":5 } </code></pre>  <p>Would using a watch function to the data help refresh the grid?</p>