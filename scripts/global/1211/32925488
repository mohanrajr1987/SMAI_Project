<p>Trying to use both AspectJ and <code>@Configurable</code> with a Spring application.</p>  <ul> <li>If I load AspectJ with a <code>@Component</code> annotation on a class, the AspectJ wrapper works but the class cannot be instantiated at runtime and have dependencies injected with the <code>@Autowired</code> annotation. I would like to use the <code>new</code> keyword.</li> <li>If I load a <code>@Configurable</code> class without the AspectJ bean, all dependencies are injected correctly on <code>new</code> but none of the methods are proxied.</li> </ul>  <p><strong>How can I do both?</strong></p>  <p>Here's my code. Configuration:</p>  <pre><code>@Configuration @ComponentScan(basePackages="com.example") @EnableSpringConfigured @EnableAspectJAutoProxy @EnableLoadTimeWeaving public class TestCoreConfig {      @Bean     public SecurityAspect generateSecurityAspect(){         return new SecurityAspect();     }       @Bean     public SampleSecuredClass createSampleClass(){         return new SampleSecuredClass();     } } </code></pre>  <p>Aspect:</p>  <pre><code>@Aspect public class SecurityAspect {      @Pointcut("execution(public * *(..))")     public void publicMethod() {}       @Around("publicMethod()")     public boolean test (ProceedingJoinPoint joinPoint) throws Throwable {         System.out.println("Here!");         joinPoint.proceed();         return true;         }  } </code></pre>  <p>SampleClass:</p>  <pre><code>//@Configurable @Component public class SampleSecuredClass {      @Autowired     public SecurityService securityService;      public boolean hasSecurityService(){         return securityService != null;     }      public boolean returnFalse(){         return false;     } } </code></pre>  <p>And the unit test:</p>  <pre><code>@ContextConfiguration(classes={TestCoreConfig.class}) @RunWith(SpringJUnit4ClassRunner.class) public class SecurityAspectComponentTest {      @Autowired     private SampleSecuredClass sampleSecuredClass;      @Test     public void testSecurityRoles(){         //SampleSecuredClass sampleSecuredClass = new SampleSecuredClass();          assertTrue("We need to ensure the the @Configurable annotation injected the services correctly", sampleSecuredClass.hasSecurityService());          assertTrue("We need to ensure the the method has been overwritten", sampleSecuredClass.returnFalse());     }  } </code></pre>  <ul> <li>If I get rid of the beans in the <code>TestCoreConfig</code> and create an instance of <code>SampleSecuredClass</code> in the test with <code>new</code>, and change its annotation to <code>@Configurable</code> then the service is injected, but the aspect is not applied.</li> <li>If I run as is here (by injecting the <code>SampleSecuredClass</code> as a bean), then the aspect works and the service is injected, but then all objects have to be created on framework start. I would like to use the <code>@Configurable</code> annotation.</li> <li>If I use both the <code>@Configurable</code> annotation and the Aspect together then I get a <code>illegal type in constant pool</code> error and the context does not start.</li> </ul>  <hr>  <p>Other pieces of information.</p>  <ul> <li><p>I have tried a few different java agents--both spring instrumentation and aspectjwrapper. no change.</p></li> <li><p>If I include an aop.xml file, then the aspect works but not the @Configurable.</p></li> </ul>