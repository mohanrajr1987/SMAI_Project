<p>In C# 5, the closure semantics of the <code>foreach</code> statement (when the iteration variable is "captured" or "closed over" by anonymous functions) was <a href="http://stackoverflow.com/questions/8898925/"><strong>famously changed</strong> (link to thread on that topic)</a>.</p>  <p><strong>Question:</strong> Was it the intention to change this for arrays of pointer types also?</p>  <p>The reason why I ask is that the "expansion" of a <code>foreach</code> statement has to be rewritten, for technical reasons (we cannot use the <code>Current</code> property of the <code>System.Collections.IEnumerator</code> since this property has declared type <code>object</code> which is incompatible with a pointer type) as compared to <code>foreach</code> over other collections. The relevant section in the C# Language Specification, <em>"Pointer arrays"</em>, in <strong>version 5.0</strong>, says that:</p>  <pre><code>foreach (V v in x) EMBEDDED-STATEMENT </code></pre>  <p>is expanded to:</p>  <pre><code>{   T[,,…,] a = x;   V v;   for (int i0 = a.GetLowerBound(0); i0 &lt;= a.GetUpperBound(0); i0++)   for (int i1 = a.GetLowerBound(1); i1 &lt;= a.GetUpperBound(1); i1++)   …   for (int in = a.GetLowerBound(N); iN &lt;= a.GetUpperBound(n); iN++) {     v = (V)a.GetValue(i0,i1,…,iN);     EMBEDDED-STATEMENT   } } </code></pre>  <p>We note that the declaration <code>V v;</code> is outside all the <code>for</code> loops. So it would appear that the closure semantics are still the "old" C# 4 flavor, "loop variable is reused, loop variable is "outer" with respect to the loop".</p>  <p>To make it clear what I am talking about, consider this complete C# 5 program:</p>  <pre><code>using System; using System.Collections.Generic;  static class Program {   unsafe static void Main()   {     char* zeroCharPointer = null;     char*[] arrayOfPointers =       { zeroCharPointer, zeroCharPointer + 1, zeroCharPointer + 2, zeroCharPointer + 100, };      var list = new List&lt;Action&gt;();      // foreach through pointer array, capture each foreach variable 'pointer' in a lambda     foreach (var pointer in arrayOfPointers)       list.Add(() =&gt; Console.WriteLine("Pointer address is {0:X2}.", (long)pointer));      Console.WriteLine("List complete");     // invoke those delegates     foreach (var act in list)       act();   }    // Possible output:   //   // List complete   // Pointer address is 00.   // Pointer address is 02.   // Pointer address is 04.   // Pointer address is C8.   //   // Or:   //   // List complete   // Pointer address is C8.   // Pointer address is C8.   // Pointer address is C8.   // Pointer address is C8. } </code></pre>  <p>So what is the correct output of the above program?</p>