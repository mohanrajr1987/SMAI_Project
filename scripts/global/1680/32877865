<p><strong>TLDR;</strong></p>  <p>Non-trivial memory leak, can be seen easily in Resharper. See minimal example below.</p>  <hr>  <p>I'm seeing a memory leak in the following program but failing to see why. </p>  <p>The program sends pings to a number of hosts asynchronously and determines if at least one is ok. To do that, a method (<code>SendPing()</code>) that runs these async operations is repeatedly called which runs them in a background thread (it doesn't have to, but in the actual application <code>SendPing()</code> will be called by the main UI thread which shouldn't be blocked). </p>  <p>The task seems pretty trivial but I think the leak occurs due to the way I create lambdas inside the <code>SendPing()</code> method. The program can be changed to not use lambdas but I'm more interested in understanding what causes the leak here.</p>  <pre><code>public class Program {      static string[] hosts = { "www.google.com", "www.facebook.com" };      static void SendPing()     {         int numSucceeded = 0;         ManualResetEvent alldone = new ManualResetEvent(false);          ManualResetEvent[] handles = new ManualResetEvent[hosts.Length];         for (int i = 0; i &lt; hosts.Length; i++)             handles[i] = new ManualResetEvent(false);          BackgroundWorker worker = new BackgroundWorker();         worker.DoWork += (sender, args) =&gt;         {             numSucceeded = 0;             Action&lt;int, bool&gt; onComplete = (hostIdx, succeeded) =&gt;             {                 if (succeeded) Interlocked.Increment(ref numSucceeded);                 handles[hostIdx].Set();             };              for (int i = 0; i &lt; hosts.Length; i++)                 SendPing(i, onComplete);              ManualResetEvent.WaitAll(handles);         };          worker.RunWorkerCompleted += (sender, args) =&gt;         {             Console.WriteLine("Succeeded " + numSucceeded);             BackgroundWorker bgw = sender as BackgroundWorker;             alldone.Set();         };          worker.RunWorkerAsync();         alldone.WaitOne();         worker.Dispose();     }      static void SendPing(int hostIdx, Action&lt;int, bool&gt; onComplete)     {         Ping pingSender = new Ping();         pingSender.PingCompleted += (sender, args) =&gt;         {             bool succeeded = args.Error == null &amp;&amp; !args.Cancelled &amp;&amp; args.Reply != null &amp;&amp; args.Reply.Status == IPStatus.Success;             onComplete(hostIdx, succeeded);             Ping p = sender as Ping;             p.Dispose();         };          string data = "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa";         byte[] buffer = Encoding.ASCII.GetBytes(data);         PingOptions options = new PingOptions(64, true);         pingSender.SendAsync(hosts[hostIdx], 2000, buffer, options, hostIdx);     }      private static void Main(string[] args)     {         for (int i = 0; i &lt; 1000; i++)         {             Console.WriteLine("Send ping " + i);             SendPing();         }     } } </code></pre>  <p>Resharper shows the leaks are due to uncollected closure objects (<code>c__DisplayClass...</code>). </p>  <p><a href="http://i.stack.imgur.com/HhBJt.png" rel="nofollow"><img src="http://i.stack.imgur.com/HhBJt.png" alt="enter image description here"></a> <a href="http://i.stack.imgur.com/ki1T5.png" rel="nofollow"><img src="http://i.stack.imgur.com/ki1T5.png" alt="enter image description here"></a></p>  <p>From what I understand, there shouldn't be a leak because there are no circular references (as far as I see) and therefore GC should take of the leaks. I also call <code>Dispose</code> to release the thread (bgw) + sockets (<code>Ping</code> object) promptly. (Even if I didn't GC will clean them up eventually, won't it?)</p>  <h2><strong>Suggested changes from comments</strong></h2>  <ul> <li>Remove event handles before Disposing</li> <li>Dispose <code>ManualResetEvent</code></li> </ul>  <p><strong>But the leak is still there!</strong></p>  <p>Changed program:</p>  <pre><code>public class Program {      static string[] hosts = { "www.google.com", "www.facebook.com" };      static void SendPing()     {         int numSucceeded = 0;         ManualResetEvent alldone = new ManualResetEvent(false);          BackgroundWorker worker = new BackgroundWorker();         DoWorkEventHandler doWork = (sender, args) =&gt;         {             ManualResetEvent[] handles = new ManualResetEvent[hosts.Length];             for (int i = 0; i &lt; hosts.Length; i++)                 handles[i] = new ManualResetEvent(false);              numSucceeded = 0;             Action&lt;int, bool&gt; onComplete = (hostIdx, succeeded) =&gt;             {                 if (succeeded) Interlocked.Increment(ref numSucceeded);                 handles[hostIdx].Set();             };              for (int i = 0; i &lt; hosts.Length; i++)                 SendPing(i, onComplete);              ManualResetEvent.WaitAll(handles);             foreach (var handle in handles)                 handle.Close();          };          RunWorkerCompletedEventHandler completed = (sender, args) =&gt;         {             Console.WriteLine("Succeeded " + numSucceeded);             BackgroundWorker bgw = sender as BackgroundWorker;             alldone.Set();         };          worker.DoWork += doWork;         worker.RunWorkerCompleted += completed;          worker.RunWorkerAsync();         alldone.WaitOne();         worker.DoWork -= doWork;         worker.RunWorkerCompleted -= completed;         worker.Dispose();     }      static void SendPing(int hostIdx, Action&lt;int, bool&gt; onComplete)     {         Ping pingSender = new Ping();         PingCompletedEventHandler completed = null;         completed = (sender, args) =&gt;         {             bool succeeded = args.Error == null &amp;&amp; !args.Cancelled &amp;&amp; args.Reply != null &amp;&amp; args.Reply.Status == IPStatus.Success;             onComplete(hostIdx, succeeded);             Ping p = sender as Ping;             p.PingCompleted -= completed;             p.Dispose();         };          pingSender.PingCompleted += completed;          string data = "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa";         byte[] buffer = Encoding.ASCII.GetBytes(data);         PingOptions options = new PingOptions(64, true);         pingSender.SendAsync(hosts[hostIdx], 2000, buffer, options, hostIdx);     }       private static void Main(string[] args)     {         for (int i = 0; i &lt; 1000; i++)         {             Console.WriteLine("Send ping " + i);             SendPing();         }     } } </code></pre>