<p>I have an abstract base POGO:</p>  <pre><code>abstract class AuthorizingResource {     void authorize(String credential) {         if(!credentialIsValid(credential)) {             throw new AuthorizationException(credential)         }     }      boolean credentialIsValid(String credential) {         // Do stuff to determine yea or nay     } } </code></pre>  <p>And many concrete subclasses like so:</p>  <pre><code>class FizzResource extends AuthorizingResource {     List&lt;Fizz&gt; getAllFizzes(String credential) {         authorize(credential)          List&lt;Fizz&gt; fizzes          // Do stuff          fizzes     }      Fizz getFizzById(String credential, Long id) {         authorize(credential)          Fizz fizz          // Do stuff          fizz     }      void considerTheLillies(Buzz buzz) {         // Do stuff     }      void upsertFizz(String credential, Fizz fizz) {         authorize(credential)          // Do stuff     } } </code></pre>  <p>As you can see there's several things going on:</p>  <ul> <li>Any <code>FizzResource</code> methods that I want authenticated/authorized, I need to manually call <code>authorize(...)</code> at the top of the method</li> <li>Some methods (<code>considerTheLillies</code>) do not need to be authed</li> </ul>  <p>I was wondering if I could mimic AOP by using a closure to call <code>authorize(...)</code> (so I don't have to keep adding it mindlessly) that can use some sort of pattern for selecting which methods to "wrap" inside the closure. In the particular case of the <code>FizzResource</code>, this would be any method that contains "<code>*Fizz*</code>" in it, but that pattern should be (ideally) any valid regex. <strong>The one thing that can't change is that any method that accepts <code>credential</code> arg cannot have its signature modified.</strong></p>  <p>So basically, something like Spring AOP or Google Guice's method interceptors, but using native Groovy closures.</p>  <p>Any ideas?</p>