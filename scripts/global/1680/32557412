<p>I want to debug a SSL problem in the Swift 2.0 Alamofire library. I'm using a custom Alamofire Manager with a custom ServerTrustPolicy set-up like this:</p>  <pre><code>static let manager: Manager = {     let serverTrustPolicies: [String: ServerTrustPolicy] = [         "localhost": .PinCertificates(             certificates: ServerTrustPolicy.certificatesInBundle(),             validateCertificateChain: false,             validateHost: false         ) //        "localhost": .DisableEvaluation     ]      let configuration = NSURLSessionConfiguration.defaultSessionConfiguration()     configuration.HTTPAdditionalHeaders = Alamofire.Manager.defaultHTTPHeaders     return Alamofire.Manager(configuration: configuration,     serverTrustPolicyManager: ServerTrustPolicyManager(policies: serverTrustPolicies)) }() </code></pre>  <p>I tried both, <code>.PinCertificates</code> and <code>.DisableEvaluation</code>. Both threw me the same error</p>  <pre><code>Error Domain=NSURLErrorDomain Code=-1200 "An SSL error has occurred and a secure connection to the server cannot be made." UserInfo={   NSURLErrorFailingURLPeerTrustErrorKey=&lt;SecTrustRef: 0x60c00004d980&gt;,   NSLocalizedRecoverySuggestion=Would you like to connect to the server anyway?,   _kCFStreamErrorDomainKey=3,    _kCFStreamErrorCodeKey=-9802,    NSErrorPeerCertificateChainKey=&lt;CFArray 0x6060001498a0 [0x10bb3c7b0]&gt;{     type = immutable, count = 1, values = (      0 : &lt;cert(0x61600006ed80) s: localhost i: localhost&gt;     )},     NSUnderlyingError=0x6040000ad750 {      Error Domain=kCFErrorDomainCFNetwork Code=-1200 "(null)"      UserInfo={        _kCFStreamPropertySSLClientCertificateState=0,         kCFStreamPropertySSLPeerTrust=&lt;SecTrustRef: 0x60c00004d980&gt;,        _kCFNetworkCFStreamSSLErrorOriginalValue=-9802,        _kCFStreamErrorDomainKey=3,        _kCFStreamErrorCodeKey=-9802,        kCFStreamPropertySSLPeerCertificates=&lt;CFArray 0x6060001498a0 [0x10bb3c7b0]&gt;{          type = immutable, count = 1, values = (            0 : &lt;cert(0x61600006ed80) s: localhost i: localhost&gt;          )}      }    },    NSLocalizedDescription=An SSL error has occurred and a secure connection to the server cannot be made.,    NSErrorFailingURLKey=https://localhost:3000/auth/requestToken?auth_appId=d018ccd505db2cb1d5aacabb03fc2f3a,    NSErrorFailingURLStringKey=https://localhost:3000/auth/requestToken?auth_appId=d018ccd505db2cb1d5aacabb03fc2f3a,    NSErrorClientCertificateStateKey=0 } </code></pre>  <p>I tried to do the request using curl which works just fine</p>  <pre><code>curl --cacert ./ca.pem https://localhost:3000 </code></pre>  <p>I narrowed it down to a single method from where a completionHandler is beeing called. Until the closure gets called everything is fine so I want to know what this completionHandler actually does.</p>  <pre><code>public func URLSession(     session: NSURLSession,     didReceiveChallenge challenge: NSURLAuthenticationChallenge,     completionHandler: ((NSURLSessionAuthChallengeDisposition, NSURLCredential?) -&gt; Void)) {     // some other stuff but     // everything fine so far      completionHandler(disposition, credential) } </code></pre>  <p>I think the <code>URLSession</code> method gets called from a dispatch queue or something like that.</p>  <p>So my question: How can I find the closure that is passed as the <code>completionHandler</code> argument to the <code>URLSession</code> method?</p>