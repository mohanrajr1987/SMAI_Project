<p>If, in a XAML file, I bind a Button to "Command" from the following class, then clicking the Button does not cause DoIt to be executed:</p>  <pre><code>class Thing() {   public Thing(Foo p1)   {     Command = new RelayCommand(() =&gt; DoIt(p1));   }    private DoIt(Foo p)   {     p.DoSomething();   }    public ICommand Command { get; private set; } } </code></pre>  <p>However, it does work if I initialize a field from p1 and pass the field as a parameter to the method call inside the lambda:</p>  <pre><code>class Thing() {   private Foo field;   public Thing(Foo p1)   {     field = p1;     Command = new RelayCommand(() =&gt; DoIt(field));   }    private DoIt(Foo p)   {     p.DoSomething();   }    public ICommand Command { get; private set; } } </code></pre>  <p>Why does the former fail, but the latter work as expected?</p>  <p>Probably relevant: <a href="http://stackoverflow.com/questions/1928636/how-do-closures-work-behind-the-scenes-c">How do closures work behind the scenes? (C#)</a></p>  <p>EDIT: To clarify, the following would also work for me. However, I would still like to know why the second example did what I expected, but the first one did not.</p>  <pre><code>class Thing() {   private Foo field;   public Thing(Foo p1)   {     field = p1;     Command = new RelayCommand(DoIt);     //Command = new RelayCommand(() =&gt; DoIt()); Equivalent?   }    private DoIt()   {     field.DoSomething();   }    public ICommand Command { get; private set; } } </code></pre>