<p>I'm a novice at developing thread-safe methods. I have a configuration service, implemented as a Singleton class, that needs to be thread-safe. When the service is started, a collection of configuration files are read and stored in a map. This only needs to happen once. I have used <code>AtomicBoolean</code> for the <code>isStarted</code> state field, but I am not sure if I have done this properly:</p>  <pre><code>public class ConfigServiceImpl implements ConfigService {     public static final URL PROFILE_DIR_URL =            ConfigServiceImpl.class.getClassLoader().getResource("./pageobject_config/");      private AtomicBoolean isStarted;     private Map&lt;String,ConcurrentHashMap&lt;String,LoadableConfig&gt;&gt; profiles = new ConcurrentHashMap&lt;&gt;();      private static final class Loader {         private static final ConfigServiceImpl INSTANCE = new ConfigServiceImpl();     }      private ConfigServiceImpl() { }      public static ConfigServiceImpl getInstance() {         return Loader.INSTANCE;     }      @Override     public void start() {         if(!isStarted()) {             try {                 if (PROFILE_DIR_URL != null) {                     URI resourceDirUri = PROFILE_DIR_URL.toURI();                     File resourceDir = new File(resourceDirUri);                     @SuppressWarnings("ConstantConditions")                     List&lt;File&gt; files = resourceDir.listFiles() != null ?                             Arrays.asList(resourceDir.listFiles()) : new ArrayList&lt;&gt;();                      files.forEach(this::addProfile);                     isStarted.compareAndSet(false, true);                 }             } catch (URISyntaxException e) {                 throw new IllegalStateException("Could not generate a valid URI for " + PROFILE_DIR_URL);             }         }     }      @Override     public boolean isStarted() {         return isStarted.get();     }      .... } </code></pre>  <p>I wasn't sure if I should set <code>isStarted</code> to <code>true</code> before populating the map, or even if this matters at all. Would this implementation be reasonably safe in a multi-threaded environment?</p>  <p>UPDATE:</p>  <p>Using zapl's suggestion to perform all initialization in the private constructor and JB Nizet's suggestion to use <code>getResourceAsStream()</code>:</p>  <pre><code>public class ConfigServiceImpl implements ConfigService {     private static final InputStream PROFILE_DIR_STREAM =             ConfigServiceImpl.class.getClassLoader().getResourceAsStream("./pageobject_config/");      private Map&lt;String,HashMap&lt;String,LoadableConfig&gt;&gt; profiles = new HashMap&lt;&gt;();      private static final class Loader {         private static final ConfigServiceImpl INSTANCE = new ConfigServiceImpl();     }      private ConfigServiceImpl() {         if(PROFILE_DIR_STREAM != null) {             BufferedReader reader = new BufferedReader(new InputStreamReader(PROFILE_DIR_STREAM));             String line;              try {                 while ((line = reader.readLine()) != null) {                     File file = new File(line);                     ObjectMapper mapper = new ObjectMapper().registerModule(new Jdk8Module());                     MapType mapType = mapper.getTypeFactory()                             .constructMapType(HashMap.class, String.class, LoadableConfigImpl.class);                      try {                         //noinspection ConstantConditions                         profiles.put(file.getName(), mapper.readValue(file, mapType));                     } catch (IOException e) {                         throw new IllegalStateException("Could not read and process profile " + file);                     }                  }                  reader.close();             } catch(IOException e) {                 throw new IllegalStateException("Could not read file list from profile directory");             }         }     }      public static ConfigServiceImpl getInstance() {         return Loader.INSTANCE;     }      ... } </code></pre>