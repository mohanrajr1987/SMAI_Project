<p>For Sept 2015, here's exactly how you make a singleton in Swift:</p>  <pre><code>public class Model     {     static let shared = Model()      func test()-&gt;Double         {         return 3.33         }     } </code></pre>  <p>then elsewhere...</p>  <pre><code>// file ViewController.swift, say import UIKit class ViewController:UIViewController     {     override func viewDidLoad()         {         super.viewDidLoad()         print("view controller loaded!")         print("singleton test! \( Model.shared.test() )")         }     } </code></pre>  <p>No problem.</p>  <p>However, I like to do this:</p>  <pre><code>public let model = Model.shared public class Model     {     static let shared = Model()      func test()-&gt;Double         {         return 3.33         }     } </code></pre>  <p>then, you can simply do the following project-wide:</p>  <pre><code>class ViewController:UIViewController     {     override func viewDidLoad()         {         super.viewDidLoad()         print("view controller loaded!")         print("singleton test! \( model.test() )")         }     } </code></pre>  <p>This results in everything looking pretty:</p>  <p><a href="http://i.stack.imgur.com/4oD9P.png" rel="nofollow"><img src="http://i.stack.imgur.com/4oD9P.png" alt="enter image description here"></a></p>  <p>(Typically then, for you those "singleton variables" would be things like <code>scores.</code>, <code>networking.</code>, <code>heuristics.</code>, or whatever the case may be in your project.)</p>  <p>This then, is a <strong>"macro-like" idiom</strong>, the purpose of which is clarity ... simplifying appearances of <code>ImportantSystem.SharedImportantSystem</code> to just <code>importantSystem.</code> throughout the project.</p>  <h1>Can anyone see any problems with this idiom?</h1>  <p>Problems may be technical, stylistic, or any other category.</p>