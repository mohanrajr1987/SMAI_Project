<p>I have the following design for a database table handler.  I want to allow for the most generic table implementation to the most specific.</p>  <p>I have a development and production database, and I only want to up to one instance for each one at any time.  Thus I designed a class containing a small number of Singleton-esque objects.</p>  <p>Generic table class - not a Singleton:</p>  <pre><code>abstract class DbTable {     protected $table;   // table name     protected $records; // array of records     protected $db;      // PDO connection      protected function __construct(PDO $db, $table, $preloadData) {         $this-&gt;db    = $db;         $this-&gt;table = $table;         if ($preloadData) {             $this-&gt;updateFromDatabase();         }     }      abstract public function updateFromDatabase();      public function getAllRows() {         // Performs a SELECT * FROM $table     } } </code></pre>  <p>Abstract class that creates a structure to store the "singleton" instances of tables per schema (dev vs. prod) per database.  Note, the <code>on_dev_server()</code> function returns <code>TRUE</code> if and only if the PHP script is running on the development server, as opposed to the production server.</p>  <pre><code>abstract class DevProdDbTable extends DbTable {     /**      * Array that stores the "Singleton" table objects.  The array is indexed first      * by database name (from the immediate subclass), then by "Dev" and "Prod", then by      * table name.      *      * @var DevProdDbTable[][][]      */     private static $tables = [];      protected static function($dbname, $preload, $dbsrc=NULL) {         $table = get_called_class();  // Gets the youngest descendant class that called this         if (is_null($dbsrc)) {             $dbsrc = on_dev_server() ? "Dev" : "Prod";         }          if (!isset(self::$tables[$dbname][$dbsrc][$table])) {             self::$tables[$dbname][$dbsrc][$table] = new static($preload, $dbsrc);         }         return self::$tables[$dbname][$dbsrc][$table];     }      private function __clone() {}; } </code></pre>  <p>Database class, which handles both dev &amp; prod:</p>  <pre><code>abstract class MyDbTable extends DevProdDbTable {      /**      * Two database connections - one for dev, one for prod.  (Probably could just use two      * separate variables for this.      * @var MyDbConn[]      */     private static $dbConns = [];      /**      * Calls the parent class's getInstance() method using the MyDbTable class name for the      * first index of DevProdDbTable::$tables.      */     protected static function getInstance($preload, $dbsrc=null) {         return parent::getInstance(__CLASS__, $preload, $dbsrc); // violates LSP     }      protected function __construct($tableName, $preloadData, $dbsrc) {         if (!array_key_exists($dbsrc, self::$dbConns)) {             self::$dbConns[$dbsrc] = new MyDBConn($dbsrc);         }         $dbConn = self::$dbConns[$dbsrc];         parent::__construct($dbConn, $tableName, $preloadData);     } } </code></pre>  <p>Sample table implementer, which will create the object and prefill the data from the PERSON table into the inherited $records property.</p>  <pre><code>final class PersonTable extends MyDbTable {      public static function getInstance($dbsrc = null)  { // violates LSP         return parent::getInstance(true, $dbsrc);     }      protected function __constuct($preload, $dbsrc) {         parent::__construct("PERSON", $preload, $dbsrc);     }      public function updateFromDatabase() {         $rows = $this-&gt;getAllRows();   // defined in DbTable: does a SELECT * FROM $table         foreach ($rows as $row) {             $person = new PersonRecord($row);  // implementation is unimportant             $personId = $person-&gt;getUid();             $this-&gt;records[$personId] = $person;         }     } } </code></pre>  <p>I'm obviously going about this the wrong way, as the <code>getInstance()</code> methods clearly violate the Liskov Substitution Principle.</p>  <p>What should I do instead?</p>