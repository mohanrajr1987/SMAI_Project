<h2>Application Setup (simplified)</h2>  <p>I feel like I am pretty familiar with concurrency in Java, but I am relatively new to Java EE and its annotations.</p>  <p>I have a class called <code>DataHandler</code> annotated with <code>@Singleton</code> that performs some business logic for my application. This class is injected into a web service implementation class annotated with <code>@WebService</code>. When one of the web service's methods is called, <code>DataHandler</code> calls the <code>parseFiles()</code> method which parses some files, and stores data inside of <code>DataHandler</code>. Afterwards it makes some calls to getters inside of <code>DataHandler</code>:</p>  <pre><code>@WebService(portName = "portName",     serviceName = "MyService",     endpointInterface = "com.myco.MyPortType",     wsdlLocation = "WEB-INF/wsdl/MyWSDL.wsdl",     targetNamespace = "targetNamespace") public class MyServiceImpl implements MyPortType {  @EJB private DataHandler dataHandler;  @Override public ResponseType doStuff(RequestType request) {     // code     // ....     dataHandler.parseFiles();     // ....     // more code     Map&lt;String, CustomType&gt; map = dataHandler.getCustomTypeMap();     Map&lt;String, CustomType2&gt; map2 = dataHandler.getCustomType2Map(); } </code></pre>  <p>Now I also have message-driven bean that receives some data on a topic called UpdateTopic, then converts it into another type and stores it inside of <code>DataHandler</code>:</p>  <pre><code>@MessageDriven(activationConfig = {     @ActivationConfigProperty(propertyName = "acknowledgeMode", propertyValue = "Auto-acknowledge"),     @ActivationConfigProperty(propertyName = "destinationType", propertyValue = "javax.jms.Topic"),     @ActivationConfigProperty(propertyName = "destination", propertyValue = "UpdateTopic") }) public class UpdateTopicMDB implements MessageListener {  @EJB DataHandler dataHandler;  @Override public void onMessage(Message message) {     try {         if (message instanceof ObjectMessage) {             ObjectMessage objMessage = (ObjectMessage) message;             Serializable data = objMessage.getObject();             if (data instanceof UpdateType) {                 dataHandler.convertAndStore((UpdateType) data);             }         }     } catch(Exception e) {         // log Exception     } } </code></pre>  <p>I wanted to synchronize the <code>parseFiles()</code> method, the <code>convertAndStore()</code> method, and the two getters so that all data would be up-to-date when accessed.</p>  <p>I simply made all four methods <code>synchronized</code> to achieve this. My understanding is that if the files were in the middle of being parsed and an update comes into the MDB, then the <code>convertAndStore()</code> method would be locked until <code>parseFiles()</code> is done. Likewise, if an update is being converted and stored and the web service is trying to access one of the two maps, it will wait until <code>convertAndStore()</code> is finished. Correct me if I'm wrong on any of that.</p>  <hr>  <h2>My Question</h2>  <p>With all of that being said, I just recently read about the <code>@ConcurrencyManagement</code> and <code>@Lock</code> annotations. Instead of synchronizing these four methods. It now seems as though I should just annotate <code>parseFiles()</code> and <code>convertAndStore()</code> with <code>@Lock(LockType.WRITE)</code> since they are modifying the bean's state and the two getters with <code>@Lock(LockType.READ)</code>.</p>  <p>Should I do this and avoid using the <code>synchronized</code> keyword altogether? Would there be any use for <code>synchronized</code> (maybe just for synchronized blocks?), or do these annotations replace it now?</p>