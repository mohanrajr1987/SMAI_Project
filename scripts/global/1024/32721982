<p>So I have two view controllers. 1 "main" VC, 1 "settings" VC. In the settings VC the user is asked if he/she wants to use the accelerometer.</p>  <p>This boolean value is stored with <em>NSUserDefaults</em> like this:</p>  <pre><code>- (IBAction)accSwitchValueChanged:(id)sender {      //Method gets called when switch value changes.     [[NSUserDefaults standardUserDefaults] setBool:self.accSwitch.on forKey:@"accelerometerPitch"];     [[NSUserDefaults standardUserDefaults]synchronize];  } </code></pre>  <p>Then in the "main" VC in I have the following property:</p>  <pre><code>@property (nonatomic) MotionHandler *sharedMotionManager; </code></pre>  <p><em>MotionHandler</em> is the singleton class for CMMotionManager:</p>  <p><strong>MotionHandler.h:</strong></p>  <pre><code>#import &lt;Foundation/Foundation.h&gt; #import &lt;CoreMotion/CoreMotion.h&gt; @interface MotionHandler : NSObject {     CMMotionManager *motionManager; } @property (nonatomic, retain) CMMotionManager *motionManager;  + (id) sharedManager;  @end </code></pre>  <p><strong>MotionHandler.m:</strong></p>  <pre><code>#import "MotionHandler.h"  @implementation MotionHandler  + (id)sharedManager {     static MotionHandler *sharedMyManager = nil;     static dispatch_once_t onceToken;     dispatch_once(&amp;onceToken, ^{         sharedMyManager = [[self alloc] init];     });     return sharedMyManager; }  - (id)init {     if (self = [super init]) {         motionManager = [[CMMotionManager alloc]init];     }     return self; } @end </code></pre>  <p><strong>In the "main" VC in viewDidLoad:</strong></p>  <pre><code>self.sharedMotionManager = [MotionHandler sharedManager]; </code></pre>  <p><strong>In the "main" VC in viewWillAppear:</strong></p>  <pre><code>if ([[NSUserDefaults standardUserDefaults]boolForKey:@"accelerometerPitch" ] == YES &amp;&amp; [[NSUserDefaults standardUserDefaults]boolForKey:@"accRunning"] == NO) {          [self.sharedMotionManager.motionManager startAccelerometerUpdatesToQueue:[[NSOperationQueue alloc]init] withHandler: ^(CMAccelerometerData *data, NSError *error){         NSLog(â€œrunning");                              }];          [[NSUserDefaults standardUserDefaults]setBool:YES forKey:@"accRunning"];    }  if ([[NSUserDefaults standardUserDefaults]boolForKey:@"accelerometerPitch"] == NO &amp;&amp; [[NSUserDefaults standardUserDefaults]boolForKey:@"accRunning"] == YES) {          [[NSUserDefaults standardUserDefaults]setBool:NO forKey:@"accRunning"];        [self.sharedMotionManager.motionManager stopAccelerometerUpdates];      } </code></pre>  <p>The problem I'm having is that when using the singleton class, the accelerometer isn't working. I have tried it without a singleton class and it worked, but I need the singleton because when I leave the VC and come back I can't access the same CMMotionManager anymore.</p>  <p>Why isn't the singleton working?</p>