<p>This has been asked many times, but I'm still at a crossroads. </p>  <p>My application is required to save data, this data can be accessed through many areas of the application.</p>  <p>I wanted to avoid core data as it is overkill for what I need to save 3-4 simple different  classes.</p>  <p>So I’m using NSCoding, and its working without issue.</p>  <p>Im not stuck on whats the “best” way to access this stored data.</p>  <p>Essentially, singleton or not. Been reading a variety of posts and most say avoid the use of a singleton.</p>  <p>This issue became apparent as my current design uses a singlelton object to provide a way for me to access my data from disc easily. Problem is testing… couldn’t find a way to overcome the inability to test - this is when I decided to ask should i not be using this pattern.</p>  <p>So, what is the better way to access my data - to allow read and write from anyplace within my application.</p>  <p>Use the singleton and just don’t test - or create a new instance, and ask that instance to retrieve my data. I also don’t want to pass data along - I want to be able to easily access data - read and write (using tab bar controller etc)</p>  <p>This was my singleton implementation</p>  <pre><code>class InvalidClientCollection {      static var errorList = InvalidClientCollection.loadErrataClients()     static private let kErrataClientSaveFileName = "errorClientsFile"      static var clientCount:Int {         get {             return errorList.count         }     }      static func loadErrataClients() -&gt; [Client] {          let mysavefile = FilePath(fileName: kErrataClientSaveFileName).filePath         if let data = NSKeyedUnarchiver.unarchiveObjectWithFile(mysavefile) as? [Client] {             return data         }         return [Client]()     }      static func saveErrataClientList() {         let mysavefile = FilePath(fileName: kErrataClientSaveFileName).filePath         NSKeyedArchiver.archiveRootObject(errorList, toFile: mysavefile)     } }  </code></pre>  <p>Should I redesign, so to get my data I would</p>  <pre><code>let mycolleection = InvalidClientCollection() let mystuff = mycollection.errorList </code></pre>  <p>I guess something like this ?</p>  <pre><code>class InvalidClientCollection {      var errorList:[Client] {         get {            return loadErrataClients()         }         set {             self.errorList = newValue             // maybe even save at same time             //saveErrataClientList()         }     }     // etc... } </code></pre>  <p>Any ideas - improved code would be much appreciated. </p>