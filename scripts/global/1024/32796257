<p>I'm experiencing strange behaviors and <code>NullPointerException</code> (sometimes) with a <code>Singleton</code> pattern using in an <code>Activity</code>.</p>  <p>The activity in manifest (declared the orientation landscape):</p>  <pre><code>&lt;activity    android:name="com.lux.game.MainActivity"    android:screenOrientation="landscape" /&gt; </code></pre>  <p>The activity class:</p>  <pre><code>private GameManager.OnEventListener mEventListener = new GameManager.OnEventListener {    @Override    public void onEvent(Event event) {       if (event == Event.PLAYER_SELECTED_PUZZLE) {          // Do something on the UI       }    } };  @Override protected void onCreate(Bundle savedInstanceState) {     super.onCreate(savedInstanceState);     getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN);      // If the orientation is landscape, then initialize the Game Manager     if (getResources().getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE) {        GameManager.getInstance().init();         // Register an interface to deal with game events        GameManager.getInstance().registerForEvent(mEventListener);     } }  @Override protected void onDestroy() {     super.onDestroy();      // The activity was destroyed, remove the interface and clear the references     GameManager.getInstance().cleanUp(); } </code></pre>  <p>The <code>GameManager</code> singleton:</p>  <pre><code>public class GameManager {    private static GameManager mInstance;     private GameManager() {    }     public static synchronized getInstance() {       if (mInstance == null) {           mInstance = new GameManager();       }        return mInstance;    } } </code></pre>  <p>As you can see, I'm using the <code>GameManager</code> singleton to deal with game events (player selects a card, game end, etc). The singleton is instantiated at <code>onCreate()</code> if the orientation is in landscape and an <code>interface</code> is passed to the singleton and it's stored as a member of the class. The <code>interface</code> is removed at activity's <code>onDestroy()</code>.</p>  <p>Activity lifecycle and logs:</p>  <pre><code>#1 onCreate(), orientation: LANDSCAPE #2 back button pressed #3 onDestroy(), orientation: PORTRAIT </code></pre>  <p>Everything was working as I expected, until I started to test the application by <strong>locking/unlocking</strong> and pressing the <strong>HOME</strong> button on the device (real device, not emulator).</p>  <p>Activity lifecycle and logs:</p>  <pre><code>#1 onCreate(), orientation: LANDSCAPE #2 lock phone #3 onDestroy(), orientation: PORTRAIT #4 onCreate(), orientation: PORTRAIT #5 unlock phone #6 onDestroy(), orientation: PORTRAIT #7 onCreate(), orientation: LANDSCAPE </code></pre>  <p><code>onCreate</code> and <code>onDestroy</code> is called sever times (normal behavior because orientation change), however this does not creates an issue, because the activity's <code>lifecycle</code> methods are called in the <strong>excpeted</strong> order and the <code>interface</code> is removed, and I'm not leaving any reference which could cause memory leak.</p>  <p>The problem (sometimes) comes to the surface  if the steps above are getting called in a different order:</p>  <pre><code>#1 onCreate(), orientation: LANDSCAPE (inst #1) #2 lock phone #3 onDestroy(), orientation: PORTRAIT (inst #1) #4 onCreate(), orientation: PORTRAIT (inst #2) #5 unlock phone #6 onCreate(), orientation: LANDSCAPE (inst #3) #7 onDestroy(), orientation: PORTRAIT (inst #2) </code></pre>  <p>As you can see, step <strong>6</strong> and <strong>7</strong> are inverse compared to the previous steps. <code>onCreate</code> is called before <code>onDestroy</code>. Also I have added a number <em>(inst #N)</em>, which indicates how many activity instances are getting created and which is getting destroyed. </p>  <p>According to the logs, there are a total of 3 different activity instances which are getting created while I'm locking/unlocking the phone. The problem is caused by the last step, when the 3rd activity (inst #3) is created, and the 2nd activity (inst #2) is destroyed. I'm using a <code>Singleton</code> (only 1 instance exists in the whole application) to deal with events and manage the game, at activity's <code>onDestroy</code> the <code>Singleton</code> expects that the game has ended, and it must remove the references to the activity. This way, if an event occur in the game a <code>NullPointerException</code> is being thrown because the <code>Singleton</code> has cleared all the references.</p>  <ol> <li>Should I use a different approach than Singleton? (How to deal with game events?)</li> <li>Should I use onSave/onRestore instances? (Why and how?)</li> <li>Should I onPause/onResume instead of onCreate/onDestroy?</li> <li>Out of ideas. If you have any good idea how to solve this issue is welcomed.</li> </ol>