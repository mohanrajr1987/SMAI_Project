<p>When I use this c struct in c# declaration ref it works</p>  <p>C++ declaration;</p>  <pre class="lang-c prettyprint-override"><code>typedef struct Module {     char * moduleName;     char * path;  } Module;  __declspec(dllexport) void __cdecl ListProcessModule(DWORD dwPID, Module *pmodule) {     HANDLE hModuleSnap = INVALID_HANDLE_VALUE;     MODULEENTRY32 me32;      hModuleSnap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, dwPID);      me32.dwSize = sizeof(MODULEENTRY32);     Module32Next(hModuleSnap, &amp;me32);      (*pmodule).moduleName = new char[wcslen(me32.szModule) + 1];     wcstombs_s(NULL, (*pmodule).moduleName, wcslen(me32.szModule) + 1,              me32.szModule, wcslen(me32.szModule) + 1);      (*pmodule).path = new char[wcslen(me32.szExePath) + 1];     wcstombs_s(NULL, (*pmodule).path, wcslen(me32.szExePath) + 1,       me32.szExePath, wcslen(me32.szExePath) + 1);     CloseHandle(hModuleSnap); } </code></pre>  <p>c# call:</p>  <pre class="lang-c prettyprint-override"><code> [StructLayout(LayoutKind.Sequential)]     public struct Module     {         [MarshalAs(UnmanagedType.SysInt)]         public IntPtr moduleName;          [MarshalAs(UnmanagedType.SysInt)]         public IntPtr modulePath;     }   [DllImport("DllManagerDependencies.dll", CallingConvention =   CallingConvention.Cdecl)]     public static extern void ListProcessModule(int dwPID, ref Module module);      Module module = new Module();     ListProcessModule(7228, ref module); </code></pre>  <p>The problem starts when I try to do send the same structure with an Module structure array:</p>  <pre class="lang-c prettyprint-override"><code>__declspec(dllexport) void __cdecl ListProcessModules(DWORD dwPID, Module *    pmodules) {     HANDLE hModuleSnap = INVALID_HANDLE_VALUE;     MODULEENTRY32 me32;     int currentValue = 0;      hModuleSnap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, dwPID);      me32.dwSize = sizeof(MODULEENTRY32);      do     {          pmodules[currentValue].moduleName = new char[wcslen(me32.szModule) + 1];          wcstombs_s(NULL, pmodules[currentValue].moduleName,     wcslen(me32.szModule) + 1, me32.szModule, wcslen(me32.szModule) + 1);           pmodules[currentValue].path = new char[wcslen(me32.szExePath) + 1];          wcstombs_s(NULL, pmodules[currentValue].path, wcslen(me32.szExePath) +    1, me32.szExePath, wcslen(me32.szExePath) + 1);           currentValue++;      } while (Module32Next(hModuleSnap, &amp;me32));      CloseHandle(hModuleSnap); } </code></pre>  <p>And the c# failure call:</p>  <pre class="lang-c prettyprint-override"><code>    [DllImport("DllManagerDependencies.dll", CallingConvention = CallingConvention.Cdecl)]     public static extern void ListProcessModules(int dwPID, Module []modules);      Module []modules = new Module[100];     ListProcessModules(7228,  modules); </code></pre>  <p>It return me an empty array. So the question is what is the correct way to send the c# array to dll function?</p>