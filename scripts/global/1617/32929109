<p>I have a function that removes from a linked list. Each node in the linked list is a dynamically created struct. To remove, I pass a data value in that I would like to search for in the list of nodes. If one of those nodes contains that data, I want to remove the entire node containing that data. It appears like they get added fine, but whenever I remove, the size variable decrements but the nodes are still in the list.</p>  <pre><code>In Mag.h: struct ListNode  {     int* data;     ListNode* nextNode; };  class Mag  { private:     ListNode* head; public:     Mag();     Mag(Mag&amp; mag);     Mag &amp;operator= (const Mag &amp;);     ~Mag();     int size;     void add(const int&amp;);     void remove(const int&amp;);     void printList();     }; } </code></pre>  <p>I add nodes to the list like this:</p>  <pre><code>// adds to front of list void Mag::add(int const &amp;num)  {     Node* new_data = new ListNode();     new_data-&gt;data = num;     new_data-&gt;next = head;     head = newNode;      size++; } </code></pre>  <p>Now here's how I remove them (probably the issue):</p>  <pre><code>void Mag::remove(int const &amp;num)  {     if (head == NULL)         return;      int look_for = num;     ListNode* searchFor = head;     int count = 0;     count = size;      if (count != 0)      {         do          {             if (searchFor-&gt;data == look_for)              {                 ListNode* delete_node = new ListNode;                 delete_node = searchFor;                 searchFor = searchFor-&gt;next;                  size--;                 delete delete_node;                 return;             }              searchFor = searchFor-&gt;next;             count--;          } while (count != 0);     } } </code></pre>