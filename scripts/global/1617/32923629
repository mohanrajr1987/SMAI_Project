<p>I have a struct that stores two points that should be interchangeable.</p>  <pre><code>struct Edge {     unsigned short firstIndex;     unsigned short secondIndex;     Edge(unsigned short firstIndex, unsigned short secondIndex) :         firstIndex(firstIndex), secondIndex(secondIndex) {} }; </code></pre>  <p>The <code>operator==</code> method should be as follows (To make them interchangeable)</p>  <pre><code>bool operator == (const Edge&amp; e2) const {     return          first == e2.first &amp;&amp; second == e2.second ||          first == e2.second &amp;&amp; second == e2.first; } </code></pre>  <p><strong>I am looking to create an <code>operator&lt;</code> and <code>operator&gt;</code> method in order to use the struct in a <code>std::map</code></strong></p>  <p>I have tried the following (using multiplication) but it does not work since there are many cases in which different edges return the same value</p>  <pre><code>bool operator &lt; (const Edge&amp; e2) const {     return first * second &lt; e2.first * e2.second; } </code></pre>  <p>The code that I would like to use is the following:</p>  <pre><code>std::map&lt;Edge, unsigned int&gt; edgePoints; Edge e1(0, 1); Edge e2(1, 2); Edge e3(2, 0);  edgePoints[e1] = 2; edgePoints[e2] = 0; edgePoints[e3] = 1; </code></pre>  <p>Although the code does not work with my <code>operator&lt;</code> method because <code>0 * 1 == 2 * 0</code> so the map returns <code>2</code> when I call <code>edgePoints[e3]</code></p>  <p><strong>Does anyone know of an <code>operator&lt;</code> and <code>operator&gt;</code> method that I could use or even some other way of mapping the edges in order to use the <code>std::map</code></strong></p>