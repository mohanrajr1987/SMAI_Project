<p>I create a data collection system that has a tree-like structure built on the similarity to the pattern of the factory, and I have the difficulty in working with this structure, more stingrays lot of code to find the element opredelnie. </p>  <pre><code>public interface ITag : IRegister {     string Name { get; set; }     string SystemName { get; } }  public interface ISignal : IRegister { }  public interface IRegister {     Type GetType { get; } }  public interface IGroup : IRegister {     string Name { get; set; }     string SystemName { get; } }  public interface IDevice : IRegister {     string Name { get; set; }     string SystemName { get; } }  public interface IServer : IRegister { }  public interface INode : IRegister {     string Name { get; set; }     string SystemName { get; } }  [Serializable] public class Server : IServer {     public string Name;     public string SystemName;     public List&lt;INode&gt; Nodes;       public Server(string name, List&lt;INode&gt; node)     {         Name = name;         Nodes = node;         SystemName = "Server";     }     public Type GetType     {         get { return typeof(Server); }     } }  [Serializable] public class TCP : INode {     public string IPAddress;     public int Port;     public List&lt;IDevice&gt; Nodes;     public string Name { get; set; }     public string SystemName { get; }      public TCP(string name, string ip, int port, List&lt;IDevice&gt; devices)     {         Name = name;         IPAddress = ip;         Port = port;         Nodes = devices;         SystemName = "Node";     }      public TCP()     {     }      public Type GetType     {         get { return typeof(TCP); }     } }  [Serializable] public class RTU : INode {     public string Name { get; set; }     public string SystemName { get; }     public string Port;     public int SpeedRate;     public int DataBits;     public int StopBits;     public Parity Parity;     public List&lt;IDevice&gt; Devices;      public RTU(string name, int sr, int db, int sb, Parity par, string port, List&lt;IDevice&gt; devices)     {         Name = name;         Port = port;         SpeedRate = sr;         StopBits = sb;         DataBits = db;         Devices = devices;         Parity = par;         SystemName = "Node";     }      public Type GetType     {         get { return typeof(RTU); }     } }  [Serializable] public class Device : IDevice {     public int Address;     public string Name { get; set; }     public string SystemName { get; }     public List&lt;IGroup&gt; Groups;      public Device(int address, string name, List&lt;IGroup&gt; groups)     {         Address = address;         Groups = groups;         Name = name;         SystemName = "Device";     }      public Type GetType     {         get { return typeof(Device); }     }      public Type DeviceType(List&lt;IRegister&gt; list )     {         return list.GetType();     } }  [Serializable] public class Group : IGroup {     public List&lt;ITag&gt; Tags;     public string Name { get; set; }     public string SystemName { get; }      public Group(string name, List&lt;ITag&gt; tags)     {         Tags = tags;         Name = name;         SystemName = "Group";     }      public Type GetType     {         get { return typeof(Group); ; }     }  }  [Serializable] public class Tag : ITag, IGroup {     public ISignal Signal;     public TypeData Data;     public TypeModbus TypeModbus;     //public object Value;     //public DateTime Time;     public string Name { get; set; }     public string SystemName { get; }      public Tag(ISignal signal, TypeData data, TypeModbus typeModbus,string n, object value = null)     {         Signal = signal;         Data = data;         TypeModbus = typeModbus;         //Value = value;         //Time = time;         Name = n;         SystemName = "Tag";     }       public Type GetType     {         get { return typeof(Tag); }     }  }  [Serializable] public class Analog : ISignal {     public int Address;     public int Address_validaty;     public float MinWarning;     public float MinEmergency;     public float MaxWarning;     public float MaxEmergency;     public bool Control;     public float Coeficient;     public float Shift;     public bool IsCoeficient;     public string MinWText;     public string MinEText;     public string MaxWText;     public string MaxEText;      public Type GetType     {         get { return typeof(Analog); }     } }  [Serializable] public class Discrete : ISignal {     public int Address;     public int Address_validaty;     public bool IsAutomat;     public static ITag Tag = null;     public string TrueText;     public string FalseText;     public Discrete(int ad, int adv,  bool isautomat, string ft, string tt, ITag tag = null)     {         Address = ad;         Address_validaty = adv;         TrueText = tt;         FalseText = ft;         IsAutomat = isautomat;          if (isautomat)             Tag = tag;     }     public Type GetType     {         get { return typeof(Discrete); }     }  }  [Serializable] public class Managment : ISignal {     public ITag ConnectionRegister;     public int Address;     public int SecondsReply;       public Type GetType     {         get { return typeof(Managment); }     } } </code></pre>  <p>In this example I'm using nested loops to find Teg on List  which contains the entire structure, and are searching for me to have to use for each node of the structure, and it only renames the item, and there is deletion, search duplicate, overlap, and so on.</p>  <pre><code>if(e.Node.Name.Equals("Tag")) {     foreach(Server z in List)     {         foreach(INode node in z.Nodes)         {             if(node.GetType == typeof(TCP))             {                 TCP _node = (TCP) node;                 foreach(Device device in _node.Devices)                 {                     IEnumerable&lt;IGroup&gt; d = device.Groups.Where(p =&gt; p.GetType == typeof(Group));                     foreach(Group group in d)                     {                         var n = group.Tags.Where(p =&gt; p.Name == e.Node.Text);                         foreach(ITag tag in n)                         {                             tag.Name = newname;                         }                     }                 }             }             else if(node.GetType == typeof(RTU))             {                 RTU _node = (RTU) node;                 foreach(Device device in _node.Devices)                 {                     IEnumerable&lt;IGroup&gt; d = device.Groups.Where(p =&gt; p.GetType == typeof(Group));                     foreach(Group group in d)                     {                         var n = group.Tags.Where(p =&gt; p.Name == e.Node.Text);                         foreach(ITag tag in n)                         {                             tag.Name = newname;                         }                     }                 }             }         }     } } </code></pre>  <p>Please tell me how to simplify the search, make it more readable.</p>