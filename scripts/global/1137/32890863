<p>We have an inheriting attached property which stores an object.  Further down the visual tree, we want to bind to a property on that object from code.</p>  <p>Normally we construct the Path portion of a binding like so...</p>  <pre><code>var someBinding = new Binding() {     Path = new PropertyPath(AttachedPropertyOwner.SomeAttachedProperty),     RelativeSource = new RelativeSource(RelativeSourceMode.Self) };  </code></pre>  <p>That works, but we now want a property of the object stored in <code>SomeAttachedProperty</code>.  I take it we're supposed to use the string representation?</p>  <p>Also, while researching this, I found this on MSDN: <a href="https://msdn.microsoft.com/en-us/library/cc645024(v=vs.95).aspx" rel="nofollow">Property Path Syntax</a></p>  <p>The concerning part is down under the heading 'PropertyPathInCode'</p>  <blockquote>   <p>If you construct a PropertyPath from a DependencyProperty, that PropertyPath is not usable as a Binding.Path, it is only usable for animation targeting. The Path value for the constructed PropertyPath from a DependencyProperty is the string value (0), which is a sentinel value used by the binding engine for an invalid path.</p> </blockquote>  <p>...which doesn't make sense to me since it appears to work fine. Am I missing something? Have we been doing all of our code bindings wrong?</p>  <h2>Update</h2>  <p>Reading the MSDN documentation comment (which I missed was Silverlight, but I don't think matters in this case), it says you can't use a Dependency <strong><em>Property</em></strong>.  However, it says you <em>can</em> use a DependencyProperty <strong><em>identifier</em></strong>, the identifier being what's returned from the Register methods.</p>  <p>In other words, I think what they're saying is what we're doing is valid...</p>  <pre><code>var someBinding = new Binding() {     Path = new PropertyPath(CarClass.WheelCountProperty) };  </code></pre>  <p>...but this is not.</p>  <pre><code>var someBinding = new Binding() {     Path = new PropertyPath(MyCarInstance.WheelCount) };  </code></pre>  <p>Seemingly confirming this, under the hood, Reflector shows it's essentially just doing this...</p>  <pre><code>public PropertyPath(object value) : this("(0)", new [] { value }) {     .... } </code></pre>  <p>...so I think that scare was a red herring.</p>  <p>I think that also means I can do what I'm after like this...</p>  <pre><code>Path = new PropertyPath("(0).(1)",     SomeClass.SomeAttachedProperty,     SomeOtherClass.SomeOtherAttachedProperty) </code></pre>  <p>...which gets the value of the second attached property from the object stored in the first attached property.</p>