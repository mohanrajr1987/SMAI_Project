<p>I have created an WCF client as a service reference in Visual Studio using the WSDL from the web-service (Windchill WS-JAX). It works fine for the simple return of a string.  For a number of reasons I want to change this to use the ChannelFactory, that means removing the use of a proxy, and just get the result as xml in the message. Based on examples from MSDN I have generated some code:</p>  <pre><code>'Create Binding Dim binding As New CustomBinding() binding.Elements.Add(New HttpTransportBindingElement())  'Use the binding to build the channel factory Dim factory As IChannelFactory(Of IRequestChannel) =binding.BuildChannelFactory(Of IRequestChannel)(New BindingParameterCollection())  'open the channel factory factory.Open()  'Use the channel factory to create a channel Dim channel As IRequestChannel = factory.CreateChannel(New EndpointAddress(myEndpoint)) channel.Open()  'create a message Dim requestmessage As Message = Message.CreateMessage(MessageVersion.Soap12WSAddressing10, myAction, myBody)  'send message Dim replymessage As Message = channel.Request(requestmessage) </code></pre>  <p>The code as such works until the point where the message is sent. I have compared the message of the working WCF with the replymessage and can see the main difference is in the header, especially regaring security (no surprise since security has not been added to the code.</p>  <p>My question is now, <strong>how do I transform the security settings of the WCF into security settings of the ChannelFactory?</strong> I have looked at can see that there is a jungle of options like WSTrustChannel, security of custombindings and much more. Could somebody point me in the right direction?</p>  <p>Below is included the app.config bindings from the working WCF client:</p>  <p></p>  <pre><code>                &lt;!--The wsdl schema that was used to create this configuration file contained a 'RequireIssuerSerialReference' assertion for a X509Token.  This can not be represented in configuration, you will need to programatically adjust the appropriate X509SecurityTokenParameters.X509KeyIdentifierClauseType to X509KeyIdentifierClauseType.IssuerSerial.  The default of X509KeyIdentifierClauseType.Thumbprint will be used, which may cause interop issues.--&gt;                      &lt;security defaultAlgorithmSuite="Basic128" authenticationMode="UserNameForCertificate"                          requireDerivedKeys="false" securityHeaderLayout="Lax" includeTimestamp="true"                          messageProtectionOrder="SignBeforeEncrypt" messageSecurityVersion="WSSecurity11WSTrust13WSSecureConversation13WSSecurityPolicy12BasicSecurityProfile10"                          requireSignatureConfirmation="false"&gt;                          &lt;localClientSettings detectReplays="true" /&gt;                          &lt;localServiceSettings detectReplays="true" /&gt;                      &lt;/security&gt;                      &lt;textMessageEncoding messageVersion="Soap11WSAddressing10" /&gt;                      &lt;httpTransport /&gt;                  &lt;/binding&gt; ... &lt;client&gt; &lt;endpoint address="http://icenterv01.ptcnet.ptc.com:80/Windchill/servlet/SEP082015"                  binding="customBinding" bindingConfiguration="SEP082015ImplPortBinding"                  contract="WCF_A.SEP082015Impl" name="SEP082015ImplPort" /&gt; &lt;/client&gt; </code></pre>  <p>In order to get the WCF to work I used the following code:</p>  <pre><code>Dim client As New WCF_A.SEP082015ImplClient         client.Endpoint.EndpointBehaviors.Add(New WindchillInspectorBehavior)         client.ClientCredentials.UserName.UserName = "jl"         client.ClientCredentials.UserName.Password = "ptc"         client.ClientCredentials.ServiceCertificate.SetDefaultCertificate(StoreLocation.CurrentUser, _                     StoreName.TrustedPeople, X509FindType.FindBySubjectName, "icenterv01.ptcnet.ptc.com") </code></pre>