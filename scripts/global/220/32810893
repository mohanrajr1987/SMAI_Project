<p>I have to implement De La Brandais Trie from scratch and add all the words to the trie from a dictionary.txt file which contains 500 words, one word/line. Eventually I need to make the trie like a password checking thing. User is allowed to input a 5 character long password, and I need to check the entire trie to see if their input is included, if it is then it's a bad password I will ask them to provide another one. If not, then it's a good password, my job is done. </p>  <p>But right now I'm having trouble with the Node class when I test the add method. I'm really confused because Eclipse tells me that it can't find "dictionary.txt" but when I ran on terminal it tells me Exception in thread "main" <code>java.lang.NullPointerException</code> at DLB$Node.access$400(DLB.java:168). </p>  <p>Why am I getting different error messages? And how can i fix this? </p>  <p>If you can also help me with the search method it would be fantastic. Once again, appreciate your help guys! </p>  <p>Here's my code so far:</p>  <pre><code>import java.util.; import java.io.;  public class DLB {      boolean isEmpty = true; // THIS INDICATES IF THE TRIE IS EMPTY     Node rootNode; // THIS IS THE VERY FIRST NODE IN THE TRIE, THE HEAD OF THE TOPMOST LINKEDLIST      public static void main(String args[]) throws IOException {         DLB newDLB = new DLB();         newDLB.generateDicTrie(); //CALL THE METHOD TO GENERATE A TRIE THAT HAS ALL THE WORDS FROM DICTIONARY.TXT - BAD PASSWORDS         // SCAN GETS USER INPUT         Scanner scan = new Scanner(System.in);          // IF USER ENTERS NOTHING, DISPLAY A WARNING MESSAGE         if (args.length == 0) {             System.out.println("Please provide a password. Or you can terminate the program - quit");             // THEN WAIT FOR ANOTHER USER INPUT             String input = scan.nextLine();             // DECIDE IF USER WANTS TO QUIT              while (!input.equalsIgnoreCase("quit")) {                 if (input.length() == 0) {                     System.out.println("Please provide a password. Or you can terminate the program - quit");                     input = scan.nextLine();                 } // IF ENTERS -g, GO TO ANOTHER METHOD AND GENERATE THE LIST OF GOOD PASSWORDS.                 else if (input.equalsIgnoreCase("-g")) {                     //TO DO                 } else {                     // CHECK PASSWORD                     //boolean password = checkPassword(input);                     System.out.println(newDLB.rootNode.value);                       //TO DO                     }             }             return;         }     }  // IN THIS METHOD, WE SEARCH THROUGH THE TRIE AND CHECK IF THE PASSWORD IS INCLUDED, IF SO IT IS A BAD PASSWORD, IF NOT, IT IS A GOOD PASSWORD.     boolean checkPassword(String input) throws IOException {         return search(input); // RETURN RESULTS FROM search(String s), true IF FOUND, WHCICH MEANS IT IS A BAD PASSWORD. false IF NOT FOUND, WHICH MEANS IT IS A GOOD PASSWORD.     }  //WE NEED TO GENERATE A TRIE THAT HAS ALL THE WORDS FROM DICTIONARY.TXT - BAD PASSWORDS     void generateDicTrie() throws IOException {         //TO DO          BufferedReader read = new BufferedReader(new FileReader("dictionary.txt"));         String line;         while ((line = read.readLine()) != null) {             add(line); // PASS THE WORD TO ADD         }         read.close();     }  //ADD THE WORD FROM THE DICTIONARY, s is the word     void add(String s) {         //TO DO         if (isEmpty) {             if (s.length() == 1) {                 rootNode = new Node(s.charAt(0), null, null);                   // SET UP ROOTNODE (letter, nextNode, childNode)                 rootNode.end = true;                                            // INDICATES THAT THIS IS THE END OF THE WORD                 return;             } else {                 rootNode = new Node(s.charAt(0), null, null);                   // SET UP ROOTNODE                 for (int i = 1; i &lt; s.length(); ++i) {                            // ADD THE FIRST WORD                     rootNode.child = new Node(s.charAt(i), null, null);                     rootNode = rootNode.child;                 }                 rootNode.end = true;                                            //SET END TO FALSE, END OF THE WORD             }             isEmpty = false;                                                    // SET isEmpty TO false NOW BECAUSE WE HAVE ALREADY SET UP THE ROOTNODE.         }          Node currentNode = rootNode;         for (int i = 0; i &lt; s.length();) {             int notFound = 0;                                                       // A FLAG TO CHECK IF THE LETTER WAS EVER FOUND, IF NOT WE ADD THE LETTER AT THE END             if (currentNode.next != null) {                                       // NEED NEXTNODE TO EXIST TO CHECK ITS LETTER                    if (currentNode.value != s.charAt(i)) {                           // CHECK ROW                     currentNode = currentNode.next;                     ++notFound;                 } else {                                                           // CHECK COLUMN                     ++i;                     currentNode = currentNode.child;                     ++notFound;                 }             }             if (currentNode.next == null &amp;&amp; currentNode.value == s.charAt(i) &amp;&amp; notFound == 0) {                 ++i;                 currentNode = currentNode.child;                 ++notFound;             }             //NOT FOUND, SO WE ADD THE LETTER             if (notFound == 0) {                 currentNode.next = new Node(s.charAt(i), null, null);                 currentNode = currentNode.next;                 for (int j = i + 1; j &lt; s.length(); ++j) {                     currentNode.child = new Node(s.charAt(j), null, null);                     currentNode = currentNode.child;                 }                 currentNode.end = true;                 break;             }         }      }      boolean search(String s) {         //TO DO           return false;     }      private class Node {          private Node next;         private Node child;         private char value;         private boolean end = false;          private Node(char letter, Node nextNode, Node childNode) {             this.value = letter;// THE LETTER IN THE NODE             this.next = nextNode;// NEXT NODE             this.child = childNode; // CHILD NODE         }     } } </code></pre>