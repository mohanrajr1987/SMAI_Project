<p>I have a program (say, "prog")  written in C that makes many numerical operations. I want to write  a "driver" utility in python that runs the "prog" with different configurations in a parallel way, reads its outputs and logs them. There are several issues to take into account:</p>  <ol> <li>All sort of things can go bad any time so logging has to be done as soon as possible after any <code>prog</code> instance finishes.</li> <li>Several <code>prog</code>s can finish simultaneously so logging should be done centralized</li> <li>workers may be killed somehow and <code>driver</code> has to handle that situation properly</li> <li>all workers and logger must be terminated correctly without tons of backtraces when <code>KeyboardInterrupt</code> is handled</li> </ol>  <p>The first two points make me think that all workers have to send their results to some centralized <code>logger</code> worker through for example <code>multiprocessing.Queue</code>. But it seems that the third point makes this solution a bad one because if a worker is killed the queue is going to become corrupted. So the Queue is not suitable. Instead I can use multiple  process to process pipes (i.e. every worker is connected through the pipe with a logger). But then the other problems raise:</p>  <ol> <li>reading from pipe is a blocking operation so one logger can't read asynchronously from several workers (use threads?)</li> <li>if a worker is killed and a pipe is corrupted, how the logger can diagnose this?</li> </ol>  <p>P.S. point #4 seems to be solveable -- a have to</p>  <ol> <li><p>disable default SIGINT handling in all workers and logger;</p></li> <li><p>add <code>try except</code> block to main process that makes <code>pool.terminate();pool.join()</code> calls in case of SIGINT exception handled.</p></li> </ol>  <p>Could you please suggest a better design approach if possible and if not than how to tackle the problems described above?</p>  <p>P.S. python 2.7</p>