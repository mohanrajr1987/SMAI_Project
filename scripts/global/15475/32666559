<p>If I write a class with a class variable, generate two class objects, and change the value of the class variable by using a method of one of the two objects, the class variable value is of course also changed for the other object. Here's what I mean in code:</p>  <pre><code>class DemoClass:     ClassVariable = False      def __init__(self):         pass      def do(self):         print(DemoClass.ClassVariable)         DemoClass.ClassVariable = True   class1 = DemoClass() class1.do()  # False class2 = DemoClass() class2.do()  # True </code></pre>  <p>However, if I do the same with multiprocessing.Process, it does not work. The class variable value will only change for the object that changed it:</p>  <pre><code>import multiprocessing  class DemoProcess(multiprocessing.Process):     ClassVariable = False      def __init__(self):         multiprocessing.Process.__init__(self)      def run(self):         print(DemoProcess.ClassVariable)         DemoProcess.ClassVariable = True         print(DemoProcess.ClassVariable)   if __name__ == '__main__':     process_list = []     p1 = DemoProcess()     process_list.append(p1)     p1.start()  # False True     p2 = DemoProcess()     process_list.append(p2)     p2.start()  # False True; should be: True True      for p in process_list:         p.join() </code></pre>  <p>The code behaves as if each process generates a new class variable. Am I doing something wrong?</p>