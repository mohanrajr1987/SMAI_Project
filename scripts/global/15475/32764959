<p>I have the following program which is a Boggle solver:</p>  <pre><code>import logging import multiprocessing from random import choice from string import ascii_uppercase   def get_grid(size=None, letters=None):     if size:         grid = {(x, y): choice(ascii_uppercase) for x in range(size[0]) for y in                 range(size[1])}     elif letters:         grid = {}         rows = letters.split()         for y, row in enumerate(rows):             for x, letter in enumerate(row):                 grid[x, y] = letter      return grid   def print_grid(grid):     s = ''     for y in range(size[1]):         for x in range(size[0]):             s += grid[x, y] + ' '         s += '\n'      print s   def get_neighbours():     neighbours = {}     for position in grid:         x, y = position         positions = [(x - 1, y - 1), (x, y - 1), (x + 1, y - 1), (x + 1, y),                      (x + 1, y + 1), (x, y + 1), (x - 1, y + 1), (x - 1, y)]         neighbours[position] = [p for p in positions if                                 0 &lt;= p[0] &lt; size[0] and 0 &lt;= p[1] &lt; size[1]]     return neighbours   def get_wordlist():     stems = set()     wordlist = set()      with open('words.txt') as f:         for word in f:             word = word.strip().upper()             wordlist.add(word)              for i in range(len(word)):                 stems.add(word[:i + 1])     return wordlist, stems   def path_to_word(path):     return ''.join([grid[p] for p in path])   def search(path):     word = path_to_word(path)      if word not in stems:         return      if word in wordlist:         paths.append(path)      for next_pos in neighbours[path[-1]]:         if next_pos not in path:             search(path + [next_pos])   def get_words():     for position in grid:         logging.info('searching %s' % str(position))         search([position])     return {path_to_word(p) for p in paths}  if __name__ == '__main__':      logging.basicConfig(level=logging.WARNING)     size = 4, 4     grid = get_grid(size=size)     print_grid(grid)     neighbours = get_neighbours()     wordlist, stems = get_wordlist()     paths = []      #words = get_words()      pool = multiprocessing.Pool(processes=4)     results = pool.map(search, grid)     words = [path_to_word(p) for p in paths]      print sorted(words, key=len, reverse=True) </code></pre>  <p>When I run it I get the following message:</p>  <pre><code>   Traceback (most recent call last):      File "C:/Users/will/PycharmProjects/boggle/boggle.py", line 103, in &lt;module&gt;        results = pool.map(search, grid)      File "C:\Python27\lib\multiprocessing\pool.py", line 251, in map        return self.map_async(func, iterable, chunksize).get()      File "C:\Python27\lib\multiprocessing\pool.py", line 567, in get        raise self._value    NameError: global name 'grid' is not defined </code></pre>  <p>The program works fine when I don't try to use multiprocessing module, i.e. comment out the 3 lines:</p>  <pre><code>pool = multiprocessing.Pool(processes=4) results = pool.map(search, grid) words = [path_to_word(p) for p in paths] </code></pre>  <p>and uncomment:</p>  <pre><code>words = get_words() </code></pre>  <p>I'm guessing that multiprocessing changes variable scoping somehow?</p>