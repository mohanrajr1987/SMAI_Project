<p>Consider the following multiprocessing python program:</p>  <pre><code>import multiprocessing as mp from math import sqrt  def funcA(mylist):     worker_poolA = mp.Pool()     jobs = mylist     results = worker_poolA.map(sqrt, jobs)     worker_poolA.close()     worker_poolA.join()     return results  def funcB():     worker_poolB = mp.Pool()     jobs = [[0, 1, 4, 9, 16, 25],[25, 4, 16, 0,1]]     finalresults = worker_poolB.map(funcA, jobs)     worker_poolB.close()     worker_poolB.join()     print finalresults  def funcC():     jobs = [[0, 1, 4, 9, 16, 25],[25, 4, 16, 0,1]]     for job in jobs:         print funcA(job)  if __name__ == "__main__":     funcC()  #works fine     funcB()  #ERROR: AssertionError: daemonic processes are not allowed to have children </code></pre>  <p>In order to overcome this issue, I then Subclassed the multiprocesing.pool.Pool module and set the daemon flag to False as suggested in this <a href="http://stackoverflow.com/questions/6974695/python-process-pool-non-daemonic">post</a> . But now it is resulting in creation of zombie process. What is the right way to call a pool function from another pool function? Is this design flawed? I am using python 2.6.</p>