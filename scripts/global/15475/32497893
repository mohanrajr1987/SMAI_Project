<p>I've found that numpy.fft.fft (and its variants) very slow when run in the background.  Here is an example of what I'm talking about  </p>  <pre><code>import numpy as np import multiprocessing as mproc import time import sys  # the producer function, which will run in the background and produce data def Producer(dataQ):     numFrames = 5     n = 0     while n &lt; numFrames:         data = np.random.rand(3000, 200)         dataQ.put(data)   # send the datta to the consumer         time.sleep(0.1)  # sleep for 0.5 second, so we dont' overload CPU         n += 1              # the consumer function, which will run in the backgrounnd and consume data from the producer def Consumer(dataQ):     while True:         data = dataQ.get()         t1 = time.time()         fftdata = np.fft.rfft(data, n=3000*5)         tDiff = time.time() - t1         print("Elapsed time is %0.3f" % tDiff)         time.sleep(0.01)         sys.stdout.flush()  # the main program  if __name__ == '__main__': is necessary to prevent this code from being run # only when this program is started by user if __name__ == '__main__':          data = np.random.rand(3000, 200)     t1 = time.time()     fftdata = np.fft.rfft(data, n=3000*5, axis=0)     tDiff = time.time() - t1     print("Elapsed time is %0.3f" % tDiff)      # generate a queue for transferring data between the producedr and the consumer     dataQ = mproc.Queue(4)      # start up the processoso     producerProcess = mproc.Process(target=Producer, args=[dataQ], daemon=False)     consumerProcess = mproc.Process(target=Consumer, args=[dataQ], daemon=False)     print("starting up processes")      producerProcess.start()     consumerProcess.start()     time.sleep(10) # let program run for 5 seconds      producerProcess.terminate()     consumerProcess.terminate() </code></pre>  <p>The output it produes on my machine:</p>  <pre><code>Elapsed time is 0.079 starting up processes Elapsed time is 0.859 Elapsed time is 0.861 Elapsed time is 0.878 Elapsed time is 0.863 Elapsed time is 0.758 </code></pre>  <p>As you can see, it is roughly 10x slower when run in the background, and I can't figure out why this would be the case. The time.sleep() calls should ensure that the other process (the main process and producer process) aren't doing anything when the FFT is being computed, so it should use all the cores. I've checked CPU utilization through Windows Task Manager and it seems to use up about 25% when numpy.fft.fft is called heavily in both the single process and multiprocess cases. </p>  <p>Anyone have an idea whats going on?</p>