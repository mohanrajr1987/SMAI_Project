<p>I am developping a script where I create objects at random but I don't want duplicates. They are stored and each time I create a new one I check it against the already existing ones. As I want to do it for large numbers of objects, I am now trying to parallelize it but so far with no success. I tried some solutions found on the web (mainly here in fact) but still not working.</p>  <p>The idea is that I launch a pool and map my function to it. When a process finds a match, it sets a value to 1. This value is readable by all processes, they can write it using a lock and I need it at the end to return. Thus I made a <code>Lock</code> and a <code>Value</code>, so that all processes can read the value (hence the <code>lock=False</code>) and check if a match has been found in another process. Then I tried something different with an <code>Event</code> and checking if it is set but this is still not working... I then tried to raise a special <code>Exception</code> but still no success in making the code to a success.</p>  <p>Please, I prefer to program OOP, so I will avoid until my last resource to define a <code>global</code> variable as I regard them as unsure (personal opinion).</p>  <p>Here is a MWE, I replaced my complicated objects by <code>int</code> and my stored objects by a <code>range(10000)</code> to help you understand.</p>  <pre><code>#!/usr/bin/env python3  import multiprocessing as muproc   def ParallelCheck(me):     print(" Testing {}...".format(me))     #manager = muproc.Manager()     #lock = manager.Lock()     lock = muproc.Lock()     back = muproc.Value("i", 0, lock=False)     ParChild = ParallelChild(me, lock, back)     with muproc.Pool() as pool:         try:             pool.map(ParChild.run, range(10000))         except AbortPool:             pool.terminate()             print("pool")     return back.value   def Computation(me, neighbour):     return me == neighbour    class ParallelChild(object):     def __init__(self, me, lock, back):         self.abort = muproc.Event()         self.lock = lock         self.me = me         self.back = back      def run(self, neighbour):         print("run")         if self.abort.is_set():             print("Aborting")             pass         else:             if Computation(self.me, neighbour):                 self.lock.acquire()                 self.abort.set()                 self.back.value = 1                 print("GOTCHA")                 self.lock.release()                 raise AbortPool             else:                 print("...")   class AbortPool(Exception):     #pass     def __init__(self):         ## Just to check         print("AbortPool raised!")    if __name__ == "__main__":     values = [12000, 13, 7]     for v in values:         print("value={} match={}".format(v, ParallelCheck(v))) </code></pre>  <p>Now it yields a <code>RunTimeError</code>:</p>  <pre><code>me@stigepc4$ python3 mwe.py   Testing 12000... Traceback (most recent call last):   File "mwe.py", line 63, in &lt;module&gt;     print("value={} match={}".format(v, ParallelCheck(v)))   File "mwe.py", line 16, in ParallelCheck     pool.map(ParChild.run, range(10000))   File "/usr/lib/python3.4/multiprocessing/pool.py", line 260, in map     return self._map_async(func, iterable, mapstar, chunksize).get()   File "/usr/lib/python3.4/multiprocessing/pool.py", line 599, in get     raise self._value   File "/usr/lib/python3.4/multiprocessing/pool.py", line 383, in _handle_tasks     put(task)   File "/usr/lib/python3.4/multiprocessing/connection.py", line 206, in send     self._send_bytes(ForkingPickler.dumps(obj))   File "/usr/lib/python3.4/multiprocessing/reduction.py", line 50, in dumps     cls(buf, protocol).dump(obj)   File "/usr/lib/python3.4/multiprocessing/sharedctypes.py", line 128, in reduce_ctype     assert_spawning(obj)   File "/usr/lib/python3.4/multiprocessing/context.py", line 347, in assert_spawning     ' through inheritance' % type(obj).__name__ RuntimeError: c_int objects should only be shared between processes through inheritance </code></pre>  <p>I guess it has something to do with the <code>Lock</code> (though the commented <code>Manager</code> but this did not work any better) or with the <code>Value</code> but now idea how to get rid of it...</p>  <p><strong>Edit</strong></p>  <p>As I continue to try to change my code to work the way I want it to, I realize I did not mention what my main problem was. My real difficulty is to have all the process in the pool stop if a match is found. This is what I need so that running parallel is better than serial. For now I can have an event to tell the child run if a match was already found or not, but it keeps looping through the data, even if I raise an exception...</p>  <p><strong>Edit 2</strong></p>  <p>Simply put, I have the following...</p>  <pre><code>for o in objects:     if too_close(o, existing_objects):         return 1 return 0 </code></pre>  <p>...that I want to distribute among CPUs in something like...</p>  <pre><code>for o in objects:     if too_close(o, some_existing_objects):         return 1 and abort other processes return 0 </code></pre>