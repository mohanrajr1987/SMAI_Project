<p>For a couple weeks I have been trying to solve a problem with a multiprocessing module in python (2.7.x)</p>  <p><strong>Idea:</strong></p>  <p>Lets have Message Queue (RabbitMQ in our case). Create a listener on that queue and on the message spawn task which will process that message.</p>  <p><strong>Problem:</strong></p>  <p>Everything works fine, but after a couple hundred tasks, some sub-processes became zombies which is the main problem.</p>  <p>We have also some limitation (such as max number of tasks per machine) - which in the end leads that the machine stops processing any task.</p>  <p><strong>Current implementation:</strong></p>  <p>I created minimal code which should explain our approach </p>  <pre><code># -*- coding: utf-8 -*- from multiprocessing import Process import signal from threading import Lock   class Task(Process):      def __init__(self, data):         super(Task, self).__init__()         self.data = data      def run(self):         # ignore sigchild signals in subprocess         signal.signal(signal.SIGCHLD, signal.SIG_DFL)         self.do_job() # long job there         pass      def do_job(self):         # very long job         pass   class MQListener(object):      def __init__(self):         self.tasks = []         self.tasks_lock = Lock()         self.register_signal_handler()         mq = RabbitMQ()         mq.listen("task_queue", self.on_message)      def register_signal_handler(self):         signal.signal(signal.SIGCHLD, self.on_signal_received)      def on_signal_received(self, *_):         self._check_existing_processes()      def on_message(self, message):         # ack message and create task         task = Task(message)         with self.tasks_lock:             self.tasks.append(task)             task.start()         pass      def _check_existing_processes(self):         """         go over all created task, if some is not alive - remove them from tasks collection         """         try:             with self.tasks_lock:                 running_tasks = []                 for w in self.tasks:                     if not w.is_alive():                         w.join()                     else:                         running_tasks.append(w)                  self.tasks = running_tasks         except Exception:             # log             pass    if __name__ == '__main__':     m = MQListener() </code></pre>  <p>I'm quite open to use some library for that - if you can recommend some, that will be great as well.</p>