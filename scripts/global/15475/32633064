<p>I've been studying Python multiprocessing capabilities recently and encountered an issue with the following code</p>  <pre><code>import syslog from multiprocessing import Pool def launcher(i):     time.sleep(i)     syslog.openlog( 'test', 0, syslog.LOG_LOCAL4 )     syslog.syslog( '{} {}'.format(i,datetime.now()))  if __name__ == '__main__':     pool=Pool(8)     pool.map(launcher,range(1,3000))     pool.close()     pool.join() </code></pre>  <p>The idea behind it is simple: I need to get a stead flow of messages in my syslog (one message per second), but I want to spawn it across 8 worker-processes with multiprocessing Pool.</p>  <p>In my syslog (which is local /var/log/syslog on my Ubuntu) I've got the following</p>  <pre><code>Sep 17 17:17:57 test: 1 2015-09-17 17:17:57.225699 Sep 17 17:17:58 test: 2 2015-09-17 17:17:58.226957 Sep 17 17:18:00 test: 3 2015-09-17 17:18:00.229196 Sep 17 17:18:03 test: 4 2015-09-17 17:18:03.232390 Sep 17 17:18:07 test: 5 2015-09-17 17:18:07.236587 Sep 17 17:18:12 test: 6 2015-09-17 17:18:12.241737 Sep 17 17:18:18 test: 7 2015-09-17 17:18:18.247926 Sep 17 17:18:25 test: 8 2015-09-17 17:18:25.255169 Sep 17 17:18:29 test: 9 2015-09-17 17:18:29.258229 Sep 17 17:18:33 test: 10 2015-09-17 17:18:33.263454 Sep 17 17:18:42 test: 64 2015-09-17 17:18:42.272675 Sep 17 17:18:52 test: 33 2015-09-17 17:18:52.283012 Sep 17 17:19:01 test: 11 2015-09-17 17:19:01.290070 Sep 17 17:19:02 test: 12 2015-09-17 17:19:02.259826 </code></pre>  <p>Firstly, the flow is not uniform and, secondly, out of order.</p>  <p>What can be the cause if that?</p>  <p>Why linux process scheduler work like that with Python multiprocessing?</p>  <p>Is there any way to solve my task with multiprocessing at all?</p>