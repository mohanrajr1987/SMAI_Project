<p>I am using RestSharp (version 105.2.3.0 in Visual Studio 2013, .net 4.5) to call a NodeJS hosted webservice.  One of the calls I need to make is to upload a file.  Using a RESTSharp request, if I retrieve the stream from my end into a byte array and pass that to AddFile, it works fine.  However, I would much rather stream the contents and not load up entire files in server memory (the files can be 100's of MB).</p>  <p>If I set up an Action to copy my stream (see below), I get an exception at the "MyStream.CopyTo" line of System.Net.ProtocolViolationException (Bytes to be written to the stream exceed the Content-Length bytes size specified).  This exception is thrown withinin the Action block after client.Execute is called.</p>  <p>From what I read, I should not be manually adding a Content-Length header, and it doesn't help if I do.  I have tried setting CopyTo buffer to small and large values, as wel as omitting it entirely, to no avail.  Can somebody give me a hint on what I've missed?</p>  <pre><code>    // Snippet...     protected T PostFile&lt;T&gt;(string Resource, string FieldName, string FileName,         string ContentType, Stream MyStream,          IEnumerable&lt;Parameter&gt; Parameters = null) where T : new()     {         RestRequest request = new RestRequest(Resource);         request.Method = Method.POST;          if (Parameters != null)         {             // Note:  parameters are all UrlSegment values             request.Parameters.AddRange(Parameters);         }          // _url, _username and _password are defined configuration variables         RestClient client = new RestClient(_url);         if (!string.IsNullOrEmpty(_username))         {             client.Authenticator = new HttpBasicAuthenticator(_username, _password);         }          /*         // Does not work, throws System.Net.ProtocolViolationException,         // Bytes to be written to the stream exceed the          // Content-Length bytes size specified.         request.AddFile(FieldName, (s) =&gt;         {             MyStream.CopyTo(s);             MyStream.Flush();         }, FileName, ContentType);         */          // This works, but has to load the whole file in memory         byte[] data = new byte[MyStream.Length];         MyStream.Read(data, 0, (int) MyStream.Length);         request.AddFile(FieldName, data, FileName, ContentType);          var response = client.Execute&lt;T&gt;(request);          // check response and continue...     } </code></pre>