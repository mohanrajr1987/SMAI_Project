<p>I'm trying to down/upload a file with retrofit 2 but can't find any tutorials examples on how to do so. My code for downloading is:</p>  <pre><code>@GET("documents/checkout") public Call&lt;File&gt; checkout(@Query(value = "documentUrl") String documentUrl, @Query(value = "accessToken") String accessToken, @Query(value = "readOnly") boolean readOnly); </code></pre>  <p>and</p>  <pre><code>Call&lt;File&gt; call = RetrofitSingleton.getInstance(serverAddress)                 .checkout(document.getContentUrl(), apiToken, readOnly[i]); call.enqueue(new Callback&lt;File&gt;() {         @Override         public void onResponse(Response&lt;File&gt; response,                 Retrofit retrofit) {             String fileName = document.getFileName();             try {                 System.out.println(response.body());                 long fileLength = response.body().length();                 InputStream input = new FileInputStream(response.body());                 File path = Environment.getExternalStorageDirectory();                 File file = new File(path, fileName);                 BufferedOutputStream output = new BufferedOutputStream(                         new FileOutputStream(file));                 byte data[] = new byte[1024];                  long total = 0;                 int count;                 while ((count = input.read(data)) != -1) {                     total += count;                     output.write(data, 0, count);                 }                  output.flush();                  output.close();             } catch (IOException e) {                 String logTag = "TEMPTAG";                 Log.e(logTag, "Error while writing file!");                 Log.e(logTag, e.toString());             }         }         @Override         public void onFailure(Throwable t) {             // TODO: Error handling             System.out.println(t.toString());         }     }); </code></pre>  <p>I've tried with Call and Call but nothing seems to work.</p>  <p>The server-side code writes the file's bytes into HttpServletResponse's output stream after setting the headers and mime type correctly.</p>  <p>What am I doing wrong?</p>  <p>Finally, the upload code:</p>  <pre><code>@Multipart @POST("documents/checkin") public Call&lt;String&gt; checkin(@Query(value = "documentId") String documentId, @Query(value = "name") String fileName, @Query(value = "accessToken") String accessToken, @Part("file") RequestBody file); </code></pre>  <p>and</p>  <pre><code>RequestBody requestBody = RequestBody.create(MediaType.parse(document.getMimeType()), file);              Call&lt;String&gt; call = RetrofitSingleton.getInstance(serverAddress).checkin(documentId, document.getFileName(), apiToken, requestBody);             call.enqueue(new Callback&lt;String&gt;() {                 @Override                 public void onResponse(Response&lt;String&gt; response, Retrofit retrofit) {                     System.out.println(response.body());                 }                  @Override                 public void onFailure(Throwable t) {                     System.out.println(t.toString());                 }             }); </code></pre>  <p>Thanks!</p>  <p><strong>Edit:</strong> </p>  <p>After the answer, downloading only yields a corrupted file (without the @Streaming), uploading doesn't as well. When I use the above code, the server returns a 400 error. After changing it to</p>  <pre><code>RequestBody requestBody = RequestBody.create(MediaType.parse(document.getMimeType()), file);             MultipartBuilder multipartBuilder = new MultipartBuilder();             multipartBuilder.addFormDataPart("file", document.getFileName(), requestBody);              Call&lt;String&gt; call = RetrofitSingleton.getInstance(serverAddress).checkin(documentId, document.getFileName(), apiToken, multipartBuilder.build()); </code></pre>  <p>, the request executes but the backend doesn't seem to receive a file.</p>  <p>Backend code:</p>  <pre><code>@RequestMapping(value = "/documents/checkin", method = RequestMethod.POST) public void checkInDocument(@RequestParam String documentId,         @RequestParam String name, @RequestParam MultipartFile file,         @RequestParam String accessToken, HttpServletResponse response) </code></pre>  <p>What am I doing wrong? I was able to use the backend from plain Java with the Apache HttpClient:</p>  <pre><code>    MultipartEntityBuilder builder = MultipartEntityBuilder.create();     builder.setMode(HttpMultipartMode.BROWSER_COMPATIBLE);     builder.addBinaryBody("file", new File("E:\\temp\\test.jpg"));     HttpEntity httpEntity = builder.build();     System.out.println("HttpEntity " + EntityUtils.toString(httpEntity.));     HttpPost httpPost = new HttpPost(uri);     httpPost.setEntity(httpEntity); </code></pre>  <p><strong>Edit v2</strong></p>  <p>For anyone interested, both up- and downloading work now: These are the solutions:</p>  <p>Service:</p>  <pre><code>@GET("documents/checkout") public Call&lt;ResponseBody&gt; checkout(@Query(value = "documentUrl") String documentUrl, @Query(value = "accessToken") String accessToken, @Query(value = "readOnly") boolean readOnly);  @Multipart @POST("documents/checkin") public Call&lt;String&gt; checkin(@Query(value = "documentId") String documentId, @Query(value = "name") String fileName, @Query(value = "accessToken") String accessToken, @Part("file") RequestBody file); </code></pre>  <p>Download Code:</p>  <pre><code>    Call&lt;ResponseBody&gt; call = RetrofitSingleton.getInstance(serverAddress)                 .checkout(document.getContentUrl(), apiToken, readOnly[i]);         call.enqueue(new Callback&lt;ResponseBody&gt;() {             @Override             public void onResponse(Response&lt;ResponseBody&gt; response,                     Retrofit retrofit) {                 String fileName = document.getFileName();                  try {                     File path = Environment.getExternalStorageDirectory();                     File file = new File(path, fileName);                     FileOutputStream fileOutputStream = new FileOutputStream(file);                     IOUtils.write(response.body().bytes(), fileOutputStream);                 } catch (IOException e) {                     Log.e(logTag, "Error while writing file!");                     Log.e(logTag, e.toString());                 }             }              @Override             public void onFailure(Throwable t) {                 // TODO: Error handling                 System.out.println(t.toString());             }         }); </code></pre>  <p>Upload Code:</p>  <pre><code>    Call&lt;String&gt; call = RetrofitSingleton                     .getInstance(serverAddress).checkin(documentId,                             document.getFileName(), apiToken,                             multipartBuilder.build());             call.enqueue(new Callback&lt;String&gt;() {                 @Override                 public void onResponse(Response&lt;String&gt; response,                         Retrofit retrofit) {                     // Handle response here                 }                  @Override                 public void onFailure(Throwable t) {                     // TODO: Error handling                     System.out.println("Error");                     System.out.println(t.toString());                 }             }); </code></pre>