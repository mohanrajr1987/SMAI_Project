<p>After a long work hours on this, i couldn't get any success with <code>multi-threading</code> with this method. i really appreciate your help.</p>  <p>i have a <code>listview</code> and in it first column has urls that we will need later in other methods. seconds column is for the result.</p>  <p>I'm creating two <code>ArrayLists</code> with urls and sending them(urls with arraylist) to the method, then in the method, with a <code>httpwebrequest</code>, i'm getting the page title from each url.</p>  <p>So the problem is when i try to fire <code>5 threads</code>, it works like :</p>  <p>(U : url, R: result)</p>  <p>u1 = r1 ( so, i must get u1's result as r1..) </p>  <p>but i'm getting like :</p>  <p>u1 = r1, u2 = r1, u3(or4) = r1, u4 = r1, u5=r2(or3,4)</p>  <p>but what i expecting : u1=r1, u2=r2, u3=r3, u4=r4...</p>  <p>For better explanation please check <strong>the pictures below</strong></p>  <p>then i tried to use <code>Lock</code> keyword with a private object but then i lost <code>multi-threading</code>.it works as i excepted but one by one. not fire 5 different threads at the same time and waits finishing the thread 1 for move to the next thread.</p>  <p>///Main Class///</p>  <pre><code>/* A store of all created threads. */ ArrayList _threads = new ArrayList(); /* A store of all FileDownloader objects. */ ArrayList _instances = new ArrayList(); private int _activeDownloadCount = 0; object _lockObject = new object(); </code></pre>  <p>The Button :</p>  <pre><code>_instances = new ArrayList(); _threads = new ArrayList(); _activeDownloadCount = 0;  FileDownloader download = null; foreach (ListViewItem item in listviewUrl.Items) {                  item.SubItems[9].Text = "Not started";              download = new FileDownloader(item.SubItems[0].Text);                    item.Tag = download;                     try     {        ThreadStart tsDelegate = new ThreadStart(download.Download);        download.DownloadStarting += new FileDownloader._delDownloadStarting(download_DownloadStarting);        download.DownloadCompleted += new FileDownloader._delDownloadCompleted(download_DownloadCompleted);         Thread t = new Thread(tsDelegate);        t.Name = item.SubItems[0].Text;        _threads.Add(t);        _instances.Add(download);      }     catch     {          item.SubItems[9].Text = "Error";     } } StartDownload(); </code></pre>  <p>StartDownload Method :</p>  <pre><code>int j = 0; int limit = int.Parse(numThreadSearch.Text); int iCount = 0; lock (_lockObject) {     iCount = _instances.Count; } if (iCount != 0) {     foreach (Thread thread in _threads)     {         FileDownloader file = ((FileDownloader)_instances[j]);         if (file._IsStarted == false)         {             lock (_lockObject)             {                 thread.Start();                  Console.WriteLine(_activeDownloadCount);                 _activeDownloadCount++;             }         }         if (_activeDownloadCount == limit)         {             break;         }         j++;     } } else {     /* If all the files have downloaded, we will do something here. } </code></pre>  <p>when the method completed :</p>  <pre><code> void download_DownloadCompleted(FileDownloader thread, bool isSuccess)         {              lock (_lockObject)             {                 _activeDownloadCount--;              }              PageRankReturns(FileDownloader._PageRankReturn, thread);             RemoveFromInternalPool(thread);             StartDownload();          }            delegate void delSetStatus(string Status, FileDownloader f);       private void PageRankReturns(string Status, FileDownloader f)             {                 if (listviewUrl.InvokeRequired)                 {                     delSetStatus s = new delSetStatus(PageRankReturns);                     this.Invoke(s, new object[] { Status, f });                 }                 else                 {                     foreach (ListViewItem item in listviewUrl.Items)                     {                         if (item.Tag == f)                         {                             /* Use locking to synchronise across mutilple thread calls. */                             lock (_lockObject)                             {                                 item.SubItems[2].Text = Status;                              }                             break;                         }                     }                 }             }     private void RemoveFromInternalPool(FileDownloader thread)         {             int i = 0;             foreach (FileDownloader f in _instances)             {                 if (f == thread)                 {                     /* If the file has downloaded, remove it from our pool. */                     lock (_lockObject)                     {                         _threads.Remove(_threads[i]);                         _instances.Remove(f);                         break;                     }                 }                 i++;             }         } </code></pre>  <p>/// Second Class ///</p>  <pre><code>#region  Fields  private string _DocumentUrl = string.Empty; private string _DirectoryPath = string.Empty; public bool _IsDownloading = false; public bool _IsDownloadSuccessful = false;  public bool _IsStarted = false;  #endregion  #region Delegates public delegate void _delDownloadStarting(FileDownloader thread); public delegate void _delDownloadCompleted(FileDownloader thread, bool isSuccess); public delegate void _delDownloadCWorking(FileDownloader thread);  #endregion  #region Events public event _delDownloadStarting DownloadStarting; public event _delDownloadCompleted DownloadCompleted;  protected static readonly object locker = new object(); public static string pageTitleResult= string.Empty;  public static string _pageTitleResult {     get { return pageTitleResult; } }  public FileDownloader(string documentUrl) {     _DocumentUrl = documentUrl; } </code></pre>  <p>//Download Method // </p>  <pre><code>public void Download() {     _IsStarted = true;     DownloadStarting(this);                 _IsDownloading = true;     _IsDownloadSuccessful = false;      // with lock keyword it works one by one//     //without lock or monitor.enter keyword then it works as i tried explain above u1 = r1, u2 = r1, ur3 = r1, u4=r3 etc...      try     {         string pageHtml = getHtml(_DocumentUrl);         HtmlAgilityPack.HtmlDocument htmlDoc = new HtmlAgilityPack.HtmlDocument();          //html agibility works with returned string from gethtml...       // string pageTitle = html agibility work result, it's string...        pageTitleResult = pageTitle           _IsDownloadSuccessful = true;         _IsDownloading = false;         /* raise a download completed event. */         DownloadCompleted(this, _IsDownloadSuccessful);     }     catch     {         _IsDownloadSuccessful = false;     }    Thread.Sleep(10); } </code></pre>  <p>Lock Object : </p>  <pre><code>protected static readonly object locker = new object(); </code></pre>  <p>Well, I just made an example in excel to show how it works...</p>  <p>This is the return without Lock keyword : <a href="http://i.stack.imgur.com/Fkfo8.png" rel="nofollow"><img src="http://i.stack.imgur.com/Fkfo8.png" alt="Without Lock keyword for method"></a></p>  <p>This is with lock keyword, by the way, in this example, fired 5 threads but it waits first one's end... <a href="http://i.stack.imgur.com/CASQM.png" rel="nofollow"><img src="http://i.stack.imgur.com/CASQM.png" alt="enter image description here"></a></p>  <p>and this is what I'm trying to do... <a href="http://i.stack.imgur.com/NqvZW.png" rel="nofollow"><img src="http://i.stack.imgur.com/NqvZW.png" alt="enter image description here"></a></p>