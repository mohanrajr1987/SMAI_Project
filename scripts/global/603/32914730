<p>so I wanted to change my variable within my for loop over a time interval. In my code, I have my audio callback basically running the following pseudocode:</p>  <pre><code>int start = 0, target = 100; for (int i = 0; i &lt; frames; i++) {     [object makeSineWave];     [object useNum:start];     if (target &gt; start) {         // Increase start over the span of time frame     } } </code></pre>  <p>What I want to do is increase start to the target value over a logarithmic scale within a time interval (lets say 1 second to keep it simple). How would I keep track of time within the for loop of the audio callback? </p>  <p>EDIT: Guess I'm trying to make a filter sweep... I'm guessing it'd be similar to a sine sweep now that I think about it? more code-</p>  <pre><code>OSStatus RenderTone(void *inRefCon,                 AudioUnitRenderActionFlags *ioActionFlags,                 const AudioTimeStamp *inTimeStamp,                 UInt32 inBusNumber,                 UInt32 inNumberFrames,                 AudioBufferList *ioData) {     // Get Audio Data     AudioData *data = (__bridge AudioData *)inRefCon;     static Float32 phs = 0, sub_phs = 0;     Float32 freq = data-&gt;freq;     // Calculate phases     Float32 phs_incr = 2 * M_PI * freq / data-&gt;srate;     Float32 sample;      // Buffers     Float32 *bufL = (Float32 *)ioData-&gt;mBuffers[0].mData;     Float32 *bufR = (Float32 *)ioData-&gt;mBuffers[1].mData;      // Start at 1 hz, target is 500 hz     int start = 1, target = 500;      // Generate Samples     for (UInt32 i = 0; i &lt; inNumberFrames; i++) {         // Sine waveform         sample = sinf(phs);         sample = [data-&gt;filter processFilter:sample fc:start];          // change start here using current time?         // should not increase to target immediately, over span of 1 second          bufL[i] = buf[R] = sample;          // Increment phase         phs += phs_incr;         // Wrap phase         phs = wrapPhase(phs);     } } </code></pre>