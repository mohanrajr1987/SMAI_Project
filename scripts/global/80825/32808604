<p>Using VS-2012, I observed that if there is an lambda expression and it contains a error, the compiler does not show the actual syntactical error. </p>  <p>Take this example:</p>  <pre><code>public class CustomBoostrapper : DefaultNancyBootstrapper {     protected override void RequestStartup(TinyIoCContainer container, IPipelines pipelines, NancyContext context)     {         pipelines.BeforeRequest += ctx =&gt;         {             if(1=1) //the actual error that needs to be corrected             return new Response();         };     } } </code></pre>  <p>The compiler will report two errors, usually: </p>  <pre><code>Operator '+=' cannot be applied to operands of type 'some type' and 'lambda expression' Cannot convert lambda expression to type 'some type' because it is not a delegate type </code></pre>  <p>But it doesn't even bother to report that there is a non-boolean expression in the if() and when corrected, the errors about lambda expressions goes away. The worse thing is that it apparently shows for any kind of compiler error. If one is writing a complex function and make a goof somewhere, they are only left with two very generic errors and must hunt for the actual syntax error (or something similar) within the body. Is there a way to avoid this obfuscation? </p>  <p>Note: this example was noticed when using Nancy framework. I additionally observed that it was not just this particular function but also anywhere else I used a lambda function. At first I thought it was something to do with a compiler but as subsequent comments makes clear, it might not be something to do with the compiler or Visual Studio. </p>  <p>Note #2: I just discovered this only happens with anonymous function. If I define the function and then reference it from the lambda expression instead, the compiler correctly catches the errors within the function. </p>