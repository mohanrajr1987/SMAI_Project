<p>My team runs a custom test suite pretty regularly. When we want to run the whole thing, we do </p>  <pre><code>./manage.py test --keepdb --failfast --settings=AE.test_settings </code></pre>  <p>When we want to run tests on a specific app, we do the same, but with the app name include. </p>  <p>I'd like to make a custom management command that, when called, will run the default test suite, but append the --keepdb, --failfast, and --settings=AE.test_settings params. Ideally something like </p>  <pre><code>./manage.py aetest </code></pre>  <p>That can also be run with app names, such that</p>  <pre><code>./manage.py aetest registration </code></pre>  <p>Would be the same as running </p>  <pre><code>./manage.py test registration --keepdb --failfast --settings=AE.test_settings </code></pre>  <p>My attempt so far is</p>  <pre><code>from django.core.management.base import BaseCommand, CommandError from django.core import management  class Command(BaseCommand):      def handle(self, *args, **kwargs):         positional_arguments = [             '--keepdb',             '--failfast',             '--settings=NJ.test_settings',         ]         for item in args:             positional_arguments.append(item)         keyword_arguments = {             'settings': "AE.test_setings",           }         keyword_arguments.update(kwargs)         management.call_command("test", *positional_arguments, **keyword_arguments) </code></pre>  <p>If I try to pass further positional arguments, my command errors out in such a way as to imply they were never passed. And the keyword argument never makes it to the call_command (the command runs with my default settings.py file)</p>  <p>Any idea how I can have this management command accept additional positional and keyword parameters, but append the desired ones automatically?</p>  <p>Thanks!</p>  <p><strong>UPDATE</strong></p>  <p>I was given the great idea of subclassing BaseTestCommand. While this seems to work for True/False variables, passing the settings variable doesn't seem to work. If I use the following code:</p>  <pre><code>class Command(BaseTestCommand):     def handle(self, *test_labels, **options):         options['failfast'] = True         options['keepdb'] = True         options['settings'] = "AE.test_settings"         print(options)          super(Command, self).handle(*test_labels, **options) </code></pre>  <p>Running my new command uses the failfast and the keepdb, but it still uses the default settings.py for my project. Any idea why this might be?</p>  <p>Side note: running the new command with --settings=AE.test_settings works like a charm</p>