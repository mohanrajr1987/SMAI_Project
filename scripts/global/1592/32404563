<p>My P/Invoke <code>WriteProcessMemory</code> method currently looks like this:</p>  <pre><code>        [DllImport("kernel32", SetLastError = true)]         [return : MarshalAs(UnmanagedType.Bool)]         static extern bool WriteProcessMemory(             IntPtr hProcess,             IntPtr baseAddress,             byte[] bufferToWrite,             uint numBytesToWrite,             out IntPtr numBytesWritten             ); </code></pre>  <p>I need to send a string to the <code>bufferToWrite</code> parameter, but it takes a <code>byte[]</code> so I'm converting it to a <code>byte[]</code> before passing it in.</p>  <p>My issue is that as .NET strings aren't null terminated, it won't write a terminating null to the remote memory. If I was doing this in unmanaged code I'd allocate the length of the string + terminating null, and put all that in the allocated memory since the "string" I'm reading includes the null. But the managed string doesn't include it.</p>  <p>Maybe I could allocate a buffer large enough to include a terminating null, then do another call to <code>WriteProcessMemory</code> to write the null; or I could create a <code>byte[]</code> large enough to hold the string + null, write both to the array, and pass it in like that. </p>  <p>But is there a more elegant solution to this problem?</p>