<p>I'm using a late-bound solution for ActiveX components and COM+ applications so I may use it easily with some VB6 dll's we mantain in the company. As a POC I'm creating a tool to automate COM+ applications deployment. When creating a new blank COM+ application I need to invoke set_Value method, witch works fine with early-bound but fails on late-bound using InvokeMember. I'm using .Net 2.0.</p>  <h1>late-bound set_Value method</h1>  <pre><code>public void SetName(string value) {     base.InvokeMethod("set_Value", new object[] { "Name", value }); } </code></pre>  <h1>Abstract base class</h1>  <pre><code>protected void InvokeMethod(string method, object[] parameters, bool ignoreCase = true) {     this.InvokeMethod&lt;object&gt;(method, parameters, null, ignoreCase); }  private T InvokeMethod&lt;T&gt;(string method, object[] parameters, System.Reflection.ParameterModifier? parametersModifier, bool ignoreCase = true) {     if (parametersModifier.HasValue)     {         return (T)this.COMObjectType.InvokeMember(method,             (ignoreCase)             ? System.Reflection.BindingFlags.IgnoreCase |               System.Reflection.BindingFlags.InvokeMethod             : System.Reflection.BindingFlags.InvokeMethod,             null,             this.COMObject,             parameters,             new System.Reflection.ParameterModifier[] { parametersModifier.Value },             null,             null);     }     else     {         return (T)this.COMObjectType.InvokeMember(method,             (ignoreCase)             ? System.Reflection.BindingFlags.IgnoreCase |               System.Reflection.BindingFlags.InvokeMethod             : System.Reflection.BindingFlags.InvokeMethod,             null,             this.COMObject,             parameters);     } } </code></pre>