<p>There is struct:</p>  <pre><code>    [StructLayout(LayoutKind.Sequential, Pack = 4)]     public struct WAVEFORMATEX     {         public ushort wFormatTag;         public ushort nChannels;         public ushort nSamplesPerSec;         public uint nAvgBytesPerSec;         public ushort nBlockAlign;         public ushort wBitsPerSample;         public ushort cbSize;     };     public WAVEFORMATEX audioInfo = new WAVEFORMATEX(); </code></pre>  <p>With Pack=4 <strong>Marshal.SizeOf(audioInfo)</strong> returns 20 bytes</p>  <p>With Pack=1 - Length = 16 bytes.</p>  <p>On C++ level I do not use any options like "Pack" and sizeof is always = 16</p>  <p>But problem happens when I pass ref to the struct from C# to C++ (Interop).</p>  <p>If it's aligned Pack=4 the result looks correct, when Pack=1, then nAvgBytesPerSec comes with too high (abnormal) value, but others are Ok.</p>  <p>So the missing point is why in C++ the value comes ok with natural length of 16 bytes, but in C# the same value (nAvgBytesPerSec) is ok only with Pack=4 when length is 20 bytes, which is obviously longer up to 4 bytes? What happens on Interop level in that case?  What (who) takes care of alignment and correct transfer data from C++ to C#?</p>