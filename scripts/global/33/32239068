<p>There exists a game, whose state is quantified by <code>n</code> boolean variables <code>p_1</code>, <code>p_2</code>, ..., <code>p_n</code>. Assume <code>0 &lt;= n &lt;= 10</code>. The purpose of the game is to keep track of the state of as many variables as possible, and when they will change states (see below).</p>  <p>Only a subset of the variables may be observed at a time. We are always informed when the state of a variable changes from <code>true</code> to <code>false</code>, but only when the variable in question is being observed are we also informed which variable was changed.</p>  <p>If some <code>p_i</code> changes state from <code>true</code> to <code>false</code> at time <code>t</code>, then it will change state back from <code>false</code> to <code>true</code> at time <code>t + 60</code>.</p>  <p>Here are some example situations and the desired behavior. Assume that there are three variables, <code>p_1</code>, <code>p_2</code>, and <code>p_3</code>.</p>  <ul> <li>All variables are observable. A variable changes state and by observation it is <code>p_1</code>. We know that <code>p_1</code> will change state back at <code>t + 60</code>.</li> <li><code>p_1</code> and <code>p_2</code> are observable. A variable changes state. It should be inferred that it was <code>p_3</code>. We know that <code>p_3</code> will change state back at <code>t + 60</code>.</li> <li><code>p_1</code> is observable, and it is known that <code>p_2</code> changed state to <code>false</code> at time <code>t - 30</code>. A variable changes state. It was not <code>p_1</code> by observation and <code>p_2</code> will only change state to <code>true</code> at <code>t + 30</code>, therefore it was <code>p_3</code>.</li> <li>No variables are observable It is known that <code>p_1</code> changed state to <code>false</code> at time <code>t - 30</code>, <code>p_2</code> changed state to <code>false</code> at <code>t - 75</code>, and <code>p_3</code> changed state to false at <code>t - 80</code>. A variable changes state. At <code>t + 1</code> <code>p_2</code> is observed to have a value of <code>true</code>. Because <code>p_1</code> is still <code>false</code>, and <code>p_2</code> has been observed to be <code>true</code>, it should be inferred that <code>p_3</code> is <code>false</code>, and will change state back to <code>true</code> at <code>t + 60</code>.</li> <li><code>p_1</code> and <code>p_2</code> are observable. It is known that <code>p_3</code> changed state to <code>false</code> at time <code>t - 70</code>. No variable changes state. It should be inferred that <code>p_3</code> is true, since it would have changed from <code>false</code> to <code>true</code> at <code>t - 10</code>, and if it had changed from <code>true</code> to <code>false</code>, we would have been informed of a variable changing state.</li> </ul>  <p>One approach I have tried involved iterating over each of the variables on each notification of a variable state change, and ruling out the possible matches based on:</p>  <ul> <li>whether it was visible and had not changed state</li> <li>whether its last state change is known and not far enough in the past for it to have changed back.</li> </ul>  <p>then, for the leftover variables for which state is known, determining an upper and lower bound on their last variable change based on when the variable was last observed in a particular state, when the variable may have changed state (back, from <code>false</code> to <code>true</code>), etc. Then if there exists only one variable change event within that bounds, it should be the one corresponding to the variable. It ended up being too cumbersome and I didn't continue. Every line was a burden because it seemed as if the number of possible combinations of states was too large and I would not take something into account.</p>  <p>Is the above approach a reasonable one to take, given the problem statement? Is there a general way that problems like this are modeled that allows them to be solved more elegantly?</p>