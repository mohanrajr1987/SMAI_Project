<p>A <a href="https://en.wikipedia.org/wiki/Mealy_machine" rel="nofollow">mealy machine</a> is just a stateful function. Hence, two mealy machines can be composed using simple <a href="https://en.wikipedia.org/wiki/Function_composition" rel="nofollow">function composition</a>. A <a href="https://en.wikipedia.org/wiki/Moore_machine" rel="nofollow">moore machine</a> is a <a href="https://en.wikipedia.org/wiki/Moore_machine#Relationship_with_Mealy_machines" rel="nofollow">restricted mealy machine with an initial output value</a>. Is there a way to compose two moore machines? This is what I tried in Haskell:</p>  <pre class="lang-hs prettyprint-override"><code>type Mealy a b = a -&gt; b -- a stateful function, probably using unsafePerformIO  type Moore a b = (b, Mealy a b) -- output must be consistent with current state  composeMoore :: (c, b -&gt; c) -&gt; (b, a -&gt; b) -&gt; (c, a -&gt; c) composeMoore (x, f) (_, g) = (x,   f . g) --    is this correct? composeMoore (_, f) (y, g) = (f y, f . g) -- or is this correct? </code></pre>  <p>I believe that they are both wrong. In fact, I believe that it's not possible to compose two moore machines. However, I might be wrong. Is there a correct way of composing moore machines?</p>  <p><strong>Defintion:</strong> The composition of moore machines is an operation of the type <code>(.) :: Moore b c -&gt; Moore a b -&gt; Moore a c</code> for which the law of associativity (i.e. <code>h . (g . f) = (h . g) . f</code>) holds true.</p>  <p><strong>Note:</strong> This is just a theoretical question. I am not actually using Haskell to write stateful functions.</p>