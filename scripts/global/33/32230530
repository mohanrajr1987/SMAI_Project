<p>As is well known, permutations for square bit grids can be calculated using a brute force algorithm where an integer loop from <strong>0...((2^cells)-1)</strong> can be converted into each grid permutation using a bit mask. A few examples:</p>  <pre><code>Grid size 2 (4 cells): 0--&gt;15  Grid size 3 (9 cells): 0--&gt;511 </code></pre>  <p>This works well for grids up to a certain size, but for grids of size 7 and greater the sheer number of loop operations gets into the trillions.</p>  <p>What other options are there?</p>  <p>I already have working code for grids up to size 6 but a quick <a href="https://en.wikipedia.org/wiki/Fermi_problem" rel="nofollow">Fermi estimate</a> has a size 7 grid coming out at about 76 years on my workstation with all CPUs at maximum... :-(</p>  <p><strong>Target application</strong></p>  <p>Re the actual application of said grids, this would be pretty much the same as for a <a href="https://en.wikipedia.org/wiki/Nurikabe_(puzzle)" rel="nofollow">Nurikabe puzzle</a> but I'm only interested in grids that can be mirrored across their X or Y axis (preferably both). So some suitable patterns might be a diamond (X &amp; Y), the letter D (Y) or letter A (X).</p>  <p><strong>Existing efficiencies</strong></p>  <p>Due the vagaries of the target application there are many candidates that can be discarded:</p>  <ul> <li>Those that don't create a cell on the edges of the grid</li> <li>Those that cannot be mirrored across the X or Y axis</li> <li>Those where cells are isolated</li> </ul>  <p><strong>Sample output (N=4)</strong></p>  <pre><code>Current value is : 28662  ##  #### ####  ##   Current value is : 40953 #  # #### #### #  #  Current value is : 63087 ####  ##   ##  ####  Current value is : 63903 #### #  # #  # ####  Current value is : 65535 #### #### #### ####  Grid size 4, done in 22 milliseconds </code></pre>