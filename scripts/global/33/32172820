<p>Let's set the context/limitations:</p>  <ol> <li>A linked-list consists of Node objects.</li> <li>Nodes only have a reference to their next node.</li> <li>A reference to the list is only a reference to the head Node object.</li> <li>No preprocessing or indexing has been done on the linked-list other than construction (there are no other references to internal nodes or statistics collected, i.e. length).</li> <li>The last node in the list has a null reference for its next node.</li> </ol>  <p>Below is some code for my proposed solution.</p>  <pre><code>Node cursor = head; Node middle = head;  while (cursor != null) {     cursor = cursor.next;     if (cursor != null) {         cursor = cursor.next;         middle = middle.next;     } } return middle; </code></pre>  <p>Without changing the linked-list architecture (not switching to a doubly-linked list or storing a length variable), is there a more efficient way to find the middle element of singly-linked list?</p>  <hr>  <p>Note: When this method finds the middle of an even number of nodes, it always finds the left middle. This is ideal as it gives you access to both, but if a more efficient method will always find the right middle, that's fine, too.</p>