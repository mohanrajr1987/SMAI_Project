<p>I have been looking into some strategies for an inter-process shared memory data structure that allows growing and shrinking its committed capacity on windows by using a chain of "memory chunks". </p>  <p>One possible way is to use <strong>pagefile backed named memory maps</strong> as the chunk memory. An advantage of this strategy is the possibility to use <code>SEC_RESERVE</code> to reserve a big chunk of memory address space and incrementally allocate it using <code>VirtualAlloc</code> with <code>MEM_COMMIT</code>. Disadvantages appear to be (a) the requirement to have <code>SeCreateGlobalPrivilege</code> permissions to allow using a shareable name in the <code>Global\</code> namespace and (b) the fact that all committed memory contributes to the system commit charge.</p>  <p>To circumvent these disadvantages, I started investigating the use of <strong>temporary file backed memory maps</strong>. I.e. memory maps over files created using the <code>FILE_FLAG_DELETE_ON_CLOSE | FILE_ATTRIBUTE_TEMPORARY</code> flags combination. This appears to be a recommended strategy that according to e.g. <a href="http://blogs.msdn.com/b/larryosterman/archive/2004/04/19/116084.aspx" rel="nofollow">this blog post</a> should prevent flushing the mapped memory to disk (unless memory pressure causes dirty mapped pages to be paged out).  </p>  <p>I am however observing that closing the map/file handle before the owning process exits, causes dirty pages to be flushed to disk. This occurs even if the view/file handle is not the one through which the dirty pages were created and when these views/file handles were opened after the pages were 'dirtied' in a different view. </p>  <p>It appears that changing the order of disposal (i.e. unmapping the view first or closing the file handle first) has some impact on when the disk flush is initiated, but not on the fact that flushing takes place. </p>  <p>So my questions are:</p>  <blockquote>   <ul>   <li>Is there some way to use temporary file backed memory maps and prevent them from flushing dirty pages when the map/file is closed, taking into account that multiple threads within a process/multiple processes may have open handles/views to such a file?</li>   <li>If not, what is/could be the reason for the observed behavior?</li>   <li>Do you know of an alternative strategy that I may have overlooked?</li>   </ul> </blockquote>  <p><strong>UPDATE</strong> Some additional info: When running the "arena1" and "arena2" parts of the sample code below in two separate (independent) processes, with "arena1" being the process that creates the shared memory regions and "arena2" the one that opens them, the following behavior is observed for maps/chunks that have dirty pages:</p>  <ul> <li>If closing the view before the file handle in the "arena1" process, it flushes each of these chunks to disk in what seems a (partially) synchronous process (i.e. it blocks the disposing thread for several seconds), <strong>independent</strong> of whether or not the "arena2" process was started.</li> <li>If closing the file handle before the view, disk flushes only occur for those maps/chunks that are closed in the "arena1" process while the "arena2" process still has an open handle to those chunks, and they appear to be 'asynchronous', i.e. not blocking the application thread.</li> </ul>  <p>Refer to the (c++) sample code below that allows reproducing the problem on my system (x64, Win7):</p>  <pre><code>static uint64_t start_ts; static uint64_t elapsed() {     return ::GetTickCount64() - start_ts; }  class PageArena { public:     typedef uint8_t* pointer;      PageArena(int id, const char* base_name, size_t page_sz, size_t chunk_sz, size_t n_chunks, bool dispose_handle_first) :         id_(id), base_name_(base_name), pg_sz_(page_sz), dispose_handle_first_(dispose_handle_first) {         for (size_t i = 0; i &lt; n_chunks; i++)              chunks_.push_back(new Chunk(i, base_name_, chunk_sz, dispose_handle_first_));     }             ~PageArena() {         for (auto i = 0; i &lt; chunks_.size(); ++i) {             if (chunks_[i])                 release_chunk(i);         }         std::cout &lt;&lt; "[" &lt;&lt; ::elapsed() &lt;&lt; "] arena " &lt;&lt; id_ &lt;&lt; " destructed" &lt;&lt; std::endl;     }      pointer alloc() {         auto ptr = chunks_.back()-&gt;alloc(pg_sz_);         if (!ptr) {             chunks_.push_back(new Chunk(chunks_.size(), base_name_, chunks_.back()-&gt;capacity(), dispose_handle_first_));             ptr = chunks_.back()-&gt;alloc(pg_sz_);         }         return ptr;     }     size_t num_chunks() {         return chunks_.size();     }     void release_chunk(size_t ndx) {         delete chunks_[ndx];         chunks_[ndx] = nullptr;         std::cout &lt;&lt; "[" &lt;&lt; ::elapsed() &lt;&lt; "] chunk " &lt;&lt; ndx &lt;&lt; " released from arena " &lt;&lt; id_ &lt;&lt; std::endl;     }  private:     struct Chunk {     public:         Chunk(size_t ndx, const std::string&amp; base_name, size_t size, bool dispose_handle_first) :             map_ptr_(nullptr), tail_(nullptr),              handle_(INVALID_HANDLE_VALUE), size_(0),              dispose_handle_first_(dispose_handle_first) {              name_ = name_for(base_name, ndx);             if ((handle_ = create_temp_file(name_, size)) == INVALID_HANDLE_VALUE)                 handle_ = open_temp_file(name_, size);             if (handle_ != INVALID_HANDLE_VALUE) {                 size_ = size;                 auto map_handle = ::CreateFileMappingA(handle_, nullptr, PAGE_READWRITE, 0, 0, nullptr);                 tail_ = map_ptr_ = (pointer)::MapViewOfFile(map_handle, FILE_MAP_ALL_ACCESS, 0, 0, size);                 ::CloseHandle(map_handle); // no longer needed.             }         }         ~Chunk() {             if (dispose_handle_first_) {                 close_file();                 unmap_view();             } else {                 unmap_view();                 close_file();             }         }         size_t capacity() const {             return size_;         }         pointer alloc(size_t sz) {             pointer result = nullptr;             if (tail_ + sz &lt;= map_ptr_ + size_) {                 result = tail_;                 tail_ += sz;             }             return result;         }      private:         static const DWORD kReadWrite = GENERIC_READ | GENERIC_WRITE;         static const DWORD kFileSharing = FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE;         static const DWORD kTempFlags = FILE_ATTRIBUTE_NOT_CONTENT_INDEXED | FILE_FLAG_DELETE_ON_CLOSE | FILE_ATTRIBUTE_TEMPORARY;          static std::string name_for(const std::string&amp; base_file_path, size_t ndx) {             std::stringstream ss;             ss &lt;&lt; base_file_path &lt;&lt; "." &lt;&lt; ndx &lt;&lt; ".chunk";             return ss.str();         }         static HANDLE create_temp_file(const std::string&amp; name, size_t&amp; size) {             auto h = CreateFileA(name.c_str(), kReadWrite, kFileSharing, nullptr, CREATE_NEW, kTempFlags, 0);             if (h != INVALID_HANDLE_VALUE) {                 LARGE_INTEGER newpos;                 newpos.QuadPart = size;                 ::SetFilePointerEx(h, newpos, 0, FILE_BEGIN);                 ::SetEndOfFile(h);             }             return h;         }         static HANDLE open_temp_file(const std::string&amp; name, size_t&amp; size) {             auto h = CreateFileA(name.c_str(), kReadWrite, kFileSharing, nullptr, OPEN_EXISTING, kTempFlags, 0);             if (h != INVALID_HANDLE_VALUE) {                 LARGE_INTEGER sz;                 ::GetFileSizeEx(h, &amp;sz);                 size = sz.QuadPart;             }             return h;         }         void close_file() {             if (handle_ != INVALID_HANDLE_VALUE) {                 std::cout &lt;&lt; "[" &lt;&lt; ::elapsed() &lt;&lt; "] " &lt;&lt; name_ &lt;&lt; " file handle closing" &lt;&lt; std::endl;                 ::CloseHandle(handle_);                 std::cout &lt;&lt; "[" &lt;&lt; ::elapsed() &lt;&lt; "] " &lt;&lt; name_ &lt;&lt; " file handle closed" &lt;&lt; std::endl;             }         }         void unmap_view() {             if (map_ptr_) {                 std::cout &lt;&lt; "[" &lt;&lt; ::elapsed() &lt;&lt; "] " &lt;&lt; name_ &lt;&lt; " view closing" &lt;&lt; std::endl;                 ::UnmapViewOfFile(map_ptr_);                 std::cout &lt;&lt; "[" &lt;&lt; ::elapsed() &lt;&lt; "] " &lt;&lt; name_ &lt;&lt; " view closed" &lt;&lt; std::endl;             }         }          HANDLE          handle_;         std::string     name_;         pointer         map_ptr_;         size_t          size_;         pointer         tail_;         bool            dispose_handle_first_;     };      int id_;     size_t pg_sz_;     std::string base_name_;     std::vector&lt;Chunk*&gt; chunks_;     bool dispose_handle_first_; };  static void TempFileMapping(bool dispose_handle_first) {     const size_t chunk_size = 256 * 1024 * 1024;     const size_t pg_size = 8192;     const size_t n_pages = 100 * 1000;     const char*  base_path = "data/page_pool";     start_ts = ::GetTickCount64();      if (dispose_handle_first)         std::cout &lt;&lt; "Mapping with 2 arenas and closing file handles before unmapping views." &lt;&lt; std::endl;     else         std::cout &lt;&lt; "Mapping with 2 arenas and unmapping views before closing file handles." &lt;&lt; std::endl;     {         std::cout &lt;&lt; "[" &lt;&lt; ::elapsed() &lt;&lt; "] " &lt;&lt; "allocating " &lt;&lt; n_pages &lt;&lt; " pages through arena 1." &lt;&lt; std::endl;         PageArena arena1(1, base_path, pg_size, chunk_size, 1, dispose_handle_first);         for (size_t i = 0; i &lt; n_pages; i++) {             auto ptr = arena1.alloc();             memset(ptr, (i + 1) % 256, pg_size); // ensure pages are dirty.         }         std::cout &lt;&lt; "[" &lt;&lt; elapsed() &lt;&lt; "] " &lt;&lt; arena1.num_chunks() &lt;&lt; " chunks created." &lt;&lt; std::endl;         {             PageArena arena2(2, base_path, pg_size, chunk_size, arena1.num_chunks(), dispose_handle_first);             std::cout &lt;&lt; "[" &lt;&lt; ::elapsed() &lt;&lt; "] arena 2 loaded, going to release chunks 1 and 2 from arena 1" &lt;&lt; std::endl;             arena1.release_chunk(1);             arena1.release_chunk(2);         }     } } </code></pre>