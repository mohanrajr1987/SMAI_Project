<p>Some time ago, I made this beautiful assert macro for c and c++ programs</p>  <pre><code>#define ASSERT(truthy, message) \      if (!(truthy)) \      {\          cout &lt;&lt; message &lt;&lt; " on line " &lt;&lt; __LINE__ &lt;&lt; " in file " &lt;&lt; __FILE__ &lt;&lt; ". Check was " &lt;&lt; #truthy &lt;&lt; endl;\      } </code></pre>  <p>Scatter ASSERT calls throughout your code, and it will warn you whenever the <code>truthy</code> value is not truthy! Very handy during development to remind you of potential mistakes.</p>  <p>ex</p>  <pre><code>ASSERT(filesFound &gt; 0, "Couldn't find any files, check your path!"); </code></pre>  <p>When filesFound is 0, the macro will print out</p>  <blockquote>   <p>Couldn't find any files, check your path! on line 27 in file   openFiles.c. Check was filesFound  > 0</p> </blockquote>  <p>Now what I <em>want</em> it to print, to give me <em>even more</em> relevant information, is the value of any variables passed into the <code>truthy</code> parameter. Like this</p>  <blockquote>   <p>Couldn't find any files, check your path! on line 27 in file   openFiles.c. Check was filesFound > 0, filesFound is 0</p> </blockquote>  <p>This seems lisp-like territory, I wonder, is there any black magic c preprocessing that I can use to evaluate variables and functions to their values, without evaluating the <code>truthy</code> statement?</p>  <p>I assume to be disappointed.</p>