<p>I am trying to write a macro that generates patterns for the core.match macro.</p>  <pre><code>(defmacro match2   [state i predecessor]   `(match ~[state]           [(~(vec (concat (repeat i '_)                            predecessor                            '(&amp; r)))             :seq)] ~i           :else false)) </code></pre>  <p>And this works fine if I use it directly with hardcoded <em>predecessor</em>:</p>  <pre><code>(match2 ["B"] 0 ["B"]) ; 0 </code></pre>  <p>So far everything is fine, but if I try to pass the <em>predecessor</em> using function call:</p>  <pre><code>(match2 ["B"] 0 ((fn [] ["B"]))) ; AssertionError Invalid list syntax [] in (fn [] ["B"]) </code></pre>  <p>The problem is that because match2 is a macro clojure won't evaluate the function call, and will just pass the form as it is. The unevaluated form then goes to core.match (again unevaluated, because core.match is itself a macro) and core.match throws exception because the form is not correct pattern.</p>  <p>How can I force evaluation on macro argument? Or any other workaround?</p>  <p>I was hinted that this is usually done with a second macro, but my attempts yielded no good results.</p>