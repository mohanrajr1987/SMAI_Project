<p>I picked up a project done by another programmer in C++ under Linux and I'm trying to figure out why I get Segmentation Fault when using preprocessor macro with 16 ASCII char array but not when using less or more than 16.</p>  <p>The macro definition :</p>  <pre><code>#define func(a,b) { char *p=a; char *r=b; while(*p) *p++ -= *r++; } while(0) </code></pre>  <p>and in the code it is used like this :</p>  <pre><code>char str1[16] = { 0xBD, 0x71, 0x27, 0xF4, 0xB1, 0x24, 0xF7, 0xA0, 0xC4, 0x78, 0x84, 0xBE, 0x79, 0xC1, 0x85, 0x39 }; char str2[19] = { 0x70, 0x06, 0xBE, 0x92, 0x7E, 0xB6, 0x8F, 0x52, 0x5D, 0x42, 0x40, 0x8A, 0x01, 0x48, 0x19, 0xCF, 0xE7, 0xF1, 0x80 }; func1(str1,str2); </code></pre>  <p>Basically that macro shifts each character from str1 with the value of character from same position in str2. Due to the fact that it works with unsigned chars even when, by shifting, it gets negative value it returns modulus of it returning the correct char.</p>  <p>So the issue is not with shifting and the value obtained after shifting is with the size of the string.</p>  <p>If I use str1 of size 1 to 15 or 17 to 90 ASCII chars it works without any issues but when str1 is equal with 16 ASCII chars I get Segmentation fault.</p>  <p>I've converted the macro to a function and it works OK even with 16 ASCII chars.</p>  <p>Any ideas why this behavior ?</p>  <p>Thank you</p>