<p>There is such code:</p>  <pre><code>#include &lt;assert.h&gt;  void fun1() {    int x; }  int main() {    assert(true          ==true);    return 0; }  void fun2() {    int y; } </code></pre>  <p>There are two unused variables <code>x</code> and <code>y</code> which should be reported by a compiler when option <code>-Wall</code> is passed.</p>  <p>Let's first run only preprocessor:</p>  <pre><code>g++ main.cpp -Wall -E -o main2.cpp </code></pre>  <p>The output:</p>  <pre><code>a lot of stuff from assert.h ... # 2 "main.cpp" 2  void fun1() {    int x; }  int main() {    ((true ==true) ? static_cast&lt;void&gt; (0) : __assert_fail ("true ==true",  "main.cpp" # 10 "main.cpp" 3 4    ,  11 # 10 "main.cpp" 3 4    , __PRETTY_FUNCTION__))                 ;    return 0; }  void fun2() {    int y; } </code></pre>  <p>Let's try to compile this thing:</p>  <pre><code>$ g++ main2.cpp -Wall -c -o main2.o main.cpp: In function ‘void fun1()’: main.cpp:5:8: warning: unused variable ‘x’ [-Wunused-variable]     int x;         ^ </code></pre>  <p>There is only a warning for the first unused variable but not for the second. It looks like that some warnings are disabled after the <code>assert</code> macro.</p>  <p>But when I change <code>assert</code> to be one-line statement:</p>  <pre><code>int main() {    assert(true==true);    return 0; } </code></pre>  <p>then these things:</p>  <pre><code># 10 "main.cpp" 3 4 </code></pre>  <p>are <strong>not</strong> generated and when I compile the preprocessed file then I get two warnings as expected for two unused variables.</p>  <p>I will get also two warnings when I remove <code>3 4</code> from these directives in preprocessed file:</p>  <pre><code># 10 "main.cpp" 3 4 </code></pre>  <p>to </p>  <pre><code># 10 "main.cpp" </code></pre>  <p>Why the behaviour of the compiler (g++ 4.9.2) is so different when the condition inside <code>assert</code> is one-line and multiline?</p>