<p>I am trying to simplify the declaration of an array, but ran into an issue with the preprocessors that I am using.  My initial code looks like the following:</p>  <pre><code>#define REQ_ENTRY(parm_1, parm_2)    \ #if defined(parm_1)                  \     { parm_1, parm_2 },              \ #endif  typedef struct {     int parm1,         parm2; } MyTypedef_t;  static const MyTypedef_t MyList[] = {     REQ_ENTRY( ID_1, 1 )     REQ_ENTRY( ID_2, 2 )     REQ_ENTRY( ID_3, 3 )     REQ_ENTRY( ID_4, 4 )     REQ_ENTRY( ID_5, 5 ) }; </code></pre>  <p>The build fails, of course, with the error message of "error: '#' is not followed by a macro parameter".  The reason for this is explained here (<a href="http://stackoverflow.com/questions/10074520/why-compiler-complain-about-this-macro-declaration">Why compiler complain about this macro declaration</a>)</p>  <p>Basically, I am trying to avoid declaring the array as the follows, which does work:</p>  <pre><code>static const MyTypedef_t MyList[] = {     #if defined (ID_1)     { ID_1, 1 },     #endif      #if defined (ID_2)     { ID_2, 2 },     #endif      #if defined (ID_3)     { ID_3, 3 },     #endif      #if defined (ID_4)     { ID_4, 4 },     #endif      #if defined (ID_5)     { ID_5, 5 },     #endif         }; </code></pre>  <p>The list can be rather long and vary depending upon the build type of the project.  I have tried thinking of using x-macros, but I think I would have the same issue.  I am hoping someone might see a way of creating the preprocessor macros in such a way that I could achieve the original sugar syntax?  Any insight is greatly appreciated.</p>