<h1>Basic Description of Problem</h1>  <p>I don't seem to be able to draw a triangle in any color other than white.</p>  <p>Here is my fragment shader code.</p>  <pre><code>#version 330 core out vec3 color;  void main() {     color = vec3(1.0, 0.0, 0.0); } </code></pre>  <p>For the sake of clarity, I have not included any other code. My vertex shader works - I can see a white triangle on the screen.</p>  <p>I am new to the programmable pipeline way of using OpenGL.</p>  <h1>More Details and main.cpp Code</h1>  <p>It has been suggested that the fault may be that my program falls back to the fixed pipeline way of doing things, so here is my main.cpp code which perhaps contains the problem rather than the shader code.</p>  <pre><code>#include &lt;GL/glew.h&gt; #include &lt;GL/glut.h&gt;  #include &lt;iostream&gt; #include &lt;fstream&gt;   GLuint LoadShaders(const char *vertex_shader_path, const char *fragment_shader_path) {     GLuint VertexShaderID = glCreateShader(GL_VERTEX_SHADER);      std::ifstream vertex_shader_file;     vertex_shader_file.open(vertex_shader_path, std::ios::in | std::ios::ate);     if(vertex_shader_file.is_open())     {         unsigned long long vertex_shader_code_size = vertex_shader_file.tellg();         char *vertex_shader_code = new char[vertex_shader_code_size];         vertex_shader_file.seekg(0, std::ios::beg);         vertex_shader_file.read(vertex_shader_code, vertex_shader_code_size);         vertex_shader_file.close();          GLint Result = GL_FALSE;         int InfoLogLength;          std::cout &lt;&lt; "Compiling Vertex Shader: " &lt;&lt; vertex_shader_path &lt;&lt; std::endl;         glShaderSource(VertexShaderID, 1, (const GLchar**)(&amp;vertex_shader_code), (const GLint*)(&amp;vertex_shader_code_size));         glCompileShader(VertexShaderID);          glGetShaderiv(VertexShaderID, GL_COMPILE_STATUS, &amp;Result);         glGetShaderiv(VertexShaderID, GL_INFO_LOG_LENGTH, &amp;InfoLogLength);         char *VertexShaderErrorMessage = new char[InfoLogLength];         glGetShaderInfoLog(VertexShaderID, InfoLogLength, nullptr, &amp;VertexShaderErrorMessage[0]);         std::cout.write(VertexShaderErrorMessage, InfoLogLength);         std::cout.flush();          delete [] VertexShaderErrorMessage;         delete [] vertex_shader_code;          std::cout &lt;&lt; "Done" &lt;&lt; std::endl;     }     else     {         std::cout &lt;&lt; "Error: Could not open vertex shader source: " &lt;&lt; vertex_shader_path &lt;&lt; std::endl;         exit(-1);     }      GLuint FragmentShaderID = glCreateShader(GL_FRAGMENT_SHADER);      std::ifstream fragment_shader_file;     fragment_shader_file.open(fragment_shader_path, std::ios::in | std::ios::ate);     if(fragment_shader_file.is_open())     {         unsigned long long fragment_shader_code_size = fragment_shader_file.tellg();         char *fragment_shader_code = new char[fragment_shader_code_size];         fragment_shader_file.seekg(0, std::ios::beg);         fragment_shader_file.read(fragment_shader_code, fragment_shader_code_size);         fragment_shader_file.close();          GLint Result = GL_FALSE;         int InfoLogLength;          std::cout &lt;&lt; "Compiling Fragment Shader: " &lt;&lt; fragment_shader_path &lt;&lt; std::endl;         glShaderSource(FragmentShaderID, 1, (const GLchar**)(&amp;fragment_shader_code), (const GLint*)(&amp;fragment_shader_code_size));         glCompileShader(FragmentShaderID);          glGetShaderiv(FragmentShaderID, GL_COMPILE_STATUS, &amp;Result);         glGetShaderiv(FragmentShaderID, GL_INFO_LOG_LENGTH, &amp;InfoLogLength);         char *FragmentShaderErrorMessage = new char[InfoLogLength];         glGetShaderInfoLog(FragmentShaderID, InfoLogLength, nullptr, &amp;FragmentShaderErrorMessage[0]);         std::cout.write(FragmentShaderErrorMessage, InfoLogLength);         std::cout.flush();          delete [] FragmentShaderErrorMessage;         delete [] fragment_shader_code;          std::cout &lt;&lt; "Done" &lt;&lt; std::endl;     }     else     {         std::cout &lt;&lt; "Error: Could not open fragment shader source: " &lt;&lt; fragment_shader_path &lt;&lt; std::endl;     }  }  GLuint vertexbuffer;  void display() {     glClearColor(0.0f, 0.0f, 0.0f, 0.0f);     glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);      glLoadIdentity();     gluLookAt(0.0, 0.0, -10.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0);      glEnableVertexAttribArray(0);     glBindBuffer(GL_ARRAY_BUFFER, vertexbuffer);     glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, (void*)0);     glDrawArrays(GL_TRIANGLES, 0, 3);     glDisableVertexAttribArray(0);      //glFlush();     glutSwapBuffers(); }  void reshape(int width, int height) {     glViewport(0, 0, (GLint)width, (GLint)height);     glMatrixMode(GL_PROJECTION);     glLoadIdentity();     gluPerspective(60.0, (GLdouble)width/(GLdouble)height, 0.0, 100.0);     glMatrixMode(GL_MODELVIEW); }  void keyboard(unsigned char key, int x, int y) {     if(key == 27)     {         exit(0);     } }  int main(int argc, char argv[]) {      glutInit(&amp;argc, &amp;argv);      glutInitDisplayMode(GLUT_DOUBLE);      glutInitWindowSize(800, 600);     glutCreateWindow("window");      glewExperimental = true;     glewInit();      GLuint vertexarrayID;     glGenVertexArrays(1, &amp;vertexarrayID);     glBindVertexArray(vertexarrayID);      static const GLfloat gvertexbufferdata[] = {-1.0f, -1.0f, 0.0f, 1.0f, -1.0f, 0.0f, 0.0f, 1.0f, 0.0f};      glGenBuffers(1, &amp;vertexbuffer);     glBindBuffer(GL_ARRAY_BUFFER, vertexbuffer);     glBufferData(GL_ARRAY_BUFFER, sizeof(gvertexbufferdata), gvertexbufferdata, GL_STATIC_DRAW);       glutKeyboardFunc(keyboard);     glutReshapeFunc(reshape);     glutDisplayFunc(display);       GLuint programID = LoadShaders("vertexshader.glsl", "fragmentshader.glsl");      glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);      glUseProgram(programID);      glutMainLoop();      return 0; } </code></pre>  <h1>Compilation Information</h1>  <p>Here is some info on the compilation process if relevant:</p>  <p>I am compiling within codeblocks, and linking with <code>-lGL -lGLU -lGLEW -lglut</code>. Optimization level is <code>-O3</code>. <code>--std=c++11</code>.</p>