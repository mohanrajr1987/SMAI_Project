<p>To use bindless images in OpenGL, you need to create a GLuint64 handle using <em>glGetImageHandleARB</em>. You can then set this handle to a uniform image2D variable and use the image as if you had bound it the old way. No problems with that. With textures/samplers, it is further possible to set the (texture) handle not to a sampler2D, but to a plain uniform uint64_t variable. This handle can then be used to "construct" a sampler object at runtime with the constructor <em>sampler2D(handle)</em>.</p>  <p><a href="https://www.opengl.org/registry/specs/ARB/bindless_texture.txt" rel="nofollow">The extension description says:</a></p>  <blockquote>   <p>Samplers are represented using 64-bit integer handles, and may be   converted to and from 64-bit integers using constructors.</p> </blockquote>  <p>and</p>  <blockquote>   <p>Images are represented using 64-bit integer handles, and may be   converted to and from 64-bit integers using constructors.</p> </blockquote>  <p>So I would assume that the construction for images works the same way as it does for samplers, but this is not the case. Sample code:</p>  <pre><code>#version 450 #extension GL_ARB_bindless_texture : enable #extension GL_NV_gpu_shader5 : enable  layout(bindless_image, rgba8) uniform image2D myBindlessImage;  uniform uint64_t textureHandle; uniform uint64_t imageHandle;  void main() {     sampler2D mySampler = sampler2D(textureHandle); // works like a charm     ... = texture(mySampler, texCoord);      ... = imageLoad(myBindlessImage, texCoordI); // works like a charm      layout(rgba8) image2D myImage = image2D(imageHandle); // error C7011: implicit cast from "uint64_t" to "int"     ... = imageLoad(myImage, texCoordI); } </code></pre>  <p>Apparently, neither the image2D(uint64_t) constructor nor the image2D(uvec2) constructor mentioned in the extension description are known to the compiler. Am I missing something here or is this simply not implemented right now, although it should be? The video driver I am using right now is Nvidia's 355.82. I would be glad if someone could shed some light on whether this works with any other driver/vendor's card.</p>  <p>By the way, why would I need that feature: In contrast to texture handles, image handles do not identify the whole underlying data, but only one texture level. If you want to do any mipmap or otherwise hierarchical work in shaders and need to bind several/all texture levels, you could provide the handles of all levels in a buffer and then construct them at shader runtime as needed. Right now, you have to define n different uniform image2Ds for your n texture levels, which is rather tedious, especially if the image size changes.</p>  <p>Addendum: The fastest way to reproduce the compile error is to just put <em>image2D(0lu);</em> somewhere in your shader code.</p>