<p>I've written a fragment shader that uses simple ray tracing to render a sphere inside of a fragment shader that diffusely shades the shape. I can get this to work for one sphere; however, when I try to make multiple spheres, only one can be seen. In the main() function of the shader, I basically am doing the same process I did to render the one sphere for each additional sphere that I want to make, but this doesn't seem to be working currently. </p>  <h3>Additional Info:</h3>  <p>The vertex of the sphere (x,y,z,r) are found by using: the vertex positions for x and y (i.e. <code>float x = vPosition.x;</code>                                    and <code>float y = vPosition.y;</code>). The vertex position for z is computed using the <code>computeZ()</code> function found in the code below. Lastly, for sphere.r, I used the ray's origin vertex (V) + the ray's direction (W). The rays themselves are shooting from an origin point into the screen and determining the color of of sphere based on whether or not it has hit the sphere (I have the code for the functionality that does this in <code>raySphere()</code>.</p>  <p>I think I just need  to make an array in main to store the spheres and then to make a for loop to call the <code>raySphere()</code> and <code>shadeSphere()</code> functions for each sphere in the array (this is what I tried originally but it didn't work). </p>  <p>In main, after initializing the one sphere's vertex positions and the V and W for the ray, I have an if statement that checks if z is greater than 0 meaning that the shader is currently inside of the sphere so it can proceed with the shading, and otherwise do nothing. Since defining the bounds of the sphere this way, I wasn't sure how to have this same logic apply for multiple spheres using the for loop solution I mentioned previously. Also in main, I check to see whether the t values (for each sphere) is less than 10000 and if so, call the <code>shadeSphere()</code> function to shade the sphere; however, my current logic also isn't working for multiple spheres. The turbulence and fractal functions are just to add procedural texturing and they are long so I won't add the code for them.</p>  <p>What is the correct way to make multiple spheres? I have the relevant code below:</p>  <pre><code>float computeZ(vec2 xy, float r) {       float zz = (r * r - xy.x * xy.x - xy.y * xy.y)/.5;       if (zz &lt; 0.)          return -1.;       else          return sqrt(zz);    }  float raySphere(vec3 V, vec3 W, vec4 sph) {         float b = 2.0 * dot(V -= sph.xyz, W);         float c = dot(V, V) - sph.w * sph.w;         float d = b * b - 4.0 * c;         return d &lt; 0.0 ? 10000. : (-b - sqrt(d)) / 2.0;    } vec3 shadeSphere(vec3 point, vec4 sphere, vec3 material, float s) {       vec3 color = vec3(1.,2.,4.);       vec3 N = (point - sphere.xyz) / sphere.w;       float diffuse = max(dot(Ldir, N), 0.0);       vec3 ambient = material/5.0;       color = ambient + Lrgb * s *diffuse *  max(0.0, dot(N , Ldir));       return color;    } void main(void) {       vec2 c = uCursor.xy;       Lrgb = vec3(1.,.5,0.);       Ldir = normalize(vec3(c.x, c.y, 1. - 2. * dot(c, c)));       float x = vPosition.x;       float y = vPosition.y;       float z = computeZ(vPosition.xy, 1.0);       // COMPUTE V AND W TO CREATE THE RAY FOR THIS PIXEL,       // USING vPosition.x AND vPosition.y.       //vec4 spheres[2];       vec3 V, W;       V  = vec3(2.0,1.0,.0);       W = normalize(vec3( 2.0,0.0,1.0 ));        if(z &gt; 0.){       sphere = vec4(x,y,z,V + W));       sphere2 = vec4(x+10.,y+10.,z+10.,V + W));       vec2 uv = vPosition.xy/uCursor.xy;       //generate a ray        //V = vec3(0.0, 1.0, 3.0);       //W = normalize(vec3((-1.0 + 2.0   )*vec2(1.78,1.0), -1.0));       //SET x,y,z AND r FOR sphere.       //SET r,g,b FOR material.       vec3 material = vec3(4., 1., 3.);       vec3 color = vec3(0., 0., 0.);       float t1 = raySphere(V, W, sphere);       float t2 = raySphere(V, W, sphere2);       //float s = sin((uTime));       vec3 time = vec3(uTime*2., 1.,1.);       float s = tan((tan(sphere.z)/tan((fractal(time))*.90+200.0)));       if (t1 &lt; 10000.)          //float s = (sin(sphere.x)/cos(uTime*1.123+200.0));          color = shadeSphere(V + t1 * W, sphere, material,s);       if (t2 &lt; 10000.)         color = shadeSphere(V + t2 * W, sphere, material,s);        color.r = 0.5;       color = pow(color, vec3(.45,.45,.45)); // Do Gamma correction.        gl_FragColor = vec4(color, 1.);        // Set opacity to 1.       if(uCursor.x &gt; z)         gl_FragColor = vec4(fractal(color) * vec3(1.0, 5.0, 8.5), 1.);       else if((-uCursor.x) &gt; z)         gl_FragColor = vec4(fractal(color) * vec3(7.6, 2.0, 1.5), 1.);       else if(uCursor.y &gt; z)         gl_FragColor = vec4(turbulence(color) * vec3(2.6, 2.0, 8.5), 1.);       else if((-uCursor.y) &gt; z)         gl_FragColor = vec4(turbulence(color) * vec3(3.6, 9.0, 3.5), 1.);       else {gl_FragColor = vec4(fractal(color) * vec3(0.0, 1.0, 0.5), 1.);}       }    } </code></pre>