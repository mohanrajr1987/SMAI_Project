<p>I tried to create a shader for implicit rendering of curves. Unfortunately, it malfunctions (problem most likely lies in the geometry shader), displaying merely a clear screen.</p>  <p>Apologies for possibly wrong terminology. Instead of aproximating a curve by a line strip, my program should proccess each individual pixel in a certain area and color it, accordingly to an implicit equation, defining the curve - hence, implicit rendering.</p>  <p>Vertex shader - takes a line strip as an input, two planar coordinates and the angle between the curve and x-axis at the said coordinates</p>  <pre><code>#version 330 core  layout (location = 0) in vec2 x; layout (location = 1) in float t;  out VS_OUT {   float t; } vs_out;  void main () {   vs_out.t = t;   gl_Position = vec4 (vec3 (x, 0), 1); } </code></pre>  <p>geometry shader - creates a triangle over a line, in which individual pixels are tested</p>  <pre><code>#version 330 core  layout (lines) in; layout (triangle_strip, max_vertices = 50) out;  in VS_OUT {   float t; } gs_in[];  out float k;  out vec2 R;  void main () {       vec2 A = vec2 (gl_in [0].gl_Position);   vec2 B = vec2 (gl_in [1].gl_Position);    float u = gs_in [0].t;   float v = gs_in [1].t;    float a = A.x - B.x;   float b = A.y - B.y;   float D = sin (u) * cos (v) - cos (u) * sin (v);    vec2 V = A + vec2 (cos (u), sin (u)) * (- sin (v) * a - cos (v) * b) / D;    float p = (cos (v) * a + sin (v) * b) / D;   float q = (- cos (u) * a - sin (u) * b) / D;    vec2 S = A + vec2 (sin (u), cos (u)) * p;    gl_Position = vec4 (vec3 (V, 0), 1);   R = V - S;   EmitVertex ();    gl_Position = gl_in [0].gl_Position;   k = p;   R = A - S;   EmitVertex ();    gl_Position = gl_in [1].gl_Position;   k = q;   R = B - S;   EmitVertex ();    EndPrimitive(); }   </code></pre>  <p>and fragment shader - colors pixel, that is located in a close proximity of the curve, white</p>  <pre><code>#version 330 core  in float k;  in vec2 R;  out vec4 bv;  float lyn (const float x) {   if (abs (x) &lt; 0.1)     return 1;   else     return 0; }  float kv (const vec2 x, const float r) {   return dot (x, x) - r * r; }  void main () {   bv = vec4 (lyn (kv (R, k))); } </code></pre>