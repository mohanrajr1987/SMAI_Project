<p>im learning about OpenGL and i wrote the following code in C++ using <a href="https://open.gl/drawing" rel="nofollow">this guide</a> and <a href="http://www.youtube.com/watch?v=csKrVBWCItc&amp;list=PLEETnX-uPtBXT9T-hD0Bj31DSnwio-ywh&amp;index=7" rel="nofollow">this video</a>. Also i am using GLFW for context creation and GLEW for GL functions Most of the Shader class is copied from the video up linked, </p>  <p>The problem is that using glDrawElements() to render inside the main loop gets me a segmentation fault:</p>  <pre><code>Segmentation fault   ------------------ (program exited with code: 139) Press return to continue </code></pre>  <p>while with glDrawArrays() i can draw with no problems.</p>  <p>Does anyone know what this could be caused by? I think the error might depend on the implementation of the Shader class, because i used glDrawArrays() in other programs that did not used this class and that cared about shaders in the main function.</p>  <p><strong>program.cpp</strong></p>  <pre><code>//INCLUDE AND DECLARATIONS #include &lt;iostream&gt; #include &lt;fstream&gt;  // GLEW #define GLEW_STATIC #include &lt;GL/glew.h&gt; // GLFW #include &lt;GLFW/glfw3.h&gt; #include "Shader.h"  void key_callback(GLFWwindow* window, int key, int scancode, int action, int mode); unsigned long getFileLength(std::ifstream&amp; file); int loadshader(char* filename, GLchar** ShaderSource, unsigned long* len);  const GLuint WIDTH = 800, HEIGHT = 600;   //VERTEX DATA float data[] = { //    X      Y     R     G     B        -0.5f,  0.5f, 1.0f, 0.0f, 0.0f, // Top-left      0.5f,  0.5f, 0.0f, 1.0f, 0.0f, // Top-right      0.5f, -0.5f, 0.0f, 0.0f, 1.0f, // Bottom-right     -0.5f, -0.5f, 1.0f, 1.0f, 1.0f  // Bottom-left };   GLuint elements[] = {         0, 1, 2,         2, 3, 0     };  //main int main() {   //INIT GLFW AND WINDOW     glfwInit();     glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);     glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);     glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);     glfwWindowHint(GLFW_RESIZABLE, GL_FALSE);     GLFWwindow* window = glfwCreateWindow(WIDTH, HEIGHT, "LearnOpenGL", nullptr, nullptr);     glfwMakeContextCurrent(window);     glfwSetKeyCallback(window, key_callback);     glewExperimental = GL_TRUE;     glewInit();     glViewport(0, 0, WIDTH, HEIGHT);        //ALLOCATE BUFFERS         //VERTEX ARRAY BUFFER     GLuint vbo;     glGenBuffers(1, &amp;vbo);     glBindBuffer(GL_ARRAY_BUFFER, vbo);     glBufferData(GL_ARRAY_BUFFER, sizeof(data), data, GL_STATIC_DRAW);         //ELEMENT ARRAY BUFFER     GLuint ebo;     glGenBuffers(1, &amp;ebo);     glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ebo);     glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(elements), elements, GL_STATIC_DRAW);         //CREATE SHADER     Shader shader("./shaders/basicShader");       // main loop     while (!glfwWindowShouldClose(window))     {         shader.Bind();         glfwPollEvents();                       //window events         glClearColor(1.0f, 0.0f, 0.5f, 0.5f);   //background         glClear(GL_COLOR_BUFFER_BIT);         glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);          glfwSwapBuffers(window);                //update window     }      glDeleteBuffers(1, &amp;vbo);     glDeleteBuffers(1, &amp;ebo);     glfwTerminate();     return 0; }   void key_callback(GLFWwindow* window, int key, int scancode, int action, int mode) {     if (key == GLFW_KEY_ESCAPE &amp;&amp; action == GLFW_PRESS)         glfwSetWindowShouldClose(window, GL_TRUE); } </code></pre>  <p><strong>Shader.h</strong></p>  <pre><code>#include &lt;iostream&gt; #include &lt;fstream&gt; #include &lt;GL/glew.h&gt; #include &lt;GLFW/glfw3.h&gt;   class Shader {         public:             Shader(const std::string&amp; filepath);             ~Shader();             void Bind();         private:             static const GLuint NUM_SHADERS = 2;             GLuint program;               GLuint shaders[NUM_SHADERS];              std::string LoadShader(const std::string&amp; fileName);             void CheckShaderError(GLuint shader, GLuint flag, bool isProgram, const std::string&amp; errorMessage);             GLuint CreateShader(const std::string&amp; text, unsigned int type);  }; </code></pre>  <p><strong>Shader.cpp</strong></p>  <pre><code>#include "Shader.h"  Shader::Shader(const std::string&amp; filepath) {     program = glCreateProgram();     shaders[0] = CreateShader(LoadShader(filepath + ".vs"), GL_VERTEX_SHADER);     shaders[1] = CreateShader(LoadShader(filepath + ".fs"), GL_FRAGMENT_SHADER);      for(unsigned int i = 0; i &lt; NUM_SHADERS; i++)     {         glAttachShader(program, shaders[i]);     }     glBindAttribLocation(program, 0, "position");     glBindFragDataLocation(program, 0, "outColor");      glLinkProgram(program);     CheckShaderError(program, GL_LINK_STATUS, true, "Error linking shader program");      glValidateProgram(program);     CheckShaderError(program, GL_LINK_STATUS, true, "Invalid shader program");         GLuint vao;     glGenVertexArrays(1, &amp;vao);          glBindVertexArray(vao);           GLint posAttrib = glGetAttribLocation(program, "position");     glVertexAttribPointer(posAttrib, 2, GL_FLOAT, GL_FALSE, 5*sizeof(float), 0);     glEnableVertexAttribArray(posAttrib);      GLint AttribColor = glGetAttribLocation(program, "color");     glVertexAttribPointer(AttribColor, 3, GL_FLOAT, GL_FALSE, 5*sizeof(float), (void*)(2*sizeof(float)));     glEnableVertexAttribArray(AttribColor);   }  Shader::~Shader() {     for(unsigned int i = 0; i &lt; NUM_SHADERS; i++)     {         glDetachShader(program, shaders[i]);         glDeleteShader(shaders[i]);     }     glDeleteProgram(program); }  void Shader::Bind() {         glUseProgram(program); }   //loads shaders from files std::string Shader::LoadShader(const std::string&amp; fileName) {     std::ifstream file;     file.open((fileName).c_str());      std::string output;     std::string line;      if(file.is_open())     {         while(file.good())         {             getline(file, line);             output.append(line + "\n");         }     }     else     {         std::cerr &lt;&lt; "Unable to load shader: " &lt;&lt; fileName &lt;&lt; std::endl;     }      return output; } //Checks for eventual errors in shaders void Shader::CheckShaderError(GLuint shader, GLuint flag, bool isProgram, const std::string&amp; errorMessage) {     GLint success = 0;     GLchar error[1024] = { 0 };      if(isProgram)         glGetProgramiv(shader, flag, &amp;success);     else         glGetShaderiv(shader, flag, &amp;success);      if(success == GL_FALSE)     {         if(isProgram)             glGetProgramInfoLog(shader, sizeof(error), NULL, error);         else             glGetShaderInfoLog(shader, sizeof(error), NULL, error);          std::cerr &lt;&lt; errorMessage &lt;&lt; ": '" &lt;&lt; error &lt;&lt; "'" &lt;&lt; std::endl;     } }  GLuint Shader::CreateShader(const std::string&amp; text, unsigned int type) {     GLuint shader = glCreateShader(type);         if(shader == 0)             std::cerr &lt;&lt; "error allocating shader" &lt;&lt; std:: endl;      const GLchar* p[1];     p[0] = text.c_str();     GLint lengths[1];     lengths[0] = text.length();      glShaderSource(shader, 1, p, lengths);     glCompileShader(shader);     CheckShaderError(shader, GL_COMPILE_STATUS, false, "Error compiling shader!");      return shader; } </code></pre>