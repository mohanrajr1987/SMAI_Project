<p><strong>EDIT BELOW</strong></p>  <p>I have my compute shader and it compiles fine, but when linking I get an error stating "too many uniforms are used in this shader". Weirdly enough when i remove two lines of the code the shader compiles and links fine. these two lines are:</p>  <pre><code>atomicMin(minDepth, d); atomicMax(maxDepth, d); </code></pre>  <p>I can't imagine why these two lines would cause that error. My guess is it is something I am missing because I am quite new to compute shaders.</p>  <p>Thanks for any help, this has got me stuck for a while.</p>  <p>Shader Code:</p>  <pre><code>#version 430  #define WORK_GROUP_SIZE 32 #define MAX_LIGHTS_PER_TILE 40  #define MAX_LIGHTS 1024  struct Attenuation {     float constant;     float linear;     float exponent; };  struct Light {     vec3 color;     float intensity; };  struct DirectionalLight {     Light light;     vec3 direction; };  struct PointLight {     Light light;     Attenuation atten;     vec3 position;     float radius; };  struct SpotLight {     Light light;     Attenuation atten;     vec3 position;     float range;     vec3 direction;     float cutoff; };  layout (binding = 1, std140) uniform DATA {     mat4 viewMatrix;     mat4 projectionMatrix;     int numActiveLights;      DirectionalLight directionalLight;     Light ambientLight;      vec2 resolution;     vec3 camPos; };  layout (binding = 2, rgba32f) uniform image2D geometryPosition; layout (binding = 3, rgba32f) uniform image2D geometryDiffuse; layout (binding = 4, rgba32f) uniform image2D geometryNormal; layout (binding = 5, rgba32f) uniform image2D geometrySpecular; layout (binding = 6, rgba32f) uniform image2D finalImage;  layout (std430, binding = 7) buffer point {     PointLight pointLights[]; };  layout (std430, binding = 8) buffer spot {     SpotLight spotLights[]; };  layout (local_size_x = WORK_GROUP_SIZE, local_size_y = WORK_GROUP_SIZE) in;  shared uint minDepth; shared uint maxDepth; shared uint pointLightCount; shared uint pointLightIndex[MAX_LIGHTS];  vec4 calcLight(Light light, vec3 direction, vec3 normal, vec3 fragPos, vec3 specular, vec3 camPos) {     float diffuseFactor = dot(normal, -direction);      vec4 diffuseColor = vec4(0.0, 0.0, 0.0, 0.0);     vec4 specularColor = vec4(0.0, 0.0, 0.0, 0.0);      if (diffuseFactor &gt; 0)     {         // might need to be 0.0----------| |         diffuseColor = vec4(light.color, 1.0) * light.intensity * diffuseFactor;          vec3 directionToEye = normalize(camPos - fragPos);         vec3 halfDirection = normalize(directionToEye - direction);          float specularFactor = dot(halfDirection, normal);         // maybe not 32?         specularFactor = pow(specularFactor, 32);          if (specularFactor &gt; 0)         {             // maybe 0.0 again             specularColor = vec4(light.color, 1.0) * vec4(specular, 1.0) * specularFactor;         }     }      return diffuseColor + specularColor; }  vec4 calcDirectionalLight(DirectionalLight dirLight, vec3 pos, vec3 normal, vec3 specular, vec3 camPos) {     return calcLight(dirLight.light, dirLight.direction, normal, pos, specular, camPos); }  vec4 calcPointLight(PointLight pointLight, vec3 pos, vec3 normal, vec3 specular, vec3 camPos) {     vec3 lightDirection = pos - pointLight.position;     float distanceToPoint = length(lightDirection);      lightDirection = normalize(lightDirection);      vec4 color = calcLight(pointLight.light, lightDirection, normal, pos, specular, camPos);      float atten = pointLight.atten.constant + pointLight.atten.linear * distanceToPoint + pointLight.atten.exponent * distanceToPoint * distanceToPoint + 0.0001;      return color / atten; }  void main() {     minDepth = 0xFFFFFFFF;     maxDepth = 0;     pointLightCount = 0;      vec3 camPos = vec3(0, 0, 0);     vec2 resolution = vec2(600, 400);      ivec2 pixelPos = ivec2(gl_GlobalInvocationID.xy);     vec2 tilePos = vec2(gl_WorkGroupID.xy * gl_WorkGroupSize.xy) / resolution;      vec4 normalColor = imageLoad(geometryNormal, pixelPos);      float d = normalColor.w;     uint depth = uint(d * 0xFFFFFFFF);      //atomicMin(minDepth, depth);     //atomicMax(maxDepth, depth);      barrier();      float minDepthZ = float(minDepth / float(0xFFFFFFFF));     float maxDepthZ = float(maxDepth / float(0xFFFFFFFF));      vec2 tileScale = resolution * (1.0 / float( 2 * WORK_GROUP_SIZE));     vec2 tileBias = tileScale - vec2(gl_WorkGroupID.xy);      vec4 col1 = vec4(-projectionMatrix[0][0] * tileScale.x, projectionMatrix[0][1], tileBias.x, projectionMatrix[0][3]);     vec4 col2 = vec4(projectionMatrix[1][0], -projectionMatrix[1][1] * tileScale.y, tileBias.y, projectionMatrix[1][3]);     vec4 col4 = vec4(projectionMatrix[3][0], projectionMatrix[3][1], -1.0, projectionMatrix[3][3]);      vec4 frustumPlanes[4];     frustumPlanes[0] = col4 + col1;     frustumPlanes[1] = col4 - col1;     frustumPlanes[2] = col4 - col2;     frustumPlanes[3] = col4 + col2;     //frustumPlanes[4] = vec4(0.0, 0.0, -1.0, -minDepthZ);     //frustumPlanes[5] = vec4(0.0, 0.0, -1.0, maxDepthZ);      for (int i = 0; i &lt; 4; i++)     {         frustumPlanes[i] *= 1.0 / length(frustumPlanes[i].xyz);     }      uint threadCount = WORK_GROUP_SIZE * WORK_GROUP_SIZE;     uint passCount = (numActiveLights + threadCount - 1) / threadCount;      for (uint passIt = 0; passIt &lt; passCount; passIt++)     {         uint lightIndex = passIt * threadCount + gl_LocalInvocationIndex;         lightIndex = min(lightIndex, numActiveLights);          PointLight p = pointLights[lightIndex];         vec4 pos = viewMatrix * vec4(p.position, 1.0);         float rad = p.radius;          if (pointLightCount &lt; MAX_LIGHTS_PER_TILE)         {             bool inFrustum = true;             for (uint i = 3; i &gt;= 0 &amp;&amp; inFrustum; i--)             {                 float dist = dot(frustumPlanes[i], pos);                 inFrustum = (-rad &lt;= dist);             }              if (inFrustum)             {                 uint id = atomicAdd(pointLightCount, 1);                 pointLightIndex[id] = lightIndex;             }         }     }      barrier();      vec3 position = imageLoad(geometryPosition, pixelPos).xyz;     vec4 diffuse = vec4(imageLoad(geometryDiffuse, pixelPos).xyz, 1.0);     vec3 normal = normalColor.xyz;     vec3 specular = imageLoad(geometrySpecular, pixelPos).xyz;      vec4 color = vec4(0.0, 0.0, 0.0, 1.0);      for (int i = 0; i &lt; pointLightCount; i++)     {         color += calcPointLight(pointLights[pointLightIndex[i]], position, normal, specular, camPos);     }      //color += calcDirectionalLight(directionalLight, position, normal, specular, camPos);     //diffuse *= vec4((ambientLight.intensity * ambientLight.color).xyz, 1.0);     color += diffuse;      barrier();      imageStore(finalImage, pixelPos, color); } </code></pre>  <p><strong>EDIT</strong></p>  <p>I have figured out that using atomicMin and atomicMax the way I have is some how causing the program to crash and not respond when calling glLinkProgram. I have figured this out by rewriting the shader slowly and testing. This has shown me for sure that atomicMin and atomicMax are the issue while atomicAdd seems to work fine. When I comment out min  and max the program links fine. What is causing this to happen? Is it something I have done or is it a problem with drivers?</p>