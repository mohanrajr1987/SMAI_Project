<p>I've written an a ray tracer that is supposed to diffusely shade a sphere on a canvas. When I run the code I have in the browser, I'm only seeing a square appear (as the sphere is supposed to be formed from 4 vertices) and not the sphere within it. I commented out the function call for the function that is supposed to determine the color of the sphere and nothing changes. I have no idea what the problem is as the function that calculates the quadratic formula seems to be working properly. Since there is no way of tracing the function calls being added to the stack, I'm lost on how to trace what is actually happening at runtime. What could wrong with the structure of the code? I have the relevant GLSL functions below:</p>  <pre><code>precision mediump float;    uniform float uTime;    uniform vec3  uCursor;    varying vec3  vPosition;     vec4 sphere;    vec3 material;     vec3 Lrgb;    vec3 Ldir;      float computeZ(vec2 xy, float r) {       float zz = (r * r - xy.x * xy.x - xy.y * xy.y)/.5;       if (zz &lt; 0.)          return -1.;       else          return sqrt(zz);    }    float raySphere(vec3 V, vec3 W, vec4 sph) {     float b = 2. * dot(V -= sph.xyz, W);         float c = dot(V, V) - sph.w * sph.w;         float d = b * b - 4. * c;         return d &lt; 0. ? 10000. : (-b - sqrt(d)) / 2.;    }     // Diffusely shade a sphere.    //    point is the x,y,z position of the surface point.    //    sphere is the x,y,z,r definition of the sphere.    //    material is the r,g,b color of the sphere.    vec3 shadeSphere(vec3 point, vec4 sphere, vec3 material) {       vec3 color = vec3(1.,2.,4.);       vec3 N = (point - sphere.xyz) / sphere.w;       float diffuse = max(dot(Ldir, N), 0.0);       vec3 ambient = material/5.0;       color = ambient + Lrgb * diffuse *  max(0.0, dot(N , Ldir));       return color;    }     void main(void) {       vec2 c = uCursor.xy;       Lrgb = vec3(1.,.5,0.);       Ldir = normalize(vec3(c.x, c.y, 1. - 2. * dot(c, c)));       float x = vPosition.x;       float y = vPosition.y;       float z = computeZ(vPosition.xy, 1.0);       // COMPUTE V AND W TO CREATE THE RAY FOR THIS PIXEL,       // USING vPosition.x AND vPosition.y.       vec2 uv = vPosition.xy/uCursor.xy;        //generate a ray        vec3 V, W;       //V  = vec3(0.0,1.0,0.0);       //W = normalize(vec3( 2.0,0.0,1.0 ));        V = vec3(0.0, 1.0, 3.0);       W = normalize(vec3((-1.0 + 2.0  )*vec2(1.78,1.0), -1.0));        //SET x,y,z AND r FOR sphere.        sphere = vec4(x,y,z,V + W);        //SET r,g,b FOR material.        vec3 color = vec3(5., 2., 3.);       float t = raySphere(V, W, sphere);        if (t &lt; 10000.)          // This function doesn't seem to be getting called as the square just appears white          color = shadeSphere(V + t * W, sphere, material);        //color.r = 0.0;         color = pow(color, vec3(.45,.45,.45)); // Do Gamma correction.        gl_FragColor = vec4(color, 1.);        // Set opacity to 1.    } </code></pre>