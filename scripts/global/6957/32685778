<p>To learn opengl, I'm creating a simple 3D graphics engine using openGL 3.3.  I've recently added light attenuation over distance; this has turned all objects completely black.  This was done by adding the following code to my light calculations in the fragment shader:</p>  <pre><code>float distance = length(lite.position - FragPos); float attenuation = 1.0f/(lite.constant + (lite.linear * distance) + (lite.quadratic * (distance * distance))); ambient *= attenuation; diffuse *= attenuation; specular *= attenuation;  result += (ambient + diffuse + specular); </code></pre>  <p>It seems safe to assume that <code>attenuation</code> is very small, effectively or actually 0, or negative (black).  To test this I use <code>result += vec3(attenuation);</code>, the result of this is white objects; this then indicates that <code>attenuation</code> is not near 0 and instead 1.0 or larger; an additional test trying <code>result += vec3(attenuation/500000);</code> still produces white, which indicates that attenuation is quite large, perhaps infinite.  I did some infinity and NaN checks on it.  NaN checks told me it is a number, infinity checks tell me it is sometimes infinite and sometimes isn't.  In fact it told me that it is both infinite and not infinite at the same time.  I determined this by using the following code segment:</p>  <pre><code>if(isinf(attenuation)){   result += vec3(1.0, 0.0, 0.0); } if(isinf(attenuation) &amp;&amp; !isinf(attenuation)){   result += vec3(0.0, 1.0, 0.0); } if(!isinf(attenuation)){   result += vec3(0.0, 0.0, 1.0); } </code></pre>  <p>My objects turned purple/magenta.  Were <code>attenuation</code> infinite, I would expect my objects to appear red; were they not infinite, I would expect them to appear blue; were they somehow both infinite and not infinite I would expect them to appear green.  If I make the <code>result += ...</code> to be <code>result = ...</code>, the objects appear red.  In this case, were it both infinite and not infinite, as my purple objects suggest, <code>result</code> would first be set to red, and then set to blue, resulting in blue objects (if somehow the green check fails).</p>  <p>I hope this describes the source of my confusion.  My testing shows that <code>attenuation</code> is infinite, and that it is not infinite, AND that it is neither.</p>  <p>To top everything off when I use:</p>  <pre><code>float attenuation = 1.0f/(1.0 + (0.0014 * distance) + (0.000007* (distance * distance))); </code></pre>  <p>to determine the attenuation factor, everything works exactly as expected; however the values shown here as constants are exactly what's passed in from my openGL calls (c++):</p>  <pre><code>glUniform1f(lightConstantLoc,  1.0f); glUniform1f(lightLinearLoc,    0.0014f); glUniform1f(lightQuadraticLoc, 0.000007f); </code></pre>  <p>From there I should conclude that my data is not being delivered to my shaders correctly, however I'm confident my <code>lite.constant</code> etc values have been set correctly, and that <code>distance</code> is a reasonable value.  When I single each one out as a color, the objects do turn that color.i.e.: using this</p>  <pre><code>result = vec3(lite.constant, 0.0, 0.0); </code></pre>  <p>my objects turn some shade of red, for <code>lite.constant</code>, <code>lite.linear</code> etc.</p>  <p>Searching google and stack overflow for things like "glsl isinf true and false" or "glsl variable is and isn't infinite" gives me absolutely no relevant results.</p>  <p>I get the feeling I'm distinctly ignorant of something happening here, or the way something works.  And so I turn to you, am I missing something obvious, doing this all wrong, or is this a true mystery?</p>