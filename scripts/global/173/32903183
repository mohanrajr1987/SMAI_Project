<p>Currently I am writing an application that consists of hundreds of JS objects asynchronously being updated in the background. Multiple panels, created with iframes can be used to visualize the various objects in HTML.</p>  <p>The challenge: as soon as an object is updated, the corresponding HTML element displaying the updated property/attribute should automatically update itself. Changes occurring to the HTML element should/do not necessarily affect the object!  Many of the two-way databinding libraries I've seen are way to overblown for my needs.</p>  <p>Is it possible to write something efficient using Object.observe? Currently I have tried the following (which works), but is terrible for performance and objects keep getting observed after the HTML is already deleted (the panel was closed or a new object opened):</p>  <p>main.html:</p>  <pre><code>&lt;iframe src="panel.html"&gt;&lt;/iframe&gt; &lt;script&gt; var module = function(){ // constructor     var obj = this;     obj.param1 = "foo";     obj.param2 = "bar";     obj.id = 123;    }; module.prototype = {}; var mod = new module(); // create the object &lt;/script&gt; </code></pre>  <hr>  <p>panel.html</p>  <pre><code>&lt;script&gt; // jquery extension to observe attribute and set/update value $.fn.extend({   vbind: function(object,parameter) {     var el = this; // get current element instance      $(el).html(object[parameter]); // set current value of parameter      // observe object of interest     Object.observe(object, function(changes){         // This asynchronous callback runs         changes.forEach(function(change) {             $(el).html( object[change.name] ); // set new value of parameter         });     });     return el;   } });   $(function(){ // create 1000 elements all listening for changes in object for(var i = 0; i &lt; 1000; i++){         $("&lt;div&gt;").vbind(parent.mod,"param1").appendTo("body");     } }); &lt;/script&gt; </code></pre>  <p>setting "obj.param1 = 0;" in the console of main.html will cause all the elements to change exactly the way I need. Is there a more elegant way of achieving this, especially with elements being created and deleted all the time?</p>  <p>Thanks in advance for comments and ideas!</p>