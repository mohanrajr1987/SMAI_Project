<p>So this program is supposed to ask the user for a temperature in <em>Kelvin</em>s and the starting <em>Ne</em>. And then interpolate to find the given value.</p>  <p>The <code>temp</code> array is all temperatures and is used to find what temperature we are between.</p>  <p>The <code>n</code> array is all the <em>Ne</em>'s and is used to find what Ne we are between.</p>  <p>Whatever spots we get in each will end up being the spot we are interpolating in the bigger array, HPE.</p>  <p>The main function ask the user for a temperature and <em>Ne</em> and calls upon the Interpolation function.</p>  <p>The interpol function is the function that interpolates. First it finds where the given temperature is in the temp array. Then it finds where the given Ne is in the n array. Then it uses that spot (HPE[k][l]) to do the 2D interpolation.</p>  <p>My problem is when I run it and enter values that should be giving me an answer, I get "The value determined is <code>nan</code>"</p>  <p>What am I doing wrong?</p>  <pre><code>#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;math.h&gt;  double interpol(double Ti, double Ne);  int main() {     int ni;     double Ti, result, Ne;      printf("\nEnter the temperature in kelvins and Ne separated by a space.\n");     ni = scanf("%lf %lf", &amp;Ti, &amp;Ne);     result = interpol(Ti, Ne);     printf("\nThe value determined is %lf\n", result); }   double interpol(double Ti, double Ne) {     int i, j, k, l;     double y1, y2, y3, y4, t, u, p;     double temp[15] = {         1000.0, 2000.0, 3000.0, 4000.0, 5000.0,         6000.0, 7000.0, 8000.0, 9000.0, 10000.0,         11000.0, 12000.0, 13000.0, 14000.0, 15000.0};     double n[8] = {10.0, 11.0, 12.0, 13.0, 14.0, 15.0, 16.0, 17.0};     double HPE[15][8] = {         {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},         {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},         {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},         {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},         {0.0017, 0.0002, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},         {0.2980, 0.0407, 0.0042, 0.0004, 0.0, 0.0, 0.0, 0.0},         {0.9582, 0.6961, 0.1864, 0.0224, 0.0023, 0.0002, 0.0, 0.0},         {0.9979, 0.9791, 0.8241, 0.3191, 0.0448, 0.0047, 0.0005, 0.0},         {0.9998, 0.9980, 0.9804, 0.8335, 0.3335, 0.0477, 0.0050, 0.0005},         {1.0, 0.9997, 0.9971, 0.9713, 0.7719, 0.2529, 0.0327, 0.0034},         {1.0, 0.9999, 0.9994, 0.9939, 0.9425, 0.6211, 0.1408, 0.0161},         {1.0, 1.0, 0.9998, 0.9984, 0.9841, 0.8606, 0.3817, 0.0581},         {1.0, 1.0, 0.9999, 0.9995, 0.9948, 0.9503, 0.6568, 0.1607},         {1.0, 1.0, 1.0, 0.9998, 0.9980, 0.9807, 0.8358, 0.3373},         {1.0, 1.0, 1.0, 0.9999, 0.9992, 0.9917, 0.9229, 0.5448}     };      for (i = 1 ; i &lt; 16 ; i++)     {         if (temp[i] &lt;= Ti &amp;&amp; temp[i+1] &gt;= Ti)         {             k = i;             break;         }     }      for (j = 1 ; j &lt; 9 ; j++)     {         if (n[j] &lt;= Ne &amp;&amp; n[j+1] &gt;= Ne)         {             l = j;             break;         }     }      y1 = HPE[k][l];     y2 = HPE[k+1][l];     y3 = HPE[k+1][l+1];     y4 = HPE[k][l+1];      t = (Ti - (HPE[k][0])) / ((HPE[k+1][0]) - (HPE[k][0]));     u = (Ne - (HPE[0][l])) / ((HPE[0][l+1]) - (HPE[0][l]));     p = ((1 - t) * (1 - u) * y1) + (t * (1 - u) * y2) + (t * u * y3) + ((1 - t) * u * y4);      return (p); } </code></pre>