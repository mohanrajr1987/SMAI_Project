<p>I am currently working on understanding the Java concept of multithreading. I went through a tutorial which uses the Tortoise and the Hare example to explain the concept of multithreading, and to a large extent I understood the syntax and the logic of the video tutorial. At the end of the video tutorial, the Youtuber gave an assignment that involves applying Multithreading to an olympic race track. </p>  <p>Using my knowledege from the example, I was able to create 10 threads (representing the athletes) that run within a loop, that executes 100 times (representing 100 meters).</p>  <p>My challenge is that when the Thread scheduler makes an Athlete to get to 100 meters before the other 9 athletes, the remaining 9 threads always do not complete their race. This is not usually the case in a standard race track. The fact that a Thread called Usain Bolts gets to 100 first, does not mean Yohan Blake should stop running if he is at 90m at that time. </p>  <p>I am also interested in getting the distance (note that they are all using the same variable) for each thread, so that I can use a function to return the positions of each Thread at the end of the race.</p>  <p>What I have done (that did not work):  1) I have tried to use an if else construct (containing nine "else"  statement) to assign the distance of each executing thread to a new integer variable. (using the Thread.currentThread().getName() property and the name of each thread) but that did not work well for me. This was an attempt to give positions to the athletes alone using their distance but does nothing about the 9 athletes not finishing the race.<br> 2) I have also tried to use an ArrayList to populate the distance at runtime but for some strange reasons this still overwrites the distance each time it wants to add another distance.</p>  <p>Below are my codes:</p>  <pre><code>package olympics100meters;  import java.util.ArrayList;  public class HundredMetersTrackRules implements Runnable { public static String winner;  public void race() { for (int distance=1;distance&lt;=50;distance++) { System.out.println("Distance covered by "+Thread.currentThread    ().getName  ()+" is "+distance+" meters.");   boolean isRaceWon=this.isRaceWon(distance); if (isRaceWon) { ArrayList&lt;Integer&gt; numbers = new ArrayList(); numbers.add(distance); System.out.println("testing..."+numbers); break; }  } }   private boolean isRaceWon(int totalDistanceCovered) {    boolean isRaceWon=false;    if ((HundredMetersTrackRules.winner==null)&amp;&amp;    (totalDistanceCovered==50)) {    String winnerName=Thread.currentThread().getName();    HundredMetersTrackRules.winner=winnerName;    System.out.println("The winner is "+HundredMetersTrackRules.winner);    isRaceWon=true;    }     else if (HundredMetersTrackRules.winner==null) {    isRaceWon=false;    }     else if (HundredMetersTrackRules.winner!=null) {    isRaceWon=true;    }    return isRaceWon; }  public void run() { this.race(); }      } </code></pre>  <p>This is my main method (I reduced it to 5 Athletes till I sort out the issues):</p>  <pre><code>public class Olympics100Meters {  /**  * @param args the command line arguments  */  public static void main(String[] args) {    HundredMetersTrackRules racer=new HundredMetersTrackRules();    Thread UsainBoltThread=new Thread(racer,"UsainBolt");    Thread TysonGayThread=new Thread (racer,"TysonGay");    Thread AsafaPowellThread=new Thread(racer,"AsafaPowell");    Thread YohanBlakeThread=new Thread (racer,"YohanBlake");    Thread JustinGatlinThread=new Thread (racer,"JustinGatlin");     UsainBoltThread.start();    TysonGayThread.start();    AsafaPowellThread.start();    YohanBlakeThread.start();    JustinGatlinThread.start();   } } </code></pre>