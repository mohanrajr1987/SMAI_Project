<p>I think this is easier seen in pseudo code, but let me know if you want to see the real deal.  I have a couple tables of interest:</p>  <pre><code>Document - {Id(int), TypeId(int)} DocumentType - {Id(int)} </code></pre>  <p>EF generated some models for me:</p>  <pre><code>Document - {Id(int), TypeId(int), Type(DocumentType)} DocumentType - {Id(int), Documents(ICollection&lt;Document&gt;)} </code></pre>  <p>I think this looks alright at this point.  DocumentType probably doesn't need a collection, but there are cases when this same architecture is useful.</p>  <p>Now I'm going to make a call, assuming we have some hearty populated data:</p>  <p>context.Documents.Include("Type").Where(x => x.Id &lt; 3):</p>  <pre><code>Document:{id:1, type:{id:1, documents:null}} Document:{id:2, type:{id:4, documents:null}} </code></pre>  <p>This looks fine.  Now I will do another call. </p>  <p>context.Documents.Include("Type").Where(x => x.Id &lt; 4):</p>  <pre><code>Document:{id:1, type:{id:1, documents:[{id:1, type:{id:1, documents:*}},{id:2, type:{id:4, documents:*}},{id:3, type:{id:1, documents:*}}]}} Document:{id:2, type:{id:4, documents:[{id:1, type:{id:1, documents:*}},{id:2, type:{id:4, documents:*}},{id:3, type:{id:1, documents:*}}]}} Document:{id:3, type:{id:1, documents:[{id:1, type:{id:1, documents:*}},{id:2, type:{id:4, documents:*}},{id:3, type:{id:1, documents:*}}]}} </code></pre>  <p>Where '*' represents and infinite recursion of model properties.  This recursion ONLY happens if the embedded collection contains an object that is also properly loaded anywhere in the model or array of models retrieved.  (In this example case, the third entry has a type that matches the first entry.)  This to me feels like something cache related that EF is doing, but hoping someone has some input on why this is happening.</p>  <p>(EF4, Database-First - model generation via edmx)</p>  <p>Thanks!</p>