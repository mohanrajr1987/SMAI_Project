<p>I'm new to C and trying to write a command line program with it. I'm trying to free a char array right before the program terminates. But I'm getting a "debug assertion failed" run-time error when it reaches the <code>free</code> command. Before it reaches that point, the program is removing characters in that array up until the first whitespace. I'm using the incrementing technique on the array since I read that was a way to remove chars one by one from an array. Here's that piece of code:</p>  <pre><code>char command[140]; char * input = getInput();  //prompt function for user input  //get string up to first whitespace to separate the command and its parameters for (i = 0; i &lt; strlen(input); i++) {     if (input[i] == ' ' || input[i] == '\0')         break;      command[i] = input[i]; }  for (j = 0; j &lt;= i; j++)    //removes command and space and leaves parameters     input++;  command[i] = '\0';  //null terminate char array numParams = getNumParams(input); free(input);  //should've added this line earlier to avoid confusion. </code></pre>  <p>My <code>getInput()</code> function does this:</p>  <pre><code>char * getInput() {     int n, size = 260;     char * input = (char*)malloc(size);     if (!input)                 //make sure memory allocation worked         return NULL;      do     {         printf("cmd&gt; ");            //prompt         fgets(input, 256, stdin);   //get user input/commands         n = strlen(input);     } while (n &lt;= 1);      if (input[n - 1] == '\n')           //remove new line from input array         input[n - 1] = '\0';      return input; } </code></pre>  <p>So after the rest of the program ends I want to be able to free the memory that was allocated in the <code>getInput()</code> function. I'm thinking the way I have the <code>input</code> returning to a char pointer is messing that up. But I'm not sure how to fix it. Any help is appreciated.</p>