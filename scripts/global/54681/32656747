<p>I am building an application using Xamarin (Android), it uses a PCL project as a Service layer. I have a Web Api endpoint and I am using <code>HttpClient</code> to consume it.</p>  <p>Everything works fine, but if I leave my Android app open and idle for a while (like 2 minutes) and I try to make a new request, the first request using the singleton <code>HttpClient</code> won't work. It just never returns and stays there until it timeouts (<code>TaskCancelledException</code>). I also put a breakpoint on my Api and it doesn't get hit. If I try to send the request again, then it works.</p>  <p>After a lot of debugging I found that this only happens if I try to use the <code>HttpClient</code> as a Singleton. If I create a new <code>HttpClient</code> for every request everything works.</p>  <p>At first I thought this was a deadlock issue, I've done a lot of research and double checked everything following the guidelines described in this <a href="http://stackoverflow.com/questions/10343632/httpclient-getasync-never-returns-when-using-await-async">other answer</a> and <a href="http://blog.stephencleary.com/2012/02/async-and-await.html" rel="nofollow">Stephen Cleary's excellent post</a> and I'm almost sure this is not the case.<br> I'm using <code>ConfigureAwait(false)</code> in every call from my PCL project so it doesn't capture the context.</p>  <h2>The flow of a request goes like this:</h2>  <p>Inside an Android Fragment:</p>  <pre><code>SampleService svc = new SampleService(); response = await svc.GetAllSamples(); </code></pre>  <p>The service called (in my PCL project):</p>  <pre><code>public class SampleService {     public HttpClient Client { get; set; }      public SampleService()     {         // resolves my singleton instance and uses my custom DelegatingHandler         Client = CustomHttpClient.Instance;     }      public async Task&lt;IEnumerable&lt;Sample&gt;&gt; GetAllSamples()     {         IEnumerable&lt;Sample&gt; list = null;          // this never returns and timeouts the first time         using (var response = await Client.GetAsync("samples").ConfigureAwait(false))         {             if (response.IsSuccessStatusCode)             {                 string json = await response.Content.ReadAsStringAsync().ConfigureAwait(false);                 lista = await Task.Run(() =&gt; JsonConvert.DeserializeObject&lt;IEnumerable&lt;Sample&gt;&gt;(json)).ConfigureAwait(false);             }              return list;         }     } } </code></pre>  <p>This is how I build my Singleton instance:</p>  <pre><code>public sealed class CustomHttpClient {     private static HttpClient _client;      public static HttpClient GetClient()     {         if (_client == null)         {             HttpMessageHandler messageHandler = new HttpClientHandler();             _client = new HttpClient(messageHandler);             _client.Timeout = TimeSpan.FromSeconds(30);             _client.BaseAddress = new Uri("myendpoint");             _client.DefaultRequestHeaders.Accept.Clear();             _client.DefaultRequestHeaders.Accept.Add(new MediaTypeWithQualityHeaderValue("application/json"));         }          return _client;     } } </code></pre>  <p>I tried to simplify and isolate the code here, if I can provide any other useful snippets, just let me know.</p>  <p>Am I doing something wrong regarding singletons <code>HttpClient</code> that I'm not aware of?</p>  <p><strong>Update:</strong> Just for clarification, I'm trying to use <code>HttpClient</code> as a Singleton just because, as I found in <a href="http://stackoverflow.com/a/20075006/1710624">this answer by Darrel Miller</a> and in the book <a href="http://rads.stackoverflow.com/amzn/click/1449337716" rel="nofollow">Designing Evolvable Web APIs with ASP.NET</a> (Chapter 14), they were designed to be reusable and thread-safe (in most of the cases). From my research I'm not using anything that is not thread-safe in it.</p>