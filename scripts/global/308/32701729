<p>I'm getting everything ready in a little DirectX 11.0 project of mine for a deferred rendering pipeline. However, I've been having quite a lot of trouble with sampling the depth buffer from within a pixel shader. </p>  <p>First I define the depth texture and its shader resource view: </p>  <pre><code>    D3D11_TEXTURE2D_DESC depthTexDesc;     ZeroMemory(&amp;depthTexDesc, sizeof(depthTexDesc));     depthTexDesc.Width = nWidth;     depthTexDesc.Height = nHeight;     depthTexDesc.Format = DXGI_FORMAT_R32_TYPELESS;     depthTexDesc.Usage = D3D11_USAGE_DEFAULT;     depthTexDesc.BindFlags = D3D11_BIND_DEPTH_STENCIL | D3D11_BIND_SHADER_RESOURCE;     depthTexDesc.MipLevels = 1;     depthTexDesc.ArraySize = 1;     depthTexDesc.SampleDesc.Count = 1;     depthTexDesc.SampleDesc.Quality = 0;     depthTexDesc.CPUAccessFlags = 0;     depthTexDesc.MiscFlags = 0;      hresult = d3dDevice_-&gt;CreateTexture2D(&amp;depthTexDesc, nullptr, &amp;depthTexture_);      D3D11_DEPTH_STENCIL_VIEW_DESC DSVDesc;     ZeroMemory(&amp;DSVDesc, sizeof(DSVDesc));     DSVDesc.Format = DXGI_FORMAT_D32_FLOAT;     DSVDesc.ViewDimension = D3D11_DSV_DIMENSION_TEXTURE2D;     DSVDesc.Texture2D.MipSlice = 0;      hresult = d3dDevice_-&gt;CreateDepthStencilView(depthTexture_, &amp;DSVDesc, &amp;depthView_);      D3D11_SHADER_RESOURCE_VIEW_DESC gbDepthTexDesc;     ZeroMemory(&amp;gbDepthTexDesc, sizeof(gbDepthTexDesc));     gbDepthTexDesc.Format = DXGI_FORMAT_R32_FLOAT;     gbDepthTexDesc.ViewDimension = D3D11_SRV_DIMENSION_TEXTURE2D;     gbDepthTexDesc.Texture2D.MipLevels = 1;     gbDepthTexDesc.Texture2D.MostDetailedMip = -1;      d3dDevice_-&gt;CreateShaderResourceView(depthTexture_, &amp;gbDepthTexDesc, &amp;gbDepthView_); </code></pre>  <p>Here's the relevant part of my rendering function:</p>  <pre><code>    float clearColor[4] = { 0.0f, 0.0f, 0.0f, 1.0f };     d3dContext_-&gt;ClearRenderTargetView(backBufferTarget_, clearColor);     d3dContext_-&gt;ClearDepthStencilView(depthView_, D3D11_CLEAR_DEPTH, 1.0f, 0);      // GBuffer packing pass (in the future): /////////////////////////////////////////      d3dContext_-&gt;OMSetRenderTargets(1, &amp;backBufferTarget_, depthView_);      unsigned int nStride = sizeof(Vertex);     unsigned int nOffset = 0;      d3dContext_-&gt;IASetInputLayout(inputLayout_);     d3dContext_-&gt;IASetVertexBuffers(0, 1, &amp;vertexBuffer_, &amp;nStride, &amp;nOffset);     d3dContext_-&gt;IASetIndexBuffer(indexBuffer_, DXGI_FORMAT_R32_UINT, 0);     d3dContext_-&gt;IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);      d3dContext_-&gt;VSSetShader(firstVS_, 0, 0);     d3dContext_-&gt;PSSetShader(firstPS_, 0, 0);      d3dContext_-&gt;DrawIndexed(nIndexCount_, 0, 0);      d3dContext_-&gt;OMSetRenderTargets(1, &amp;backBufferTarget_, nullptr);      d3dContext_-&gt;VSSetShader(secondVS_, 0, 0);     d3dContext_-&gt;PSSetShader(secondPS_, 0, 0);     d3dContext_-&gt;PSGetShaderResources(0, 1, &amp;gbDepthView_);     d3dContext_-&gt;PSSetSamplers(0, 1, &amp;colorMapSampler_);      d3dContext_-&gt;DrawIndexed(nIndexCount_, 0, 0);      swapChain_-&gt;Present(0, 0); </code></pre>  <p>In this temporary implementation, firstVS_ and secondVS_ are identical, and their only function is to do all the transforms and pass on the data to the PSs.</p>  <p>And finally, here are firstPS_ and secondPS_:</p>  <pre><code>// firstPS_ float4 main(PS_Input frag) : SV_TARGET {     return float4(1.0f, 1.0f, 1.0f, 1.0f); }  // secondPS_ Texture2D&lt;float&gt; depthMap_ : register(t0); SamplerState colorSampler_ : register(s0);  float4 main(PS_Input frag) : SV_TARGET {     float4 psOut;     psOut.xyz = depthMap_.Sample(colorSampler_, frag.tex0).xxx;     psOut.w = 1.0f;     return psOut; } </code></pre>  <p><strong>So, my actual questions:</strong></p>  <p>1) All this code compiles without any issues, but when I sample the depth buffer, it just turns out black. I read this could be caused by having your depth &amp; stencil view bound by <code>D3D11DeviceContext::OMSetRenderTargets()</code> at the time you want to sample the depth buffer. I fixed that, but the buffer is still black. I checked the graphics debugger, with no success. So, is my depth buffer not getting written correctly, or am I sampling the wrong way? firstPS_ works fine.</p>  <p>2) Speaking of sampling, the book I'm using just says "we'll be using a point sampler," but I have no idea what is exactly meant. Now I'm just using a standard texture map sampler, but is there something else I should sample with?</p>  <p>3) Also, the book uses the <code>SamplerState.Gather()</code> function in secondPS_, but when I tried that it complained that "the expression could not be mapped to pixel shader instruction set." Is <code>Gather()</code> an error in the book, or is it my GPU (D3D feature level 11.0) who doesn't understand what that is? Is <code>Sample()</code> good enough for what I want to do? The original use of <code>Gather()</code> was in the context of creating a silhouette around objects in the depth buffer.</p>  <p>4) I tried to get secondVS_ to draw nothing but a full-screen quad, but FXC complained about my use of <code>SV_VertexID</code> as "invalid," saying that my type should be integral, even though it already was. I read somewhere that <code>SV_VertexID</code> can only be used by the first VS in a pipeline. Is that the problem here? How do I solve this in this particular case? In my current inefficient solution, is the problem being caused by the UVs?</p>