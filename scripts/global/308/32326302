<p>I'm trying to create a texture manually from my own data and display it. As I could seize in different DirectX docs the main part of code would be written in this manner</p>  <pre><code>// Global variables HWND g_hWnd = NULL; D3D10_DRIVER_TYPE g_driverType = D3D10_DRIVER_TYPE_NULL; ID3D10Device *g_pd3dDevice = NULL; IDXGISwapChain *g_pSwapChain = NULL; ID3D10RenderTargetView *g_pRenderTargetView = NULL; ID3D10ShaderResourceView *g_pShaderResource = NULL; ID3DX10Sprite *g_pSprite = NULL; ID3D10Texture2D *g_pTexture = NULL;  // Any additional code for creation the window object // ............  // Initialize DirectX HRESULT InitDirectX() {     HRESULT hr = S_OK;      RECT rc;     GetClientRect(g_hWnd, &amp;rc);     UINT width = rc.right - rc.left;     UINT height = rc.bottom - rc.top;      D3D10_DRIVER_TYPE driverTypes[] =      {         D3D10_DRIVER_TYPE_HARDWARE,          D3D10_DRIVER_TYPE_REFERENCE     };     UINT numDriverTypes = sizeof(driverTypes)/sizeof(driverTypes[0]);      // Initialization of the Swap Chain and the Device     DXGI_SWAP_CHAIN_DESC sd;     ZeroMemory(&amp;sd, sizeof(sd));     sd.BufferCount = 1;     sd.BufferDesc.Width = 64;     sd.BufferDesc.Height = 64;     sd.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;     sd.BufferDesc.RefreshRate.Numerator = 60;     sd.BufferDesc.RefreshRate.Denominator = 1;     sd.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;     sd.OutputWindow = g_hWnd;     sd.SampleDesc.Count = 1;     sd.SampleDesc.Quality = 0;     sd.Windowed = TRUE;     sd.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;      for (UINT driverTypeIndex = 0; driverTypeIndex &lt; numDriverTypes; driverTypeIndex++)     {         g_driverType = driverTypes[driverTypeIndex];         hr = D3D10CreateDeviceAndSwapChain(NULL, g_driverType, NULL, D3D10_CREATE_DEVICE_DEBUG, D3D10_SDK_VERSION, &amp;sd, &amp;g_pSwapChain, &amp;g_pd3dDevice);         if (SUCCEEDED(hr))             break;     }     if (FAILED(hr))         return hr;      ID3D10Texture2D *pBackBuffer;     hr = g_pSwapChain-&gt;GetBuffer(0, __uuidof(ID3D10Texture2D), (LPVOID*)&amp;pBackBuffer);     if (FAILED(hr))         return hr;      hr = g_pd3dDevice-&gt;CreateRenderTargetView(pBackBuffer, NULL, &amp;g_pRenderTargetView);     pBackBuffer-&gt;Release();     if (FAILED(hr))         return hr;      g_pd3dDevice-&gt;OMSetRenderTargets(1, &amp;g_pRenderTargetView, NULL);      // Create the Viewport     D3D10_VIEWPORT vp;     vp.Width = 64;     vp.Height = 64;     vp.MinDepth = 0.0f;     vp.MaxDepth = 1.0f;     vp.TopLeftX = 0.0f;     vp.TopLeftY = 0.0f;     g_pd3dDevice-&gt;RSSetViewports(1, &amp;vp);       // Fill the structure of future texture     D3D10_TEXTURE2D_DESC desc;     desc.Width = 64;     desc.Height = 64;     desc.MipLevels = desc.ArraySize = 1;     desc.MiscFlags = 0;     desc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;     desc.SampleDesc.Count = 1;     desc.Usage = D3D10_USAGE_DYNAMIC;     desc.BindFlags = D3D10_BIND_SHADER_RESOURCE;     desc.CPUAccessFlags = D3D10_CPU_ACCESS_WRITE;      hr = g_pd3dDevice-&gt;CreateTexture2D( &amp;desc, NULL, &amp;g_pTexture );      // Get the access to the texture data     D3D10_MAPPED_TEXTURE2D mappedTex;     g_pTexture-&gt;Map( D3D10CalcSubresource(0, 0, 1), D3D10_MAP_WRITE_DISCARD, 0, &amp;mappedTex );      int cnt = 0;     UCHAR* pTexels = (UCHAR*)mappedTex.pData;     ZeroMemory(pTexels, sizeof(pTexels));     for( UINT row = 0; row &lt; desc.Height; row++ )     {         UINT rowStart = row * mappedTex.RowPitch;         for( UINT col = 0; col &lt; desc.Width; col++ )         {             UINT colStart = col * 4;             if (cnt == 0)             {                 pTexels[rowStart + colStart + 0] = 255; // Red                 pTexels[rowStart + colStart + 1] = 128; // Green                 pTexels[rowStart + colStart + 2] = 64; // Blue                 pTexels[rowStart + colStart + 3] = 255; // Alpha             }              else             {                 pTexels[rowStart + colStart + 0] = 64;// Red                 pTexels[rowStart + colStart + 1] = 128;// Green                 pTexels[rowStart + colStart + 2] = 255;// Blue                 pTexels[rowStart + colStart + 3] = 255;// Alpha             }             cnt++;             cnt %= 2;         }     }      g_pTexture-&gt;Unmap( D3D10CalcSubresource(0, 0, 1));      // Bind shader and texture     D3D10_SHADER_RESOURCE_VIEW_DESC srvDesc;      // Fill the shader attributes     srvDesc.Format = desc.Format;     srvDesc.ViewDimension = D3D10_SRV_DIMENSION_TEXTURE2D;     srvDesc.Texture2D.MipLevels = desc.MipLevels;     srvDesc.Texture2D.MostDetailedMip = desc.MipLevels - 1;     hr = g_pd3dDevice-&gt;CreateShaderResourceView(g_pTexture, &amp;srvDesc, &amp;g_pShaderResource);      // Create sprite object     hr = D3DX10CreateSprite(g_pd3dDevice, 1, &amp;g_pSprite);     if (FAILED(hr))         return hr;      return S_OK; }  // Now render the texture  void RenderScene() {      float ClearColor[4] = {1.0f, 1.0f, 1.0f, 1.0f};     g_pd3dDevice-&gt;ClearRenderTargetView(g_pRenderTargetView, ClearColor);      D3DXMATRIX mWorld;     D3DXMATRIX mView;     D3DXMATRIX mProjection;      // Now render the generated texture thus it will be entirelly displayed in window     D3DXMatrixTranslation(&amp;mWorld, 0.0f, 0.0f, 0.0f);     D3DXMatrixPerspectiveFovLH(&amp;mProjection, 0.3258f, 1.0f, 0.0f, 0.01f);      g_pSprite-&gt;SetProjectionTransform(&amp;mProjection);      D3DXVECTOR3 vEyePt(0.0f, 0.0f, -3.0f);     D3DXVECTOR3 vLookAtPt(0.0f, 0.0f, 0.0f);     D3DXVECTOR3 vUpVec(0.0f, 1.0f, 0.0f);     D3DXMatrixLookAtLH(&amp;mView, &amp;vEyePt, &amp;vLookAtPt, &amp;vUpVec);      g_pSprite-&gt;SetViewTransform(&amp;mView);      HRESULT hr;      g_pSprite-&gt;Begin(D3DX10_SPRITE_SORT_TEXTURE);      // Render sprite based on shader created on the basis of generated texture     D3DX10_SPRITE SpriteToDraw; // Sprite array     SpriteToDraw.matWorld = mWorld;     SpriteToDraw.TexCoord.x = 0.0f;     SpriteToDraw.TexCoord.y = 0.0f;     SpriteToDraw.TexSize.x = 1.0f;     SpriteToDraw.TexSize.y = 1.0f;     SpriteToDraw.ColorModulate = D3DXCOLOR(1.0f, 1.0f, 1.0f, 1.0f);     SpriteToDraw.pTexture = g_pShaderResource;     SpriteToDraw.TextureIndex = 0;      hr = g_pSprite-&gt;DrawSpritesBuffered(&amp;SpriteToDraw, 1);     if (FAILED(hr))     {         MessageBox(NULL, L"Sprite display error", L"Error", 0);     }      g_pSprite-&gt;Flush();     g_pSprite-&gt;End();      g_pSwapChain-&gt;Present(0, 0); } </code></pre>  <p>Suddenly, the final result represents the image with nonuniform "lightened" stripes. </p>  <p><img src="http://savepic.org/7623429.jpg" alt="link to image">:</p>  <p>I've tried to change viewpoint parameters, that led to change the number of visible stripes and their shade, but I can't understand the cause of appearance of different blue/orange shades (in code their colors are uniform). Also, if I generate texture that is evenly filled with one color, i.e:</p>  <pre><code>for( UINT row = 0; row &lt; desc.Height; row++ ) {     UINT rowStart = row * mappedTex.RowPitch;     for( UINT col = 0; col &lt; desc.Width; col++ )     {         UINT colStart = col * 4;         pTexels[rowStart + colStart + 0] = xxx; // Exact color has no reason         pTexels[rowStart + colStart + 1] = yyy;          pTexels[rowStart + colStart + 2] = zzz;          pTexels[rowStart + colStart + 3] = ttt;      } } </code></pre>  <p>there is no effect of nonuniform shade of the final displayed texture. </p>