<p>I have an array of custom dtype <em>my_type</em> which I successfully read from a binary file. The custom dtype has a header section after that comes the data. The data part are <strong>np.int16</strong> numbers, so the custom dtype looks like this:</p>  <pre><code>header, imaginary, real, imaginary, real,  ..., imaginary, real  </code></pre>  <p>Now I am looking for a smart way to use Numpy's <strong>view</strong> to get an array of <strong>np.complex64</strong> of <em>only data</em> without copying/looping etc. considering the following facts:</p>  <ul> <li>the header part should be ignored</li> <li>somehow correct the order (i.e. first real, imaginary)</li> <li>the resulting array should be complex64 not complex32!</li> </ul>  <p>That is, from an array of custom dtype:</p>  <pre><code>[my_type, my_type, ..., my_type]  </code></pre>  <p>I like to get a much larger array containing:</p>  <pre><code>[complex64, complex64, ..., complex64] </code></pre>  <p>Is it possible to do this in one go using Numpy's <strong>view</strong>?</p>  <p><strong>UPDATE:</strong></p>  <p>So the solution is copying in memory. Many thanks to the answers below. But because the annoying header appears before every data frame, it seems that in spite of copying in the memory, a loop over all data frames is still necessary. In a schematic manner I have:</p>  <pre><code>a = np.arange(10, dtype=np.float16) skip_annoying_header = 2 r = np.zeros(a.size - skip_annoying_header, np.float16) r[0::2], r[1::2] = a[skip_annoying_header + 1::2], a[skip_annoying_header::2] r = r.astype(np.float32) r = r.view(np.complex64) </code></pre>  <p>And I do this in a <code>for</code> loop for every data frame, and then at the end of the <code>for</code> loop, I copy again the content of <code>r</code> into <strong>big</strong> array.</p>  <p>Can this looping be somehow eliminated?</p>