<p>I have a function that compares bits from a binary representation string and a chunk of memory and returns true if they are equal.</p>  <p>This is the function (which works as expected): I'll explain with comments what some external methods are supposed to do, accept that they work as expected for the sake of this question.</p>  <pre><code>size_t bytes = (check_n_bits + 7) / 8; size_t bytes_with_skip = (check_n_bits + skip_b_bits + 7) / 8;  //Check if `this` contains the number of bytes we need if(this-&gt;canMoveForward(bytes_with_skip) == false) return false;  //Read the required number if bits. Ignore the skip_b_bits argument. Bits *data = this-&gt;readBits(check_n_bits, skip_b_bits);  unsigned char *bin_string = Utils::removeSpaces(string); size_t len = strlen((const char *) bin_string); if(Utils::isValidBinString(bin_string) || len &lt; check_n_bits) return false;  unsigned int last_bits = check_n_bits &lt;= 8 ? check_n_bits : (bytes * 8) - check_n_bits; last_bits = last_bits == 0 ? 8 : last_bits;  char tmp_bin_repr[9], tmp_bin_repr_2[9];  for(size_t i = 0; i &lt; bytes ; i++) {     int skip_bits_if_last = i + 1 == bytes ? (8 - last_bits) : 0;     int bits_to_compare = i + 1 == bytes ? last_bits : 8;      uint8_t c = data-&gt;read_uint8();     sprintf((char *) &amp;tmp_bin_repr, BYTETOBINARYPATTERN, BYTETOBINARY(c));     for(int j = 0; j &lt; bits_to_compare; j++) {         tmp_bin_repr_2[j] = *(&amp;(bin_string[i * 8]) + j);     }      if(memcmp((const char *) tmp_bin_repr + skip_bits_if_last, (const char *) tmp_bin_repr_2, bits_to_compare) != 0) {         match = false;         break;     } } </code></pre>  <p>Helper macro:</p>  <pre><code>#define BYTETOBINARYPATTERN "%d%d%d%d%d%d%d%d" #define BYTETOBINARY(byte) \     (byte &amp; 0x80 ? 1 : 0), \     (byte &amp; 0x40 ? 1 : 0), \     (byte &amp; 0x20 ? 1 : 0), \     (byte &amp; 0x10 ? 1 : 0), \     (byte &amp; 0x08 ? 1 : 0), \     (byte &amp; 0x04 ? 1 : 0), \     (byte &amp; 0x02 ? 1 : 0), \     (byte &amp; 0x01 ? 1 : 0) </code></pre>  <p>Let's call this function <code>compareBinary(const char *string, size_t check_n_bits, size_t skip_b_bits)</code>.</p>  <p>How is this function used? The function is a method of an object that contains some data. When this method is called, it compares as many bits from a binary string representation of <code>data</code> as we pass it with the data contained in the object.</p>  <p>Example:</p>  <pre><code>mObj-&gt;compareBinary("01010101 11110100 00", 18, 0); </code></pre>  <p>This will compare 18 bits in total with the data that is hold in the object. First 8 chars of the passed string will be taken and the first byte of the data hold by the object will be converted to a string (using the helper macro). Then both will be compared. Second 8 chars, the same. Then we'd get the last <code>00</code> chars, take the third byte, convert it to a 8 chars binary representation, but only the first two chars will be compared.</p>  <p>This lets me compare a random number of bits with a simple binary representation of the data.</p>  <p>While the function works as expected and it's passing multiple unit tests, I believe it can be refactored and optimized. Can you give me any tips how to do it?</p>