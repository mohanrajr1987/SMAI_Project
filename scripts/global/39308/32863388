<p>I would like to show an arrow on my map when a marker is outside of the viewport.</p>  <p>It would be exactly like this, but this solution works only for the version 2 of Google Maps API.</p>  <p><a href="http://gmaps-utility-library.googlecode.com/svn/trunk/markertracker/release/examples/onetracker.html" rel="nofollow">http://gmaps-utility-library.googlecode.com/svn/trunk/markertracker/release/examples/onetracker.html</a></p>  <p>Anybody has some code or an idea about how to do this?? Here is the code I got so far, it works but I could only make it refresh the arrows when the map throws an IDLE event, and another problem is that I am not able to show the arrows on the side of my viewport, only an aproximate radius from the center of my map.</p>  <pre><code>google.maps.event.addListener($rootScope.map, 'idle', function() {  setProximityFromMap();   // Watches for map bounds change - if so - set radius and refresh data Start                         function setProximityFromMap() {                             // Get Gmap radius / proximity start                             // First, determine the map bounds                             var bounds = $rootScope.map.getBounds();                              // Then the points                             var swPoint = bounds.getSouthWest();                             var nePoint = bounds.getNorthEast();                              var proximitymeter = google.maps.geometry.spherical.computeDistanceBetween(swPoint, nePoint) / 2;                             var padding = (proximitymeter / 100) * 40;                             $rootScope.proximitymeter = proximitymeter - padding;                          }  //Clear the little arrow markers that we could have drawn before                         angular.forEach( $rootScope.directionMarkers, function(value, key) {                              value.setMap(null);                         });                         $rootScope.directionMarkers = [];                           angular.forEach( markersVivas, function(value, key) {                             if (!( $rootScope.map.getBounds().contains( value.position ) )) {                                  var heading = google.maps.geometry.spherical.computeHeading( $rootScope.map.getCenter(), value.position );                                 var boundPosition = google.maps.geometry.spherical.computeOffset($rootScope.map.getCenter(), $rootScope.proximitymeter, heading);                                  var directionMarker = new google.maps.Marker({                                     position: boundPosition,                                     map: $rootScope.map,                                     draggable: false,                                     icon: {                                             path: google.maps.SymbolPath.FORWARD_CLOSED_ARROW,                                             scale: 2,                                             rotation: heading                                           }                                 });                                 $rootScope.directionMarkers.push(directionMarker);                             }                         }); } </code></pre>  <p>As you can see, I use an aproximate padding of 40% of the distance between NE and SW of my viewport as a radius. </p>