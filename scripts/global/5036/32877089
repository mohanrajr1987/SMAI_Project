<p>I have been experimenting with abstract types. The code below gives me a desired effect.</p>  <pre><code>class base{ public:  virtual void do_stuff() = 0; };  class derived: public base{ public:  void do_stuff(){/*stuff*/} };  class manager{  vector&lt;shared_ptr&lt;base&gt;&gt; ptrs; public:  void add(base* ptr){   ptrs.emplace_back(ptr);  } };  manager foo; foo.add(new derived()); </code></pre>  <p>Fine and dandy, but it's awkward because the user is not only dealing with pointers, but has to use <code>new</code> without ever calling <code>delete</code>. My question is if there's a way I can implement this where the user of <code>manager</code> doesn't ever have to deal with pointers or <code>new</code>.</p>  <pre><code>foo.add(derived()); //example </code></pre>  <p>My attempts to implement this end up as:</p>  <pre><code>class manager{  vector&lt;shared_ptr&lt;base&gt;&gt; ptrs; public:  void add(base&amp; ref){   ptrs.emplace_back(&amp;ref);  } }; </code></pre>  <p>But, the compiler says <code>no known conversion from 'derived' to 'base&amp;'</code>. I have no idea how to make a reference to <code>base</code> compatible with a reference to <code>derived</code>. How do I get around this?</p>