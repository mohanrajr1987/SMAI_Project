<p>In C++, I have a class <code>MyClass</code>, which during construction takes a reference to an <code>int</code> to create an internal reference to it.</p>  <p>I then have a class <code>BigClass</code>, containing both an <code>std::vector&lt;int&gt; vecInt_</code> and an <code>std::vector&lt;MyClass&gt; vecMyClass_</code>. The constructor of <code>BigClass</code> takes as an argument the size of the vectors <code>vecInt_</code> and <code>vecMyClass_</code>. In the constructor of <code>BigClass</code>, I would like to have each element of <code>vecMyClass_</code> use in its constructor the corresponding element of <code>vecInt_</code>.</p>  <p>How could I write that ? If I could call the constructors of <code>vecMyClass</code> from the body of the constructor of BigClass, that would look like that :</p>  <pre><code>BigClass(int nbElem) :     vecInt_(nbElem),     vecMyClass_(nbElem) {     for (int i = 0; i &lt; nbElem; ++i)     {         vecMyClass_[i](vecMyInt_[i]);     } } </code></pre>  <p>But of course the parenthesis here would mean <code>operator()</code>, and not the constructor. I cannot write something like:</p>  <pre><code>vecMyClass_[i] = MyClass(vecMyInt_[i]); </code></pre>  <p>Because MyClass contains a reference and not a pointer, and thus referenced value can not be modified.</p>