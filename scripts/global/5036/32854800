<p>Code:</p>  <pre><code>4: typedef unsigned short  USHORT; 5: #include &lt;iostream.h&gt; 6: 7:     class Counter 8:     { 9:        public: 10:          Counter(); 11:          ~Counter(){} 12:          USHORT GetItsVal()const { return itsVal; } 13:          void SetItsVal(USHORT x) {itsVal = x; } 14:          void Increment() { ++itsVal; } 15:          const Counter&amp; operator++ (); 16: 17:       private: 18:          USHORT itsVal; 19: 20:    }; 21: 22:    Counter::Counter(): 23:    itsVal(0) 24:    {}; 25: 26:    const Counter&amp; Counter::operator++() 27:    { 28:       ++itsVal; 29:       return *this; 30:    } 31: 32:    int main() 33:    { 34:       Counter i; 35:       cout &lt;&lt; "The value of i is " &lt;&lt; i.GetItsVal() &lt;&lt; endl; 36:       i.Increment(); 37:       cout &lt;&lt; "The value of i is " &lt;&lt; i.GetItsVal() &lt;&lt; endl; 38:       ++i; 39:       cout &lt;&lt; "The value of i is " &lt;&lt; i.GetItsVal() &lt;&lt; endl; 40:       Counter a = ++i; 41:       cout &lt;&lt; "The value of a: " &lt;&lt; a.GetItsVal(); 42:       cout &lt;&lt; " and i: " &lt;&lt; i.GetItsVal() &lt;&lt; endl; 48:     return 0; 49: } </code></pre>  <p>I'm studying overloading operators in C++ and can't wrap my head around the "const" specifier in line 26. The way I understood constant reference is that we are not allowed to change the value that is stored in the reference. But inside the operator++ function (lines 26-30), the member variable "itsVal" is incremented. Doesn't this violate the "const" requirement in the function's definition?</p>