<p>It is well known (or should be) that binding the result of <a href="http://en.cppreference.com/w/cpp/algorithm/min" rel="nofollow"><code>std::min</code></a> to a <code>const</code> reference is a very bad idea, whenever one of the arguments of <code>std::min</code> is a rvalue, since <code>const</code> reference binding is not propagated through function return. So the following code</p>  <pre><code>#include &lt;iostream&gt; #include &lt;algorithm&gt;  int main() {     int n = 42;     const int&amp; r = std::min(n - 1, n + 1); // r is dangling after this line     std::cout &lt;&lt; r; } </code></pre>  <p>should produce undefined behaviour since <code>r</code> is dangling. And indeed, when compiling with gcc5.2 with <code>-Wall -O3</code> the compiler spits</p>  <blockquote>   <p>warning: <code>&lt;anonymous&gt;</code> is used uninitialized in this function [-Wuninitialized]</p> </blockquote>  <p>However, compiling with clang (llvm 7.0.0) using the same flags (even including <code>-Wextra</code>) does not emit any warning, and the program seems to "work", i.e. displays <code>41</code>. </p>  <p><strong>Question:</strong> Is the clang using a "safe" version of <code>std::min</code>? Like a version that uses some SFINAE to return by value whenever one of the arguments is a rvalue? Or is it simply not required to emit any diagnostic and the program "happens" to produce the "right" result in this UB scenario?</p>