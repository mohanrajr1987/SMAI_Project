<p>Dearest fellow programmers,</p>  <p>I seem to lack some understanding as of how the referencing works in C#.</p>  <p><strong>The case:</strong><br /> I tried to implement some sort of Memento proxy which would wrap an interface and store every parameter that we're provided to the method calls and store these into a list.</p>  <p>Whenever necessary we could call the RestoreState and the objects would "reset" to the original state.</p>  <p><strong>The code:</strong><br /> <em>Consumer and model object</em></p>  <pre><code>class Program {     static void Main(string[] args)     {         IMemento memento = new Memento();         PrestationInfo prestationInfo2 = new PrestationInfo { Advance = 2 };          memento.Add(prestationInfo2);         Console.WriteLine(prestationInfo2.Advance);   //Expect 2          prestationInfo2.Advance = 1;         Console.WriteLine(prestationInfo2.Advance);   //Expect 1          memento.RestoreState();         Console.WriteLine(prestationInfo2.Advance);   //Expect 2, but still 1          Console.ReadKey();     } }  [Serializable] public class PrestationInfo {     public int Advance { get; set; } } </code></pre>  <p><em>Memento</em></p>  <pre><code>    public interface IMemento {     void Add(object pItem);     void RestoreState(); }   public class Memento : IMemento {     public Memento()     {         MementoList = new Dictionary&lt;long, object&gt;();         ReferenceList = new List&lt;object&gt;();         ObjectIDGenerator = new ObjectIDGenerator();     }       private ObjectIDGenerator ObjectIDGenerator { get; set; }     private Dictionary&lt;long, object&gt; MementoList { get; set; }     private List&lt;object&gt; ReferenceList { get; set; }        public void Add(object pItem)     {         bool firstTime;         long id = ObjectIDGenerator.GetId(pItem, out firstTime);          if (firstTime)         {             var mementoObject = DeepCopy(pItem);             MementoList.Add(id, mementoObject);              ReferenceList.Add(pItem);         }     }      public void RestoreState()      {         for (int i = 0; i &lt; ReferenceList.Count; i++)         {             object reference = ReferenceList[i];              bool firstTime;             long id = ObjectIDGenerator.GetId(reference, out firstTime);              if (MementoList.ContainsKey(id))             {                 object mementoObject = MementoList[id];                  reference = mementoObject;                 //reference = PropertyCopy&lt;PrestationInfo&gt;.CopyFrom(mementoObject as PrestationInfo);   //Property copy                 //Interlocked.Exchange(ref reference, mementoObject);   //Also tried this             }         }     }       private static TCopy DeepCopy&lt;TCopy&gt;(TCopy pObjectToCopy)     {         using (MemoryStream memoryStream = new MemoryStream())         {             BinaryFormatter binaryFormatter = new BinaryFormatter();             binaryFormatter.Serialize(memoryStream, pObjectToCopy);              memoryStream.Position = 0;             return (TCopy)binaryFormatter.Deserialize(memoryStream);         }     } } </code></pre>  <p><strong>Extra info</strong><br /> My guess is, I'm doing/understand something wrong regarding the List.</p>  <p>I also tried the Interlocked.Exchange, playing around with "ref"'s, using WeakReference's and storing the object into a CareTaker object (and storing that CareTaker into the List), implement some copy Property thing...</p>  <p>And ... I just can't see it.</p>  <p>My expected result would be the PrestationInfo.Advance property containing the value 2. But it keeps </p>