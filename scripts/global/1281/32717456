<p>I would like to extract "linked dependencies" like I call it.</p>  <p>I am able to create dependency trees with the Stanford Parser and Java. My Sentence is: "Also, important e-mails have to be moved and marked by Thomas."</p>  <p>The results are looking like the following:</p>  <pre><code>Dependency Graph: root(ROOT-0, have-5) advmod(have-5, Also-1) punct(have-5, ,-2) amod(e-mails-4, important-3) nsubj(have-5, e-mails-4) nsubjpass(moved-8, e-mails-4) mark(moved-8, to-6) auxpass(moved-8, be-7) xcomp(have-5, moved-8) cc(moved-8, and-9) xcomp(have-5, marked-10) conj:and(moved-8, marked-10) case(Thomas-12, by-11) nmod:by(marked-10, Thomas-12) punct(have-5, .-13) </code></pre>  <p>As you can see, there are indexes 1-12. With some loops and If-Statements I am able to extract for example: "Thomas marked E-mails".</p>  <p>Code:</p>  <pre><code>  import edu.stanford.nlp.ling.CoreAnnotations;    import edu.stanford.nlp.pipeline.Annotation;    import edu.stanford.nlp.pipeline.StanfordCoreNLP;    import edu.stanford.nlp.semgraph.SemanticGraph;    import edu.stanford.nlp.semgraph.SemanticGraphCoreAnnotations;    import edu.stanford.nlp.util.CoreMap;    import java.util.Properties;   public static void main(String[] args) {      Properties props = new Properties();      props.put("annotators", "tokenize,ssplit,pos,parse,depparse");      props.put("tokenize.options", "ptb3Escaping=false");      props.put("parse.maxlen", "10000");      props.put("depparse.extradependencies", "SUBJ_ONLY");      StanfordCoreNLP pipeline = new StanfordCoreNLP(props);       String str = "Also, important e-mails have to be moved and marked by Thomas.";      Annotation document = new Annotation(str);      pipeline.annotate(document);      CoreMap sentence =     document.get(CoreAnnotations.SentencesAnnotation.class).get(0);  SemanticGraph dependency_graph = sentence.get(SemanticGraphCoreAnnotations.CollapsedCCProcessedDependenciesAnnotation.class);  System.err.println("\n\nDependency Graph: " + dependency_graph.toString(SemanticGraph.OutputFormat.LIST)); </code></pre>  <p>}</p>  <p>But I also want to extract "Thomas moved E-Mails". Quite easy to see in the dependency tree "conj:and". Is there an efficient way to do such extraction? I am building Loops and Loops and that can't be the solution.</p>  <p>This is my current loop-if desaster:</p>  <pre><code>for (int i = 0; i &lt; tdl.size(); i++) {        //Ausgehend vom Subjekt       if(tdl.get(i).reln().toString().contains("nsubj")){            String subjekt = "";            //Abfangen wenn Person = Subjekt           if(tdl.get(i).dep().toString().contains("PRP")){               subjekt = "PERSON";           } else {               subjekt = tdl.get(i).dep().word();           }            String praedikat = tdl.get(i).gov().word();            System.out.println(subjekt + praedikat);            for (int j = 0; j &lt; tdl.size(); j++) {                //Ausgehend vom Subjekt               if((tdl.get(j).reln().toString() == "dobj") &amp;&amp; (tdl.get(i).gov().index() == tdl.get(j).gov().index())){                    //Suche Objekt                   System.out.println(praedikat + "(" + subjekt + "," + tdl.get(j).dep().word() + ")");                } else if((tdl.get(j).reln().toString().contains("conj") &amp;&amp; (tdl.get(i).gov().index() == tdl.get(j).dep().index()))  ) {                    for (int k = 0; k &lt; tdl.size(); k++) {                        if((tdl.get(k).reln().toString() == "dobj") &amp;&amp; (tdl.get(k).gov().index() == tdl.get(j).gov().index())){                            System.out.println(praedikat + "(" + subjekt + "," + tdl.get(k).dep().word() + ")");                        }                   }                } else if((tdl.get(j).reln().toString().contains("nmod:agent") &amp;&amp; (tdl.get(j).gov().index() == tdl.get(i).gov().index()))  ) {                              System.out.println(praedikat + "(" + subjekt + "," + tdl.get(j).dep().word() + ")");                }            }       } </code></pre>