<p>I want to generate an xpath expression for any element name in XSD I pass as an argument to a method.If there are more than element name in XSD i need the paths for all the element names.I couldn't find any API I could use.Any help?</p>  <p>here is an example suppose i have an xsd with following tags</p>  <pre><code>&lt;xs:element name="ContactInformation"&gt;   &lt;xs:complexType&gt;   &lt;xs:sequence&gt;     &lt;xs:choice&gt;       &lt;xs:element name="Name" type="abc:NameInfo"/&gt;       &lt;xs:element name="businessName" type="abc:NameBusinessInfo"/&gt;     &lt;/xs:choice&gt;       &lt;xs:element name="Email" type="abc:AddressInfo"/&gt;       &lt;xs:element name="Phone" type="abc:PhoneInfo"/&gt;      &lt;/xs:sequence&gt;   &lt;/xs:complexType&gt;  &lt;/xs:element&gt;  &lt;xs:element name="Information"&gt;    &lt;xs:complexType&gt;      &lt;xs:sequence&gt;       &lt;xs:element name="Phone" type="abc:PhoneInfo"/&gt;          &lt;xs:annotation&gt;             &lt;xs:documentation&gt;Personal Information/xs:documentation&gt;           &lt;/xs:annotation&gt;         &lt;/xs:element&gt;        &lt;/xs:sequence&gt;      &lt;/xs:complexType&gt;    &lt;/xs:element&gt; </code></pre>  <p>If I pass the argument "phone" . i need to get two paths to the element. ../../../ContactInformation/phone and  ../../../information/phone</p>  <p>I tried this code mentioned here <a href="http://stackoverflow.com/questions/9564987/create-xpath-from-xsd-in-java">Create Xpath from XSD in Java</a></p>  <p>I will post the entire code from that post</p>  <pre><code>public class SAXCreateXPath extends DefaultHandler {  // map of all encountered tags and their running count  private Map&lt;String, Integer&gt; tagCount; // keep track of the succession of elements  private Stack&lt;String&gt; tags;  // set to the tag name of the recently closed tag  String lastClosedTag;  /**  * Construct the XPath expression  */  private String getCurrentXPath() {     String str = "//";     boolean first = true;     for (String tag : tags) {         if (first)             str = str + tag;         else             str = str + "/" + tag;         str += "["+tagCount.get(tag)+"]";         first = false;     }     return str; }  @Override public void startDocument() throws SAXException {     tags = new Stack();     tagCount = new HashMap&lt;String, Integer&gt;(); }  @Override public void startElement (String namespaceURI, String localName, String qName, Attributes atts)     throws SAXException {     boolean isRepeatElement = false;      if (tagCount.get(localName) == null) {         tagCount.put(localName, 0);     } else {         tagCount.put(localName, 1 + tagCount.get(localName));     }      if (lastClosedTag != null) {         // an element was recently closed ...         if (lastClosedTag.equals(localName)) {             // ... and it's the same as the current one             isRepeatElement = true;         } else {             // ... but it's different from the current one, so discard it             tags.pop();         }     }      // if it's not the same element, add the new element and zero count to list     if (! isRepeatElement) {         tags.push(localName);     }      System.out.println(getCurrentXPath());     lastClosedTag = null; }  @Override public void endElement (String uri, String localName, String qName) throws SAXException {     // if two tags are closed in succession (without an intermediate opening tag),     // then the information about the deeper nested one is discarded     if (lastClosedTag != null) {         tags.pop();     }     lastClosedTag = localName; }  public static void main (String[] args) throws Exception {     if (args.length &lt; 1) {         System.err.println("Usage: SAXCreateXPath &lt;file.xml&gt;");         System.exit(1);     }      // Create a JAXP SAXParserFactory and configure it     SAXParserFactory spf = SAXParserFactory.newInstance();     spf.setNamespaceAware(true);     spf.setValidating(false);      // Create a JAXP SAXParser     SAXParser saxParser = spf.newSAXParser();      // Get the encapsulated SAX XMLReader     XMLReader xmlReader = saxParser.getXMLReader();      // Set the ContentHandler of the XMLReader     xmlReader.setContentHandler(new SAXCreateXPath());      String filename = args[0];     String path = new File(filename).getAbsolutePath();     if (File.separatorChar != '/') {         path = path.replace(File.separatorChar, '/');     }     if (!path.startsWith("/")) {         path = "/" + path;     }      // Tell the XMLReader to parse the XML document     xmlReader.parse("file:"+path); } </code></pre>  <p>}</p>  <p>But it is not exactly what i am looking for.It doesn't allow me to pass the element name as argument.</p>