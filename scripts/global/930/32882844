<p>I have looked at every single example on SO (and also looked elsewhere) and I'm stumped about this one.</p>  <p>tblNodes is the MS Access dbase table for storage of a JTree... at read-in I'm trying to find all cases where there is anomalous case of more than one record having the same parent ID and the same sibling index.</p>  <p>This is my SSCCE, although obviously it's not that useful without the dbase itself.  But I think anyone with knowledge in this area will find the output pretty head-scratching.</p>  <pre><code>import java.sql.Connection; import java.sql.DriverManager; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.sql.SQLException;  public class CursorProb {      public static void main(String[] args) throws SQLException {         // normalise where we find any duplicate sib_index+parent ID pairings...          // this more complex SQL statement lists the parent nodes involved //        String dup_sib_indices_sql = "SELECT Parent FROM ( SELECT Parent, SiblingIndex, Count(*) " + //                "FROM tblNodes GROUP BY Parent, SiblingIndex HAVING Count(*)&gt;1 ) AS ParentsToNormalise GROUP BY Parent";          // but, bafflingly, even this simpler one produces the "Invalid cursor state" error          String dup_sib_indices_sql =                  "SELECT tblNodes.Parent, tblNodes.SiblingIndex FROM tblNodes GROUP BY tblNodes.Parent, tblNodes.SiblingIndex";          String data_source =  "jdbc:odbc:Copy of kernel3_1 DATA $USER";         Connection dbase_conn = DriverManager.getConnection( data_source, "", "");         PreparedStatement ps_dup_sib_indices = dbase_conn.prepareStatement( dup_sib_indices_sql,                  java.sql.ResultSet.TYPE_SCROLL_SENSITIVE,  java.sql.ResultSet.CONCUR_READ_ONLY ); // NB various combos tried here:        //              java.sql.ResultSet.TYPE_SCROLL_INSENSITIVE,  java.sql.ResultSet.CONCUR_UPDATABLE ); ... etc.          ResultSet rs = ps_dup_sib_indices.executeQuery();          // rs.beforeFirst(); &lt;-- makes no difference         int i = 0;         while ( rs.next() ){             int parent_id = rs.getInt( "Parent" );             System.out.println( "=== parent_id " + parent_id + ", i " + i );             i++;         }         System.out.println( "=== Never get to here..." );     } } </code></pre>  <p>This is the output:</p>  <pre><code>=== parent_id 0, i 0 === parent_id 1, i 1 ... === parent_id 2765, i 491 === parent_id 2768, i 492 Exception in thread "main" java.sql.SQLException: [Microsoft][ODBC Driver Manager] Invalid cursor state     at sun.jdbc.odbc.JdbcOdbc.createSQLException(JdbcOdbc.java:6964)     at sun.jdbc.odbc.JdbcOdbc.standardError(JdbcOdbc.java:7121)     at sun.jdbc.odbc.JdbcOdbc.SQLGetDataInteger(JdbcOdbc.java:3818)     at sun.jdbc.odbc.JdbcOdbcResultSet.getDataInteger(JdbcOdbcResultSet.java:5637)     at sun.jdbc.odbc.JdbcOdbcResultSet.getInt(JdbcOdbcResultSet.java:582)     at sun.jdbc.odbc.JdbcOdbcResultSet.getInt(JdbcOdbcResultSet.java:600)     at root.CursorProb.main(CursorProb.java:34) </code></pre>  <p>Running the SQL as a query in the MS Access dbase itself causes no problems (and produces the same output before the error: 493 rows).</p>  <p>I.e. "SELECT tblNodes.Parent, tblNodes.SiblingIndex FROM tblNodes GROUP BY tblNodes.Parent, tblNodes.SiblingIndex;"</p>