<p>In my XAML I've got a ListBox which is bound to a list of viewmodel objects.   </p>  <p>A usercontrol is defined to use this TestViewModel as its data context. In the usercontrol I've got 2 command buttons which are bound to methods using ICommand pattern. With the help these buttons I'm able to add and remove viewmodels to the above mentioned list, which makes the ListBox to grow in height (which makes the scrollbars to appear).</p>  <p>Everything seems to be working fine. However, things don't work as the expected way, when the usercontrols are partially shown because of the screen/application height is not enough.</p>  <p>Even though commands buttons are visible, the commands are not getting fired. Instead, The ListBox is getting scrolled to the last item and the partially shown item becomes fully visible. After that the commands for that item is getting fired as expected.</p>  <p>Setting a fixed height for the ListBox is not an option, as the application has to support different screen resolutions.</p>  <p>Anybody has any idea how to fix this? Or is this an expected behavior?</p>  <p><strong>Update:</strong> Adding the sample source codes. My current screen resolution is 1366x768. Under that I'm able to see only 2 full controls. 3rd one is visible only partially.</p>  <p><strong>Window:</strong></p>  <pre><code>&lt;Window x:Class="WpfApplication1.MainWindow"         xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"         xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"         xmlns:uc="clr-namespace:WpfApplication1"         Title="MainWindow" WindowState="Maximized"&gt;     &lt;Window.DataContext&gt;         &lt;uc:MainViewModel&gt;&lt;/uc:MainViewModel&gt;     &lt;/Window.DataContext&gt;     &lt;Grid&gt;         &lt;ListBox ItemsSource="{Binding VmList}"&gt;&lt;/ListBox&gt;     &lt;/Grid&gt; &lt;/Window&gt; </code></pre>  <p><strong>Viewmodel for window:</strong></p>  <pre><code>public class MainViewModel : INotifyPropertyChanged     {         public event PropertyChangedEventHandler PropertyChanged;          public void OnPropertyChanged(string propertyName)         {             if (PropertyChanged != null)                 PropertyChanged(this, new PropertyChangedEventArgs(propertyName));         }           private ObservableCollection&lt;TestViewModel&gt; vmList;          public ObservableCollection&lt;TestViewModel&gt; VmList         {             get { return vmList; }             set              {                  vmList = value;                 OnPropertyChanged("VmList");             }         }          public MainViewModel()         {             VmList = new ObservableCollection&lt;TestViewModel&gt;()              {                 new TestViewModel(1),                 new TestViewModel(2),                 new TestViewModel(3)             };         }         } </code></pre>  <p><strong>Usercontrol:</strong></p>  <pre><code>&lt;UserControl x:Class="WpfApplication1.TestUserControl"              xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"              xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"              xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"               xmlns:d="http://schemas.microsoft.com/expression/blend/2008"               mc:Ignorable="d" Height="300" Width="200"&gt;         &lt;Grid&gt;         &lt;Grid.RowDefinitions&gt;             &lt;RowDefinition&gt;&lt;/RowDefinition&gt;             &lt;RowDefinition&gt;&lt;/RowDefinition&gt;         &lt;/Grid.RowDefinitions&gt;           &lt;Grid.ColumnDefinitions&gt;             &lt;ColumnDefinition Width="85*"&gt;&lt;/ColumnDefinition&gt;             &lt;ColumnDefinition Width="15*"&gt;&lt;/ColumnDefinition&gt;         &lt;/Grid.ColumnDefinitions&gt;         &lt;Border BorderThickness="1" BorderBrush="Gray" Grid.Row="0" Grid.Column="0" Grid.RowSpan="2"&gt;         &lt;Grid Grid.Row="0" Grid.Column="0" Grid.RowSpan="2" HorizontalAlignment="Center" VerticalAlignment="Center"&gt;                 &lt;Border BorderThickness="2" BorderBrush="Black"&gt;                     &lt;Label Content="{Binding Count}"&gt;&lt;/Label&gt;&lt;/Border&gt;         &lt;/Grid&gt;&lt;/Border&gt;         &lt;Button Grid.Row="0" Grid.Column="1" Width="30" Height="30" Command="{Binding OnControlAdd}"                 CommandParameter="{Binding RelativeSource={RelativeSource Mode=FindAncestor, AncestorType={x:Type Window}}, Path=DataContext}"&gt;+&lt;/Button&gt;     &lt;/Grid&gt; &lt;/UserControl&gt; </code></pre>  <p><strong>Viewmodel for usercontrol:</strong></p>  <pre><code>public class TestViewModel : INotifyPropertyChanged     {         public event PropertyChangedEventHandler PropertyChanged;          public void OnPropertyChanged(string propertyName)         {             if (PropertyChanged != null)                 PropertyChanged(this, new PropertyChangedEventArgs(propertyName));         }          private int count;          public int Count         {             get { return count; }             set { count = value; }         }           public ICommand OnControlAdd         {             get             {                 return new RelayCommand(AddControl);             }         }          private void AddControl(object param)         {             MainViewModel mainView = param as MainViewModel;              if (null != mainView)             {                 mainView.VmList.Add(new TestViewModel(mainView.VmList.Count + 1));             }         }          public TestViewModel(int count)         {             Count = count;         }     } </code></pre>  <p><strong>Datatemplate:</strong></p>  <pre><code>&lt;DataTemplate DataType="{x:Type local:TestViewModel}"&gt;                 &lt;local:TestUserControl&gt;&lt;/local:TestUserControl&gt;     &lt;/DataTemplate&gt; </code></pre>