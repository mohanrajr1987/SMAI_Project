<p>Short version of the question: I have 2 functions that share the same array, when one is editing it, the other is reading it. However, the vector is long (5000 samples) and concurrent access rarely happens. but the Mutex contention on <code>MUTEX1</code> is slowing down the program. '</p>  <p>How can I lock certain locations of the memory instead of the complete block in order to reduce contention?</p>  <p>EDIT: Note: I have to use updated G values whenever possible. </p>  <p>EDIT2:  For example I have array G of length 5000. <code>foo1</code> locks <code>mutex1</code> to edit index 124.  Although <code>foo2</code> wants to edit index 2349, it cannot until <code>foo1</code> releases <code>mutex1</code>. </p>  <p>is there a way I can move the contention of locking a mutex down to the element level? meaning: I want <code>foo2</code> and <code>foo1</code> to only contest on a the same mutex, only when they want to edit the same index. E.g: <code>foo1</code> wants to edit index 3156, and <code>foo2</code> wants to edit index 3156.</p>  <p>Long version with code explanation:  I am writing a code for a complex mathematical function,  and I am using pthreads to parallel the code and enhance the performance. The code is very complex and I can post it but I can post a model to the code.  </p>  <p>Basically I have 2 arrays that I want to edit using 2 threads that run in parallel. One thread runs <code>foo1</code> and the other runs <code>foo2</code>.  However, they should run in a particular sequence and I use <code>mutex</code>es(<code>_B</code>,<code>_A1</code>, and <code>_A2</code>) to grantee the sequence. it goes as follows :</p>  <pre><code>foo1 (first half) foo2 (first half) and foo1 (second half) (in parallel) foo1 (first half) and foo2 (second half) (in parallel) ... foo2(second half) </code></pre>  <p>then I would retrieve my results. In the first half of <code>foo1</code> I will be using results in <code>G1</code> that is might be edited at the same time by <code>foo2</code>.  Therefore I use <code>Mutex1</code> to protect it. same happens in <code>foo2</code> for <code>G</code>.  However, locking the complete vector for 1 value is very in efficient, they nearly never edit the same memory location at the same time. when I compare the results, it is almost always the same. I would like a way to lock one element at a time, so that they only contest the same element.</p>  <p>I will describe the code for people interested to know how it works: </p>  <pre><code>#include &lt;pthread.h&gt; #include &lt;iostream&gt;  using namespace std;  #define numThreads 2 #define Length 10000  pthread_t threads[numThreads];  pthread_mutex_t mutex1   = PTHREAD_MUTEX_INITIALIZER; pthread_mutex_t Mutex_B  = PTHREAD_MUTEX_INITIALIZER; pthread_mutex_t Mutex_A1 = PTHREAD_MUTEX_INITIALIZER; pthread_mutex_t Mutex_A2 = PTHREAD_MUTEX_INITIALIZER;  struct data_pointers {     double  *A;     double  *B;     double  *G;     double  *L;     int idxThread; };  void foo1   (data_pointers &amp;data); void foo2   (data_pointers &amp;data);  void *thread_func(void *arg){     data_pointers data = *((data_pointers *) arg);     if (data.idxThread==0)         foo1 (data);     else         foo2 (data); } </code></pre>  <p>Up to here it is definitions and thread calling function, bare in mind that I define <code>Length 10000</code> and <code>numThreads 2</code></p>  <pre><code>void foo1 ( data_pointers &amp;data) {     double *A           = data.A;     double *L           = data.L;      double *G           = data.G;      double U;      for (int ijk =0;ijk&lt;5;ijk++){         /* here goes some definitions*/          pthread_mutex_lock(&amp;Mutex_A1);          for (int k =0;k&lt;Length;k++){             pthread_mutex_lock(&amp;mutex1);              U = G[k];             pthread_mutex_unlock(&amp;mutex1);             /*U undergoes a lot of mathematical operations here               */         }          pthread_mutex_lock(&amp;Mutex_B);         pthread_mutex_unlock(&amp;Mutex_A2);         for (int k =0;k&lt;Length;k++){             /*U another mathematical operations here               */             pthread_mutex_lock(&amp;mutex1);             L[k] = U;             pthread_mutex_unlock(&amp;mutex1);             pthread_mutex_unlock(&amp;Mutex_B);         }     } } </code></pre>  <p>in foo1 I lock <code>mutexA1</code> and complete my work,  then I lock <code>MutexB</code> and unlock <code>MutexA2</code> so <code>foo2</code> can start working. Note that <code>main</code> starts by locking <code>MutexA2</code>. This way I garantee <code>foo1</code> started second half with <code>mutexB</code> locked, this way, <code>foo2</code> cannot enter the second half of the function until <code>foo1</code> unlocks <code>mutexB</code></p>  <pre><code>void foo2 (data_pointers &amp;data) {     double *A           = data.A;     double *L           = data.L;      double *G           = data.G;      double U;      for (int ijk =0;ijk&lt;5;ijk++){         /* here goes some definitions*/          pthread_mutex_lock(&amp;Mutex_A1);          for (int k =0;k&lt;Length;k++){             pthread_mutex_lock(&amp;mutex1);              U = G[k];             pthread_mutex_unlock(&amp;mutex1);             /*U undergoes a lot of mathematical operations here               */         }          pthread_mutex_lock(&amp;Mutex_B);         pthread_mutex_unlock(&amp;Mutex_A2);         for (int k =0;k&lt;Length;k++){                     /*U another mathematical operations here               */             pthread_mutex_lock(&amp;mutex1);             L[k] = U;             pthread_mutex_unlock(&amp;mutex1);             pthread_mutex_unlock(&amp;Mutex_B);          }     } } </code></pre>  <p>Now, when <code>foo1</code> unlocks <code>mutexB</code> it will have to wait for <code>foo2</code> to unlock <code>mutexA1</code> so it can work, <code>foo2</code> will only unlock <code>mutexA2</code> when it already unlocked <code>mutexB</code>.  </p>  <p>this goes on and on 5 times. </p>  <pre><code>int main(){     double G1[Length];     double G2[Length];     double B1[Length];     double B2[Length];     double A2[Length];     double A1[Length];     data_pointers data[numThreads];      data[0].L           = G2;     data[0].G           = G1;        data[0].A           = A1;     data[0].B           = B1;     data[0].idxThread   = 0;      data[1].L           = G1;     data[1].G           = G2;        data[1].A           = A2;     data[1].B           = B2;     data[1].idxThread   = 1;      pthread_mutex_lock(&amp;Mutex_A2);      pthread_create(&amp;(threads[0]), NULL, thread_func, (void *) &amp;(data[0]));     pthread_create(&amp;(threads[1]), NULL, thread_func, (void *) &amp;(data[1]));     pthread_join(threads[1], NULL);     pthread_join(threads[0], NULL);      pthread_mutex_unlock(&amp;Mutex_A1);     pthread_mutex_unlock(&amp;Mutex_A2);      return 0; } </code></pre>  <p>note this is only an example code. compiles and works as intended, but with no output. </p>  <p>LAST EDIT:  Thank you all for the great ideas, I had a lot of experience, and fun following those suggestions. I will up vote all answers as they were useful, and pick the closest to the original question (atomicity)</p>