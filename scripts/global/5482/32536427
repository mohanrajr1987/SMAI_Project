<p>I have a such a requirement that:- 1) There are two class, say Wrapper and Wrapper2. 2) Wrapper2 contains reference object of class Wrapper. 3) A thread will write data to a variable of class Wrapper which should be essentially be calling a member function of Wrapper. 4) Another thread can read and write data to class member of Wrapper and this thread essentially be called through Wrapper2. </p>  <p>Based on some answers on older question on Stackoverflow, i created an example code to check why my production code is failing and i am not able to figure out the problem. As soon as thread2 is created it receives SIGSEG signals. Code is below:-</p>  <pre><code>    #include &lt;thread&gt;     #include &lt;iostream&gt;     #include &lt;chrono&gt;     #include &lt;unistd.h&gt;     #include &lt;stdlib.h&gt;     #include &lt;signal.h&gt;     #include &lt;stdio.h&gt;     #include &lt;signal.h&gt;     #include &lt;pthread.h&gt;     #include &lt;wait.h&gt;     #include &lt;string.h&gt;      pthread_mutex_t mt1;      void thread_signal(int signum)     {       pthread_exit(0);     }      void sig_func(int sig)     {      write(1, "Caught signal 11\n", 17);      std::cout&lt;&lt;"Caught signal :"&lt;&lt;sig&lt;&lt;std::endl;      signal(SIGSEGV,sig_func);      thread_signal(sig);     }      class Wrapper {        public:         Wrapper():i(10)        {             std::cout&lt;&lt;"Wrapper Constructor Called. "&lt;&lt;this&lt;&lt;" \n";        }         ~Wrapper()        {             std::cout&lt;&lt;"Wrapper Destructor Called. "&lt;&lt;this&lt;&lt;"\n";        }           void member1() {               std::cout &lt;&lt; "i am member1" &lt;&lt; std::endl;           }           void member2(const char *arg1, unsigned arg2) {               std::cout &lt;&lt; "i am member2 and my first arg is (" &lt;&lt; arg1 &lt;&lt; ") and second arg is (" &lt;&lt; arg2 &lt;&lt; ")" &lt;&lt; std::endl;           }         void setI(int i)         {             pthread_mutex_lock(&amp;mt1);             this-&gt;i=i;             std::cout&lt;&lt;"set: "&lt;&lt; this-&gt;i&lt;&lt;std::endl;             pthread_mutex_unlock(&amp;mt1);         }         int getI()         {             pthread_mutex_lock(&amp;mt1);             std::cout&lt;&lt;"get: "&lt;&lt; this-&gt;i&lt;&lt;std::endl;             pthread_mutex_unlock(&amp;mt1);             return 0;         }         int i;     };      class Wrapper2     {     public:         Wrapper2(Wrapper &amp; wp):wp2(wp)     {             std::cout&lt;&lt;"Wrapper2 Constructor Called. "&lt;&lt;this&lt;&lt;" \n";     }          ~Wrapper2()        {             std::cout&lt;&lt;"Wrapper2 Destructor Called. "&lt;&lt;this&lt;&lt;" \n";        }         Wrapper &amp; wp2;     };       struct ThreadWrapper {         Wrapper &amp; wr1;         Wrapper2 &amp; wr2;          ThreadWrapper( Wrapper &amp; wr1,Wrapper2&amp; wr2):                     wr1(wr1),wr2(wr2)         {          }      };      extern "C" void* wrapper1Fun ( void* wr1)     {         std::auto_ptr&lt; Wrapper &gt; wrp1 ( static_cast&lt; Wrapper* &gt;( wr1 ) );         std::cout&lt;&lt;"Thread 1 created. \n";         while(1)         {             wrp1-&gt;setI(rand()%100);             usleep(50);         }          return 0;     }      extern "C" void* wrapper2Fun ( void* wr2)     {         std::auto_ptr&lt; Wrapper2 &gt; wrp2 ( static_cast&lt; Wrapper2* &gt;( wr2 ) );         std::cout&lt;&lt;"Thread 2 created. \n";         while(1)         {             wrp2-&gt;wp2.getI();             usleep(50);         }          return 0;     }      int main(int argc, char **argv) {       struct sigaction sa;       memset(&amp;sa, 0, sizeof(sa));       sa.sa_handler = thread_signal;       sa.sa_flags = 0;       sigaction(SIGTERM, &amp;sa, 0);       bool mainRunning= true;        Wrapper w;        Wrapper2 w1(w);         sleep(1);        ThreadWrapper * myWrap = new ThreadWrapper(w,w1);        sleep(1);        pthread_t pt1;        pthread_t pt2;        pthread_attr_t attr;        signal(SIGSEGV,sig_func); // Register signal handler before going multithread        pthread_attr_init(&amp;attr);        int i = pthread_create(&amp;pt1, NULL,wrapper1Fun, myWrap);        std::cout&lt;&lt;"First thread status "&lt;&lt;i&lt;&lt;std::endl;        sleep(1);        int j = pthread_create(&amp;pt2, &amp;attr,wrapper2Fun, myWrap);        std::cout&lt;&lt;"Second thread status "&lt;&lt;j&lt;&lt;std::endl;        sleep(1);        while(1);        fprintf(stderr, "kill thread\n");        //pthread_kill(pt1, SIGTERM);        fprintf(stderr, "join thread\n");        pthread_join(pt1, NULL);        pthread_join(pt1, NULL);         return 0;     } </code></pre>