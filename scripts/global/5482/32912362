<p>The following code is taken from <a href="http://www.yolinux.com/TUTORIALS/LinuxTutorialPosixThreads.html#SYNCHRONIZATION" rel="nofollow">this site</a> and it shows how to use mutexes. It implements both pthread_join and pthread_mutex_lock:</p>  <pre><code>#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;pthread.h&gt;  void *functionC(); pthread_mutex_t mutex1 = PTHREAD_MUTEX_INITIALIZER; int  counter = 0;  main() {    int rc1, rc2;    pthread_t thread1, thread2;     /* Create independent threads each of which will execute functionC */     if( (rc1=pthread_create( &amp;thread1, NULL, &amp;functionC, NULL)) )    {       printf("Thread creation failed: %d\n", rc1);    }     if( (rc2=pthread_create( &amp;thread2, NULL, &amp;functionC, NULL)) )    {       printf("Thread creation failed: %d\n", rc2);    }     /* Wait till threads are complete before main continues. Unless we  */    /* wait we run the risk of executing an exit which will terminate   */    /* the process and all threads before the threads have completed.   */     pthread_join( thread1, NULL);    pthread_join( thread2, NULL);      exit(EXIT_SUCCESS); }  void *functionC() {    pthread_mutex_lock( &amp;mutex1 );    counter++;    printf("Counter value: %d\n",counter);    pthread_mutex_unlock( &amp;mutex1 ); } </code></pre>  <p>I ran the code as given above as it is and it produced following result:</p>  <p>Counter value: 1</p>  <p>Counter value: 2</p>  <p>But in the second run i removed "pthread_mutex_lock( &amp;mutex1 );" and  "pthread_mutex_unlock( &amp;mutex1 );" . I compiled and ran the code, it again produced the same result. </p>  <p>Now the thing that confuses me is why mutex lock is used in above code when same thing can be done without it (using pthread_join)? If pthread_join prevents another thread from running untill the first one has finished then i think it would already prevent the other thread from accessing the counter value. Whats the purpose of pthread_mutex_lock? </p>