<p>I've clearly developed a flawed understanding of condition variables and how to use them.  My intention is to have a single producer and multiple consumer threads but I can demonstrate my problem with a single producer and a single consumer.</p>  <p>There is a single shared variable called <code>work</code> that is protected with a mutex and a condition variable. The producer sets the <code>work</code> variable and signals it is ready, but the consumer thread never get's to run?</p>  <p>If the program works correctly, it should print <code>this line never get's printed</code>, but instead I get <code>consumer never did work...giving up</code>. Any assistance would be greatly appreciated</p>  <pre><code>#include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt; #include &lt;pthread.h&gt;  pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; pthread_cond_t cond = PTHREAD_COND_INITIALIZER; int work = 0;  void* consumer(void* ptr) {     pthread_mutex_lock(&amp;mutex);     while(1) {         pthread_cond_wait(&amp;cond, &amp;mutex);         if (work == 0)             continue;         printf("this line never get's printed\n");         work = 0;         }      return NULL;     }  int main() {     pthread_t thr;     pthread_create(&amp;thr, NULL, consumer, NULL);     sleep(1); /* give consumer moment to lock mutex */      for(int ndx=0; ndx &lt; 50; ndx++) {         pthread_mutex_lock(&amp;mutex);         if (work == 1) {              printf("consumer never did work...giving up\n");             return -1;             }         work = 1;         pthread_cond_signal(&amp;cond);         pthread_mutex_unlock(&amp;mutex);         }     return 0;     } </code></pre>  <p>Compiled with:</p>  <pre><code>$ g++ -pthread simple.cpp -o simple </code></pre>  <p>Running on Debian 7.9 (also reproduced on CentOS 6.7)</p>  <pre><code>$ getconf GNU_LIBPTHREAD_VERSION NPTL 2.13  $ g++ --version gcc version 4.7.2 (Debian 4.7.2-5) </code></pre>