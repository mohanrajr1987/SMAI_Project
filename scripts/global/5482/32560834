<p>I am getting a data race when calling pthread_create() recursively. I don't know if the recursion causes the problem, but the race seems to never occur on the first iteration, mostly on the second and rarely on the third.</p>  <p>When using libgc, there are memory corruption symptoms, such as segmentation fault, that coincide with the the data race.</p>  <p>The following program is a minimal example that illustrates the problem. I'm not using libgc in the example as only the data race is the topic of this question.</p>  <p>The data race is visible when running Valgrind with the Helgrind tool. There are slight variations on the problems reported, including sometimes no problem at all.</p>  <p>I'm running Linux Mint 17.2. The version of gcc is (Ubuntu 4.8.4-2ubuntu1~14.04) 4.8.4.</p>  <p>The following example, 'main.c', reproduces the problem. It iterates over a linked list, printing each elements value in a separate thread:</p>  <pre><code>#include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #include &lt;pthread.h&gt;   typedef struct List {   int head ;   struct List* tail ; } List ;  // create a list element with an integer head and a tail List* new_list( int head, List* tail ) {   List* l = (List*)malloc( sizeof( List ) ) ;   l-&gt;head = head ;   l-&gt;tail = tail ;   return l ; }   // create a thread and start it void call( void* (*start_routine)( void* arg ), void* arg ) {   pthread_t* thread = (pthread_t*)malloc( sizeof( pthread_t ) ) ;    if ( pthread_create( thread, NULL, start_routine, arg ) ) {     exit( -1 ) ;   }    pthread_detach( *thread ) ;   return ; }   void print_list( List* l ) ;  // start routine for thread void* print_list_start_routine( void* arg ) {    // verify that the list is not empty ( = NULL )   // print its head   // print the rest of it in a new thread   if ( arg ) {      List* l = (List*)arg ;      printf( "%d\n", l-&gt;head ) ;      print_list( l-&gt;tail ) ;    }    return NULL ; }  // print elements of a list with one thread for each element printed // threads are created recursively void print_list( List* l ) {   call( print_list_start_routine, (void*)l ) ; }   int main( int argc, const char* argv[] ) {    List* l = new_list( 1, new_list( 2, new_list( 3, NULL ) ) ) ;    print_list( l ) ;      // wait for all threads to finnish   pthread_exit( NULL ) ;    return 0 ; } </code></pre>  <p>Here is 'makefile':</p>  <pre><code>CC=gcc  a.out: main.o     $(CC) -pthread main.o  main.o: main.c     $(CC) -c -g -O0 -std=gnu99 -Wall main.c  clean:     rm *.o a.out </code></pre>  <p>Here is the most common output of Helgrind. Notice that the lines with only a single digit, 1, 2 and 3 are output of the program and not Helgrind:</p>  <pre><code>$ valgrind --tool=helgrind ./a.out  ==13438== Helgrind, a thread error detector ==13438== Copyright (C) 2007-2013, and GNU GPL'd, by OpenWorks LLP et al. ==13438== Using Valgrind-3.10.0.SVN and LibVEX; rerun with -h for copyright info ==13438== Command: ./a.out ==13438==  1 2 ==13438== ---Thread-Announcement------------------------------------------ ==13438==  ==13438== Thread #3 was created ==13438==    at 0x515543E: clone (clone.S:74) ==13438==    by 0x4E44199: do_clone.constprop.3 (createthread.c:75) ==13438==    by 0x4E458BA: pthread_create@@GLIBC_2.2.5 (createthread.c:245) ==13438==    by 0x4C30C90: ??? (in /usr/lib/valgrind/vgpreload_helgrind-amd64-linux.so) ==13438==    by 0x4007EB: call (main.c:25) ==13438==    by 0x400871: print_list (main.c:58) ==13438==    by 0x40084D: print_list_start_routine (main.c:48) ==13438==    by 0x4C30E26: ??? (in /usr/lib/valgrind/vgpreload_helgrind-amd64-linux.so) ==13438==    by 0x4E45181: start_thread (pthread_create.c:312) ==13438==    by 0x515547C: clone (clone.S:111) ==13438==  ==13438== ---Thread-Announcement------------------------------------------ ==13438==  ==13438== Thread #2 was created ==13438==    at 0x515543E: clone (clone.S:74) ==13438==    by 0x4E44199: do_clone.constprop.3 (createthread.c:75) ==13438==    by 0x4E458BA: pthread_create@@GLIBC_2.2.5 (createthread.c:245) ==13438==    by 0x4C30C90: ??? (in /usr/lib/valgrind/vgpreload_helgrind-amd64-linux.so) ==13438==    by 0x4007EB: call (main.c:25) ==13438==    by 0x400871: print_list (main.c:58) ==13438==    by 0x4008BB: main (main.c:66) ==13438==  ==13438== ---------------------------------------------------------------- ==13438==  ==13438== Possible data race during write of size 1 at 0x602065F by thread #3 ==13438== Locks held: none ==13438==    at 0x4C368F5: mempcpy (in /usr/lib/valgrind/vgpreload_helgrind-amd64-linux.so) ==13438==    by 0x4012CD6: _dl_allocate_tls_init (dl-tls.c:436) ==13438==    by 0x4E45715: pthread_create@@GLIBC_2.2.5 (allocatestack.c:252) ==13438==    by 0x4C30C90: ??? (in /usr/lib/valgrind/vgpreload_helgrind-amd64-linux.so) ==13438==    by 0x4007EB: call (main.c:25) ==13438==    by 0x400871: print_list (main.c:58) ==13438==    by 0x40084D: print_list_start_routine (main.c:48) ==13438==    by 0x4C30E26: ??? (in /usr/lib/valgrind/vgpreload_helgrind-amd64-linux.so) ==13438==    by 0x4E45181: start_thread (pthread_create.c:312) ==13438==    by 0x515547C: clone (clone.S:111) ==13438==  ==13438== This conflicts with a previous read of size 1 by thread #2 ==13438== Locks held: none ==13438==    at 0x51C10B1: res_thread_freeres (in /lib/x86_64-linux-gnu/libc-2.19.so) ==13438==    by 0x51C1061: __libc_thread_freeres (in /lib/x86_64-linux-gnu/libc-2.19.so) ==13438==    by 0x4E45199: start_thread (pthread_create.c:329) ==13438==    by 0x515547C: clone (clone.S:111) ==13438==  3 ==13438==  ==13438== For counts of detected and suppressed errors, rerun with: -v ==13438== Use --history-level=approx or =none to gain increased speed, at ==13438== the cost of reduced accuracy of conflicting-access information ==13438== ERROR SUMMARY: 8 errors from 1 contexts (suppressed: 56 from 48) </code></pre>  <p>As mentioned by Pooja Nilangekar, replacing pthread_detach() with pthread_join() removes the race. However, detaching the threads is a requirement so the goal is to <em>cleanly</em> detach the threads. In other words, keep the pthread_detach() while removing the race.</p>  <p>There seems to be some unintended sharing between the threads. The unintended sharing may be related to what is discussed here: <a href="http://www.domaigne.com/blog/computing/joinable-and-detached-threads/" rel="nofollow">http://www.domaigne.com/blog/computing/joinable-and-detached-threads/</a> Especially the bug in the example.</p>  <p>I still don't understand what is really going on.</p>