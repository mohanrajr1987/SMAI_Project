<p>So, I have about 100+ processes that I would like to make parallely executed. I am using PHP pthreads to do that.</p>  <p>The problem I have is that the threads start but they do not pass values to another object which is initialized within the thread. What I would like to do is the execute each of those child process in separate objects.</p>  <h3>updated code</h3>  <pre><code>&lt;?php  ini_set('display_errors', 1); define('DEBUG', true);  function pr($var) {    if (!DEBUG) {        return;    }     echo PHP_EOL;     if ($var) {       print_r($var);    } else {       var_dump($var);    }     echo PHP_EOL; }  class A {     //public $results = 1;     function init() {       pr(__CLASS__ . ' initailized');    }     function getResult() {        return ($this-&gt;results);    } }  class B extends A {     public $val;    public $results = [        'queries' =&gt; []    ];     function set($k, $v) {       $this-&gt;{$k} = $v;    }     function init() {       pr(__CLASS__ . ' initailized');       parent::init();        $this-&gt;results = ['some_value' =&gt; true];    } }  class Fetching extends Thread {      function __construct() {      }     public function run() {       $this-&gt;e = new B;       $this-&gt;e-&gt;init();        pr($this-&gt;e-&gt;getResult());    } }  $data = [    'id' =&gt; 12345,    'message' =&gt; 'some text here' ];  $thread = new Fetching();  $thread-&gt;start(); $thread-&gt;join(); pr($thread); </code></pre>  <p>When I run $thread->results it outputs as NULL. But if I make it a string or int it works just fine.</p>