<p>I have a callback function I am writing where I need to:</p>  <p>1 create a struct<br> 2 create a new thread and pass this struct to the thread for it's exclusive use<br> 3 return a pointer to this struct ... from the callback function ... to the main program.</p>  <p>This will allow communications through shared memory between the original program and the new threads.</p>  <p>I assume I have to use malloc since the scope of a struct created in the callback function is only in the function.</p>  <p>I can't make it static because I will create multiple threads each with their own personal struct.</p>  <p>I need to understand the process since I am a newbie.</p>  <p>Would it work this way?</p>  <p>1 malloc a chunk of memory "sizeof" the struct.<br> 2 pass the pointer to this chunk to the new thread and return it to the main program.<br> 3 once in the new thread make a new struct using this memory?  </p>  <p>I have searched for a week now and can't see how this should be done.</p>  <p>BTW: I cannot modify the main program which is single threaded by design. I can only make this callback function to spawn one of many new threads and communicate thru this shared memory which I would like to be a struct.</p>  <p>Thanks.</p>  <pre><code>struct myStruct {     int elem1;     int elem2;     int elem3; };    int* callBack(some parameters) {     *p = malloc(sizeof(myStruct));      result = pthead_create( ??, ??, void *(*newThread), *p);      return p; }   void newThread() {     // pull off *p from stack?      // somehow use the declared struct to access the malloc mem      p-&gt;elem1 = p-&gt;elem2 + p-&gt;elem3; } </code></pre>