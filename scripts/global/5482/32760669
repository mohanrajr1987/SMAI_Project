<p>When attempting to create a single thread that only reads and prints its own argument and then returns, helgrind finds a lot of possible data races, despite the fact that the main thread performs pthread_join as soon as the new thread is created.</p>  <p>Here is the thread initialization (a scaled-down version that still reproduces the problem):</p>  <pre><code>void liveness(cfg_t* cfg) {     vertex_t*               u;     size_t                  i;     size_t*                 arg;     pthread_t               thread;     pthread_mutex_t*        lock;      lock = (pthread_mutex_t*) malloc(sizeof(pthread_mutex_t));     if (lock == NULL) {         printf("Error when allocating memory for locks");     }     if (pthread_mutex_init(lock, NULL) != 0) {         printf("Error when creating lock\n");     }      arg = malloc(sizeof(size_t));     (*arg) = 0;     if (pthread_create(&amp;thread, NULL, thread_start, arg)) {         perror("Error when creating thread\n");         exit(1);     }     if (pthread_join(thread, NULL)) {                        perror("Error when joining thread\n");         exit(1);     }     free(lock);     free(arg); //244 } </code></pre>  <p>and this is thread_start</p>  <pre><code>void* thread_start(void* arguments) {     size_t          index;     index = * (size_t*) arguments; /155     printf("Thread started! Index %zu\n", index);     fflush(stdout);     return NULL; } </code></pre>  <p>The output is correct (Thread started! Index 0) but helgrind produces the following output </p>  <pre><code>==3489== Possible data race during write of size 8 at 0x4003330 by thread #1 ==3489== Locks held: none ==3489==    at 0x42970F: _int_free (in /h/d9/b/dat11ote/courses/edan25/lab4home/live) ==3489==    by 0x402D5C: liveness (paralleldataflow.c:244) ==3489==    by 0x401E4F: main (main.c:134) ==3489== ==3489== This conflicts with a previous read of size 8 by thread #2 ==3489== Locks held: none ==3489==    at 0x402C4C: thread_start (paralleldataflow.c:155) ==3489==    by 0x4040B1: start_thread (pthread_create.c:312) ==3489==    by 0x4500E8: clone (in /h/d9/b/dat11ote/courses/edan25/lab4home/live) </code></pre>  <p>and 30 more errors from 25 contexts. If i change the return statement to go before the thread argument as in</p>  <pre><code>void* thread_start(void* arguments) {     size_t          index;     return NULL; } </code></pre>  <p>then everything works fine. I use the -pthreads and -static flags to gcc. If I remove the printf and fflush, this leaves the error above but removes all the other errors, which looked like:</p>  <pre><code>Possible data race during write of size 8 at 0x6D7878 by thread #1 Locks held: none at 0x40F449: vfprintf (in /h/../live) by 0x419075: printf (in /h/../live) by 0x401E76: main (main.c:137) This conflicts with a previous write of size 8 by thread #2 Locks held: none at 0x40F449: vfprintf (in /h/../live) by 0x419075: printf (in /h/../live) by 0x402C68: thread_start (in /h/../live) by 0x404061: start_thread (pthread_create.c:312) by 0x44B2A8: clone (in /h/../live) </code></pre>