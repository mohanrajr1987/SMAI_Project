<p>I'm trying to write a Visual C++ 2008 application, running on Win2012, being able to read/write files asynchronously from/to 2 different disk groups on a NAS over a single Gbps interface (and a Gbps switch).</p>  <p>Simultaneous manual file copy (from network storage to local hard drive, and from local hard drive  to network storage) shows that, with our system, network interface, switch and NAS, we are able to perform 1Gbps throughput (send 950 Mbps, receive 950 Mbps).</p>  <p>But using my Visual C++ application, which has two threads (boost), one for reading operations, the other one for writing operations (on a separate file), we have something like 350Mbps for writing and 650Mbps for reading.</p>  <p>When stoping the reader or the writer, the send or receive speed goes up to 950 Mbps.</p>  <p>I'm using stdio fread/fwrite to read and write 2 MB data chunks.</p>  <p>I'm testing many things to figure this out, that I could explain later, but for the moment, maybe there is something obvious that could explain why I can't get the desired throughput?</p>  <p>Here is my code below to reproduce the behavior, there is no interaction between threads so IO operations shouldn't block each other. I'm checking the throughput with the task manager.</p>  <pre><code>#include &lt;stdio.h&gt; #include &lt;windows.h&gt; #include &lt;boost/thread.hpp&gt;  #define INPUT_CHUNK_SIZE 2700000 #define OUTPUT_CHUNK_SIZE 2700000 #define OUTPUT_FILE_DESIRED_SIZE 1000000000  boost::thread* readerProcessThread = NULL; boost::thread* writerProcessThread = NULL; bool readerEnded = false; bool writerEnded = false; bool stop = false; const char* inputFileName = "\\\\NASIP\\input\\inputfile.bin"; const char* outputFileName = "\\\\NASIP\\output\\outputfile.bin";  void readerThread() {     FILE *myFile = fopen(inputFileName, "rb");     char *inputBuffer = new char[INPUT_CHUNK_SIZE];      if(myFile)     {         while(!stop &amp;&amp; !feof(myFile))         {             size_t readBytes = fread(inputBuffer, 1, INPUT_CHUNK_SIZE, myFile);         }          fclose(myFile);     }     delete[] inputBuffer;      readerEnded = true;     stop = (writerEnded || !writerProcessThread); }  void writerThread() {     char *outputBuffer = new char[OUTPUT_CHUNK_SIZE];     memset(outputBuffer, 0, OUTPUT_CHUNK_SIZE);     FILE *myFile = fopen(outputFileName, "wb");     unsigned long long writtenBytesTotal = 0;     size_t writtenBytes = OUTPUT_CHUNK_SIZE;      if(myFile)     {         while(!stop &amp;&amp; writtenBytesTotal &lt; OUTPUT_FILE_DESIRED_SIZE &amp;&amp; writtenBytes == OUTPUT_CHUNK_SIZE)         {             size_t writtenBytes = fwrite(outputBuffer, 1, OUTPUT_CHUNK_SIZE, myFile);             writtenBytesTotal += (unsigned long long)writtenBytes;         }         fclose(myFile);     }      writerEnded = true;     stop = (readerEnded || !readerProcessThread); }  int main(int argc, char * argv[]) {     readerProcessThread = new boost::thread(&amp;readerThread);     writerProcessThread = new boost::thread(&amp;writerThread);     if(readerProcessThread &amp;&amp; writerProcessThread)     {         while(!stop)         {             Sleep(1000);         }     }     stop = true;     if (readerProcessThread)     {         readerProcessThread-&gt;join();         delete readerProcessThread;         readerProcessThread = NULL;     }      if (writerProcessThread)     {         writerProcessThread-&gt;join();         delete writerProcessThread;         writerProcessThread = NULL;     }     return 0; } </code></pre>