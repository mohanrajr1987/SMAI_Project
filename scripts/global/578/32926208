<p>Hi there I'm trying to use these quicksort methods to figure out how many comparison are happening. We are given a global variable that does the counting but we aren't able to use the global variable when we hand it in. Instead we need to recursively count the comparisons. Now I am trying to figure out how to do that and I'm not looking for the answer, I'm trying to get on the right steps on how to solve this problem. I've been trying things for a couple hours now and no luck.</p>  <pre><code>static int qSortCompares = 0;  // GLOBAL var declaration  /**  * The swap method swaps the contents of two elements in an int array.  *  * @param The array containing the two elements.  * @param a The subscript of the first element.  * @param b The subscript of the second element.  */ private static void swap(int[] array, int a, int b) {     int temp;      temp = array[a];     array[a] = array[b];     array[b] = temp; }   public static void quickSort(int array[]) {     qSortCompares = 0;     int qSCount = 0;     doQuickSort(array, 0, array.length - 1);  }  /**  * The doQuickSort method uses the QuickSort algorithm to sort an int array.  *  * @param array The array to sort.  * @param start The starting subscript of the list to sort  * @param end The ending subscript of the list to sort  */ private static int doQuickSort(int array[], int start, int end) {     int pivotPoint;     int qSTotal = 0;     if (start &lt; end) {          // Get the pivot point.         pivotPoint = partition(array, start, end);          // Note - only one +/=         // Sort the first sub list.         doQuickSort(array, start, pivotPoint - 1);          // Sort the second sub list.         doQuickSort(array, pivotPoint + 1, end);      }      return qSTotal; }  /**  * The partition method selects a pivot value in an array and arranges the  * array into two sub lists. All the values less than the pivot will be  * stored in the left sub list and all the values greater than or equal to  * the pivot will be stored in the right sub list.  *  * @param array The array to partition.  * @param start The starting subscript of the area to partition.  * @param end The ending subscript of the area to partition.  * @return The subscript of the pivot value.  */ private static int partition(int array[], int start, int end) {     int pivotValue;    // To hold the pivot value     int endOfLeftList; // Last element in the left sub list.     int mid;           // To hold the mid-point subscript     int qSCount = 0;      // see http://www.cs.cmu.edu/~fp/courses/15122-s11/lectures/08-qsort.pdf     // for discussion of middle point - This improves the almost sorted cases     // of using quicksort     // Find the subscript of the middle element.     // This will be our pivot value.     mid = (start + end) / 2;      // Swap the middle element with the first element.     // This moves the pivot value to the start of     // the list.     swap(array, start, mid);      // Save the pivot value for comparisons.     pivotValue = array[start];      // For now, the end of the left sub list is     // the first element.     endOfLeftList = start;      // Scan the entire list and move any values that     // are less than the pivot value to the left     // sub list.     for (int scan = start + 1; scan &lt;= end; scan++) {         qSortCompares++;         qSCount++;         if (array[scan] &lt; pivotValue) {             endOfLeftList++;             // System.out.println("Pivot=" + pivotValue + "=" + endOfLeftList + ":" + scan);             swap(array, endOfLeftList, scan);         }     }      // Move the pivot value to end of the     // left sub list.     swap(array, start, endOfLeftList);      // Return the subscript of the pivot value.     return endOfLeftList; }  /**  * Print an array to the Console  *  * @param A  */ public static void printArray(int[] A) {     for (int i = 0; i &lt; A.length; i++) {         System.out.printf("%5d ", A[i]);     }     System.out.println(); }  /**  * @param args the command line arguments  */ public static void main(String[] args) {     final int SIZE = 10;     int[] A = new int[SIZE];      // Create random array with elements in the range of 0 to SIZE - 1;     System.out.printf("Lab#2 Sorting Algorithm Performance Analysis\n\n");      for (int i = 0; i &lt; SIZE; i++) {         A[i] = (int) (Math.random() * SIZE);     }      System.out.printf("Unsorted Data = %s\n", Arrays.toString(A));      int[] B;      // Measure comparisons and time each of the 4 sorts     B = Arrays.copyOf(A, A.length);  // Need to do this before each sort     long startTime = System.nanoTime();     quickSort(B);     long timeRequired = (System.nanoTime() - startTime) / 1000;      System.out.printf("Sorted Data = %s\n", Arrays.toString(B));     System.out.printf("Number of compares for quicksort     = %8d time = %8d us Ratio = %6.1f compares/us\n", qSortCompares, timeRequired, qSortCompares / (double) timeRequired);      // Add code for the other sorts here ... } </code></pre>  <p>The instructions give some hints but I am still lost:</p>  <p>"The quicksort method currently counts the # of comparisons by using a global variable. This is not a good programming technique. Modify the quicksort method to count comparisons by passing a parameter. This is a little trickier as the comparisons are done in the partition method. You should be able to see that the number of comparisons can be determined before the call to the partition method. You will need to return this value from the Quicksort method and modify the quickSort header to pass this value into each recursive call. You will need to add the counts recursively. As an alternative to the recursive counting, you can leave the code as is and complete the lab without the modification."</p>  <p>The way I have been looking at this assignment I made a variable in the partition method called qSCount which when it is called will count how many comparisons were made. However I can't use that variable because I am not returning it. And I'm not sure how I would use recursion in that state. My idea was after each time qSCount had a value I could somehow store it in doQuickSort method under qSTotal. But then again the hint is saying I need to make a parameter in quicksort so I am all sorts of confused. I would really appreciate some help on how I should do this.  </p>