<p>I am working on implementing a non-blocking UDP socket on Linux using the 'old-school' SELECT. Basically, I have a thread that is running the following function:</p>  <pre><code>int NBRecv(void* pv, size_t len){     int res = -1;     FD_ZERO(&amp;select_socks);         FD_SET(sock, &amp;select_socks);     int readsocks = select(sock + 1, &amp;select_socks, (fd_set *)0, (fd_set *)0, &amp;select_timeout);     assert(readsocks &gt;= 0);     if(readsocks == 0)         return NBRecv(pv, len);     else {         if(FD_ISSET(sock, &amp;select_socks)){             res = read(sock, pv, len);         }         else             res = 0;         return res;     } } </code></pre>  <p>Above there you see that I am calling the function again if no socket is available for read to keep on waiting (I am aware that this is an infinite loop). However, I got a segmentation error each time running this function (specifically, when running the recursive call). After removing the recursive call, everything works fine. </p>  <p>My naive understanding is that the recursion here is no different from a while loop. </p>  <p>So could anyone help me with why this error is happening?</p>