<p>When calling a recursive function with kwargs multiple times, previous values of the kwargs are retained even though they are local variables. </p>  <p>The following code snippet demonstrates the problem. </p>  <pre><code>#!/usr/bin/env python  def countfunc(count, messagelist=[]):     count -= 1     if count &gt; 0:         messagelist.append(count)         countfunc(count, messagelist=messagelist)     else:         print messagelist         del messagelist         return(count)  if __name__ == "__main__":     print("Call 1")     countfunc(5)     print("Call 2")     countfunc(5)     print("Call 3")     countfunc(5)     print("Call 4")     countfunc(5) </code></pre>  <p>The output is: </p>  <p>Call 1 [4, 3, 2, 1] </p>  <p>Call 2 [4, 3, 2, 1, 4, 3, 2, 1] </p>  <p>Call 3 [4, 3, 2, 1, 4, 3, 2, 1, 4, 3, 2, 1] </p>  <p>Call 4 [4, 3, 2, 1, 4, 3, 2, 1, 4, 3, 2, 1, 4, 3, 2, 1]</p>  <p>I would expect the output for all for calls to be:</p>  <p>[4, 3, 2, 1]</p>  <p>I call countfunc 4 times, each passing no kwargs. The function definition is set to provide an empty list as a default for "messagelist" if the kwarg is omitted. However, messagelist seems to retain it's previous value across all 4 calls of countfunc.  </p>  <p>I would expect that local variables in prior calls of countfunc should not influence local variables in subsequent calls. </p>  <p>I suspect this has to do with the way Python handles recursion. Passing in an empty list each time I call the function gives the desired result, so I already have a work around.  I would like to understand why this is happening.  Does anyone have insight?</p>