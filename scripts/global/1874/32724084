<p>I have a TextBox and i need make it resizeble acoording to the text. The problem is that a need set a backgroundImage to simulate a transparent background. When i make it and the TextBox will render again, the control do the job, but the "old" rendered textbox doesn't disapear from the screen and make a mass on the screen.</p>  <p>What i want it's a little different from what is here:</p>  <ul> <li><a href="http://stackoverflow.com/questions/4360301/can-a-background-image-be-set-on-a-winforms-textbox">Can a background image be set on a Winforms TextBox?</a></li> </ul>  <p>1 - I don't override the OnPaintbackground method, i override WndProc and use WM_PAINT message</p>  <p>2 - It works if i dont need resize the TextBox</p>  <p>Here is my code:</p>  <pre><code>public partial class TextView : TextBox {     private Image backImage;     private bool callRender = true;      public TextView(int x, int y)     {         InitializeComponent();          this.BackColor = System.Drawing.Color.White;         this.TextChanged += new EventHandler(textView_TextChanged);         this.Multiline = true;          SetStyle(ControlStyles.UserPaint, true);         SetStyle(ControlStyles.ResizeRedraw, true);         SetStyle(ControlStyles.AllPaintingInWmPaint, true);         SetStyle(ControlStyles.OptimizedDoubleBuffer, true);          this.Location = new Point(x, y);         this.Size = TextRenderer.MeasureText(" ", this.Font);     }      private void textView_TextChanged(object sender, EventArgs e)     {         Size size = TextRenderer.MeasureText(this.Text, this.Font);         this.Width = size.Width + 5;         this.Height = size.Height + 10;         callRender = true;     }      public Image getBackgroundImage()     {         return OverlappBackgroundImages();     }      public Image getBackGroundImage(Rectangle rect)     {         Image backGroundImage = OverlappBackgroundImages();          Rectangle cropRect = rect;// new Rectangle(this.Location.X, this.Location.Y, this.ClientRectangle.Width, this.ClientRectangle.Height);         Bitmap src = backGroundImage as Bitmap;         Bitmap target = new Bitmap(cropRect.Width, cropRect.Height);          using (Graphics g = Graphics.FromImage(target))         {             g.DrawImage(src, new Rectangle(0, 0, target.Width, target.Height),                              cropRect,                              GraphicsUnit.Pixel);         }          return target;     }      private Image OverlappBackgroundImages()     {         Image image1 = BoardManager.GetFieldImage();         Image image2 = this.GenerateFieldInkOverlay("", BoardManager.m_CurrentBoardView.m_FieldView.m_InkField);         using (Graphics g = Graphics.FromImage(image1))         {             g.DrawImageUnscaled(image2, 0, 0);         }          return image1;     }      private IntPtr MakeClientSnapshot(out GDIWrapper.RECT client, IntPtr m_hWnd)     {         IntPtr hDC = GDIWrapper.GetDC(m_hWnd);         GDIWrapper.RECT rcClient;         bool bOk = false;         IntPtr hImage;          GDIWrapper.GetClientRect(m_hWnd, out rcClient);         client = rcClient;         if ((hImage = GDIWrapper.CreateCompatibleBitmap(hDC,                 rcClient.Right, rcClient.Bottom)) != null) {              IntPtr hMemDC;             IntPtr hDCBmp;              if ((hMemDC = GDIWrapper.CreateCompatibleDC(hDC)) != null)             {                 hDCBmp = GDIWrapper.SelectObject(hMemDC, hImage);                  GDIWrapper.BitBlt (hMemDC, 0, 0, rcClient.Right, rcClient.Bottom,                     hDC, 0, 0, GDIWrapper.SRCCOPY);                  GDIWrapper.SelectObject(hMemDC, hDCBmp);                 GDIWrapper.DeleteDC(hMemDC);                 bOk = true;                 }             }         GDIWrapper.ReleaseDC(m_hWnd, hDC);         if (! bOk) {             if (hImage != null) {                 GDIWrapper.DeleteObject(hImage);                  }             }         return hImage;         }      // Save HDC as a bitmap:     private void GetGDIScreenshot(IntPtr m_hWnd, out Image imageCropped)      {         IntPtr hSnapshot;         GDIWrapper.RECT client;         imageCropped = new Bitmap(200, 200);          if ((hSnapshot = MakeClientSnapshot(out client, m_hWnd)) != null)         {             uint uiBytesPerRow = (uint)( 3 * client.Right ); // RGB takes 24 bits             uint uiRemainderForPadding;              if ((uiRemainderForPadding = uiBytesPerRow % sizeof (ulong)) &gt; 0)              {                 uiBytesPerRow += (sizeof (uint) - uiRemainderForPadding);             }              uint uiBytesPerAllRows = (uint)(uiBytesPerRow * client.Bottom);             byte[] pDataBits = new byte[uiBytesPerAllRows];              GDIWrapper.BITMAPINFOHEADER bmi = new GDIWrapper.BITMAPINFOHEADER();             GDIWrapper.BITMAPFILEHEADER bmf = new GDIWrapper.BITMAPFILEHEADER();             IntPtr hDC = GDIWrapper.GetDC(m_hWnd);              // Prepare to get the data out of HBITMAP:             bmi.biSize = (uint)System.Runtime.InteropServices.Marshal.SizeOf(typeof(GDIWrapper.BITMAPINFOHEADER));             bmi.biPlanes = 1;             bmi.biBitCount = 24;             bmi.biHeight = client.Bottom;             bmi.biWidth = client.Right;              GDIWrapper.BITMAPINFO bInfo = new GDIWrapper.BITMAPINFO();             bInfo.bmiHeader = bmi;             GDIWrapper.GetDIBits(hDC, hSnapshot, 0, (uint)client.Bottom, pDataBits, ref bInfo, GDIWrapper.DIB_Color_Mode.DIB_RGB_COLORS);             GDIWrapper.ReleaseDC(m_hWnd, hDC);              // Fill the file header:             bmf.bfOffBits = (uint)(System.Runtime.InteropServices.Marshal.SizeOf(typeof(GDIWrapper.BITMAPFILEHEADER)) + System.Runtime.InteropServices.Marshal.SizeOf(typeof(GDIWrapper.BITMAPINFOHEADER)));             bmf.bfSize = bmf.bfOffBits + uiBytesPerAllRows;             bmf.bfType = 0x4D42;              try             {                 // Create a new stream to write to the file                 MemoryStream ms = new MemoryStream();                 BinaryWriter writer = new BinaryWriter(ms);                  // Writer raw data                                 writer.Write(StructureToByteArray(bmf));                 writer.Write(StructureToByteArray(bmi));                 writer.Write(pDataBits);                  imageCropped = Image.FromStream(ms);                  ms.Close();                 ms.Flush();                 writer.Flush();                 writer.Close();             }             catch(Exception ex)             {              }              GDIWrapper.DeleteObject(hSnapshot);         }     }      private byte[] StructureToByteArray(object obj)     {         int len = Marshal.SizeOf(obj);          byte[] arr = new byte[len];          IntPtr ptr = Marshal.AllocHGlobal(len);          Marshal.StructureToPtr(obj, ptr, true);          Marshal.Copy(ptr, arr, 0, len);          Marshal.FreeHGlobal(ptr);          return arr;     }      protected override void WndProc(ref Message m)     {         switch (m.Msg)         {             case GDIWrapper.WM_PAINT:                 if (callRender)                 {                     //GetGDIScreenshot(m.HWnd, out backImage);                     backImage = getBackGroundImage(new Rectangle(this.Location.X, this.Location.Y, this.Size.Width, this.Size.Height));                     try                     {                         Graphics g = this.CreateGraphics();//Graphics.FromHdc(this.Handle);                         g.DrawImage(backImage, 0, 0, new Rectangle(0, 0, backImage.Width, backImage.Height), GraphicsUnit.Pixel);                         TextRenderer.DrawText(g, this.Text, this.Font, new Point(0, 0), Color.Black, Color.Empty, TextFormatFlags.TextBoxControl | TextFormatFlags.WordBreak |                             TextFormatFlags.EndEllipsis);                     }                     catch (Exception ex)                     {                      }                 }                 m.Result = new IntPtr(1);                 callRender = false;                 break;             default:                 base.WndProc(ref m);                 break;         }     } } </code></pre>