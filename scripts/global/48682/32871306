<p>Here is my hot mess of a function. This will grab the model variants (which are in an array as strings) from the a csv file (the path of this file depends on text we grab from other csv files, hence the looping).</p>  <p>The <code>csvService.getCsvAsArray</code> call you see gets an object with the contents of a csv file where each column is stored in an array under an attribute with the name of the top column. That’s working fine so just know that when you see things like <code>result["NavigationSectionShortNames"]</code>, it’s just an array of strings.</p>  <pre><code>    var INDEX_OF_PRODUCTS_SECTION = 1;     var getAllModelVariants = function () {         return csvService.getCsvAsArray("Contents/Sections/" + navFileNames[INDEX_OF_PRODUCTS_SECTION] + "/order.csv").then(function (result) {             var products = [];             for (var i = 0; i &lt; result["NavigationSectionShortNames"].length; i++) {                 csvService.getCsvAsArray("Contents/Sections/" + navFileNames[INDEX_OF_PRODUCTS_SECTION] + "/" + result["NavigationSectionShortNames"][i]                 + "/order.csv").then(function (productModelInfo) {                     var productFamilies = []; //array of all different families for a certain product                     for (var j = 0; j &lt; productModelInfo["NavigationSectionShortNames"].length; j++) {                         csvService.getCsvAsArray("Contents/Sections/" + navFileNames[INDEX_OF_PRODUCTS_SECTION].length + "/" + result["NavigationSectionShortNames"][i] + "/" + productModelInfo["NavigationSectionShortNames"][j] + "/order.csv").then(function (modelVariants) {                             var productModels = []; //array of all different model types for a certain family                             for (var k = 0; k &lt; modelVariants.length; k++) {                                 productModels.push(modelVariants["NavigationSections"][k]);                             };                             productFamilies.push(productModels);                         });                     };                     products.push(productFamilies);                 });              };         })         return products;     }; </code></pre>  <p>Obviously, this won't work because by the time the promise is resolved, the incrementing variable (i, j, or k) has already changed. Is there to use promises in nested for loops like these successfully? I have came across <code>$q.all</code> but I am struggling to figure out how to apply it to my function. I am currently looking at <a href="http://stackoverflow.com/questions/21024411/angular-q-how-to-chain-multiple-promises-within-and-after-a-for-loop">this example</a> which uses promises in a single for loop, and I will try to expand on it.</p>  <p>My desire is to return a 3D array (see plunker at bottom of question for an example).</p>  <p>If it helps, here is a simplified version of this function with static data and no promises:</p>  <pre><code>    var getAllModelVariantsTest = function () {         var result = ["productFamily1", "productFamily2", "productFamily3"];         var testArray = ["productFamilyModel1", "productFamilyModelt2", "productFamilyModel3", "productFamilyModel4"];         var testArray3 = ["productFamilyModelVariant1", "productFamilyModelVariant2", "productFamilyModelVariant3", "productFamilyModelVariant4"];             var products = [];             for (var i = 0; i &lt; result.length; i++) {                     var productFamilies = []; //array of all different families for a certain product                     for (var j = 0; j &lt; testArray.length; j++) {                             var productModels = []; //array of all different model types for a certain family                             for (var k = 0; k &lt; testArray3.length; k++) {                                 productModels.push(testArray3[k]);                             };                             productFamilies.push(productModels);                     };                 products.push(productFamilies);             };             return products;     };     var testOutput = getAllModelVariantsTest(); </code></pre>  <p><a href="http://plnkr.co/edit/6AgZjQ9FHPK1eZz3xqUm?p=preview" rel="nofollow">Here it is in plunker form</a></p>  <p>If you run that you can see an example of what kind of output I'm desiring with my function above.</p>  <p>I'm wondering how I can get my first function with promises in nested for loops to work like the version in the plunker. Is there a way to do this with incrementing counter variables and promises?</p>  <p>Is <code>$q.all</code> the way to go?</p>  <p>Thank you very much for your time. Let me know if you need anything else or if I am being unclear.</p>