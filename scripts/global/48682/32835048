<p>I have a method in my project that receives an array of promise returning methods. When the first one is finished it moves to the next one and so forth. I am having a hard time figuring how to unit test this method.</p>  <pre><code>fireAllBatches: function (batchQueue, resolve, reject) {     if (batchQueue.length) {         var batch = batchQueue.pop();          // this returns a promise         googleCalendarService.fireBatch(batch)             .then(function (results) {                                       // when done fires the next one                 this.fireAllBatches(batchQueue, resolve, reject);              }.bind(this)).catch(reject);      } else {         console.log('resolving firing of batches.');         resolve();      } } </code></pre>  <p>This is the test:</p>  <pre><code>it('fireAllBatches should call fireBatch as many times as the number of the batches', function () {     spyOn(mockGoogleCalendarService, "fireBatch").and.returnValue(q.when({}));      datalayerObject.fireAllBatches([1, 2, 3, 4, 5, 6]);      expect(mockGoogleCalendarService.fireBatch).toHaveBeenCalled();     expect(mockGoogleCalendarService.fireBatch.calls.count()).toBe(6);  }); </code></pre>  <p><strong>Update</strong></p>  <p>After investigating and reading <a href="http://stackoverflow.com/questions/20100245/how-can-i-execute-array-of-promises-in-sequential-order">this</a> answer. I was able to transform the recursive method to this:</p>  <pre><code>fireAllBatches: function (batchQueue, resolve, reject) {     var methodArray = _.map(batchQueue, function (batch) {         return function () {             console.log('firing batch');             return googleCalendarService.fireBatch(batch)         }     });      var resolvedPromise = $q.when(true);      methodArray.reduce(function(cur, next) {         return cur.then(next);     }, resolvedPromise).then(resolve).catch(reject);  } </code></pre>  <p>However, I am not sure whether it will catch errors correctly.</p>