<p>Have a peek at this, and note the difference between the line that works vs. the line that fails.</p>  <pre><code>interface IThing { }  struct StructThing : IThing { }  class ClassThing : IThing { }  static class WorksWithThings {     public static void Work(IEnumerable&lt;IThing&gt; things) { }      static void Main()     {         List&lt;StructThing&gt; structList = new List&lt;StructThing&gt;();          List&lt;ClassThing&gt; classList = new List&lt;ClassThing&gt;();          WorksWithThings.Work(classList); // &lt;-- works fine         WorksWithThings.Work(structList); // &lt;-- FAILS*     } } </code></pre>  <p>The failure is:</p>  <blockquote>   <p>CS1503    Argument 1: cannot convert from 'System.Collections.Generic.List' to 'System.Collections.Generic.IEnumerable'</p> </blockquote>  <p>However the only difference between the two <code>List&lt;&gt;</code> parameters is the one that works holds class implementations of the <code>IThing</code> interface, but the one that fails holds struct implementations.</p>  <p><strong>Why doesn't covariance work when I pass an <code>IEnumerable</code> of structs, when it works perfectly well with an <code>IEnumerable</code> of classes?</strong></p>  <p>I know about <a href="https://msdn.microsoft.com/en-CA/library/ee207183.aspx" rel="nofollow">covariance and contravariance</a> and <a href="http://stackoverflow.com/a/2662394/3367144">how covariance is used with methods consuming <code>IEnumerable</code> parameters</a>.  This is specifically concerning the error difference between struct and class implementations.</p>