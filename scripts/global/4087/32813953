<p>As far as I know, you can only initialize static const members in the same line of their declaration <a href="http://stackoverflow.com/a/3531105/5302415">if they are integral types </a>. However, I was still able to initialize and use some static const doubles:</p>  <pre><code>// compiles and works, values are indeed doubles struct Foo1{      static const double A=2.5;     static const double B=3.2;     static const double C=1.7; };  // compiles, but values are cast to int struct Foo2{     static const int A=2;     static const int B=3;     static const double C=B/A; //becomes 1 };  // does not compile, Foo3::B cannot appear in a constant-expression struct Foo3{      static const int A=2;     static const double B=3;     static const double C=A/B;  };  // does not compile, a cast to a type other than an integral or enumeration // cannot appear in a constant-expression struct Foo4{      static const int A=2;     static const int B=3;     static const double C=(double)A/B;  }; </code></pre>  <p>Foo2 compiles but Foo2::C becomes 1, so maybe it is treated as an int as it is numerically one. Foo3 and Foo4 don't even compile, as expected. However, I don't understand why Foo1 both compiles and works correctly. Is this specific usage accepted? Is it because of some optimization? ( I've tried using -O1 and -O0) </p>  <p>Note: using GNU 5.2.0 with cmake and setting the standard to C++98. Switching to C++11 works fine ( that is, does not compile and asks to switch those members to constexpr). </p>