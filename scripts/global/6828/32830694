<p>I have a class with four dynamic arrays like this:</p>  <pre><code>CObjA * objAArray; CObjB * objBArray; CObjC * objCArray; CObjD * objDArray; </code></pre>  <p>and I initialize those like this:</p>  <pre><code>objAArray = new CObjA[numObj]; objBArray = new CObjB[numObj]; objCArray = new CObjC[numObj]; objDArray = new CObjD[numObj]; </code></pre>  <p>The problem is that those four memory allocations take a long time - performance is very bad if I have to create 40'000 objects like this.</p>  <p>my question is: is there a way to allocate all four arrays with one <code>new</code> operation?</p>  <p>If I create a new struct:</p>  <pre><code>struct _arrays {  CObjA objA;  CObjB objB;  CObjC objC;  CObjD objD; }; </code></pre>  <p>and use one array of that struct instead, I only have to use one <code>new</code>:</p>  <pre><code>_arrays * arr = new _arrays[numObj]; </code></pre>  <p>But then the objects are not laid out in memory correctly. They're then in memory as <code>CObjA1-CObjB1-CObjC1-CObjD1-CObjA2-CObjB2...</code>. instead of first all <code>CObjA</code> objects, then all <code>CObjB</code> objects, ...</p>  <p>Is there a way to use one <code>new</code> but still get the correct memory layout of the objects?</p>