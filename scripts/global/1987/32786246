<p>I have a scenario where we have an existing (old) operating system written in C, some 15 years ago. Now, we are looking at extending this system, being able to write user-space programs in Rust.</p>  <p>Naturally, because this was recently started, we haven't bothered about porting all of <code>libstd</code> to our own OS yet. We are hence using <code>#![feature(no_std)]</code>.</p>  <p>Now, I am looking for something that should be reasonably simple: <em>converting a Rust string into a C-null-terminated string</em>. Should be simple, but because I am so inexperienced with Rust I haven't (yet) been able to figure it out.</p>  <p>For the sake of this experience, it's enough to impose certain limits (like, max 1024 byte long strings; anything else gets truncated). (We do have memory allocation in place but I haven't bothered trying to handle memory allocation from Rust yet)</p>  <p>Here is my feeble attempt so far:</p>  <pre><code>pub struct CString {     buffer: [i8; 1024] }  impl CString {     pub fn new(s: &amp;str) -&gt; CString {         CString {             buffer: CString::to_c_string(s)         }     }      fn to_c_string(s: &amp;str) -&gt; [i8; 1024] {         let buffer: [i8; 1024];         let mut i = 0;          // TODO: ignore the risk for buffer overruns for now. :)         // TODO: likewise with UTF8; assume that we are ASCII-only.         for c in s.chars() {             buffer[i] = c as i8;             i = i + 1;         }          buffer[s.len()] = '\0' as i8;         buffer;     }      pub fn as_ptr(&amp;self) -&gt; *const i8 {             // TODO: Implement. The line below doesn't even compile.         self.buffer as *const i8     } } </code></pre>  <p>The core problem here is the type-casting in <code>as_ptr</code>. How do you do it in Rust? Also, are there any other issues with this code, apart from the obvious ones? (broken UTF8 non-ASCII character handling, totally stupid if the string is longer than 1024 characters... :)</p>  <p>Huge thanks in advance! This <strong>must</strong> be something fairly obvious...</p>  <hr>  <p><strong>Update</strong>: Based on the the answer by Will Fischer (thanks!), I changed my <code>as_ptr</code> method to look like this:</p>  <pre><code>pub fn as_ptr(&amp;self) -&gt; *const i8 {     &amp;self.buffer as *const i8 } </code></pre>  <p>The code now compiles, but it doesn't link:</p>  <pre><code>virtio_net_pci.0.rs:(.text._ZN6system8c_string7CString3new20hbfc6c6db748de66bpaaE+0x31): undefined reference to `memset' virtio_net_pci.0.rs:(.text._ZN6system8c_string7CString3new20hbfc6c6db748de66bpaaE+0x14f): undefined reference to `memcpy' virtio_net_pci.0.rs:(.text._ZN6system8c_string7CString3new20hbfc6c6db748de66bpaaE+0x174): undefined reference to `panicking::panic_bounds_check::h0b7be17a72a754b5P6E' virtio_net_pci.0.rs:(.text._ZN6system8c_string7CString3new20hbfc6c6db748de66bpaaE+0x18c): undefined reference to `panicking::panic_bounds_check::h0b7be17a72a754b5P6E' collect2: error: ld returned 1 exit status </code></pre>  <p>The <code>memset</code> and <code>memcpy</code> stuff is easy to fix. The bounds checking I assume is implemented in <code>libcore</code> - any way to get that working without linking to libcore? (which would probably be a reasonable thing anyway...)</p>