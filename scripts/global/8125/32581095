<p>I need to create a dynamic table from the data selected in the chart generated by the code below, how can i do that? I'm using the DC.js library. There is an example of the chart: <a href="http://dc-js.github.io/dc.js/examples/multi-focus.html" rel="nofollow">http://dc-js.github.io/dc.js/examples/multi-focus.html</a></p>  <pre><code>&lt;script type="text/javascript"&gt;  var chart1 = dc.barChart("#test1"); var chart2 = dc.barChart("#test2");  d3.csv("data1x2.csv", function(error, data) {  var parseDate = d3.time.format("%Y-%m-%d %H:%M").parse;  data.forEach(function(d) {     d.date = parseDate(d.date); });  var ndx   = crossfilter(data),       transactionDate = ndx.dimension(function (d) { return d.date;});       //prelevato i valori di date del file csv       Frequenza = transactionDate.group().reduceSum(function(d) {return d.frequenza;});       //prelevato i valori di frequenza del file csv e traformati in caratteri numerici  var minDate = transactionDate.bottom(1)[0].date; var maxDate = transactionDate.top(1)[0].date;  function bar_chart(chart) {     chart         .width(400)         .height(300)         .x(d3.time.scale().domain([minDate,maxDate]))         .brushOn(true)         .yAxisLabel("")         .dimension(transactionDate)         .group(Frequenza);     chart.render(); }  bar_chart(chart1); bar_chart(chart2);   // this example was inspired by this Stack Overflow question: // http://stackoverflow.com/questions/27445259/dc-js-applying-range-chart-to-multiple-graphs  // it would be nice to include the functionality in dc.js proper, but we'd have to deal with the // complementary part of having each focus chart change the range chart when it is zoomed // and that requires more thinking: https://github.com/dc-js/dc.js/issues/820  // we need to this helper function out of coordinateGridMixin function rangesEqual(range1, range2) {     if (!range1 &amp;&amp; !range2) {         return true;     }     else if (!range1 || !range2) {         return false;     }     else if (range1.length === 0 &amp;&amp; range2.length === 0) {         return true;     }     else if (range1[0].valueOf() === range2[0].valueOf() &amp;&amp;         range1[1].valueOf() === range2[1].valueOf()) {         return true;     }     return false;  }  // monkey-patch the first chart with a new function // technically we don't even need to do this, we could just change the 'filtered' // event externally, but this is a bit nicer and could be added to dc.js core someday chart1.focusCharts = function (chartlist) {     if (!arguments.length) {         return this._focusCharts;     }     this._focusCharts = chartlist; // only needed to support the getter above     this.on('filtered', function (range_chart) {         if (!range_chart.filter()) {             dc.events.trigger(function () {                 chartlist.forEach(function(focus_chart) {                     focus_chart.x().domain(focus_chart.xOriginalDomain());                 });             });         } else chartlist.forEach(function(focus_chart) {             if (!rangesEqual(range_chart.filter(), focus_chart.filter())) {                 dc.events.trigger(function () {                     focus_chart.focus(range_chart.filter());                 });             }         });     });     return this; };  chart1.focusCharts([chart2]); });  &lt;/script&gt; &lt;div id="tabella"&gt; &lt;/div&gt; </code></pre>