<p>I've the following structrue :</p>  <pre><code>Item {   id string,   title string   tags []string,   time int,   parent string } </code></pre>  <p>What i want, <code>list all items with tags [tag1, tag2, ... etc] of parent "parent-1" and order by time</code></p>  <p>So i did this</p>  <pre><code>r.db("db").table("tb").indexCreate("allByTime", function(row){   return row("tags").map(function(tag){     return [row("parent"), tag, row("time")]   }) }) </code></pre>  <p>It worked with a query like this </p>  <pre><code>r.db("db").table("tb").between(["parent-1", "tag1", 0], ["parent-1", "tag1", &lt;some-bigger-timestamp&gt;], {index: "allByTime"}).orderBy(...) </code></pre>  <p>But also i want something like this </p>  <pre><code>r.db("db").table("tb").between(["parent-1", ["tag1", "tag2"], 0], ["parent-1", ["tag1", "tag2"], &lt;some-bigger-timestamp&gt;], {index: "allByTime"}).orderBy(...) </code></pre>  <hr>  <p>Any suggestions ?  </p>  <h2><strong>NOTE -></strong> i don't want to use <code>r.filter(...)</code></h2>  <p>I've tried something like this</p>  <pre><code>r.union(&lt;between-query-1&gt;, &lt;between-query-2&gt;, ...) </code></pre>  <p>but i don't know what the overhead will be in large table with many between queries .</p>