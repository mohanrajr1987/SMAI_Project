<p>I need to create a ton of objects in R for a fun little simulation that I want to do. Creating these objects isn't so much the issue, but it takes forever to create millions of them. So, I want to speed up the process by running the function in parallel with the doParallel package.</p>  <p>Here is the code to the function I am trying to parallelize. (Note that it exists within a larger function. The first two parameters are numeric, the third one is a numeric between 0 and 1.)</p>  <pre><code>create_population &lt;- function(population_size, population_income, expense_ratio) { #create a list people = list()  #create a class of people with fields "income", "expenses", "interest", "buy chance"  registerDoParallel(cores = 8)   people &lt;- foreach (i=seq(population_size), .multicombine = TRUE) %dopar% {   person &lt;- setClass("Person", slots = c(income="numeric", expenses="numeric", interest_x="numeric", interest_y="numeric",                                          interest_z="numeric", buy_chance="numeric"))    #initialize people[i]   people[i] = person(income = 0, expenses = 0, interest_x = 0, interest_y = 0, interest_z = 0, buy_chance = 0)    # randomly generate a variability about the base population income   variability = rnorm(1, mean = population_income, sd = population_income * 0.25)   if (variability &lt; 0)   {     variability = 0   }    people[[i]]@income = variability    expenses = rnorm(1, mean = people[[i]]@income * expense_ratio, sd = people[[i]]@income * expense_ratio * 0.25)   if (expenses &lt; 0)   {     expenses = 0   }    people[[i]]@expenses = expenses    #generate random interests   people[[i]]@interest_x = runif(1, min = 0, max = 10)   people[[i]]@interest_y = runif(1, min = 0, max = 10)   people[[i]]@interest_z = runif(1, min = 0, max = 10)    #buy_chance to be calculated later    people }  return(people) } </code></pre>  <p>The problem is that this gives the data in the incorrect format. What I want is a list such that if I do</p>  <pre><code>people[[1]] </code></pre>  <p>I get a result that looks like the following:</p>  <pre><code>An object of class "Person" Slot "income": [1] 0  Slot "expenses": [1] 0  Slot "interest_x": [1] 0  Slot "interest_y": [1] 0  Slot "interest_z": [1] 0  Slot "buy_chance": [1] 0 </code></pre>  <p>where the zeros are replaced by actual numbers to be calculated in the program.</p>  <p>Instead, the current program gives me "blank entries" before the called value. For example, people[[3]] gives</p>  <pre><code>[[1]] NULL  [[2]] NULL  [[3]] An object of class "Person" Slot "income": [1] 5814.516  Slot "expenses": [1] 4227.224  Slot "interest_x": [1] 9.094684  Slot "interest_y": [1] 4.093398  Slot "interest_z": [1] 7.691337  Slot "buy_chance": [1] 0 </code></pre>  <p>, which will clearly cause issues in other areas of my program. Any suggestions?</p>  <p>What I could do is access the information by</p>  <pre><code>people[[i]][i] </code></pre>  <p>, but even with only 1,280 elements, the size of this list is an enormous 152.1 Mb, so I would prefer a solution that puts the data in the right format and cuts down on memory usage. </p>  <p>For a comparison in memory size:</p>  <pre><code>object.size(person[[100]]) </code></pre>  <p>returns 19560 bytes, while</p>  <pre><code>object.size(person[[100]][100]) </code></pre>  <p>returns 1488 bytes. The difference gets bigger as the index increases, so clearly a million elements could cause memory problems.</p>  <p>I don't know if this matters, but I am running my code on Windows through R Studio.</p>