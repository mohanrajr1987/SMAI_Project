<p>I deployed a Asp.Net Web API project onto my CentOS server running mono 4.3.0 (compiled from mono-4.2.1.36 branch released 2 days ago). I built the project using VS2015 enpty web api template and added owin authentication in an attempt to get a web api working with authentication using bearer tokens. </p>  <p>I'm hosting the project on apache server using mod_mono. </p>  <p>When running the project locally on my windows machine, everything works perfectly. On Linux, when I send a http POST to the /token endpoint, the server returns a 200 OK, but without any response payload (which would include the bearer token the client needs to authenticate subsequent requests). At the same time, the server logs an exception (following). </p>  <pre><code>System.MissingMethodException: Method 'HttpRequestBase.GetBufferlessInputStream' not found.   at Microsoft.Owin.Host.SystemWeb.CallStreams.InputStream.get_Stream () &lt;0xb0e339b8 + 0x00013&gt; in &lt;filename unknown&gt;:0   at Microsoft.Owin.Host.SystemWeb.CallStreams.DelegatingStream.get_CanRead () &lt;0xb0e45eb0 + 0x00013&gt; in &lt;filename unknown&gt;:0   at System.IO.StreamReader..ctor (System.IO.Stream stream, System.Text.Encoding encoding, Boolean detectEncodingFromByteOrderMarks, Int32 bufferSize, Boolean leaveOpen) &lt;0xb0e5d790 + 0x0005f&gt; in &lt;filename unknown&gt;:0   at (wrapper remoting-invoke-with-check) System.IO.StreamReader:.ctor (System.IO.Stream,System.Text.Encoding,bool,int,bool)   at Microsoft.Owin.OwinRequest+&lt;ReadFormAsync&gt;d__0.MoveNext () &lt;0xb0e33510 + 0x000f3&gt; in &lt;filename unknown&gt;:0 --- End of stack trace from previous location where exception was thrown ---   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw () &lt;0xb0e34a68 + 0x0002b&gt; in &lt;filename unknown&gt;:0   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess (System.Threading.Tasks.Task task) &lt;0xb0e346d0 + 0x000bb&gt; in &lt;filename unknown&gt;:0   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (System.Threading.Tasks.Task task) &lt;0xb0e34588 + 0x0007f&gt; in &lt;filename unknown&gt;:0   at System.Runtime.CompilerServices.TaskAwaiter.ValidateEnd (System.Threading.Tasks.Task task) &lt;0xb270df98 + 0x00033&gt; in &lt;filename unknown&gt;:0   at System.Runtime.CompilerServices.TaskAwaiter`1[TResult].GetResult () &lt;0xb270e1d0 + 0x00017&gt; in &lt;filename unknown&gt;:0   at Microsoft.Owin.Security.OAuth.OAuthAuthorizationServerHandler+&lt;InvokeTokenEndpointAsync&gt;d__22.MoveNext () &lt;0xb0e2f118 + 0x00463&gt; in &lt;filename unknown&gt;:0 --- End of stack trace from previous location where exception was thrown ---   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw () &lt;0xb0e34a68 + 0x0002b&gt; in &lt;filename unknown&gt;:0   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess (System.Threading.Tasks.Task task) &lt;0xb0e346d0 + 0x000bb&gt; in &lt;filename unknown&gt;:0   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (System.Threading.Tasks.Task task) &lt;0xb0e34588 + 0x0007f&gt; in &lt;filename unknown&gt;:0   at System.Runtime.CompilerServices.TaskAwaiter.ValidateEnd (System.Threading.Tasks.Task task) &lt;0xb270df98 + 0x00033&gt; in &lt;filename unknown&gt;:0   at System.Runtime.CompilerServices.TaskAwaiter.GetResult () &lt;0xb270df70 + 0x00013&gt; in &lt;filename unknown&gt;:0   at Microsoft.Owin.Security.OAuth.OAuthAuthorizationServerHandler+&lt;InvokeAsync&gt;d__0.MoveNext () &lt;0xb270e790 + 0x007a7&gt; in &lt;filename unknown&gt;:0 --- End of stack trace from previous location where exception was thrown ---   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw () &lt;0xb0e34a68 + 0x0002b&gt; in &lt;filename unknown&gt;:0   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess (System.Threading.Tasks.Task task) &lt;0xb0e346d0 + 0x000bb&gt; in &lt;filename unknown&gt;:0   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (System.Threading.Tasks.Task task) &lt;0xb0e34588 + 0x0007f&gt; in &lt;filename unknown&gt;:0   at System.Runtime.CompilerServices.TaskAwaiter.ValidateEnd (System.Threading.Tasks.Task task) &lt;0xb270df98 + 0x00033&gt; in &lt;filename unknown&gt;:0   at System.Runtime.CompilerServices.TaskAwaiter`1[TResult].GetResult () &lt;0xb270f5b0 + 0x00013&gt; in &lt;filename unknown&gt;:0   at Microsoft.Owin.Security.Infrastructure.AuthenticationMiddleware`1+&lt;Invoke&gt;d__0[TOptions].MoveNext () &lt;0xb270b2a0 + 0x0030f&gt; in &lt;filename unknown&gt;:0 --- End of stack trace from previous location where exception was thrown ---   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw () &lt;0xb0e34a68 + 0x0002b&gt; in &lt;filename unknown&gt;:0   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess (System.Threading.Tasks.Task task) &lt;0xb0e346d0 + 0x000bb&gt; in &lt;filename unknown&gt;:0   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (System.Threading.Tasks.Task task) &lt;0xb0e34588 + 0x0007f&gt; in &lt;filename unknown&gt;:0   at System.Runtime.CompilerServices.TaskAwaiter.ValidateEnd (System.Threading.Tasks.Task task) &lt;0xb270df98 + 0x00033&gt; in &lt;filename unknown&gt;:0   at System.Runtime.CompilerServices.TaskAwaiter.GetResult () &lt;0xb270df70 + 0x00013&gt; in &lt;filename unknown&gt;:0   at Microsoft.Owin.Host.SystemWeb.IntegratedPipeline.IntegratedPipelineContextStage+&lt;RunApp&gt;d__5.MoveNext () &lt;0xb270aa98 + 0x00173&gt; in &lt;filename unknown&gt;:0 </code></pre>  <p>After googling I found that this exception has been fixed in another namespace, but note this originates in  Microsoft.Owin.Host.SystemWeb. </p>  <p>Is there a workaround to get rid of the exception, and does anyone have information on if that exception is the reason for the behavior I'm facing or is there something else I can try in order to get bearer token based authentication working? </p>  <p>In my AuthorizationServerProvider I implement the following methods: (also, when running on Linux the response headers do not include Access-Control-Allow-Origin like they do on Windows)</p>  <pre><code>public override Task ValidateClientAuthentication(OAuthValidateClientAuthenticationContext context) {   context.OwinContext.Response.Headers.Add("Access-Control-Allow-Origin", new[] { "*" });   context.Validated();   return Task.FromResult&lt;object&gt;(null); }  public override async Task GrantResourceOwnerCredentials(OAuthGrantResourceOwnerCredentialsContext context) {     //check credentials      var identity = new ClaimsIdentity(context.Options.AuthenticationType);     identity.AddClaim(new Claim(ClaimTypes.Name, context.UserName)); //etc      var props = new AuthenticationProperties(new Dictionary&lt;string, string&gt;     {        { "as:client_id", (context.ClientId == null) ? string.Empty : context.ClientId },        { "userName", context.UserName }     });      var ticket = new AuthenticationTicket(identity, props);     context.Validated(ticket); }  public override Task TokenEndpoint(OAuthTokenEndpointContext context) {     foreach (KeyValuePair&lt;string, string&gt; property in context.Properties.Dictionary)     {         context.AdditionalResponseParameters.Add(property.Key, property.Value);     }      return Task.FromResult&lt;object&gt;(null); } </code></pre>  <p>My Startup.cs looks like this:</p>  <pre><code>public void Configuration(IAppBuilder app) {     ConfigureOAuth(app);      HttpConfiguration config = new HttpConfiguration();      config.Filters.Add(new AuthorizeAttribute());     WebApiConfig.Register(config);       GlobalConfiguration.Configuration.IncludeErrorDetailPolicy = IncludeErrorDetailPolicy.Always;     GlobalConfiguration.Configuration.Filters.Add(new AuthorizeAttribute());      app.UseCors(Microsoft.Owin.Cors.CorsOptions.AllowAll);       app.UseWebApi(config); }  public void ConfigureOAuth(IAppBuilder app) {     OAuthAuthorizationServerOptions OAuthServerOptions = new OAuthAuthorizationServerOptions()     {         AllowInsecureHttp = true,         TokenEndpointPath = new PathString("/token"),         AccessTokenExpireTimeSpan = TimeSpan.FromMinutes(15),         Provider = new BoaAuthorizationServerProvider(),          RefreshTokenProvider = new BoaRefreshTokenProvider(),         ApplicationCanDisplayErrors = true,     };     // Enable the application to use bearer tokens to authenticate users     app.UseOAuthBearerTokens(OAuthServerOptions); } </code></pre>  <hr>  <p>EDIT:</p>  <p>Some more information on this:</p>  <p>I tried the old remove-the-problematic-dll -trick, and I no longer get that exception, but however I do get a 500 Internal Server Error, when sending a http POST to the token endpoint (the same that works on windows).</p>  <p>This is the exception:</p>  <pre><code>System.Web.HttpException Method 'POST' is not allowed when accessing file '/webapitest/token'  Description: HTTP 500.Error processing request. Details: Error processing request. Exception stack trace:    at System.Web.DefaultHttpHandler.BeginProcessRequest (System.Web.HttpContext context, System.AsyncCallback callback, System.Object state) in &lt;filename unknown&gt;:line 0    at System.Web.HttpApplication+&lt;Pipeline&gt;c__Iterator1.MoveNext () in &lt;filename unknown&gt;:line 0    at System.Web.HttpApplication.Tick () in &lt;filename unknown&gt;:line 0 </code></pre>  <p>Note the Startup configuration above, is there anything there that mono does not support? If not, this seems like either a configuration problem or a bug in mono as someone previously commented that they get the same MissingMethodException about GetBufferlessInputStream that happens on Ubuntu. That comment has then been removed. </p>