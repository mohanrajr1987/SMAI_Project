<p>I am having some serious trouble getting my multiline label to show all of its lines. Often, the last line of the label simply does not appear, but it is apparent that the dynamically calculated cell height has taken in to account that it should have appeared, leaving around the appropriate amount of white space left over in my cell. </p>  <p>The affected label can display 1-7 lines depending on the data. I have played around with many various constraints to try and get it to display but regardless of what is on the last line, it just won't display. </p>  <p>The weird thing is, sometimes it will display when I segue in to the VC, but then when I use the segmented controller inside the VC to display different data and then go back again, the last line will again not display. The opposite happens frequently too (last line of label cutting off when I segue in to the VC, but then using the segmented controller inside the VC to change the displayed data and then go back, it will then display fine).</p>  <p>Things I have ensured: The label is set to word wrap, has line count of 0, has a height greater than or equal to the height of one of it's lines, its resistance and vertical content hugging is set to the highest of anything in the cell, and the width is set appropriately. </p>  <p>The below code is how I determine how many lines the label will have:</p>  <pre><code>let descString = NSMutableAttributedString()  let bountyStart = NSMutableAttributedString(string: "Bounty: ", attributes: [NSFontAttributeName : UIFont.boldSystemFontOfSize(15)]) let bountyDesc = NSMutableAttributedString(string: bounty.description) descString.appendAttributedString(bountyStart) descString.appendAttributedString(bountyDesc)  let bLine = NSMutableAttributedString(string: "\n\n", attributes: [NSFontAttributeName : UIFont.systemFontOfSize(2)]) descString.appendAttributedString(bLine)  if !(bounty.turtles == 0.0){     let turtleStart = NSMutableAttributedString(string: "Your turtle count: ")     let turtleAmount = NSMutableAttributedString(string: bounty.turtleCount.description)     descString.appendAttributedString(turtleStart)     descString.appendAttributedString(turtleAmount) } descriptionLabel.attributedText = descString </code></pre>  <p>In the screen shot below, you can see that the height of the cell is being calculated appropriately but for some reason, the last line of the label just refuses to show. It should appear after the "is for noobs" line. I've manipulated the white space to appear after the line instead of elsewhere by setting the problem labels bottom to constraint to be greater than or equal, and all other top to bottom constraints as equal to.</p>  <p><a href="http://i.stack.imgur.com/2ArcS.png" rel="nofollow"><img src="http://i.stack.imgur.com/2ArcS.png" alt="enter image description here"></a></p>  <p>Constraints of the problem label:</p>  <p><a href="http://i.stack.imgur.com/enlKw.png" rel="nofollow"><img src="http://i.stack.imgur.com/enlKw.png" alt="enter image description here"></a></p>  <p>I've been stumped for quite a while on this one, and I'm starting to think it's not the constraints I've set but something much deeper. All though I would love to be proven wrong.</p>  <p>Here is my VC code.</p>  <pre><code>    import UIKit  class TrendingVC: UIViewController, UITableViewDataSource, UITableViewDelegate{      @IBOutlet weak var menubtn:UIBarButtonItem!     @IBOutlet var trendingTableView:UITableView!        var trendingToggle:Int = 0     let nwt = NWTrending()     let appUserId = NSUserDefaults.standardUserDefaults().stringForKey("UserId") ?? "1" //@TODO: remove ?? 1     var bountyArr: [Bounty] = []     var compArr: [Completion] = []     var peopleArr: [Person] = []      var userId: String = "0"     var username: String = ""      let bountyCellIdentifier = "BountyCellNew"     let personCellIdentifier = "PersonCell"     let completedCellIdentifier = "TrendingCompletedImageCell"        @IBAction func toggleTrending(sender:UISegmentedControl){         switch sender.selectedSegmentIndex{         case 0:             //loads the bounties on segmented control tab             trendingToggle=0             nwt.getTrendingBounties(appUserId, position: 0){(bountyArr, err) in //@TODO: change pos                 self.bountyArr = bountyArr as [Bounty]                 self.reloadTableViewContent()             }         case 1:             trendingToggle=1             nwt.getTrendingCompletions(appUserId, position: 0){(compArr, err) in                 self.compArr = compArr as [Completion]                 self.reloadTableViewContent()             }         case 2:             trendingToggle=2             nwt.getTrendingPeople(appUserId, position: 0){(peopleArr, err) in                 self.peopleArr = peopleArr as [Person]                 self.reloadTableViewContent()             }         default:             break         }          //reloadTableViewContent()     }        override func viewDidLoad() {     super.viewDidLoad()      trendingTableView.estimatedRowHeight = 300.0     trendingTableView.rowHeight = UITableViewAutomaticDimension       /******* Kyle Inserted *******/     //for followers and following back button text, you set it here for when you segue into that section     let backItem = UIBarButtonItem(title: " ", style: UIBarButtonItemStyle.Plain, target: nil, action: nil)     navigationItem.backBarButtonItem = backItem     /******* END Kyle Inserted *******/      trendingTableView.allowsSelection = false;     trendingTableView.delegate = self     trendingTableView.dataSource = self      //sidebar code     if self.revealViewController() != nil {         menubtn.target = self.revealViewController()         menubtn.action = "revealToggle:"         self.view.addGestureRecognizer(self.revealViewController().panGestureRecognizer())     }      //loads the bounty on segue     nwt.getTrendingBounties(appUserId, position: 0){(bountyArr, err) in         self.bountyArr = bountyArr as [Bounty]         self.reloadTableViewContent()     } }       override func didReceiveMemoryWarning() {         super.didReceiveMemoryWarning()         // Dispose of any resources that can be recreated.     }       override func viewWillAppear(animated: Bool) {         super.viewWillAppear(animated)         //deselectAllRows()      }       func deselectAllRows() {         if let selectedRows = trendingTableView.indexPathsForSelectedRows() as? [NSIndexPath] {             for indexPath in selectedRows {                 trendingTableView.deselectRowAtIndexPath(indexPath, animated: false)             }         }     }      func reloadTableViewContent() {         dispatch_async(dispatch_get_main_queue(), { () -&gt; Void in             self.trendingTableView.reloadData()             println("reloading table view content")             self.trendingTableView.scrollRectToVisible(CGRectMake(0, 0, 1, 1), animated: false)         })     }      func numberOfSectionsInTableView(tableView: UITableView) -&gt; Int {         return 1     }       func tableView(trendingTableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {         if trendingToggle == 0{         return bountyArr.count         }         else if trendingToggle == 1{             return compArr.count         }         else {             return peopleArr.count         }     }       func tableView(trendingTableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell {         if trendingToggle == 0{             return bountyCellAtIndexPath(indexPath)         }         else if trendingToggle == 1{             return completedCellAtIndexPath(indexPath)         }         else{         return personCellAtIndexPath(indexPath)         }     }      //calls method to set and display each trending bounty cell     func bountyCellAtIndexPath(indexPath:NSIndexPath) -&gt; BountyCellNew {         let cell = trendingTableView.dequeueReusableCellWithIdentifier(bountyCellIdentifier) as! BountyCellNew         var bounty = bountyArr[indexPath.row]         cell.setBountyCellTrending(bounty)         return cell     }      func completedCellAtIndexPath(indexPath:NSIndexPath) -&gt; CompletedCell{         let cell = trendingTableView.dequeueReusableCellWithIdentifier(completedCellIdentifier) as! CompletedCell         var comp = compArr[indexPath.row]         cell.setTrendingCompletedCell(comp)         return cell     }       func personCellAtIndexPath(indexPath:NSIndexPath) -&gt; PersonCell{         let cell = trendingTableView.dequeueReusableCellWithIdentifier(personCellIdentifier) as! PersonCell         var peop = peopleArr[indexPath.row]         cell.setTrendingPeopleCell(peop)         return cell     }    } </code></pre>