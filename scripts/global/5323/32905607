<p>I have a simple Tkinter window, started from an IPython console (so mainloop() is not called, in case that's relevant)</p>  <p>When I press Ctrl+C in the console, nothing happens... until the Tkinter window does something, at which point it catches the KeyboardInterrupt and raises an error.</p>  <p>The question is: how do I catch that KeyboardInterrupt? It seems that no matter where I put a try: block, it is too late already...</p>  <p>Here's an example:</p>  <pre><code>class App(object):   def __init__(self,):     self.root = tk.Tk()     self.root.bind('&lt;FocusIn&gt;', self.focus_in)    def focus_in(self, event):     print 'I got focus' </code></pre>  <p>in the IPython console:</p>  <pre><code>app = App() </code></pre>  <p>Now press Ctrl+C in the console. Then click on the App window... and bang: </p>  <pre><code>Traceback (most recent call last): File "/usr/local/lib/python2.7/lib-tk/Tkinter.py", line 1481, in __call__ def __call__(self, *args): KeyboardInterrupt </code></pre>  <p>Adding a 'try/except KeyboardInterrupt' block inside focus_in does not help.</p>  <p>So? Is this a bug? Should TKinter even see that interrupt? Can I disable SIGINT while IPython is idle? (Naturally I still want it when it is running some code...)</p>