<p>First, the inheritance approach may not be correct. If so, please explain a different approach.</p>  <p>Here is an example of the setup.</p>  <p>I have many applications, other than using the exact same database, that are not connected. To dry up the code base, I have an engine with all of the active record classes. I would like to keep application specific scopes and methods within the main applications.</p>  <p>In my Rails engine,</p>  <pre><code>class MyEngine::User &lt; ActiveRecord::Base   has_many :dogs end  class MyEngine::Dog &lt; ActiveRecord::Base   belongs_to :user end </code></pre>  <p>In my main app,</p>  <pre><code>class User &lt; MyEngine::User end  class Dog &lt; MyEngine::Dog   # EDITED TO SHOW EXAMPLE OF HOW SCOPE DOESN'T BELONG IN ENGINE   DOGS_WITH_SPOTS_IDS = [ 1, 2, 3, 4 ]    scope :with_spots, -&gt; { where(id: DOGS_WITH_SPOTS_IDS) } end </code></pre>  <p>The issue in my main app,</p>  <pre><code>user = User.last user.dogs # =&gt; #&lt;ActiveRecord::Associations::CollectionProxy[#&lt;MyEngine::Dog spots: true&gt;]&gt; user.dogs.with_spots NoMethodError: undefined method 'with_spots' for #&lt;MyEngine::Dog::ActiveRecord_Association_CollectionProxy:0x007fa4bf838e50&gt; </code></pre>  <p>Although this works</p>  <pre><code>class User &lt; MyEngine::User   has_many :dogs end </code></pre>  <p>I would prefer not to redefine/define all of the associations in the main apps.</p>  <p>This type of problem is just going to keep occurring in different forms throughout all of my main applications. This made me think that there may be a way to redefine the associations.</p>  <p>Is there a way to evaluate the association on the subclass instead of the superclass much like the STI pattern to get Rails helpers to recognize different subclasses?</p>  <p>Meaning, I would like my main app User#dogs to return main app Dog instead of MyEngine::Dog.</p>  <pre><code># may not be the exact code, just off the top of my head  instance_eval do   def model_name     self.class.name   end end </code></pre>