<p>Having models:</p>  <pre><code>class Movie &lt; ActiveRecord::Base      has_many :comments   has_many :ratings end  # self join to unable multilevel comments class Comment &lt; ActiveRecord::Base   belongs_to :upcomment, class_name: "Comment"   belongs_to :user end  class Rating &lt; ActiveRecord::Base   belongs_to :movie   belongs_to :user end  class User &lt; ActiveRecord::Base   has_many :ratings   has_many :comments end </code></pre>  <p>when i wan't to get all comments with their replies and comments/replies authors I do following query:</p>  <pre><code>@comments = Comment   .where('comments.movie_id = ? AND comments.upcomment_id IS NULL', params[:movie])   .includes([:user, :replies =&gt; :user]) </code></pre>  <p><strong>Q1:</strong> But how should I modify this query to includes also user rating for each comment and reply?.</p>  <h2>My attempts</h2>  <p>For now I'll skip replies for simplicity. I added ratings to .includes and where clause as follows:</p>  <pre><code>@comments = Comment   .where('comments.movie_id = ? AND comments.upcomment_id IS NULL', params[:movie])    .includes([:user =&gt; :ratings])   .where(ratings: { movie_id: params[:movie] }) </code></pre>  <p>It works, but it returns only those comments which author has a rating. When I looked at the SQL generated by Rails I noticed that '"ratings"."movie_id" = ?' is (probably) in the wrong place:</p>  <pre><code>SELECT [...] LEFT OUTER JOIN "users" "users" ON "users"."id" = "comments"."user_id"  LEFT OUTER JOIN "ratings" "users_ratings" ON "ratings"."user_id" = "users"."id"  WHERE (comments.movie_id = '131' AND comments.upcomment_id IS NULL) AND "ratings"."movie_id" = 131  | So I changed and made a query in SQLite to check if it works V SELECT [...] LEFT OUTER JOIN "users" ON "users"."id" = "comments"."user_id"  LEFT OUTER JOIN "ratings" ON "ratings"."user_id" = "users"."id" AND "ratings"."movie_id" = "comments"."movie_id" WHERE (comments.movie_id = '131' AND comments.upcomment_id IS NULL) </code></pre>  <p>It seems to work, but  <strong>Q2:</strong> How can I perform join with more than one condition in Rails (without writing join by myself) ?</p>  <p>Since I didn't find answer for above question I wrote these joins by myself. I had to add eager_load to make it work and ended up with follwoing query:</p>  <pre><code>@comments = Comment   .where('comments.movie_id = ? AND comments.upcomment_id IS NULL', params[:movie])    .joins('LEFT OUTER JOIN "comments" "replies_comments" ON "replies_comments"."upcomment_id" = "comments"."id"')   .joins('LEFT OUTER JOIN "users" "users_replies_comments" ON "users_replies_comments"."id" = "replies_comments"."user_id"')   .joins('LEFT OUTER JOIN "ratings" "ratings_users_replies_comments" ON "ratings_users_replies_comments"."user_id" = "users_replies_comm    ents.id" AND "ratings_users_replies_comments"."movie_id" = "comments"."movie_id"')   .joins('LEFT OUTER JOIN "users" "users_comments" ON "users_comments"."id" = "comments"."user_id"')   .joins('LEFT OUTER JOIN "ratings" "ratings_users_comments" ON "ratings_users_comments"."user_id" = "users_comments"."id" AND "ratings_    users_comments"."movie_id" = "comments"."movie_id"')   .eager_load([:replies =&gt; { :user =&gt; :ratings }, :user =&gt; :ratings]) </code></pre>  <p>It seems to work but I think it may be performance killer. So my last idea  was to load all comments with authors/replies and iterate over it, gather all authors ids and make additional query with "IN(id1,id2,...)". Then pass it to the view as a separate variable. Something like this:</p>  <pre><code> ids = @comments.map { |c| c.user.id }  @comments.each { |c| c.replies.map { |r| ids.push r.user.id } }  ids.uniq!   @ratings = Rating    .where('movie_id = ?', params[:movie])    .where('user_id IN(?)', ids) </code></pre>  <p>Or mayby I shouldn't simply do anything and make Rails to lazy load ratings when they will be needed? What do you think? </p>