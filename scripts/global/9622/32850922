<p>I'm storing a user's profile fields in a separate table, and want to look up a user by email address (for password reset). Trying to determine the best approach, and ran into this unexpected behaviour inconsistency.</p>  <h2>Schema</h2>  <pre><code>create_table(:users) do   String        :username,                  primary_key: true   ... end  create_table(:user_fields) do   primary_key   :id   foreign_key   :user_id, :users, type: String, null: false   String        :label, null: false   String        :value, null: false end </code></pre>  <h2>Console Session</h2>  <p>This version works (look up field, eager load it's associated user, call .all, take the first one):</p>  <pre><code>irb(main):005:0&gt; a = UserField.where(label: 'email', value: 'testuser@test.com').eager(:user).all[0] I, [2015-09-29T17:54:06.273263 #147]  INFO -- : (0.000176s) SELECT * FROM `user_fields` WHERE ((`label` = 'email') AND (`value` = 'testuser@test.com')) I, [2015-09-29T17:54:06.273555 #147]  INFO -- : (0.000109s) SELECT * FROM `users` WHERE (`users`.`username` IN ('testuser')) =&gt; #&lt;UserField @values={:id=&gt;2, :user_id=&gt;"testuser", :label=&gt;"email", :value=&gt;"testuser@test.com"}&gt; irb(main):006:0&gt; a.user =&gt; #&lt;User @values={:username=&gt;"testuser"}&gt; </code></pre>  <p>You can see both queries (field and user) are kicked off together, and when you try to access a.user, the data's already loaded.</p>  <p>But when I try calling .first in place of .all:</p>  <pre><code>irb(main):007:0&gt; b = UserField.where(label: 'email', value: 'testuser@test.com').eager(:user).first I, [2015-09-29T17:54:25.832064 #147]  INFO -- : (0.000197s) SELECT * FROM `user_fields` WHERE ((`label` = 'email') AND (`value` = 'testuser@test.com')) LIMIT 1 =&gt; #&lt;UserField @values={:id=&gt;2, :user_id=&gt;"testuser", :label=&gt;"email", :value=&gt;"testuser@test.com"}&gt; irb(main):008:0&gt; b.user I, [2015-09-29T17:54:27.887718 #147]  INFO -- : (0.000172s) SELECT * FROM `users` WHERE (`username` = 'testuser') LIMIT 1 =&gt; #&lt;User @values={:username=&gt;"testuser"}&gt; </code></pre>  <p>The eager load fails -- it doesn't kick off the second query for the user object until you try to reference it with b.user.</p>  <p>What am I failing to understand about the sequel gem API here? And what's the best way to load a model instance based on the attributes of it's associated models?  (find user by email address)</p>