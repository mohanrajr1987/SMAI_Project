<p>Everywhere I've looked for answers to this question, I see people making one small char * array of size like two and hardcoding in paths for execv. What I need to do is to take a string of parameters with the path as the first set of characters, tokenize them, and then put them in an array of char *s that execv will accept. </p>  <p>here is my tokenization function</p>  <pre><code>char ** stringToVectorToCharArray(string inputString) { stringstream ss(inputString); cout &lt;&lt; "\n inputString is: " &lt;&lt; inputString &lt;&lt;"\n"; vector&lt;string&gt; tokens; tokens.clear();  while(ss &gt;&gt; inputString) {     tokens.push_back(inputString);     }   int size = tokens.size();        char **args = new char*[size + 1];  int i = 0; for(; i &lt; size; i++)     args[i] = const_cast&lt;char *&gt;(tokens.at(i).c_str());  args[i + 1] = (char *) 0;  return args; } </code></pre>  <p>And this is called from </p>  <pre><code> char **args = stringToVectorToCharArray(inputString);   execv(executeChar, args); </code></pre>  <p>Within the Child section of my fork() if-else statements for flow control. I get a bad_alloc error, but I'm not sure which of my allocation statements are right, if any are for that matter. I know the return has to be in the form </p>  <pre><code> char *const argv[] </code></pre>  <p>But I'm not sure how to set that up.</p>