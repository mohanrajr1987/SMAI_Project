<p>I am a newbie in the application of the product InstallShield. In our company we have following InstallShield artifacts to deploy and update our legacy financial application.</p>  <ul> <li>Master Setup named <code>Master.msi</code></li> <li>Patch 1 named <code>Patch1.msp</code></li> <li>Patch 2 named <code>Patch2.msp</code></li> </ul>  <p>The Master Setup contains the .NET assembly Foo.dll with the Assembly Version 1.0.0.0, which is successfully installed by the Master Setup in the Global Assembly Cache (GAC). </p>  <p>In Patch 1 we deliver a new version of Foo.dll with the Assembly File Version 1.0.1.0. The Assembly Version is still 1.0.0.0. Also this assembly is successfully installed by Patch 1.</p>  <p>So far so good. Patch 2 doesn't contain changes in Foo.dll and when we install Patch 2 we got the error:</p>  <ul> <li><code>PATCH SEQUENCER ERROR: failed to retrieve the upgrade code "X" transform in "C:\Patch2.msp" patch takes the product to! (1: 2253 2:  3: MsiPatchOldAssemblyName)</code></li> </ul>  <p>The <a href="https://msdn.microsoft.com/en-us/library/aa372835%28v=vs.85%29.aspx" rel="nofollow">Windows Installer Error 2253</a> says:</p>  <blockquote>   <p>Database: <code>[2]</code> Transform: Cannot delete table that does not exist. Table: <code>[3]</code>.</p> </blockquote>  <p>I am not really sure but I think that the above placeholder <code>[3]</code> in the Windows Installer Error corresponds to the table <code>MsiPatchOldAssemblyName</code> and the placeholder <code>[2]</code> to any database within Patch 2. It is a bit mysterious that the Windows Installer Error nothing knows about this table.</p>  <p>Anyway according to the <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa372360%28v=vs.85%29.aspx" rel="nofollow">Windows Installer Best Practices</a> article the recommended method for updating an assembly is as follow.</p>  <blockquote>   <p>The recommended method for updating an assembly is to change the strong name of the assembly in the MsiAssemblyName table. The new assembly version can be provided by a new component or by the same component that provides the old version.</p>      <p>If your update changes the strong name of the assembly, the MsiPatchOldAssemblyFile table and MsiPatchOldAssemblyName table are required if the patch package does not have a MsiPatchSequence table. The MsiPatchOldAssemblyFile table and MsiPatchOldAssemblyName table are not required if the patch package has patch sequencing information in a MsiPatchSequence table.</p> </blockquote>  <p>I recognized that the tables <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa370062%28v=vs.85%29.aspx" rel="nofollow">MsiAssemblyName</a>, <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa370346%28v=vs.85%29.aspx" rel="nofollow">MsiPatchOldAssemblyName</a> and <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa370345%28v=vs.85%29.aspx" rel="nofollow">MsiPatchOldAssemblyFile</a> were not built in Patch 2. So I started to fill these tables according to the documentation. Also I verified that we don't use the table <code>MsiPatchSequence</code> even in the master setup nor in Patch 1 and 2. In the table MsiAssemblyName I inserted the row which contain the Assembly Version 1.0.0.0 of foo.dll such as the properties name, publicKeyToken and language. </p>  <p>After that I assert that according to the Build Log of Patch 2, the tables MsiPatchOldAssemblyName and MsiPatchOldAssemblyFile are not built. However the table MsiAssemblyName is built successfully. First I thought that the InstallShield Property <a href="http://helpnet.installshield.com/installshield18helplib/IHelpPatchGAC.htm" rel="nofollow">Generate MsiPatchOldAssembly tables</a> is set to <code>No</code> but I verified that it is set to <code>Yes</code>.</p>  <p>Last but not least at the end of the <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa372360%28v=vs.85%29.aspx" rel="nofollow">Windows Installer Best Practices</a> article there is following recommendation for updating an assembly in the global assembly cache.</p>  <blockquote>   <p>An in-place update overwrites the copy of a .NET Framework Assembly in the global assembly cache. This type of assembly update does not change the strong name of the assembly. Only the value in the FileVersion field of the MsiAssemblyName table is changed. The in-place update of a .NET Framework Assembly requires .NET Framework 1.1 SP1 or greater.</p> </blockquote>  <p>Unfortunately I found no way how to configure the <code>type of assembly update</code> to <code>in-place</code> explicitly in the InstallShield-Project of Patch 2 . The only thing I see is to add the field <code>FileVersion</code> in the MsiAssemblyName Table. After I added this field with value <code>1.0.1.0</code> the Build-Log tells me still that the tables <code>MsiPatchOldAssemblyName</code> and <code>MsiPatchOldAssemblyFile</code> not generated.</p>  <p>My question is, why are the tables <code>MsiPatchOldAssemblyName</code> and <code>MsiPatchOldAssemblyFile</code> not generated? Does anyone see a fundamental failure in my explanations?</p>  <p>Thanks very much for your help!</p>