<p>As a learning exercise for Akka FSM, I modeled a simplified order processing flow at a coffee shop. Attached is the state transition diagram. However, one of the test cases I wrote times out and I don't understand why.</p>  <p>FSM (case classes not shown for brevity):</p>  <pre><code>class OrderSystem extends Actor with ActorLogging with LoggingFSM[State, Data] {   startWith(OrderPending, Data(OrderPending, PaymentPending))    when(OrderPending) {     case Event(BaristaIsBusy, _) =&gt; stay     case Event(BaristaIsAvailable(_, PaymentPending), _) =&gt; goto(OrderPlaced) using Data(stateName, PaymentPending)     case Event(b: BaristaIsAvailable, _) =&gt; goto(OrderReady)   }    val waiting = Data(OrderPlaced, PaymentAccepted)    when(OrderPlaced) {     case Event(b: BaristaIsAvailable, `waiting`) =&gt; println("1"); goto(OrderReady)     case Event(b: BaristaIsBusy, `waiting`) =&gt; println("2"); goto(OrderPending) using `waiting`     case Event(_, Data(_, PaymentDeclined)) =&gt; println("3"); goto(OrderClosed)     case Event(_, Data(_, PaymentPending)) =&gt; println("4"); stay   }    when(OrderReady) {     case Event(HappyWithOrder, _) =&gt; goto(OrderClosed)     case Event(NotHappyWithOrder, _) =&gt; goto(OrderPending) using Data(stateName, PaymentAccepted)   }    when(OrderClosed) {     case _ =&gt; stay   }    whenUnhandled {     case Event(e, s) =&gt; {       // state name is available as 'stateName'       log.warning("Received unhandled request {} in state {}/{}", e, stateName, s)       stay     }   }    // previous state data is available as 'stateData' and next state data as 'nextStateData'   // not necessary as LoggingFSM (if configured) will take care of logging   onTransition {     case _ -&gt; nextState =&gt; log.info("Entering state: {} with payment activity: {} from state: {} with payment activity: {}.",       nextState, stateData.paymentActivity, nextStateData.fromState, nextStateData.paymentActivity)   }    initialize() } </code></pre>  <p>Failing test:</p>  <pre><code>it should "stay in OrderPlaced state as long as customer has not paid" in {     val orderSystem = system.actorOf(Props[OrderSystem])     orderSystem ! BaristaIsAvailable(OrderPending, PaymentPending)      orderSystem ! SubscribeTransitionCallBack(testActor)      expectMsg(CurrentState(orderSystem, OrderPlaced))      orderSystem ! BaristaIsAvailable(OrderPlaced, PaymentPending)      expectMsg(CurrentState(orderSystem, OrderPlaced)) } </code></pre>  <p>Logs:</p>  <pre><code>2015-09-22 23:29:15.236 [order-system-akka.actor.default-dispatcher-2] [DEBUG] n.a.s.o.OrderSystem - processing Event(BaristaIsAvailable(OrderPending,PaymentPending),Data(OrderPending,PaymentPending)) from Actor[akka://order-system/system/testActor1#-2143558060] 2015-09-22 23:29:15.238 [order-system-akka.actor.default-dispatcher-2] [INFO ] n.a.s.o.OrderSystem - Entering state: OrderPlaced with payment activity: PaymentPending from state: OrderPending with payment activity: PaymentPending. 2015-09-22 23:29:15.239 [order-system-akka.actor.default-dispatcher-2] [DEBUG] n.a.s.o.OrderSystem - transition OrderPending -&gt; OrderPlaced 4 2015-09-22 23:29:15.242 [order-system-akka.actor.default-dispatcher-2] [DEBUG] n.a.s.o.OrderSystem - processing Event(BaristaIsAvailable(OrderPlaced,PaymentPending),Data(OrderPending,PaymentPending)) from Actor[akka://order-system/system/testActor1#-2143558060] [31m- should stay in OrderPlaced state as long as customer has not paid *** FAILED ***[0m [31m  java.lang.AssertionError: assertion failed: timeout (3 seconds) </code></pre>  <p><a href="http://i.stack.imgur.com/9Um8o.png" rel="nofollow"><img src="http://i.stack.imgur.com/9Um8o.png" alt="enter image description here"></a></p>