<p>I'm trying to override the SQLAlchemy <code>DATETIME2</code> type (from MS SQL Server) to discard extra digits of subsecond precision if necessary to coerce to a native Python datetime type, as described in <A HREF="http://docs.sqlalchemy.org/en/rel_1_0/core/custom_types.html#replacing-the-bind-result-processing-of-existing-types" rel="nofollow">Replacing the Bind Result Processing of Existing Types</A> section of the docs, like so:</p>  <pre><code>import re import sqlalchemy.dialects as sa_dialects  class TruncatingPrecisionDATETIME2(sa_dialects.mssql.base.DATETIME2):     __visit_name__ = 'DATETIME2'     _reg = re.compile(r"(\d+):(\d+):(\d+)(?:\.(\d{0,6})\d*)?")      def process_result_value(self, value, dialect):         if isinstance(value, util.string_types):             return datetime.time(*[                 int(x or 0)                 for x in self._reg.match(value).groups()])         else:             return value      def adapt(self, impltype):         return TruncatingPrecisionDATETIME2() </code></pre>  <p>However, when I call <code>meta.reflect()</code>, and inspect the type of one a column of type <code>DATETIME2</code> in the database, it's an instance of <code>sqlalchemy.dialects.mssql.base.DATETIME2</code> rather than <code>TruncatingPrecisionDATETIME2</code>. What do I need to do to change this globally for all DATETIME2 instances?</p>