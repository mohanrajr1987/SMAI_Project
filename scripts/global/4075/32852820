<p>I have two classes in SQLAlchemy such as:</p>  <pre><code>class Local(Base):     id = Column(Unicode, primary_key=True)     denom = Column(String)     parent = Column(String)     children = relationship("Local", backref=backref('parent', remote_side=[id]))      @hybrid_property     def anp(self):         if self.denom.startswith(u"ANP_"):             return self.denom[:6]         elif self.parent:             return self.parent.anp         return None   class Equipament(Base):     id = Column(Unicode, primary_key=True)     local = relationship("Local", backref=backref('eqps', order_by=id))      @hybrid_property     def anp(self):         if self.local is None:             return None         else:             return self.local.anp </code></pre>  <p>This works when checking for the <code>anp</code> property such as when <code>equipment_instance.anp</code>, but how do I build a proper query when trying to list all available equipments which meet a certain criteria for the property?</p>  <p>For example, I may try:</p>  <pre><code>&gt;&gt;&gt; loc = db.session.query(db.Local).first() &gt;&gt;&gt; loc.anp u'ANP_MF' </code></pre>  <p>But I can't do:</p>  <pre><code>&gt;&gt;&gt; loc = db.session.query(db.Local).filter(db.Local.anp==u'ANP_MF').first() Traceback (most recent call last): ... TypeError: Boolean value of this clause is not defined </code></pre>  <p>Alternatively, I might use:</p>  <pre><code>&gt;&gt;&gt; db.session.query(db.Local).filter(db.Local.denom.like(u"ANP_%")).first() </code></pre>  <p>But then I'd have to recurse into its children and join results manually.</p>  <p>So, is it possible to fix this so a simpler query might be used? I'm using SQLAlchemy 1.0.5 with SQLite.</p>