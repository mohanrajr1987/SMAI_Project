<p>So, I have a model that is something like:</p>  <pre><code>class Foo(model):     __tablename__ = "foo"     id = Column(Integer, primary_key=True)     data = relationship(         "FooData",         cascade="all, delete-orphan",         backref="foo",         lazy="dynamic",         order_by="desc(FooData.timestamp)"     )      @property     def first_item(self):         # the problem is here:         return self.data.order_by(asc("timestamp")).first()      @property     def latest_item(self):         return self.data.first()   class FooData(Model):     __tablename__ = "foo_data"     foo_id = Column(Integer, ForeignKey("foo.id"), primary_key=True)     timestamp = Column(DateTime, primary_key=True)     actual_data = Column(Float, nullable=False) </code></pre>  <p>So, the problem is with the <code>first_item</code> method there: when it is defined as above, the SQL looks like this:</p>  <pre><code>SELECT foo_data.timestamp AS foo_data_timestamp, foo_data.actual_data AS foo_data_actual_data, foo_data.foo_id AS foo_data_foo_id  FROM foo_data  WHERE :param_1 = foo_data.foo_id ORDER BY foo_data.timestamp DESC, foo_data.timestamp ASC --                                                                 ^^^^^^^^^^^^^^^^^^^^^^ </code></pre>  <p>Obviously, the <code>order_by</code> specified in the query is being appended to the one specified in the relationship definition, instead of replacing it; is there a way for a query to override the original <code>order_by</code>? I know I could specify a separate query directly on the <code>FooData</code> class, but I would like to avoid that if possible.</p>