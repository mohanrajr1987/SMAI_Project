<p>I've been tinkering with this for hours now and I just can't seem to find a way to make this work. It seems like it should be simple, and I'm sure it is, but I'm stumpled.</p>  <p>I have one module called 'server.py' that handles all of the routing with bottle, this is the main point of execution. An example of a request handler is as such, I'm generalizing as my codebase is rather hefty and most of it is irrelevant to the question:</p>  <p><strong>server.py</strong></p>  <pre><code>@route('home') def home():     page = Page('home') # A template manager I made     objects = db.get_objects(10) # This is what I can't get to work      return page.render(objects=objects) </code></pre>  <p>I would like the code to be that simple from the server side and all database interaction done in db.py using helper functions, however I would like to use the returned objects from queries which are still attached to the session and so it must be closed outside of db.get_objects. A session should be created and closed on each request. I could do that manually from home() like so:</p>  <p><strong>server.py</strong></p>  <pre><code>@route('home') def home():     session = Session()     page = Page('home') # A jinja template manager I made     objects = db.get_objects(session, 10)      document = page.render(objects=objects)     session.close()      return document </code></pre>  <p>I don't mind opening and closing the session every time, that seems logical and unavoidable, whether directly or through another object/function, but I do not want to have to pass that session around (manually) to every db helper function, that just seems messy to me. </p>  <p>I feel this problem can be solved with some OOP, a session manager class or something that is shared between the two, but I cannot figure out how to design or share it. The best idea I have come up with so far is to wrap my entire db.py in a class and have the constructor create the session. That would work for the helper functions, but I also have a bunch of other objects in db.py that also need access to the session such as the following, this is an actual object from my codebase:</p>  <p><strong>db.py</strong></p>  <pre><code>class Sticker(_Base):     __tablename__ = 'sticker'     sticker_id = Column(Integer, ForeignKey('product.product_id'), primary_key=True)     sticker_name = Column(String)     svg_location = Column(String, unique=True)     svg_width = Column(Numeric, nullable=False)     svg_height = Column(Numeric, nullable=False)     shaped = Column(Boolean) # Whether the cutpath countors the image      @reconstructor     def _get_related_properties(self, init=False):         '''Fetches and fills out all properties that are created by the            __init__ constructor that are not in the orm constructor.'''         if not init:             session = Session()             self._product = session.query(Product).filter(Product.product_id == self.sticker_id).first()             category_id = session.query(ProductCategory).filter(ProductCategory.product_id == self.sticker_id).first()             session.close()          self.sticker_id = self._product.product_id         self.product_type = self._product.product_type         self.date_added = self._product.date_added         self.sticker_name = self._product.product_name      def _get_svg_size(self):         """Returns a tuple of the width, height of an svg"""         # Currently only works with pixels I think. I know it fails when saved as points.         # May want to improve this for future versions.         # May also consider moving this function to an external util file or something.         # Possible units: (~"em" | ~"ex" | ~"px" | ~"in" | ~"cm" | ~"mm" | ~"pt" | ~"pc")         # Also may use viewbox attribute to determine aspect ratio and set sizes algorithmically.         import xml.etree.ElementTree as ET         import decimal         # Set decimal precision         decimal.getcontext().prec=7         tree = ET.parse(self.svg_location)         root = tree.getroot()          width = None         height = None          width_attr = root.get('width')         height_attr = root.get('height')          # Get measurement units         units = width_attr[-2:]         if units[-1] == '%':             units = '%'         elif not units.isalpha():             # if units not set assume px             width = decimal.Decimal(width_attr)             height = decimal.Decimal(height_attr)             units = 'px'          if units != 'px':             width = decimal.Decimal(width_attr[:-2])             height = decimal.Decimal(height_attr[:-2])             # Convert to px if not already             # Currently only supports in, cm, mm, and pt             # Assumes DPI is 72             MMPI = 2.834645669291339             DPI = 72              if units == 'in':                 width *= DPI                 height *= DPI             elif units == 'pt':                 width /= DPI                 height /= DPI             elif units == 'mm':                 width *= MMPI                 height *= MMPI             elif units == 'cm':                 width *= MMPI * 10                 height *= MMPI * 10             else:                 raise ValueError('Unsupported svg size unit:',units )           return width, height      def __init__(self, svg_location, name='', category='', metatags=[], sticker_sizes=None, active=False):         # If no name given use filename         if not name:             from os.path import basename             name = basename(svg_location).rstrip('.svg')         # Create parent product and save to db to generate primary key/product id         session = Session()         self._product = Product(product_name = name, product_type = 'sticker', active = active)         session.add(self._product)         session.commit()         # TODO: Handle category and metatags         # Categories should probably be created explicitly by the admin, and so should exist         # at the time of sticker creation. Metatags are more numerous and created on the fly         # and so should be created automatically by the sticker constructor.          # TODO: Expand the sticker table to reference these values from the product table maybe?         self.sticker_id = self._product.product_id         self.svg_location = svg_location         self.svg_width, self.svg_height = self._get_svg_size()         self._get_related_properties(init=True)         # Add to the Database         session.add(self)         session.commit()          # Get sticker sizes         self.sticker_sizes = []         # Check if a size tuple was added, default is empty         if sticker_sizes:             for size in sticker_sizes:                 sticker_size = StickerSize(self.sticker_id, size[0], size[1])                 session.add(sticker_size)                 self.sticker_sizes.append(StickerSize)          session.commit()         session.close() </code></pre>  <p>Most of that is unimportant, but as you can see in many cases I need to query the database from within my ORM mapped objects so they too need access to the session. So a simple question, I hope, how can I do that? Can it even be done or am I approaching this in the wrong way? If I am approaching it wrong how so, and could you offer a design pattern that would work?</p>