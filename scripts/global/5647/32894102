<p>I'm beginner C programmer and I have one not very big project in C. I written simple perl script for building it with different options. And my project wasn't split into object files, I just included .c into each other and built all with one compiler call.</p>  <p>But my project was growing and compilation time reached 1s+ (I like script-style debuging with lot of change little bit &amp;&amp; run steps), so I decided to split my project into object files, link them together and use gnu make to check if source have changed, as everyone does.</p>  <p>I expected that this will make building faster. BUT NO! make is so slow, it made compilation even slower several times and I even havenâ€™t split my project completely (one .o per .c file) yet, just in about 5 object files (project has about 20 .c files) !  It even slower or about same time for make to check if files where changed than to rebuild entire project when .c files just included into each other!</p>  <p>So now I just using enhanced version of my perl script "build system". I split project into several big parts and rebuilding only one of them (other are 3rd party libs mostly) and it works very fast. Also it's more flexible and easy to manage for me than makefiles, because I have lot of build option including crosscompiling. But this is reinventing the bicycle.</p>  <p>Having all c files included into each other isn't best practice, yes? What should I use?</p>  <p>I wanted to name this question "Why make is so slow?" but I know why - launching a shell for every code line is heavy task. Maybe for really big projects it works ok, but for me it has too much overhead.</p>  <p>So what are best practices and tools for managing C projects? What building tools are fast and flexible? I don't want make-like crap forking on every move, making build slower than naive include-all-into-one-file even if using several cores</p>