<p>After I run DataTable.load(SqlDataReader), the DataTable seems to be empty, but the DataReader contains results (can be seen while debugging).</p>  <p>Can anyone help me with this one please? I can't seem to find any solution for this problem, nor can't I find a mistake in my algorithm.. I found some solutions for using a DataAdapter &amp; Fill(), but I'm just curious about this 'problem'. My code:</p>  <pre><code>DataTable DeviceProperties = new DataTable();         try         {             string query = "SELECT PropertyID, PropertyName from DeviceProperties WHERE DeviceID = @DeviceID;";             using (SqlCommand cmdSelectDeviceProperties = new SqlCommand(query, connectionDBTest))             {                 cmdSelectDeviceProperties.Parameters.Add("@DeviceID", SqlDbType.BigInt).Value = deviceID;                 using (SqlDataReader rdrSelectDeviceProperties = cmdSelectDeviceProperties.ExecuteReader())                 {                     if (rdrSelectDeviceProperties.HasRows)                         DeviceProperties.Load(rdrSelectDeviceProperties);                     else                         Console.WriteLine("No Device Properties found..");                 }             }         }         catch (Exception ex)         {             Console.WriteLine("Error getDeviceProperties: " + ex);         }         return DeviceProperties; </code></pre>  <p>FYI: the rdrSelectDeviceProperties.HasRows passes every time, so the reader certainly contains some value.. The correct results can be found in the rdrSelectDeviceProperties, during debugging.. But the DeviceProperties data table remains empty..</p>  <p><strong>EXACT PROBLEM:</strong> the data table seemed empty while debugging, because the hover over showed: '{ }'.  The rest of the code, depending on the data table, responded as the data table was empty. <strong>SOLUTION:</strong> When you press the magnifying glass and you get the representation of the data in the data table. My mistake was in the rest of the code (comparing the data in the data table with string, without using '.ToString()').</p>  <p>Learn from my mistakes..</p>