<p>At the moment, this is how my paintComponent looks:</p>  <pre><code>    @Override     public void paintComponent(Graphics g) {     super.paintComponent(g);     System.out.println(choice);     if(choice == 1)     {            g.drawImage(img, 0, 0, getWidth(), getHeight(), this);          System.out.println("\nImgWidth: " + img.getWidth()                 + "\nFrameWidth: " + getWidth()                 + "\nImgHeight: " + img.getHeight()                 + "\nFrameHeight: " + getHeight()         );     }     else if (choice == 2)     {         scale = 3.0;         while(currScale &lt; scale){             currScale += .1;             System.out.println(currScale + "-" + scale);              Graphics2D g2 = (Graphics2D)g;             g2.setRenderingHint(RenderingHints.KEY_INTERPOLATION,                             RenderingHints.VALUE_INTERPOLATION_BICUBIC);             int w = getWidth();              int h = getHeight();              int imageWidth = img.getWidth();              int imageHeight = img.getHeight();              double x = (w - currScale * imageWidth)/2;             double y = (h - currScale * imageHeight)/2;              AffineTransform at = AffineTransform.getTranslateInstance(x,y);             at.scale(currScale, currScale);             g2.drawRenderedImage(img, at);              try {                 Thread.sleep(100);             } catch (InterruptedException ex) {}          }     }  } </code></pre>  <p>The code works when I forget about looping and just use a fixed value for scale, but I want it to be animated instead of the immediate zoom. I've tried using a Timer alternative, but nothing shows up and the image just disappears the moment paintComponent is triggered and choice is 2. </p>  <p>With the sleep method, the scaled image shows up, but only till after the loop. Before and during the loop, it still shows the original full image. It runs like the whole point of the loop (to animate) was pointless as the change only happens when it exits . </p>  <p>Any help is appreciated.</p>  <p>Also if any of you wondered how I messed up with the timer, this was my code for it (it removed the original image and didn't display anything at all, but timer does terminate)</p>  <pre><code>   else     {         scale = 3.0;             timer = new Timer(500, new ActionListener() {                 @Override                 public void actionPerformed(ActionEvent e) {          if(currScale &lt; scale){             System.out.println(currScale + "-" + scale);             currScale += .1;             Graphics2D g2 = (Graphics2D)g;             g2.setRenderingHint(RenderingHints.KEY_INTERPOLATION,                             RenderingHints.VALUE_INTERPOLATION_BICUBIC);         int w = getWidth();         int h = getHeight();         int imageWidth = img.getWidth();         int imageHeight = img.getHeight();         double x = (w - currScale * imageWidth)/2;         double y = (h - currScale * imageHeight)/2;         AffineTransform at = AffineTransform.getTranslateInstance(x,y);         at.scale(currScale, currScale);         g2.drawRenderedImage(img, at);         }                 }               });           if(currScale &gt; scale)         {              timer.stop();         }          else          {              timer.setRepeats(true);              timer.setCoalesce(true);              timer.start();            }     } </code></pre>  <p>This is the snippet of my class attributes:</p>  <pre><code> class loadImage extends JPanel {  private int choice;  double scale;  double currScale = 1.0;  BufferedImage img;  //Timer timer; (if using the timer) </code></pre>  <p><strong>FIX:</strong> To add some context, I'm using Netbean's GUI-Builder. I choose to go the way of manually typecasting the panel to the loadImage class everytime I need to use loadImage's methods. </p>  <pre><code>    public void ZoomIn() {     double scale = 3.0;     double scaleAddOn = 0.1;     Timer timer;     timer = new Timer(40, new ActionListener() {         @Override         public void actionPerformed(ActionEvent e)          {             double currScale;             currScale = ((loadImage)imageArea).getCurrScale();             if(currScale &lt; scale)             {                 ((loadImage)imageArea).setCurrScale(currScale + scaleAddOn);             }         }     });      if(((loadImage)imageArea).getCurrScale() &gt; scale)     {          timer.stop();     }      else      {          timer.setRepeats(true);          timer.setCoalesce(true);          timer.start();        } }     </code></pre>  <p>Thanks again for the help. Hopefully this page will be of use to others as well.</p>