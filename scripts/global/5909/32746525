<p>I am developing multi-threading game with a network client class which contains several timers to perform connectivity-related checks (these are <a href="https://msdn.microsoft.com/en-us/library/system.timers.timer(v=vs.110).aspx" rel="nofollow">System.Timers.Timer</a>):</p>  <pre><code>private readonly object _LockDisposing = new object(); // Important later on. private Timer _TimerPing; private Timer _TimerConnectionLost; </code></pre>  <p>This class implements <code>IDisposable</code> and is properly disposed whenever instanced in another class and not needed anymore:</p>  <pre><code>~ClassName() {     Dispose(false); }  public void Dispose() {     Dispose(true);     GC.SuppressFinalize(this); }  private void Dispose(bool disposing) {     if (!_Disposed)     {         _Disposed = true;          if (disposing)             lock (_LockDisposing)             {                 // Dispose other disposable stuff.                  if (_TimerPing != null)                 {                     _TimerPing.Dispose();                     _TimerPing = null;                 }                  if (_TimerConnectionLost != null)                 {                     _TimerConnectionLost.Dispose();                     _TimerConnectionLost = null;                 }             }     } } </code></pre>  <p>This class is instanced maybe 800 times and each instance lives in its own thread. Sometimes, when the connection breaks for any reason (I don't care), I dispose of the whole class and instance another one to replace it.</p>  <p>However, sometimes I get the following <a href="https://msdn.microsoft.com/en-us/library/system.objectdisposedexception(v=vs.110).aspx" rel="nofollow">System.ObjectDisposedException</a> exception:</p>  <pre><code>System.ObjectDisposedException was unhandled by user code   HResult=-2146232798   Message=Cannot access a disposed object.   ObjectName=""   Source=mscorlib   StackTrace:        at System.Threading.TimerQueueTimer.Change(UInt32 dueTime, UInt32 period)        at System.Timers.Timer.set_Enabled(Boolean value)        at {UnimportantClassName}.TimerPing_Elapsed(Object sender, ElapsedEventArgs e) in {UnimportantFilePath}:line 358        at System.Timers.Timer.MyTimerCallback(Object state)   InnerException: </code></pre>  <p>This is the event when <code>_TimerPing</code> elapses (<code>AutoReset</code> is enabled) which throws the exception:</p>  <pre><code>private void TimerPing_Elapsed(object sender, ElapsedEventArgs e) {     // Do something unrelated to timers.      lock (_LockDisposing)     {         if (_Disposed)             return;          _TimerPing.Start();          // The line below throws the exception.         if (_TimerConnectionLost != null &amp;&amp; !_TimerConnectionLost.Enabled)         // The line above throws the exception.             _TimerConnectionLost.Start();     } } </code></pre>  <p><code>_TimerConnectionLost</code> is created in the constructor and is not disposed at any other point.</p>  <p><strong>Why is the exception being thrown when it's clear (at least to me) that, due to locking, the program cannot get to this line of code without timer being set to <code>null</code> or being completely alive?</strong></p>  <p><strong>Why is <code>System.Timers.Timer.set_Enabled</code> being called (check the stack trace) when I'm only checking for the value of <code>Enabled</code> property?</strong></p>