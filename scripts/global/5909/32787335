<p>I have found a couple of answers for this question, but they are not very helpful. I am trying to create an app that has a running stopwatch timer in each cell of a tableview, using standard subtitle cells. The timer name is displayed in the textfield and the running timer is displayed in the subtitle. Each cell needs to display a different time format (seconds, minutes, hours, days, months, or years). The calculation of the time elapsed since the timer was started is done each time the timer expires, and the result is put into the cell's subtitle. The code works fine as long as only one timer is used. However, if a second timer is started, the running timer in the first cell is reset to zero. I believe this is because I am saving a pointer to the cell dequeued at cellForRowAtIndexPath: and using this pointer to populate the cell when the timer expires. This probably violates MVC. However, as my view controller delegate implements the protocol, I have to return a cell when the tableview requests it, and I can't do that until the timer expires so that I can update the subtitle in the cell. I don't see any way to do this without saving a pointer to the cell containing the output of the running timer. I am new to iOS development but I have written this project both programmatically and recently using a storyboard and get the same results. The code for the view controller is below. Note that the item.timerType is set from another view controller that is segued in the storyboard with the data passed back to the main view controller. That part works ok.</p>  <p>Thanks for any help!</p>  <pre><code>    // //  timerItem.h //  LifeLogger // //  Created by Nelson Capes on 9/24/15. //  Copyright © 2015 Nelson Capes. All rights reserved. //  #import &lt;Foundation/Foundation.h&gt; #import &lt;UIKit/UIKit.h&gt; @interface timerItem : NSObject  @property NSString *timerName; @property NSTimeInterval interval; @property NSString *timerOutput; @property NSDate *startTime; @property NSTimer *timer; @property NSInteger timerType; @property UITableViewCell *cell; @end      // //  NRCTimerListTableViewController.h //  LifeLogger // //  Created by Nelson Capes on 9/21/15. //  Copyright © 2015 Nelson Capes. All rights reserved. //  #import &lt;UIKit/UIKit.h&gt; #import "AddTimerItemViewController.h" @interface NRCTimerListTableViewController : UITableViewController &lt;UITabBarDelegate, UITableViewDataSource&gt; -(IBAction)listToAdd:(UIStoryboardSegue *)segue; @property NSTimer *timer; @property(strong) timerItem *item; @property NSDate *startTime;    @end      // //  NRCTimerListTableViewController.m //  LifeLogger // //  Created by Nelson Capes on 9/21/15. //  Copyright © 2015 Nelson Capes. All rights reserved. //  #import "NRCTimerListTableViewController.h" #import "timerItem.h" @interface NRCTimerListTableViewController ()   @property NSMutableArray *items;   @end  @implementation NRCTimerListTableViewController  // control comes here when user hits the Save button in AddTimerItemViewController. //  -(IBAction)listToAdd:(UIStoryboardSegue *)segue{     if(!self.items){         self.items = [[NSMutableArray alloc]init];}     if(self.item != nil)     {     [self.items addObject:self.item];         [self.tableView reloadData];     } } -(void)loadInitialData{     // get a timerItem object to pass onto to subsequent view controllers      // and add it to items array  }  - (void)viewDidLoad {     [super viewDidLoad];     [self loadInitialData];    }  - (void)didReceiveMemoryWarning {     [super didReceiveMemoryWarning];     // Dispose of any resources that can be recreated. }  #pragma mark - Table view data source  - (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView {      return 1; }  - (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section {      return [self.items count];; }   - (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {     UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@"ListPrototypeCell" forIndexPath:indexPath];      // Configure the cell...     // First, get a pointer to the timer item from the items array       switch (self.item.timerType) {         case 0:         {             NSTimeInterval interval = 1;             self.item.interval = interval;         }             break;         case 1:         {             NSTimeInterval interval = 60;             self.item.interval = interval;         }             break;         case 2:         {             NSTimeInterval interval = 3600;             self.item.interval = interval;             break;         }         case 3:         {             NSTimeInterval interval = (3600 * 24);             self.item.interval = interval;             break;         }         case 4:         {             NSTimeInterval interval = (36600 * 24 * 30);             self.item.interval = interval;             break;         }         case 5:         {             NSTimeInterval interval = (3600 * 24 * 365);             self.item.interval = interval;             break;         }         default:             break;     }           self.item.cell = cell;        //  cell.textLabel.text = self.item.timerName;          // set the start time in the item         self.item.startTime = [NSDate date];         NSTimeInterval startInterval = self.item.interval;         self.item.timer = [NSTimer scheduledTimerWithTimeInterval:startInterval target:self selector:@selector(timerCount:) userInfo:self.item repeats:YES];          [[NSRunLoop currentRunLoop] addTimer:self.item.timer forMode:NSRunLoopCommonModes];          // debug ///////////////////////////////////////////////         NSLog(@"Item %@ timer started", self.item.timerName);         ////////////////////////////////////////////////////////         [self.item.timer fire];      // set the textLabel in the cell to the itemName         return cell; }  -(void)timerCount:t     {          NSTimer *timer = t;         timerItem *item = timer.userInfo;         NSLog(@"Item %@ timer fired", item.timerName);         NSTimeInterval endInterval = [item.startTime timeIntervalSinceNow];         endInterval = (-1 * endInterval);          switch (item.timerType) {             case 0:             {                 int time = round(endInterval);                 div_t h = div(time, 3600); //seconds total, divided by 3600 equals                 int hours = h.quot;         // hours, divided by 60 equals                 div_t m = div(h.rem, 60);   // minutes                 int minutes = m.quot;                 int seconds = m.rem;        // and remainder is seconds                 NSString *intervalString = [NSString stringWithFormat:@"%d hours, %d minutes, %d seconds", hours, minutes, seconds];                  NSString *outputString = [intervalString stringByAppendingString:@" ago"];                 item.timerOutput = outputString;              }                 break;             case 1:             {                 int time = round(endInterval);                 div_t h = div(time, 3600);      // seconds total, divided by 3600 equals                 int hours = h.quot;             // hours, divided by 60 equals                 div_t m = div(h.rem, 60);       // minutes                 int minutes = m.quot;                 NSString *intervalString = [NSString stringWithFormat:@"%d hours, %d minutes", hours, minutes];                 NSString *outputString = [intervalString stringByAppendingString:@" ago"];                 item.timerOutput = outputString;             }                 break;             case 2:             {                 int time = round(endInterval);                 div_t h = div(time, 3600); // seconds total, divided by 3600 equals                 int hours = h.quot;        // hours                 NSString *intervalString = [NSString stringWithFormat:@"%d hours", hours];                 NSString *outputString = [intervalString stringByAppendingString:@" ago"];                 item.timerOutput = outputString;             }                 break;             case 3:             {                 int time = round(endInterval);                  div_t h = div(time, 3600); // seconds total, divided by 3600 equals                 int hours = h.quot;        // hours, divided by 24 equals                 div_t d =div(h.rem, 24);   // days                 int days = d.quot;                 NSString *intervalString = [NSString stringWithFormat:@"%d days, %d hours", days, hours];                 NSString *outputString = [intervalString stringByAppendingString:@" ago"];                 item.timerOutput = outputString;             }                 break;             case 4:             {                 int time = round(endInterval);                 div_t h = div(time, 3600); // seconds total, divided by 3600 equals                 __unused int hours = h.quot;        // hours, divided by 24 equals                 div_t d =div(h.rem, 24);   // days                 int days = d.quot;                 div_t y = div(d.rem, 12);// divided by 12 equals months                 int months = y.quot;                 NSString *intervalString = [NSString stringWithFormat:@"%d months, %d days", months, days];                 NSString *outputString = [intervalString stringByAppendingString:@" ago"];                 item.timerOutput = outputString;             }                 break;             case 5:             {                 int time = round(endInterval);                 div_t h = div(time, 3600); // seconds total, divided by 3600 equals                 __unused int hours = h.quot;        // hours, divided by 24 equals                 div_t d =div(h.rem, 24);   // days                 int days = d.quot;                 div_t y = div(d.rem, 365);// divided by 365 equals years                 int years = y.quot;                 NSString *intervalString = [NSString stringWithFormat:@"%d years, %d days", years, days];                 NSString *outputString = [intervalString stringByAppendingString:@" ago"];                 item.timerOutput = outputString;             }                 break;         }         item.cell.textLabel.text = item.timerName;         item.cell.detailTextLabel.text = item.timerOutput;      }     /* // Override to support conditional editing of the table view. - (BOOL)tableView:(UITableView *)tableView canEditRowAtIndexPath:(NSIndexPath *)indexPath {     // Return NO if you do not want the specified item to be editable.     return YES; } */  /* // Override to support editing the table view. - (void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath {     if (editingStyle == UITableViewCellEditingStyleDelete) {         // Delete the row from the data source         [tableView deleteRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationFade];     } else if (editingStyle == UITableViewCellEditingStyleInsert) {         // Create a new instance of the appropriate class, insert it into the array, and add a new row to the table view     }    } */  /* // Override to support rearranging the table view. - (void)tableView:(UITableView *)tableView moveRowAtIndexPath:(NSIndexPath *)fromIndexPath toIndexPath:(NSIndexPath *)toIndexPath { } */  /* // Override to support conditional rearranging of the table view. - (BOOL)tableView:(UITableView *)tableView canMoveRowAtIndexPath:(NSIndexPath *)indexPath {     // Return NO if you do not want the item to be re-orderable.     return YES; } */  #pragma mark - Navigation  // In a storyboard-based application, you will often want to do a little preparation before navigation - (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender {     // Get the new view controller using [segue destinationViewController].     // Pass the selected object to the new view controller.     if([segue.identifier isEqualToString:@"listToAdd"]){         self.item = [[timerItem alloc]init];         AddTimerItemViewController *destViewController = segue.destinationViewController;         destViewController.timerItem = self.item;} } /* #pragma mark - Table view delegate -(void)tableView:(UITableView *)tableView didDeselectRowAtIndexPath:(NSIndexPath *)indexPath{   }  */ @end </code></pre>