<p>My program has 2 activities, SFActivity (which extends a SuperClass) and get's the data from the DB and GameActivity that should get the data from SFActivity with a Launcher class that extends Application. My question would be solved if java could support multiple inheritance,unfortunately for me it doesn't. the order it starts is Launcher ->SFActivity ->GameActivity the problem is that I need the SFActivity alive so I can send and receive db data but I also need the GameActivity to be in front so that the game runs.  SFActivity, does the login, gets some data which is passed to Launcher, I don't know why but it doesn't store anything, launches GameActivity through an intent and from there on the game crashes because of the lack of data.</p>  <h2>Launcher.Java</h2>  <pre><code>public class Launcher extends Application { public ArrayList&lt;String&gt; oppNames = new ArrayList&lt;&gt;(); private static Launcher singleInstance = null; public static Launcher getInstance() {     return singleInstance; } @Override public void onCreate() {     super.onCreate();     singleInstance = this;     SalesforceSDKManager.initNative(getApplicationContext(), new KeyImpl(), SFActivity.class); }  } </code></pre>  <p>Activity.java (GameActivity)</p>  <pre><code>public class Activity extends BaseGameActivity {  public static BoundCamera camera; public static Activity thisActivity; public List&lt;String&gt; ActivityOppObjects = new ArrayList&lt;String&gt;(); ResourcesManager resourcesManager;  ................... public void onCreate(Bundle savedInstanceState) {     super.onCreate(savedInstanceState);     thisActivity = this;     ActivityOppObjects.addAll(l.oppNames);  } ........................ </code></pre>  <h2>SFActivity.java</h2>  <pre><code>public class SFActivity extends SalesforceActivity  {  private static final SFActivity INSTANCE = new SFActivity(); Launcher l = Launcher.getInstance(); public Activity a = Activity.thisActivity; RestClient.AsyncRequestCallback requestCallback =  new RestClient.AsyncRequestCallback() {     @Override     public void onSuccess(RestRequest request, RestResponse result) {         try {            // oppNames.clear();             JSONArray records = result.asJSONObject().getJSONArray("records");             for (int i = 0; i &lt; records.length(); i++) {                // oppNames.add(records.getJSONObject(i).getString("Name"));                l.oppNames.add(records.getJSONObject(i).getString("Name"));                 Debug.d("Test",l.oppNames.get(i).toString());             }             runGame();         }          catch (Exception e) {             onError(e);         }      }      @Override     public void onError(Exception exception) {         Debug.e(exception);     } }; public RestClient client;   @Override protected void onCreate(Bundle savedInstanceState) {     super.onCreate(savedInstanceState); } private void runGame() {      if (l.oppNames != null) {         Intent intent = new Intent(this, Activity.class);         Bundle bundle = new Bundle();         bundle.putStringArrayList(null, l.oppNames);         intent.putExtras(bundle);         startActivity(intent);     }  }  public void onFetchOpp() throws UnsupportedEncodingException {     sendRequest("SELECT Name FROM Opportunity");  }  private void sendRequest(String soql) throws UnsupportedEncodingException {     RestRequest restRequest = RestRequest.getRequestForQuery(getString(R.string.api_version), soql);      client.sendAsync(restRequest, requestCallback);  }  @Override public void onResume(RestClient client) {     this.client = client;      RestClient.ClientInfo ci = this.client.getClientInfo();     Toast.makeText(this, "Hello " + ci.accountName, Toast.LENGTH_LONG).show();     try {         onFetchOpp();     } catch (UnsupportedEncodingException e) {         e.printStackTrace();     } }  } </code></pre>