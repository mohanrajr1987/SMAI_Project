<p>I am writing a Linux  kernel module which redirects a packet to the localhost webserver ,which was originally forwarded through this machine using bridge  . It also redirects to reply to the client . The client is oblivious of the redirection . So there are 2 parts   1. all forwarded packets through bridge  to some webserver outside  are redirected to local webserver .</p>  <ol start="2"> <li>The output of the localhost webserver is channelled to the original client </li> </ol>  <p>I am able to do the second part through nf_hook NF_INET_LOCAL_OUT</p>  <pre><code>unsigned int snoop_hook_reply( unsigned int hooknum, struct sk_buff *skb,     const struct net_device *in, const struct net_device *out,     int(*okfn)( struct sk_buff * ) ) {     int offset, len;     struct ethhdr *ethh;     struct iphdr *iph;     struct tcphdr *tcph;     bool flag = false;     struct net_device *eth1_dev , *lo_dev;      if (!skb) return NF_ACCEPT;     iph = ip_hdr(skb);     if (!iph) return NF_ACCEPT;     skb_set_transport_header(skb, iph-&gt;ihl * 4);     tcph = tcp_hdr(skb);     /* skip lo packets */     if (iph-&gt;saddr == iph-&gt;daddr) return NF_ACCEPT;     if (tcph-&gt;dest == htons(80))             flag=true;     if(flag != true)             return NF_ACCEPT;      // correct the IP checksum     iph-&gt;check = 0;     ip_send_check (iph);      //correct the TCP checksum     offset = skb_transport_offset(skb);     len = skb-&gt;len - offset;     tcph-&gt;check = 0;     if(skb-&gt;len &gt; 60){     tcph-&gt;check  = csum_tcpudp_magic((iph-&gt;saddr), (iph-&gt;daddr), len, IPPROTO_TCP, csum_partial((unsigned char *)tcph,len,0));     }     else{     tcph-&gt;check  = ~csum_tcpudp_magic((iph-&gt;saddr), (iph-&gt;daddr), len, IPPROTO_TCP, 0);     }      //send to dev     eth1_dev = dev_get_by_name(&amp;init_net,"eth1");     lo_dev = dev_get_by_name(&amp;init_net,"lo");     skb-&gt;dev = eth1_dev;     ethh = (struct ethhdr *) skb_push(skb, ETH_HLEN);     skb_reset_mac_header(skb);     skb-&gt;protocol = ethh-&gt;h_proto = htons(ETH_P_IP);     memcpy (ethh-&gt;h_source,eth1_dev-&gt;dev_addr , ETH_ALEN);     memcpy (ethh-&gt;h_dest, d_mac, ETH_ALEN); // d_mac is mac of the gateway     dev_queue_xmit(skb);      return NF_STOLEN; } </code></pre>  <p>the above code works perfectly for me . One issue is that later on I will mangle the packet so need to create a new sk_buff, probably . </p>  <p>I am not able to do the 1st part through NF_INET_PRE_ROUTING, I am not able to push the packet/sk_buff to the webserver process through the TCP/IP stack. I tried using dev_queue_xmit() function with skb->dev as both eth1 and lo . I am seeing the packets hitting on the lo or eth1 through tcpdump . But the packets are not reaching the localhost webserver. Can anyone help me regarding this or point to some similar answered question . I believe instead of dev_queue_xmit() I need to call some receiving function . Also when packets arrive in NF_INET_PREROUTING, I the ethernet headers are already there so I am not forming it .  I have already accomplished the above tasks in variety of ways , first using raw sockets , then using nf_queue , now I want to see the performance through this method. Thanks</p>