<p>I need to make a routing using the IP source address. I have two ethernet interfaces and want the traffic received with source IP <code>192.168.3.0/24</code> and destination IP <code>192.168.2.0/24</code> is routed through <code>eth0</code> interface and the rest through <code>eth1</code>. I use the following commands:</p>  <pre><code>echo 1 &gt; /proc/sys/net/ipv4/ip_forward echo 200 virt1 &gt;&gt; /etc/iproute2/rt_tables ip rule add from 192.168.3.0/24 table virt1 ip route add 192.168.2.0/24 dev eth0 tab virt1 </code></pre>  <p>Then after entering the above command:</p>  <pre><code>~$ cat /etc/iproute2/rt_tables  # # reserved values # 255 local 254 main 253 default 0   unspec # # local # #1  inr.ruhep 250     virt1 </code></pre>  <p>List  </p>  <pre><code>~$ ip rule list 0:  from all lookup local  32765:  from 192.168.3.0/24 lookup virt1  32766:  from all lookup main  32767:  from all lookup default  </code></pre>  <p>Table virt1</p>  <pre><code>~$ ip route show table virt1 192.168.2.0/24 dev eth0  scope link  </code></pre>  <p>The main routing table is:</p>  <pre><code># ip route show table main default dev eth1  scope link  172.16.1.0/24 dev eth1  proto kernel  scope link  src 172.16.1.1  192.168.1.0/24 dev eth0  proto kernel  scope link  src 192.168.1.1  </code></pre>  <p>To test if it works, I use:</p>  <pre><code>#include&lt;stdio.h&gt;     #include&lt;string.h&gt;     #include&lt;sys/socket.h&gt;     #include&lt;stdlib.h&gt;     #include&lt;errno.h&gt;     #include&lt;netinet/ip.h&gt;  /* checksum */     unsigned short csum(unsigned short *ptr,int nbytes){         register long sum;         unsigned short oddbyte;         register short answer;        sum=0;         while(nbytes&gt;1){             sum+=*ptr++;             nbytes-=2;         }         if(nbytes==1) {             oddbyte=0;             *((u_char*)&amp;oddbyte)=*(u_char*)ptr;             sum+=oddbyte;         }      sum = (sum&gt;&gt;16)+(sum &amp; 0xffff);         sum = sum + (sum&gt;&gt;16);         answer=(short)~sum;     return(answer);     }  int main(void){         int s;         int aleatorio = rand()%65536;          srand(time(NULL));     if((s = socket (PF_INET, SOCK_RAW, IPPROTO_RAW)) == -1){             perror("socket");             exit(1);         }      char datagram[4096] , source_ip[32] , *data , *pseudogram, payload[2000];         memset (datagram, 0, 4096);       //IP header     struct iphdr *iph = (struct iphdr *) datagram;         struct sockaddr_in sin;       data = datagram + sizeof(struct iphdr);      strcpy(source_ip , "192.168.3.4");         sin.sin_family = AF_INET;         sin.sin_port = htons(80);         sin.sin_addr.s_addr = inet_addr ("192.168.2.50");      //Filling         iph-&gt;ihl = 5;         iph-&gt;version = 4;         iph-&gt;tos = 0;         iph-&gt;frag_off = 0;         iph-&gt;ttl = 255;         iph-&gt;protocol = (unsigned char)142;         iph-&gt;check = 0;      //Set to 0 before calculating checksum       iph-&gt;saddr = inet_addr ( source_ip );    //Spoof the source ip address       iph-&gt;daddr = inet_addr ("192.168.2.50");        //IP_HDRINCL to tell the kernel that headers are included in the packet     int one = 1;         const int *val = &amp;one;       if (setsockopt (s, IPPROTO_IP, IP_HDRINCL, val, sizeof (one)) &lt; 0){          perror("Error setting IP_HDRINCL");          exit(0);      }     while (1){         printf("Text\n");         scanf("%s", payload);             strncpy(data, payload, strlen(payload));             iph-&gt;id = htonl ((aleatorio+1)%65536); //Id of this packet         iph-&gt;tot_len = sizeof (struct iphdr) + strlen(payload);         iph-&gt;check = csum ((unsigned short *) datagram, iph-&gt;tot_len);         if (sendto (s, datagram, iph-&gt;tot_len ,  0, (struct sockaddr *) &amp;sin, sizeof (sin)) &lt; 0){             perror("sendto");          }else{              printf ("Se env√≠a un paquete de longitud: %d \n" , iph-&gt;tot_len);         }     }     return 0; } </code></pre>  <p>If I run this and sending the data, there is no error, but the data is not received on <code>192.168.2.50</code>. Here I think the kernel is using the default route of the main table. If I remove the default route using</p>  <pre><code># ip route del default dev eth1 </code></pre>  <p>and run the program again, I get</p>  <pre><code>sendto: Network is unreachable </code></pre>  <p>So the kernel only lookup at the main table</p>