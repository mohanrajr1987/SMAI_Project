<p>I want to create a custom map that that actually uses a fixed set of keys, but should behave like a <code>std::map</code>. Basically I use an array internally and map the keys to indexes, allowing very efficient lookup. I am however struggling to implement iterators that behave like <code>std::map</code> iterators, because I do not have internal <code>std::pair</code>s that I can hand out references to.</p>  <p>Is it possible to implement this as a zero-overhead abstraction while retaining the <code>std::map</code> interface, in particular the iterators?</p>  <p>The best i could come up with as <code>operator*</code> is to return a rvalue <code>std::pair&lt;key_type, mapped_type*&gt;</code>, which basically allows for the same operations, but unfortunately with different usage patterns.</p>  <p>I have also tried <code>std::pair&lt;key_type, boost::referene_wrapper&lt;mapped_type&gt;&gt;</code>, but that still doesn't allow <code>for(auto&amp; elem : map)</code> and often requires <code>elem.second.get()</code> for reasons I do not understand.</p>  <p>I am happy to use boost or lightweight header libraries, if there is anything that helps for the use case.</p>  <p>To illustrate the case, here is a minimal example with a map that contains all letters 'a'-'z'.</p>  <pre><code>using letter = char; static const letter letter_begin = 'a'; static const letter letter_end = 'z' + 1;  template &lt;typename T&gt; class letter_map { private:     using self = letter_map&lt;T&gt;;      template &lt;typename IT, typename M&gt;     class iterator_base : public std::iterator&lt;std::input_iterator_tag, T&gt;     {     public:         iterator_base(letter index, M&amp; map) : index_(index), data_(map)         {         }          using self_iter = iterator_base&lt;IT, M&gt;;         IT operator*()         {             return IT(index_, &amp;data_[index_]);         }          self_iter&amp; operator++()         {             index_++;             return *this;         }          self_iter operator++(int)         {             self_iter tmp(*this);             operator++();             return tmp;         }          bool operator==(self_iter other) const         {             assert(&amp;data_ == &amp;other.data_);             return index_ == other.index_;         }          bool operator!=(self_iter other) const         {             return !(*this == other);         }      private:         letter index_;         M&amp; data_;     };  public:     using key_type = letter;     using mapped_type = T;     using value_type = std::pair&lt;const key_type, mapped_type*&gt;;     using const_value_type = std::pair&lt;const key_type, const mapped_type*&gt;;  private:     static const size_t data_size = letter_end - letter_begin;     using container_type = std::array&lt;mapped_type, data_size&gt;;  public:     using iterator = iterator_base&lt;value_type, self&gt;;     using const_iterator = iterator_base&lt;const_value_type, const self&gt;;  public:     mapped_type&amp; operator[](letter l)     {         return data_[l - letter_begin];     }      const mapped_type&amp; operator[](letter l) const     {         return data_[l - letter_begin];     }      auto begin()     {         return iterator(letter_begin, *this);     }      auto end()     {         return iterator(letter_end, *this);     }      auto begin() const     {         return const_iterator(letter_begin, *this);     }      auto end() const     {         return const_iterator(letter_end, *this);     }  private:     container_type data_; };  void print_string_letter_map(const letter_map&lt;std::string&gt;&amp; lm) {     for (auto elem : lm)     {         std::cout &lt;&lt; elem.first &lt;&lt; "-&gt;" &lt;&lt; *(elem.second) &lt;&lt; std::endl;     } }  template&lt;typename T&gt; class std_letter_map : public std::map&lt;letter, T&gt; { public:     std_letter_map()     {         for (letter l = letter_begin; l != letter_end; ++l) {             this-&gt;emplace(l, T());         }     } };  void print_string_std_letter_map(const std_letter_map&lt;std::string&gt;&amp; lm) {     for (const auto&amp; elem : lm)     {         std::cout &lt;&lt; elem.first &lt;&lt; "-&gt;" &lt;&lt; elem.second &lt;&lt; std::endl;     } }  int main() {     letter_map&lt;std::string&gt; lm;     // usually I would use auto&amp; elem here     for (auto elem : lm) {         auto let = elem.first;         // usually this would be without the *         auto&amp; str = *(elem.second);         str = std::string("foo ") + let;     }     print_string_letter_map(lm);     return 0; } </code></pre>