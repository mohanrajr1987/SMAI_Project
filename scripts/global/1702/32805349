<p>When I try to pass the result of a nested <code>boost::accumulate</code> algorithm (where the result is a <code>std::vector</code>) into <code>boost::sort</code>, the compiler deduces that the input of <code>boost::sort</code> is a <code>const std::vector&amp;</code> even though it correctly deduces the return type of <code>boost::accumulate</code> to be <code>std::vector</code>. Why is that? The code below does not compile, complaining about <code>operator=</code> being undefined for <code>resultT</code>.</p>  <pre><code>#include &lt;boost/range/algorithm/find_if.hpp&gt; #include &lt;boost/range/algorithm_ext/copy_n.hpp&gt; #include &lt;boost/range/algorithm/sort.hpp&gt; #include &lt;boost/range/numeric.hpp&gt;  #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;unordered_map&gt; #include &lt;vector&gt;  struct resultT {     std::string name;     double quantity; };  auto operator&lt;(const resultT&amp; lhs, const resultT&amp; rhs) -&gt; bool {     return std::tie(lhs.quantity, lhs.name)         &lt; std::tie(rhs.quantity, rhs.name); }  auto operator&gt;(const resultT&amp; lhs, const resultT&amp; rhs) -&gt; bool {     return rhs &lt; lhs; }  auto operator&lt;&lt;(std::ostream&amp; os, const resultT&amp; row) -&gt; std::ostream&amp; {     os &lt;&lt; row.name &lt;&lt; '\t' &lt;&lt; std::setprecision(4) &lt;&lt; std::fixed &lt;&lt; row.quantity;     return os; }  template&lt;typename T&gt; auto calculate(const T&amp; in) -&gt; double {     //a stand-in for real operations on T--not important to the example     return in.second; }  using resultContainer = std::vector&lt;resultT&gt;;  template&lt;typename QuantityT&gt; auto add(resultContainer&amp; accumulated, const QuantityT&amp; next) -&gt; resultContainer&amp; {     auto accumulated_itr{boost::find_if(accumulated, [&amp;next](const resultT&amp; in) -&gt; bool     {         return in.name == next.second.first;     })};      if (accumulated_itr == std::end(accumulated))     {         accumulated.emplace_back(resultT{next.second.first, calculate(next.second)});     }     else     {         accumulated_itr-&gt;quantity += calculate(next.second);     }      return accumulated; }  auto main() -&gt; int {     using InnerT = std::pair&lt;int, std::pair&lt;std::string, int&gt;&gt;;     using OuterT = std::pair&lt;char, std::pair&lt;std::string, int&gt;&gt;;     auto addInnerOne{[](resultContainer&amp; accumulated, const InnerT&amp; next) { return add&lt;InnerT&gt;(accumulated, next); }};     auto addOuterOne{[](resultContainer&amp; accumulated, const OuterT&amp; next) { return add&lt;OuterT&gt;(accumulated, next); }};      auto InnerOne{std::unordered_multimap&lt;int, std::pair&lt;std::string, int&gt;&gt;     {         {0, {"hi", 1}}         , {1, {"ho", 5}}         , {2, {"hi", 7}}         , {3, {"ho", 7}}         , {4, {"hey", 9}}         , {5, {"fiddle", 11}}         , {6, {"hey", 11}}         , {7, {"ho", 3}}     }};     auto OuterOne{std::unordered_map&lt;char, std::pair&lt;std::string, int&gt;&gt;     {         {'A', {"hi", 1}}         , {'B', {"ho", 5}}         , {'C', {"hi", 7}}         , {'D', {"ho", 7}}         , {'E', {"hey", 9}}         , {'F', {"diddle", 21}}         , {'G', {"hey", 5}}         , {'H', {"ho", 3}}     }};      boost::copy_n(         boost::sort(             boost::accumulate(OuterOne                               , boost::accumulate(InnerOne                                                   , resultContainer{}                                                   , addInnerOne)                               , addOuterOne)                     , std::greater&lt;resultT&gt;())         , 5         , std::ostream_iterator&lt;resultT&gt;(std::cout, "\n"));      return 0; } </code></pre>  <p><a href="http://coliru.stacked-crooked.com/a/04b7a70653e31a05" rel="nofollow">Here you can see the issue live on Coliru</a>.</p>  <hr>  <p>Here is a simple fix that goes around the problem. I already have this fix--I want to know why I needed this workaround in the first place:</p>  <pre><code>auto quant{   //quant's type is correctly deduced to be std::vector     boost::accumulate(OuterOne                       , boost::accumulate(InnerOne                                           , resultContainer{}                                           , addInnerOne)                       , addOuterOne)};  boost::copy_n(     boost::sort(quant                 , std::greater&lt;resultT&gt;())     , 5     , std::ostream_iterator&lt;resultT&gt;(std::cout, "\n"));  return 0; </code></pre>  <p><a href="http://coliru.stacked-crooked.com/a/90ad13adedfb602f" rel="nofollow">Here is the fix live on Coliru</a>.</p>