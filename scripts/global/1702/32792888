<p>I am using the HTML Server 3 example from boost as my learning tool (<a href="http://www.boost.org/doc/libs/1_53_0/doc/html/boost_asio/examples.html#boost_asio.examples.http_server_3" rel="nofollow">http://www.boost.org/doc/libs/1_53_0/doc/html/boost_asio/examples.html#boost_asio.examples.http_server_3</a>) for asynchronous message handling.</p>  <p>I have taken the example, and turned it into a library with a server object I can instantiate in my programs. The only thing I have done to the above example is remove the main.cpp and compile it as a library. And it works to the extend that I can instantiate the server object in my code, and pass messages to it from the command line.</p>  <p>Where I am struggling is how to terminate the server gracefully. From the sample code I see this:</p>  <pre><code>server::server(const std::string&amp; address, const std::string&amp; port,                  std::size_t thread_pool_size,                Handler &amp;handler)           : thread_pool_size_(thread_pool_size),             signals_(io_service_),             acceptor_(io_service_),             new_connection_(),             request_handler_(handler)   {     // Register to handle the signals that indicate when the server should exit.     // It is safe to register for the same signal multiple times in a program,     // provided all registration for the specified signal is made through Asio.     signals_.add(SIGINT);     signals_.add(SIGTERM);     signals_.async_wait(boost::bind(&amp;server::handle_stop, this)); </code></pre>  <p>So an asynchronous thread is set up to listen for signals and respond to them</p>  <p>I have implemented this server object in a thread in my program as follows:</p>  <pre><code>class ServerWorker { public:     ServerWorker(std::string theHost, std::string thePort)     {         Host = theHost;         Port = thePort;     }     void Start()     {         try         {             MYRequestHandler handler;             int nCores = boost::thread::hardware_concurrency();             server *mServer = new server(Host, Port, nCores, handler);             svr-&gt;run();         }         catch(std::exception &amp;e) { /* do something */ }     }     void Stop()     {         mServer-&gt;stop(); // this should raise a signal and send it to the server                          // but don't know how to do it     } private:     std::string Host;     std::string Port;     server *mServer; };  TEST(BSGT_LBSSERVER_STRESS, BSGT_SINGLETON) {     // Launch as server on a new thread     ServerWorker sw(BSGT_DEFAULT_IPADDRESS, BSGT_DEFAULT_PORT_STR);     boost::function&lt;void()&gt; th_func = boost::bind(&amp;ServerWorker::Start, &amp;sw);     boost::thread swThread = boost::thread(th_func);      // DO SOMETHING      // How do I signal the server in the swThread to stop?     } </code></pre>  <p>How do I implement the stop() method on the server object to send the signal to itself? I have tried:<br> 1) raise(SIGTERM) - kills the whole program<br> 2) raise(SIGINT) - kills the whole program  </p>