<p>I am continuing to learn the Boost Spirit library and I have some issue with example that I couldn`t compile. The source of example you can find here: <a href="http://www.boost.org/doc/libs/1_59_0/libs/spirit/example/lex/example4.cpp" rel="nofollow">source place</a>. Also you can look at this code and compile result on <a href="http://coliru.stacked-crooked.com/a/fc874ecb7751b056" rel="nofollow">Coliru</a>.</p>  <pre><code>#include &lt;boost/config/warning_disable.hpp&gt; #include &lt;boost/spirit/include/qi.hpp&gt; #include &lt;boost/spirit/include/lex_lexertl.hpp&gt; #include &lt;boost/spirit/include/phoenix_operator.hpp&gt;  #include &lt;iostream&gt; #include &lt;fstream&gt; #include &lt;string&gt;  using namespace boost::spirit; using boost::phoenix::val;  /////////////////////////////////////////////////////////////////////////////// //  Token definition /////////////////////////////////////////////////////////////////////////////// template &lt;typename Lexer&gt; struct example4_tokens : lex::lexer&lt;Lexer&gt; {     example4_tokens()     {         identifier = "[a-zA-Z_][a-zA-Z0-9_]*";         constant = "[0-9]+";         if_ = "if";         else_ = "else";         while_ = "while";          this-&gt;self = lex::token_def&lt;&gt;('(') | ')' | '{' | '}' | '=' | ';' | constant;         this-&gt;self += if_ | else_ | while_ | identifier;          this-&gt;self("WS")             =   lex::token_def&lt;&gt;("[ \\t\\n]+")              |   "\\/\\*[^*]*\\*+([^/*][^*]*\\*+)*\\/"             ;     }      lex::token_def&lt;&gt; if_, else_, while_;     lex::token_def&lt;std::string&gt; identifier;     lex::token_def&lt;unsigned int&gt; constant; //] };  template &lt;typename Iterator, typename Lexer&gt; struct example4_grammar    : qi::grammar&lt;Iterator, qi::in_state_skipper&lt;Lexer&gt; &gt; {     template &lt;typename TokenDef&gt;     example4_grammar(TokenDef const&amp; tok)       : example4_grammar::base_type(program)     {         using boost::spirit::_val;          program              =  +block             ;          block             =   '{' &gt;&gt; *statement &gt;&gt; '}'             ;          statement              =   assignment             |   if_stmt             |   while_stmt             ;          assignment              =   (tok.identifier &gt;&gt; '=' &gt;&gt; expression &gt;&gt; ';')                 [                     std::cout &lt;&lt; val("assignment statement to: ") &lt;&lt; _1 &lt;&lt; "\n"                 ]             ;          if_stmt             =   (   tok.if_ &gt;&gt; '(' &gt;&gt; expression &gt;&gt; ')' &gt;&gt; block                      &gt;&gt; -(tok.else_ &gt;&gt; block)                  )                 [                     std::cout &lt;&lt; val("if expression: ") &lt;&lt; _2 &lt;&lt; "\n"                 ]             ;          while_stmt              =   (tok.while_ &gt;&gt; '(' &gt;&gt; expression &gt;&gt; ')' &gt;&gt; block)                 [                     std::cout &lt;&lt; val("while expression: ") &lt;&lt; _2 &lt;&lt; "\n"                 ]             ;          expression              =   tok.identifier [ _val = _1 ]             |   tok.constant   [ _val = _1 ]             ;     }      typedef boost::variant&lt;unsigned int, std::string&gt; expression_type;      qi::rule&lt;Iterator, qi::in_state_skipper&lt;Lexer&gt; &gt; program, block, statement;     qi::rule&lt;Iterator, qi::in_state_skipper&lt;Lexer&gt; &gt; assignment, if_stmt;     qi::rule&lt;Iterator, qi::in_state_skipper&lt;Lexer&gt; &gt; while_stmt;      qi::rule&lt;Iterator, expression_type(), qi::in_state_skipper&lt;Lexer&gt; &gt;  expression; };  /////////////////////////////////////////////////////////////////////////////// int main() {     typedef std::string::iterator base_iterator_type;     typedef lex::lexertl::token&lt;base_iterator_type, boost::mpl::vector&lt;unsigned int, std::string&gt; &gt; token_type;     typedef lex::lexertl::lexer&lt;token_type&gt; lexer_type;      typedef example4_tokens&lt;lexer_type&gt; example4_tokens;     typedef example4_tokens::iterator_type iterator_type;     typedef example4_grammar&lt;iterator_type, example4_tokens::lexer_def&gt; example4_grammar;      example4_tokens tokens;                         // Our lexer     example4_grammar calc(tokens);                  // Our parser      std::string str;      std::string::iterator it = str.begin();     iterator_type iter = tokens.begin(it, str.end());     iterator_type end = tokens.end();      bool r = qi::phrase_parse(iter, end, calc, qi::in_state("WS")[tokens.self]);      if (r &amp;&amp; iter == end)     {         std::cout &lt;&lt; "-------------------------\n";         std::cout &lt;&lt; "Parsing succeeded\n";         std::cout &lt;&lt; "-------------------------\n";     }     else     {         std::cout &lt;&lt; "-------------------------\n";         std::cout &lt;&lt; "Parsing failed\n";         std::cout &lt;&lt; "-------------------------\n";     }      std::cout &lt;&lt; "Bye... :-) \n\n";     return 0; } </code></pre>  <p>When I try to compile it I receive a lot of errors, see full list on <a href="http://coliru.stacked-crooked.com/a/fc874ecb7751b056" rel="nofollow">Coliru</a>.</p>  <p>What wrong with this example? What and why need be changed to compile it? How identify what exactly fails compilation process?</p>