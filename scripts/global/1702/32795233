<p>I'm attempting to write an <a href="https://tools.ietf.org/html/rfc2812#section-3.1.2" rel="nofollow">RFC 2812</a> compliant C++ IRC library. I am having some trouble with the design of the client itself. From what I have read IRC communication tends to be asynchronous.</p>  <p>I am using <code>boost::asio::async_read</code> and <code>boost::asio::async_write</code>. From reading the documentation I have gathered that you cannot perform multiple async_write requests before one is completed. You therefore end up with rather nested callbacks. Doesn't this defeat the purpose of doing async calls? Wouldn't it just be better to use synchronous calls to prevent the nesting? If not, why?</p>  <p>Secondly, if I am not mistaken, each <code>boost::asio::async_write</code> should be followed up by a <code>boost::asio::async_read</code> to receive the server's response to the commands sent. My client's functions, therefore, would need to take a callback parameter so a user of the class may do something after the client receives a response (ex. send another message...).</p>  <p>If I were to continue implementing this with async, should I keep a <code>std::deque&lt;std::tuple&lt;message, callback&gt;&gt;</code> and each time a <code>boost::asio::async_write</code> is finished, and there is a tuple in the queue, dequeue and send the message then raise the callback? Would this be the optimal way to implement this system?</p>  <p>I'm thinking since messages are sent all the time I'm going to have to implement some kind of listener loop that queues up responses, but how would you associate these responses with the specific command that triggered them? Or in the case that the response is just a message to the channel from another user?</p>