<p>Consider the following snippet:</p>  <pre><code>namespace bl = boost::locale; static bl::generator gen; static auto loc = gen("en_US.UTF-8"); std::string foo8 = u8"Föo"; std::string deco = bl::normalize(foo8,bl::norm_nfd,loc); std::string comp = bl::normalize(foo8,bl::norm_nfc,loc); std::cout &lt;&lt; "decomposed: " &lt;&lt; deco.find("o") &lt;&lt; ", composed: " &lt;&lt; comp.find("o") &lt;&lt;"\n"; </code></pre>  <p>This gives:  "decomposed: 1, composed: 3".</p>  <p>Now, the correct answer depends on the collation factor, but for most cases the latter would be what I want -- the first location of an o, not the first part of a decomposed ö.  Obviously for this example I can normalize a string to NFC to ensure I get the desired result, but this won't work for cases where a grapheme-cluster can't be composed.</p>  <p>Further, X.find("ö") will have implementation defined behavior, as there are no guarantees how that ö is encoded in the search.  </p>  <p>I can implement a Unicode safe find function by implementing the algorithm in UAX 29, or by normalizing the search strings, but I'm wondering if there is a way to do this by using the C++ std library and boost -- perhaps by combining a locale with a string algorithm -- but I haven't found a solution.</p>  <p>Anyone have a definitive answer?  I'm aware that I could use ICU, and that boost::locale is a c++ friendly wrapper around the ICU library (at least it is if you want full unicode support).  </p>