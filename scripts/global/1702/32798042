<p>Consider the following code:</p>  <pre><code>#include &lt;boost/iterator/iterator_facade.hpp&gt; #include &lt;map&gt;       // Class implements an stl compliant iterator to access the "sections" stored within a configuration.     template &lt; typename _Iterator, typename _Reference &gt;         class Section         : public boost::iterator_facade&lt;                      Section&lt; _Iterator, _Reference &gt;,                      _Iterator,                      boost::random_access_traversal_tag,                      _Reference                  &gt;         {         private:             // Define the type of the base class:             typedef boost::iterator_facade&lt;                 Section&lt; _Iterator, _Reference &gt;,                 _Iterator,                 boost::random_access_traversal_tag,                 _Reference             &gt; base_type;          public:             // The following type definitions are common public typedefs:             typedef Section&lt; _Iterator, _Reference &gt;    this_type;             typedef typename base_type::difference_type difference_type;             typedef typename base_type::reference       reference;             typedef _Iterator                           iterator_type;          public:             explicit Section( const iterator_type it )             : m_it( it )             { }              // Copy constructor required to construct a const_iterator from an iterator:             template &lt; typename _U &gt;                 Section( const Section&lt; _U, _Reference &gt; it )                 : m_it( it.m_it )                 { }          private:             // The following classes are friend of this class to ensure access onto the private member:                                                                  friend class boost::iterator_core_access;             template &lt; typename _Iterator, typename _Reference &gt; friend class Section;              void increment( ){ ++m_it; }                                                          // Advance by one position.             void decrement( ){ --m_it; }                                                          // Retreat by one position.             void advance( const difference_type&amp; n ){ m_it += n };                                // Advance by n positions.             bool equal( const this_type&amp; rhs ) const{ return m_it == rhs.m_it; }                  // Compare for equality with rhs.             reference dereference( ) const { return m_it-&gt;second; }                               // Access the value referred to.             difference_type distance_to( const this_type&amp; rhs ) const{ return rhs.m_it - m_it; }  // Measure the distance to rhs.          private:             // Current "section" iterator:             iterator_type m_it;         };   struct Data {     void f( ) const     { } };  typedef std::map&lt; int, Data &gt; map_type;  typedef Section&lt; const map_type::const_iterator, const Data&amp; &gt; iterator_type;  map_type g_map;  iterator_type begin( ) {     return iterator_type( g_map.begin( ) ); }  void main( ) {     iterator_type i = begin( );      // i-&gt;f( ); // &lt;---   error C2039: 'f' : is not a member of 'std::_Tree_const_iterator&lt;_Mytree&gt;'     ( *i ).f( ); } </code></pre>  <p>So the iterator facade shall return a reference to Data type. This works well when dereference operator is called but compile fails when operator->() is called. So I am a bit confused because operator->() tries to return a std::map::iterator. Any ideas ?</p>