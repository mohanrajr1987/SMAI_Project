<pre><code>#include &lt;boost/asio/io_service.hpp&gt; #include &lt;boost/bind.hpp&gt; #include &lt;boost/thread/thread.hpp&gt; #include &lt;iostream&gt; using namespace std;  #define MAX_THREAD_COUNT 50  class A { public:     static void ExecDecrementX(void* thisObj, int *x)     {         cout &lt;&lt; "DecrementX thread..." &lt;&lt; endl;         A *obj = (A*)thisObj;         obj-&gt;DecrementX(x);     }      void DecrementX(int* x)     {         cout &lt;&lt; "Thread Instantiated........" &lt;&lt; endl;         for (; *x &lt;= 1200; (*x)++)         {             cout &lt;&lt; "DecrementX thread, X = " &lt;&lt; *x &lt;&lt; endl;             if (*x == 1100)             {                 HANDLE hEvent = OpenEvent(EVENT_ALL_ACCESS, false, L"MyEvent1");                 if (!hEvent) { return; }                 ResetEvent(hEvent);                 if (SetEvent(hEvent))                 {                     cout &lt;&lt; "Got The signal - MyEvent 1......." &lt;&lt; endl;                     CloseHandle(hEvent);                 }             }         }         cout &lt;&lt; "End of the Thread ......" &lt;&lt; endl;     } };  int main() {     int x = 1000;     A* obj1 = new A();     DWORD dwRet;     HANDLE Events_Handle[1];     HANDLE  hEvent1 = CreateEvent(NULL, true, false, L"MyEvent1");     if (!hEvent1) return -1;     Events_Handle[0] = hEvent1;     void(*fPtr)(void*, int*) = A::ExecDecrementX;     boost::asio::io_service ioService;     boost::thread_group ThreadPool;     boost::asio::io_service::work work(ioService);     for (int threadcount = 0; threadcount &lt; MAX_THREAD_COUNT; threadcount++)     {         ThreadPool.create_thread(boost::bind(&amp;boost::asio::io_service::run, &amp;ioService));     }     cout &lt;&lt; "Main thread\n";     ioService.post(boost::bind(fPtr, obj1, &amp;x));     while (1)     {         dwRet = WaitForMultipleObjects(1, Events_Handle, false, INFINITE);         cout &lt;&lt; "dwRet = " &lt;&lt; dwRet &lt;&lt; endl;         if (dwRet == WAIT_OBJECT_0)         {             cout &lt;&lt; "All events were signaled..." &lt;&lt; endl;             ioService.stop();             ThreadPool.interrupt_all();             cout &lt;&lt; "Remaining threads interrupted... X = " &lt;&lt; x &lt;&lt; endl;             CloseHandle(hEvent1);             break;         }     }     cout &lt;&lt; "Main Thread: At the End X = " &lt;&lt; x &lt;&lt; endl;     return 0; } </code></pre>  <p>My requirment is once x reaches 1100, interrupted all threads but even after interruption of threadpool I see threadpool goes on and keep printing till end. Could you please help me understanding what is happening and how can I resolve it?</p>  <p>THanks, JK</p>