<p>I searched a lot on a parallelized version of <code>for_each</code> in C++. I found the following piece of code regarding paralleling <code>for_each</code> from <a href="http://openmp.org/forum/viewtopic.php?f=3&amp;t=109" rel="nofollow">here</a>:</p>  <pre><code>template&lt;class T, class Function&gt; void parallel_for_each(std::vector&lt; T&gt; &amp; obj, Function f) {   int size = obj.size();   #pragma omp parallel for firstprivate(f) shared(obj)   for (int i = 0; i &lt; size; i++)   {     f(obj[i]);   } } </code></pre>  <p>Here is a piece of my code:</p>  <pre><code>class A; typedef std::vector &lt;A&gt; vec_A; typedef std::vector &lt;vec_A&gt; vec_2D_A; vec_2D_A a2d;  ... //serial BOOST_FOREACH(vec_A&amp; av, a2d) {   for_each(av.begin(), av.end(), boost::bind(detect_Type, _1, CGAL, *this)); } // parallel (segfault here!) BOOST_FOREACH(vec_A&amp; av, a2d) {   parallel_for_each(av, boost::bind(detect_Type, _1, ALL, *this)); } ... </code></pre>  <p>Class <code>A</code> is a class of a specific point. Each member has a variable corresponding to its coordinates and couple of other member variables. The function <code>detect_type</code> is modifying members of <code>av</code>.</p>  <p>All members inside <code>vec_pnt</code> are independent from each other, but I still receive a segfault.</p>  <p><strong>EDIT</strong>:</p>  <p>here is more section of code. detect_type is responsible to find the type of the each object of A using Nearest Neighbor search and help of the XfieldPlus class itself. </p>  <pre><code>void detect_Type(A&amp; PNT, const NNSerach NNType, const xFieldPlus&amp; lst) {   switch (NNType)   {     case 0:      {       Nvertex = ANN_nearest(tip, lst); // It is NOT thread safe.     }       break;     case 1:     {       Nvertex = BOOST_nearest(tip, lst);     }       break;     case 2:  //we use CGAL     {       Nvertex = CGAL_nearest(tip, lst);     }       break;      default:       std::cout &lt;&lt; "Unknown NN-Serach" &lt;&lt; std::endl;       break;   }   ....   for(Entity::edgeIterator edgIter = f.beginEdge(); edgIter!= f.endEdge(); ++edgIter)        {          mesh::Edge edg = *edgIter;          if (edg != ed)          {            if (lst.getVal(edg.vertex(0)) * lst.getVal(edg.vertex(1)) &lt; 0.0 )            {              PNT._type = ON_EDGE_NEED;              return;            }          }        }    ... } </code></pre>