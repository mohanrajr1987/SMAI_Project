<p>I'm trying to implement a workaround for boost versions that cause problems with scoped enums on linking in C++11 mode: See <a href="https://svn.boost.org/trac/boost/ticket/6779" rel="nofollow">https://svn.boost.org/trac/boost/ticket/6779</a> and <a href="https://svn.boost.org/trac/boost/ticket/10038" rel="nofollow">https://svn.boost.org/trac/boost/ticket/10038</a></p>  <p>The problem is simply: Most pre-distributed boost libs expose (namespaces stripped):<br> <code>detail::copy_file(path const&amp;, path const&amp;, copy_option::enum_type, error_code*)</code><br> But C++11 compilation tries to find:<br> <code>detail::copy_file(path const&amp;, path const&amp;, copy_option, error_code*)</code><br> due to the fact, that C++98 boost uses emulated scoped enums, instead of the C++11 ones.</p>  <p>I though I might be able to write an adapter for that put it into an own object file and link that into the program, but I failed with my naive approach:</p>  <pre><code>#define copy_option native_copy_option__ #include &lt;boost/filesystem/operations.hpp&gt; #undef copy_option  namespace boost { namespace filesystem {      struct copy_option{         enum enum_type{none, fail_if_exists = none, overwrite_if_exists};     };  namespace detail {      void copy_file(const path&amp; from, const path&amp; to, copy_option::enum_type option, system::error_code* ec=0);      using copy_option = native_copy_option__;     void copy_file(const path&amp; from, const path&amp; to, copy_option option, system::error_code* ec)     {         copy_file(from, to, static_cast&lt;boost::filesystem::copy_option::enum_type&gt;(option), ec);     }  }  // namespace detail }  // namespace filesystem }  // namespace boost </code></pre>  <p>The problem is: I need to define a function with the C++11 enum in the signature but also declare a function with the C++98 enum which has the same name.</p>  <p>Is this somehow possible?</p>