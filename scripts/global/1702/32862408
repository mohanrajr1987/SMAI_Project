<p>I am trying to compile the regex part of the boost C++ library on AIX using the xlC compiler and use it as a 64-bit dynamic library, because I need to compare the performance of several C++ regex libraries and built-in solutions, and boost seemed like a viable candidate.</p>  <p>Here are my exact OS and compiler versions:</p>  <pre><code>$ uname -a AIX host_name 1 7 00F9A2144C00 $ xlC -qversion IBM XL C/C++ for AIX, V13.1.2 (5725-C72, 5765-J07) Version: 13.01.0002.0000 </code></pre>  <p>Since I do not have root priviliges, I cannot actually install the boost library, I am only trying to compile the regex part into a shared object file and to obtain all of the needed headers for my test application. I have tried to compile the latest available version (1.59.0), and also version 1.55.0, because I found that IBM has released a source code patch for boost:</p>  <p><a href="http://www-01.ibm.com/support/docview.wss?uid=swg27042921" rel="nofollow">http://www-01.ibm.com/support/docview.wss?uid=swg27042921</a></p>  <p>I compile boost and copy the headers and the shared object file to my development folder using the following commands:</p>  <pre><code>bootstrap.sh --with-toolset=vacpp --prefix=/my/user/directory --exec-prefix=/my/user/directory ./b2 address-model=64 cxxflags=-q64 cflags=-q64 b2 tools/bcp ./dist/bin/bcp boost/regex.hpp /my/include/directory cp stage/lib/libboost_regex.so /my/library/directory </code></pre>  <p>I know i could add the <code>--with-libraries=regex</code> flag to compile only the regex part, but it is irrelevant to my problems.</p>  <p>With both versions, with or without patching the boost source code, I encounter the same problems.</p>  <p><strong>First</strong>: I already have some libraries compiled, and linked to my simple test application, for example the PCRE C++ regex library. When I also try to link the boost regex library, with the <code>-lboost_regex</code> compile flag, I get the following error:</p>  <pre><code>ld: 0706-006 Cannot find or open library file: -l boost_regex ld:open(): No such file or directory make: The error code from the last command is 255. </code></pre>  <p>This is resolved by adding the <code>-brtl</code> compile flag, which as far as I know would only be needed if I would try to link a static library, so it looks like to me as if libboost_regex.so would actually be libboost_regex.a</p>  <p><strong>Second</strong>: When I add the line <code>#include "boost/regex.hpp"</code> to my code, I get a compilation error:</p>  <pre><code>"/opt/IBM/xlC/13.1.2/include/xtr1common", line 217.19: 1540-0130 (S) "false_type" is not declared. "/opt/IBM/xlC/13.1.2/include/xtr1common", line 223.19: 1540-0130 (S) "true_type" is not declared. "/opt/IBM/xlC/13.1.2/include/xtr1common", line 229.19: 1540-0130 (S) "true_type" is not declared. "/opt/IBM/xlC/13.1.2/include/xtr1common", line 235.19: 1540-0130 (S) "true_type" is not declared. "/opt/IBM/xlC/13.1.2/include/xtr1common", line 244.11: 1540-0130 (S) "false_type" is not declared. "/opt/IBM/xlC/13.1.2/include/xtr1common", line 250.11: 1540-0130 (S) "true_type" is not declared. make: The error code from the last command is 1. </code></pre>  <p>My test application is really simple. These are the contents of my Makefile:</p>  <pre><code>all:     /opt/IBM/xlC/13.1.2/bin/xlC -q64 -Iinclude -Llibs -lpcrecpp main.cpp -o regexp_test  clean:     rm regexp_test </code></pre>  <p>Here is the source code of my very basic test application:</p>  <pre><code>#include &lt;iostream&gt; #include &lt;string.h&gt;  #ifndef __IBMCPP_TR1__ #define __IBMCPP_TR1__ 1 #include &lt;regex&gt; #undef __IBMCPP_TR1__ #endif  #define __IBMCPP_TR1__ 1  /* Regular expression libraries to be included */ #include &lt;sys/types.h&gt; #include &lt;regex.h&gt; #include "pcrecpp.h" // #include "boost/regex.hpp" #include "deelx.h"  int main(int argc, char **argv) {     if(argc != 4){         std::cerr &lt;&lt; "Use: ./regexp_test &lt;posix|tr1|pcre|deelx&gt; value regexp" &lt;&lt; std::endl;         return 1;     }      int status;     char buffer[256], regexp[256];     snprintf(buffer,sizeof(buffer),argv[2]);     snprintf(regexp,sizeof(regexp),argv[3]);     std::string buffer_string = buffer;     bool match = false;      if(strcmp(argv[1],"posix")==0){          regex_t comp;         if (regcomp(&amp;comp, regexp, REG_EXTENDED) != 0) {             std::cerr &lt;&lt; "The regular expression '" &lt;&lt; regexp &lt;&lt; "' could not be compiled!" &lt;&lt; std::endl;             return 1;         } else {             status = regexec(&amp;comp, buffer, (size_t) 0, NULL, 0);             regfree(&amp;comp);             if (status == 0) {                 match = true;             }         }      } else if(strcmp(argv[1],"tr1")==0){          try {             std::tr1::smatch matches;             std::tr1::regex rgx(regexp);             status = std::tr1::regex_search(buffer_string, matches, rgx);             if(status){                 match = true;             }         }         catch(std::tr1::regex_error&amp; re)         {             std::cerr &lt;&lt; "TR1 exception caught!" &lt;&lt; std::endl;         }      } else if(strcmp(argv[1],"pcre")==0){          pcrecpp::RE re(regexp);         if(re.PartialMatch(buffer)){             match = true;         }      } else if(strcmp(argv[1],"deelx")==0){          static CRegexpT &lt;char&gt; deelx_regexp(regexp, IGNORECASE | MULTILINE);         MatchResult result = deelx_regexp.Match(buffer);         if(result.IsMatched()){             match = true;         }      } else {         std::cerr &lt;&lt; "Use: ./regexp_test &lt;posix|tr1|pcre|deelx&gt; value regexp" &lt;&lt; std::endl;         return 1;     }      if (!match) {         std::cout &lt;&lt; "The regular expression '" &lt;&lt; regexp &lt;&lt; "' does NOT match the value '" &lt;&lt; buffer &lt;&lt; "'." &lt;&lt; std::endl;     } else {         std::cout &lt;&lt; "The regular expression '" &lt;&lt; regexp &lt;&lt; "' matches the value '" &lt;&lt; buffer &lt;&lt; "'." &lt;&lt; std::endl;     }      return 0; } </code></pre>  <p>How can these problems be resolved? Any hints or advice would be appreciated.</p>