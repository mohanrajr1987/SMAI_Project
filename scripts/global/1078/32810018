<p>Here is the declaration of the <code>RotateFlipType</code> enumeration from .NET 4:</p>  <pre><code>public enum RotateFlipType {     Rotate180FlipXY = 0,     RotateNoneFlipNone = 0,     Rotate270FlipXY = 1,     Rotate90FlipNone = 1,     Rotate180FlipNone = 2,     RotateNoneFlipXY = 2,     Rotate270FlipNone = 3,     Rotate90FlipXY = 3,     Rotate180FlipY = 4,     RotateNoneFlipX = 4,     Rotate90FlipX = 5,     Rotate270FlipY = 5,     RotateNoneFlipY = 6,     Rotate180FlipX = 6,     Rotate90FlipY = 7,     Rotate270FlipX = 7, } </code></pre>  <p>I understand how the values are paired together for operations that would otherwise have the same result. The above enumeration becomes unfriendly when comparing debugger values against <code>RotateFlipType.ToString</code> values. Also not good for data binding scenarios. For example:</p>  <pre><code>var value = RotateFlipType.RotateNoneFlipNone; // Debugger shows correct string for [value] which is [RotateNoneFlipNone]. var text = value.ToString(); // Output of [text] is [Rotate180FlipXY]. Presumably because it is declared first in the list. </code></pre>  <p>Does this have anything to do with ordering of operations? Could they have not used <code>[Flags]</code> or split the enumeration into two (separating Rotation and Flipping)?</p>