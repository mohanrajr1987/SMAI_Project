<p>Suppose the following simple example:</p>  <pre><code>enum class Test { One = 1, Two = 2, Three = 3 };  int main() {     Test t{}; } </code></pre>  <p>The code above seems to compile fine on Clang, GCC, and MSVC. My concern is while the <em>underlying</em> integral type used to represent the numeric range of the individual enumerators is perfectly capable of representing <code>0</code> as a value, that 0 value does not map to the constants themselves. It's this differentiation that is confusing (the integral type range vs the range of the enumeration's enumerators). <code>t</code>'s value seems to be "well defined" from the perspective of an <code>int</code>, but it is not well defined in the sense that as a scalar, it does not map to one of the enums constants.</p>  <p>My searching resulted in <a href="http://stackoverflow.com/questions/27935026/the-behavior-of-value-initializing-an-enum">this SO post</a>, however the top answer was <em>very</em> technical and I didn't quite understand. I'm posing the question here from a slightly different angle, to see if I can get an answer that makes a little more sense to me.</p>  <p>Are there different rules and/or guarantees between enums with fixed value enumerators vs those without them? The code above makes perfect sense for enums with enumerators that have not been explicitly assigned, it's the fixed value case that is confusing.</p>