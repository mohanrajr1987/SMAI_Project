<p>Let's say that I have an enum as such:</p>  <pre><code>typedef enum {     gray = 4, //Gr[ae]y should be the same     grey = 4,     blue = 5,     red  = 6 } FOO; </code></pre>  <p>I then want to switch on this:</p>  <pre><code>switch(f){     case gray:     case grey:         printf("The color of an elephant\n"); break;     case blue:         printf("The color of the sky\n"); break;     case red:         printf("The color of an apple\n"); break;     default:         printf("I don't know this color\n");   } </code></pre>  <p>Basically I have enum that has values that are essentially synonyms that I want to handle exactly the same way.  I tried the above switch, but it doesn't compile for me. Is there a way to do this, or am I stuck using if/else logic? (I'd rather not as there are 20+ enums and the switch is much cleaner looking</p>  <p>EDIT: Yes, I know that I can just pick one or the other (and no locales are not the solution), but doesn't it seem kind of odd that enums explicitly allow you to declare duplicate values yet you then can't use them in a switch statement? I want to use enums so that I can statically enforce in a library API that they are sending proper values (yes I know you can get around with typecasting, I'm just trying to prevent stupid mistakes and such). If I do so it now seems like I lose the ability to use it in a switch statement.  </p>  <p>The compiler is just reducing the logic down to if/else logic.  If      case 4:     case 5:         bar(); break;</p>  <p>is legal, why can't      case 4:     case 4:         bar(); break;</p>  <p>be legal?  The compiler should be able to optimize that to one statement and move on.</p>