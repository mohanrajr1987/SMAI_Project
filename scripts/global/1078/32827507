<p>I made a little "Angle" enum so that I could program with different interchangeable angular formats:</p>  <pre><code>enum Angle {     case Radians(CGFloat)     case Degrees(CGFloat)     case Rotations(CGFloat) } </code></pre>  <p>I find that there's some redundant boilerplate code with this approach though. For example, I wanted to add a computed var that just returned the raw underlying associated float:</p>  <pre><code>var raw:CGFloat {     switch self {     case let .Radians(value):         return value     case let .Degrees(value):         return value     case let .Rotations(value):         return value     } } </code></pre>  <p>I tried to change that to read:</p>  <pre><code>case .Radians(let value), .Degrees(let value):     return value </code></pre>  <p>I hoped it would be clever enough to realize it was only ever going to resolve one match, so the conflict was ignorable. But no such device. Compiler says it can't resolve the conflict between the two <code>let value</code> statements.</p>  <p>So is there a bit of idiomatic cleverness I haven't discovered with Swift enum's yet that would make it so I don't have to repeat myself so much there?</p>  <p>Another similar example, was when I implemented the <code>*</code> function:</p>  <pre><code>func * (lhs:Angle, rhs:CGFloat) -&gt; Angle {     switch lhs {     case .Radians:         return .Radians(lhs.raw * rhs)     case .Degrees:         return .Degrees(lhs.raw * rhs)     case .Rotations:         return .Rotations(lhs.raw * rhs)     } } </code></pre>  <p>It seems like there should be a simpler way to express that: "Make the same enum type with my associated value times the scalar argument".</p>  <p><em>(I'm not sure I've got a good title on this question, feel free to improve/suggest better)</em></p>