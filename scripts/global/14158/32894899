<p>I'm not sure if something has changed, but our Windows Azure webjob JobHost is no longer seeing the functions included in the Functions.cs File. We have just recently upgraded the Azure Nuget packages on this solution (not sure if that is related).</p>  <p>Program.cs</p>  <pre><code>using M5Worker.Classes; using Microsoft.Azure.WebJobs; using Microsoft.ServiceBus.Messaging; using System; using TuesPechkin;  namespace M5Worker {     // To learn more about Microsoft Azure WebJobs SDK, please see    http://go.microsoft.com/fwlink/?LinkID=320976 public class Program {     // This is needed for pechkin do not remove!     public static readonly IConverter converter =                                new ThreadSafeConverter(                                    new PdfToolset(                                        new Win64EmbeddedDeployment(                                            new TempFolderDeployment())));      //published with devmode false     public static bool DevMode = false;   // Please set the following connection strings in app.config for this WebJob to run:     // AzureWebJobsDashboard and AzureWebJobsStorage     public static void Main()     {         libUFE.clsLogging cLog = new libUFE.clsLogging("M5");         try         {             cLog.LogWrite(System.Reflection.MethodBase.GetCurrentMethod().Name, 0, "", "", "Information", "M5Worker has Started", 0, "");              JobHostConfiguration jhc = new JobHostConfiguration();              if (DevMode == false)             {                 jhc.ServiceBusConnectionString = Properties.Settings.Default.strSBConnProd;             }             else             {                 jhc.ServiceBusConnectionString = Properties.Settings.Default.strSBConnDev;             }             jhc.DashboardConnectionString = "##################";             jhc.StorageConnectionString = "##################";             jhc.Queues.MaxPollingInterval = TimeSpan.FromSeconds(30);             jhc.NameResolver = new QueueNameResolver();              JobHost jh = new JobHost(jhc);             jh.RunAndBlock();              cLog.LogWrite(System.Reflection.MethodBase.GetCurrentMethod().Name, 0, "", "", "Information", "M5Worker has Finished", 0, "");         }         catch (Exception ex)         {             cLog.LogWrite(System.Reflection.MethodBase.GetCurrentMethod().Name, 0, "", "", "Error", ex.Message, 0, "");             cLog.LogWrite(System.Reflection.MethodBase.GetCurrentMethod().Name, 0, "", "", "Information", "M5Worker has Finished", 0, "");         }     }      public class QueueNameResolver : INameResolver     {         public string Resolve(string name)         {             if (DevMode == true)                 return "m5queuedev";             else                 return "m5queue";         }     } </code></pre>  <p>Function.cs</p>  <pre><code>using Microsoft.ApplicationServer.Caching; using Microsoft.Azure.WebJobs; using Microsoft.ServiceBus.Messaging; using Newtonsoft.Json; using System; using M5Worker.DB; using System.Threading; using System.Data; using M5Worker.Classes;  namespace M5Worker {      public class Functions     {          public static libUFE.clsLogging cLog = new libUFE.clsLogging("M5");          // This function will get triggered/executed when a new message is written          // on an Azure Queue called queue.         public static void M5Worker([ServiceBusTrigger("%queuename%")] BrokeredMessage message)         {             if (message != null)             {                 try                 {                      if (message.Properties.Count &gt; 0 &amp;&amp; message.Properties.ContainsKey("Function"))                     {                         //message.Complete();                         switch (message.Properties["Function"].ToString().ToUpper())                         {                             case "CREATEELECTRONICFORECLOSURE":                                 FunctionHandler.ProcessMessage(message, clsElectronicForeclosure.processItem, true);                                 break;                              case "PROCESSCUSTOMER":                                 FunctionHandler.ProcessMessage(message, clsProcessCustomer.ProcessCustomerObject, true);                                 break;                         }                     }                     else                     {                         throw new Exception("Message does not contain function");                     }                 }                 catch (System.Exception ex)                 {                     Console.WriteLine(ex.Message);                     cLog.LogWrite(System.Reflection.MethodBase.GetCurrentMethod().Name, 0, "", "", "Error", ex.Message, 0, "");                     // Indicate a problem, unlock message in queue                     message.DeadLetter();                 }                   message.Dispose();             }         }      }   } </code></pre>  <p>Results in  <a href="http://imgur.com/QvJ2Ca5" rel="nofollow">http://imgur.com/QvJ2Ca5</a></p>  <p>I've been searching around and found answers related to making sure the functions classes are public static, but not much more. </p>  <p>Any help would be appreciated.</p>