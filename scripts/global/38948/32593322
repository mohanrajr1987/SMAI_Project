<p>I'm using an MKMapView to allow the user to select a delivery location, much like the Uber app where the pin is in the centre and you drag around to select the location. </p>  <p>Everything works, but for some reason the first time I load the view with the map, it puts the centre pin in the middle of the atlantic ocean (0,0). When I got to a different view and come back to the map it works as expected and puts the centre pin at the current location of the user. It's worth noting that the view with the MKMapView is the first displayed view to the user, although technically not the root view controller - that's a UINavigationController.</p>  <p>The maps have worked perfectly fine and gone to the user location before in other apps i've built, but they've not included this centre pin. Basically I want to be able to put the centre pin at the user location on first load. </p>  <p>The code is as follows:</p>  <pre><code>- (void)viewDidLoad {     [super viewDidLoad];     [UIApplication sharedApplication].statusBarStyle = UIStatusBarStyleDefault;     [self setNeedsStatusBarAppearanceUpdate];     [UIApplication sharedApplication].statusBarStyle = UIStatusBarStyleDefault;     //Basics setup     defaults = [NSUserDefaults standardUserDefaults];     [menuButton setAction:@selector(showMenu)];     locationMapView.delegate = self;     locationMapView.showsUserLocation = YES;     locationMapView.pitchEnabled = NO;      //Add custom gesture functions     UITapGestureRecognizer* tapGesture = [[UITapGestureRecognizer alloc]initWithTarget:self action:@selector(dismissKeyboard)];     tapGesture.cancelsTouchesInView = NO;     [self.view addGestureRecognizer:tapGesture];     [locationMapView addGestureRecognizer:tapGesture];     [self.navigationItem.titleView addGestureRecognizer:tapGesture];     UIPanGestureRecognizer *panGesture = [[UIPanGestureRecognizer alloc]initWithTarget:self action:@selector(dismissKeyboard)];     [self.view addGestureRecognizer:panGesture];     [locationMapView addGestureRecognizer:panGesture];     UISwipeGestureRecognizer *swipeGesture = [[UISwipeGestureRecognizer alloc]initWithTarget:self action:@selector(dismissKeyboard)];     [locationMapView addGestureRecognizer:swipeGesture];     [self.view addGestureRecognizer:swipeGesture];      [locationMapView addSubview:self.centerAnnotationView];      //Plot selected address     CLLocationCoordinate2D  addressCoordinate;     addressCoordinate.latitude = locationMapView.userLocation.coordinate.latitude;     addressCoordinate.longitude = locationMapView.userLocation.coordinate.longitude;     MKPointAnnotation *annotation = [[MKPointAnnotation alloc] init];     [annotation setCoordinate:addressCoordinate];     [locationMapView addAnnotation:annotation];     MKCoordinateRegion region = MKCoordinateRegionMakeWithDistance (addressCoordinate, 1000, 1000);     [locationMapView setRegion:region animated:NO];      //Register for reloading mapview     [[NSNotificationCenter defaultCenter] addObserver:self                                              selector:@selector(annotationSetup:)                                                  name:@"ReloadVendors"                                                object:nil];     [GlobalFunctions getNearestVendors:[NSString stringWithFormat:@"%f", locationMapView.userLocation.coordinate.latitude] andLongitude:[NSString stringWithFormat:@"%f", locationMapView.userLocation.coordinate.longitude]];  }  - (void)didReceiveMemoryWarning {     [super didReceiveMemoryWarning];     // Dispose of any resources that can be recreated. }  //Reload on notification - (void)annotationSetup:(NSNotification *)notif {     [self clearMapView];     for (NSMutableArray *object in [GlobalFunctions vendors]) {         float latitudeNow = [[object valueForKey:@"latitude"] floatValue];         float longitudeNow = [[object valueForKey:@"longitude"] floatValue];          vendorAnnotation = [[VendorAnnotation alloc] init];         vendorAnnotation.coordinate = CLLocationCoordinate2DMake(latitudeNow, longitudeNow);         vendorAnnotation.vendorId = [object valueForKey:@"id"];         vendorAnnotation.title = [object valueForKey:@"name"];         vendorAnnotation.vendorAddress = [object valueForKey:@"address"];         vendorAnnotation.subtitle = [NSString stringWithFormat:@"%.2fkm away", [[object valueForKey:@"distance"] floatValue]];         vendorAnnotation.vendorLastActive = [object valueForKey:@"last_active"];         vendorAnnotation.vendorUpdatedAt = [object valueForKey:@"updated_at"];          [locationMapView addAnnotation:vendorAnnotation];     } }  //Clear map annotations -(void)clearMapView {     [locationMapView removeAnnotations:locationMapView.annotations]; }  - (IBAction)currentLocationPressed:(id)sender {     if([CLLocationManager locationServicesEnabled]){         self.navigationController.view.userInteractionEnabled = FALSE;         NSLog(@"Location Services Enabled");         MKCoordinateRegion region;         if([CLLocationManager authorizationStatus]==kCLAuthorizationStatusDenied){             self.navigationController.view.userInteractionEnabled = TRUE;             [self showPrivacyHelperForType:DBPrivacyTypeLocation controller:^(DBPrivateHelperController *vc) {             } didPresent:^{             } didDismiss:^{             } useDefaultSettingPane:NO];         }         else {              region.center.longitude = locationMapView.userLocation.coordinate.longitude;             [locationMapView setRegion:region animated:YES];             self.navigationController.view.userInteractionEnabled = TRUE;             [self getAddressFromCoordinates];             [GlobalFunctions getNearestVendors:[NSString stringWithFormat:@"%f", locationMapView.userLocation.coordinate.latitude] andLongitude:[NSString stringWithFormat:@"%f", locationMapView.userLocation.coordinate.longitude]];         }     } }  - (IBAction)viewCataloguePressed:(id)sender { }  - (IBAction)doneButtonPressed:(id)sender {     [self getAddressFromCoordinates];     [self.navigationController popViewControllerAnimated:YES]; }  - (IBAction)enterLocationPressed:(id)sender {     enterLocationView.backgroundColor = [UIColor colorWithHexString:@"#d3d3d3"]; }  //Dismiss Keyboard -(void)dismissKeyboard {     [self.view endEditing:YES]; }  //Set status bar to white -(UIStatusBarStyle)preferredStatusBarStyle{     return UIStatusBarStyleLightContent; }   //////////////////////////////////  - (MKPointAnnotation *)centerAnnotaion {     if (!_centerAnnotaion) {         _centerAnnotaion = [[MKPointAnnotation alloc] init];     }      return _centerAnnotaion; }  - (MKPinAnnotationView *)centerAnnotationView {     if (!_centerAnnotationView) {         _centerAnnotationView = [[MKPinAnnotationView alloc] initWithAnnotation:self.centerAnnotaion                                                                 reuseIdentifier:@"centerAnnotationView"];         _centerAnnotationView.pinColor = MKPinAnnotationColorPurple;     }      return _centerAnnotationView; }  - (CLLocationCoordinate2D)selectedCoordinate {     return locationMapView.centerCoordinate; }  - (void)setMapView:(MKMapView *)mapView {     // Remove ourselves as delegate to old and add to new     if (locationMapView) {         locationMapView.delegate = nil;     }      locationMapView = mapView;      if (locationMapView) {         mapView.delegate = self;     } }  #define DEFAULT_INITIAL_SIZE 1000  - (NSUInteger)initialMapSize {     if (!_initialMapSize) {         _initialMapSize = DEFAULT_INITIAL_SIZE;     }      return _initialMapSize; }  #define DEFAULT_ZOOM_SIZE 100  - (NSUInteger)zoomMapSize {     if (!_zoomMapSize) {         _zoomMapSize = DEFAULT_ZOOM_SIZE;     }      return _zoomMapSize; }  - (void)setDoesDisplayPointAccuracyIndicators:(BOOL)doesDisplayPointAccuracyIndicators {     _doesDisplayPointAccuracyIndicators = doesDisplayPointAccuracyIndicators;     [self updatePointAccuracyIndicators]; }  -(void)setRequiredPointAccuracy:(CLLocationDistance)requiredPointAccuracy {     _requiredPointAccuracy = requiredPointAccuracy;     [self updatePointAccuracyIndicators]; }  - (void)setZoomToUser:(BOOL)zoomToUser {     if (zoomToUser) {         if (locationMapView.showsUserLocation &amp;&amp; locationMapView.userLocation.location &amp;&amp; !locationMapView.userLocation.updating) {             [self changeRegionToCoordinate:locationMapView.userLocation.location.coordinate withSize:self.zoomMapSize];             _zoomToUser = NO;         } else {             _zoomToUser = YES;         }     } else     {         _zoomToUser = NO;     } }   - (void)setShowUserTrackingButton:(BOOL)showUserTrackingButton {     if (_showUserTrackingButton != showUserTrackingButton) {         _showUserTrackingButton = showUserTrackingButton;     } }  - (CLGeocoder *)geocoder {     if (!_geocoder) {         _geocoder = [[CLGeocoder alloc] init];     }      return _geocoder; }  - (CLLocationCoordinate2D)userCoordinate {     return locationMapView.userLocation.coordinate; }  #pragma mark - View Controller Lifecycle   -(void)viewWillAppear:(BOOL)animated {     [super viewWillAppear:animated];       [locationMapView setRegion:MKCoordinateRegionMakeWithDistance(CLLocationCoordinate2DMake(locationMapView.userLocation.coordinate.latitude, locationMapView.userLocation.coordinate.longitude),self.initialMapSize, self.initialMapSize)]; }  -(void)viewDidAppear:(BOOL)animated {     [super viewDidAppear:animated];      [self.navigationController.navigationBar lt_reset];      [self moveMapAnnotationToCoordinate:locationMapView.userLocation.coordinate];  }   // These are the constants need to offset distance between the lower left corner of // the annotaion view and the head of the pin #define PIN_WIDTH_OFFSET 7.75 #define PIN_HEIGHT_OFFSET 5  - (void)moveMapAnnotationToCoordinate:(CLLocationCoordinate2D) coordinate {     CGPoint mapViewPoint = [locationMapView convertCoordinate:coordinate toPointToView:locationMapView];      // Offset the view from to account for distance from the lower left corner to the pin head     CGFloat xoffset = CGRectGetMidX(self.centerAnnotationView.bounds) - PIN_WIDTH_OFFSET;     CGFloat yoffset = -CGRectGetMidY(self.centerAnnotationView.bounds) + PIN_HEIGHT_OFFSET;      self.centerAnnotationView.center = CGPointMake(mapViewPoint.x + xoffset,                                                    mapViewPoint.y + yoffset); }  - (void)changeRegionToCoordinate:(CLLocationCoordinate2D)coordinate withSize:(NSUInteger)size {     MKCoordinateRegion newRegion = MKCoordinateRegionMakeWithDistance(coordinate, size, size);     [locationMapView setRegion:newRegion animated:YES]; }  - (CLLocationDistance)metersPerViewPoint {     CGRect comparisonRect = CGRectMake(locationMapView.center.x,                                        locationMapView.center.y,                                        1,                                        1);     MKCoordinateRegion comparisonRegion = [locationMapView convertRect:comparisonRect toRegionFromView:locationMapView];     CLLocationCoordinate2D comparisonCoordinate1 = CLLocationCoordinate2DMake(comparisonRegion.center.latitude - comparisonRegion.span.latitudeDelta,                                                                               comparisonRegion.center.longitude - comparisonRegion.span.longitudeDelta);     CLLocationCoordinate2D comparisonCoordinate2 = CLLocationCoordinate2DMake(comparisonRegion.center.latitude + comparisonRegion.span.latitudeDelta,                                                                               comparisonRegion.center.longitude + comparisonRegion.span.longitudeDelta);     CLLocationDistance sizeInMeters = MKMetersBetweenMapPoints(MKMapPointForCoordinate(comparisonCoordinate1),                                                                MKMapPointForCoordinate(comparisonCoordinate2));      return sizeInMeters; }  - (BOOL)mapIsAtValidZoomScale {     if (self.requiredPointAccuracy) {         return [self metersPerViewPoint] &lt;= self.requiredPointAccuracy;     } else {         return YES;     } }  #define INDICATOR_BORDER_WIDTH 5  - (void)updatePointAccuracyIndicators {     if (self.doesDisplayPointAccuracyIndicators &amp;&amp; self.requiredPointAccuracy &gt; 0) {         if ([self mapIsAtValidZoomScale]) {             locationMapView.layer.borderColor = [UIColor greenColor].CGColor;             locationMapView.layer.borderWidth = INDICATOR_BORDER_WIDTH;         } else {             locationMapView.layer.borderColor = [UIColor redColor].CGColor;             locationMapView.layer.borderWidth = INDICATOR_BORDER_WIDTH;         }     }     else     {         locationMapView.layer.borderWidth = 0;     }  }  - (CLLocation *)locationForCoordinate:(CLLocationCoordinate2D)coordinate {     CLLocation *location = [[CLLocation alloc] initWithCoordinate:coordinate                                                          altitude:0                                                horizontalAccuracy:1                                                  verticalAccuracy:1                                                         timestamp:[NSDate date]];      return location; }  - (void)reverseGeoCodeAfterTimer:(NSTimer *)timer {     CLLocation *location = (CLLocation *)timer.userInfo;      // If we are still at the same location after the delay, reverse geocod     if ((location.coordinate.latitude == self.selectedCoordinate.latitude) &amp;&amp;         (location.coordinate.longitude == self.selectedCoordinate.longitude)) {         CLGeocodeCompletionHandler handler = ^(NSArray *placemark, NSError *error){             if (error) {                 NSLog(@"Error in geocode request. Error message: %@", error);             }             else             {                 // If there is atleast one placemark, set the selected placemark and call delegate                 if (placemark &amp;&amp; ([placemark count] &gt; 0)) {                     self.selectedPlacemark = placemark[0];                     NSLog(@"%@", placemark);                     NSLog(@"Reverse location name: %@", self.selectedPlacemark.name);                     if ([self.delegate respondsToSelector:@selector(centerPinMapViewController:didResolvePlacemark:)]) {                         // Notify delegate on main thread                         dispatch_async(dispatch_get_main_queue(), ^{                             [self.delegate centerPinMapViewController:self didResolvePlacemark:placemark[0]];                         });                     }                 }             }         };         [self.geocoder reverseGeocodeLocation:location completionHandler:handler];     } }  #pragma mark - MapView Delegate methods  #define REVERSE_GEOCODE_DELAY 2.0  - (void)mapView:(MKMapView *)mapView regionDidChangeAnimated:(BOOL)animated {     BOOL currentZoomStateValid = [self mapIsAtValidZoomScale];      if (self.lastValidZoomState != currentZoomStateValid) {         self.lastValidZoomState = currentZoomStateValid;         if (self.doesDisplayPointAccuracyIndicators &amp;&amp; self.requiredPointAccuracy &gt; 0) {             [self updatePointAccuracyIndicators];         }          if ([self.delegate respondsToSelector:@selector(centerPinMapViewController:didChangeValidZoomScaleTo:)]) {             [self.delegate centerPinMapViewController:self didChangeValidZoomScaleTo:currentZoomStateValid];         }     }      // If the center coordinate has changed, update values     if ((self.centerAnnotaion.coordinate.latitude) != (locationMapView.centerCoordinate.latitude) ||         (self.centerAnnotaion.coordinate.longitude != (locationMapView.centerCoordinate.longitude))) {          self.centerAnnotaion.coordinate = mapView.centerCoordinate;         self.selectedPlacemark = nil;          [self moveMapAnnotationToCoordinate:mapView.centerCoordinate];          // If the current zoom state is valid update selected values         if (currentZoomStateValid) {             self.selectedCoordinate = locationMapView.centerCoordinate;              // Schedule geocode if enabled             if (self.shouldReverseGeocode) {                 [NSTimer scheduledTimerWithTimeInterval:REVERSE_GEOCODE_DELAY                                                  target:self selector:@selector(reverseGeoCodeAfterTimer:)                                                userInfo:[self locationForCoordinate:self.selectedCoordinate]                                                 repeats:NO];             }              if ([self.delegate respondsToSelector:@selector(centerPinMapViewController:didChangeSelectedCoordinate:)]) {                 [self.delegate centerPinMapViewController:self didChangeSelectedCoordinate:locationMapView.centerCoordinate];             }         }      }      [self getAddressFromCoordinates]; }  -(MKAnnotationView*)mapView:(MKMapView*)mapView viewForAnnotation:(id&lt;MKAnnotation&gt;)annotation {      // If it's the user location, just return nil.     if ([annotation isKindOfClass:[MKUserLocation class]])         return nil;      // Handle any custom annotations.     if ([annotation isKindOfClass:[VendorAnnotation class]])     {         // Try to dequeue an existing pin view first.         MKAnnotationView *pinView = (MKAnnotationView*)[locationMapView dequeueReusableAnnotationViewWithIdentifier:@"CustomPinAnnotationView"];         if (!pinView)         {             // If an existing pin view was not available, create one.             pinView = [[MKAnnotationView alloc] initWithAnnotation:annotation reuseIdentifier:@"CustomPinAnnotationView"];             //pinView.animatesDrop = YES;             pinView.canShowCallout = NO;             pinView.image = [UIImage imageNamed:@"VendorPin"];               // Add a detail disclosure button to the callout.             UIButton* rightButton = [UIButton buttonWithType:UIButtonTypeDetailDisclosure];             pinView.rightCalloutAccessoryView = rightButton;           } else {             pinView.annotation = annotation;             pinView.image = [UIImage imageNamed:@"VendorPin"];         }         return pinView;     }      MKAnnotationView *pinView = (MKAnnotationView*)[locationMapView dequeueReusableAnnotationViewWithIdentifier:@"CentreAnnotationView"];     if (!pinView)     {         // If an existing pin view was not available, create one.         pinView = [[MKAnnotationView alloc] initWithAnnotation:annotation reuseIdentifier:@"CentreAnnotationView"];         //pinView.animatesDrop = YES;         pinView.canShowCallout = NO;         //pinView.image = [UIImage imageNamed:@"CentrePin"];      } else {         pinView.annotation = annotation;         //pinView.image = [UIImage imageNamed:@"CentrePin"];     }     return pinView; }  - (void)mapView:(MKMapView *)mapView didUpdateUserLocation:(MKUserLocation *)userLocation {     if (self.zoomToUser) {         [self changeRegionToCoordinate:userLocation.coordinate withSize:self.zoomMapSize];         self.zoomToUser = NO;     }      if ([self.delegate respondsToSelector:@selector(centerPinMapViewController:didUpdateUserLocation:)]) {         [self.delegate centerPinMapViewController:self didUpdateUserLocation:userLocation.location];     } } </code></pre>