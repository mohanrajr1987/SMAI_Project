<p>I am writing a protocol, that uses <a href="https://tools.ietf.org/html/rfc7049" rel="nofollow">RFC 7049</a> as its binary representation. The standard states, that the protocol may use 32-bit floating point representation of numbers, if their numeric value is equivalent to respective 64-bit numbers. The conversion must not lead to lose of precision.</p>  <ul> <li>What 32-bit float numbers can be bigger than 64-bit integer and numerically equivalent with them?</li> <li>Is comparing <code>float x; uint64_t y; (float)x == (float)y</code> enough for ensuring, that the values are equivalent? Will this comparison ever be true?</li> </ul>  <p><a href="https://tools.ietf.org/html/rfc7049#section-3.6" rel="nofollow">RFC 7049 ยง3.6. Numbers</a></p>  <blockquote>   <p>For the purposes of this specification, all number representations       for the same numeric value are equivalent.  This means that an       encoder can encode a floating-point value of 0.0 as the integer 0.       It, however, also means that an application that expects to find       integer values only might find floating-point values if the encoder       decides these are desirable, such as when the floating-point value is       more compact than a 64-bit integer.</p> </blockquote>