<p>I'm new to Haskell, and just stumbled across this problem. I'm trying to figure out an explaination, but I don't have enough experience with Haskell types to be sure.</p>  <p>The function:</p>  <pre><code>mystery :: Int -&gt; Int -&gt; Float -&gt; Bool mystery x y z = not ((x==y) &amp;&amp; ((fromIntegral y) == z )) </code></pre>  <p>behaves as it seems like it would. It's basically checking if the values are all NOT equal, but doing a type conversion from an <code>Integral</code> <code>y</code> to make sure it can be compared with <code>z</code></p>  <p>If this is true, then why does:</p>  <pre><code>case1 = do      if mystery 1 1 1.00000001 -- a very small number         then putStrLn "True"         else putStrLn "False" </code></pre>  <p>Print False (ie. The values are all equal, so <code>1 == 1 == 1.00000001</code>) whereas:</p>  <pre><code>case2 = do      if mystery 1 1 1.0000001 -- a larger number         then putStrLn "True"         else putStrLn "False" </code></pre>  <p>Prints True? (ie. The values are not all equal)</p>  <p>I know it likely has something to do with precision, but I don't get it. Any help is greatly appreciated.</p>