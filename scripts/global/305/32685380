<p>I believe that 17 decimal places should be enough to correctly represent an 8-byte float, such that it is round-trip safe (converted to a string and back without any loss).</p>  <p>But in this test, the number can go as high as 23, and probably higher if you increase the number of iterations.</p>  <p>Is this a flawed test and why?<br> And how do you ensure a round-trip integrity of a float in Python?</p>  <pre><code>def TestLoop():     sFormat = ''     success = True     ff = [1.0/i for i in range(1,10000000)]     for n in range(17, 31):         sFormat = '{{:.{:d}f}}'.format(n)         success = True         for f in ff:             if f != float(sFormat.format(f)):                 success = False                 break         if success:             return(n)     return(-1)  n = TestLoop()    print('Lossless with ', n, ' decimal places.') </code></pre>  <p><a href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format" rel="nofollow">If an IEEE 754 double precision is converted to a decimal string with at least 17 significant digits and then converted back to double, then the final number must match the original.</a></p>