<p>I am using the softfloat library (<a href="http://www.jhauser.us/arithmetic/SoftFloat.html" rel="nofollow">http://www.jhauser.us/arithmetic/SoftFloat.html</a>) to implement a single precision sqrt algorithm. I am trying to understand the reciprocal sqrt approximation function implemented as part of the softfloat library. Please see below the code. Could anyone explain how they came up with the LUT? It looks like a combination of LUT and NR approximations, but a detailed explanation would definitely help</p>  <pre><code>    /*     Returns an approximation to the reciprocal of the square root of       the number represented by `a', where `a' is interpreted as an         unsigned fixed-point number either with one integer bit and 31       fraction bits or with two integer bits and 30 fraction bits.  The      format of `a' is determined by `oddExpA', which must be either 0 or      1.  If `oddExpA' is 1, `a' is interpreted as having one integer bit,      and if `oddExpA' is 0, `a' is interpreted as having two integer      bits.  The `a' input must be "normalized", meaning that its      most-significant bit (bit 31) must be 1.  Thus, if A is the value of      the fixed-point interpretation of `a', it follows that 1 &lt;= A &lt; 2      when `oddExpA' is 1, and 2 &lt;= A &lt; 4 when `oddExpA' is 0.      The returned value is interpreted as a pure unsigned fraction, having     no integer bits and 32 fraction bits.  The approximation returned is      never greater than the true reciprocal 1/sqrt(A), and it differs      from the true reciprocal by at most 2.06 ulp (units in the last      place).  The approximation returned is also always within the range      0.5 to 1; thus, the most-significant bit of the result is always set.     */       uint32_t softfloat_approxRecipSqrt32_1( unsigned int oddExpA,   uint32_t a )     {         int index;         uint16_t eps;         static const uint16_t k0s[] = {           0xB4C9, 0xFFAB, 0xAA7D, 0xF11C, 0xA1C5, 0xE4C7, 0x9A43, 0xDA29,           0x93B5, 0xD0E5, 0x8DED, 0xC8B7, 0x88C6, 0xC16D, 0x8424, 0xBAE1         };         static const uint16_t k1s[] = {           0xA5A5, 0xEA42, 0x8C21, 0xC62D, 0x788F, 0xAA7F, 0x6928, 0x94B6,           0x5CC7, 0x8335, 0x52A6, 0x74E2, 0x4A3E, 0x68FE, 0x432B, 0x5EFD         };         uint16_t r0;         uint_fast32_t ESqrR0;         uint32_t delta0;         uint_fast32_t r;         uint32_t sqrDelta0;          index = (a&gt;&gt;27 &amp; 0xE) + oddExpA;         eps = (uint16_t) (a&gt;&gt;12);         r0 = k0s[index] - ((k1s[index] * (uint_fast32_t) eps)&gt;&gt;20);         ESqrR0 = (uint_fast32_t) r0 * r0;         if ( ! oddExpA ) ESqrR0 &lt;&lt;= 1;         delta0 = ~(uint_fast32_t) (((uint32_t) ESqrR0 * (uint_fast64_t)  a)&gt;&gt;23);         r = ((uint_fast32_t) r0&lt;&lt;16) + ((r0 * (uint_fast64_t) delta0)&gt;&gt;25);         sqrDelta0 = ((uint_fast64_t) delta0 * delta0)&gt;&gt;32;         r += ((uint32_t) ((r&gt;&gt;1) + (r&gt;&gt;3) - ((uint_fast32_t) r0&lt;&lt;14))           * (uint_fast64_t) sqrDelta0)          &gt;&gt;48;         if ( ! (r &amp; 0x80000000) ) r = 0x80000000;         return r;        } </code></pre>