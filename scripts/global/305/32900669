<p>I was writing a program for finding roots for a class, and had finished and got it working perfectly. As I go to turn it in, I see the document requires the <code>.cpp</code> to compile using Visual Studio 2012 - so I try that out. I normally use Dev C++ - and I've come to find it allows me to compile "funky things" such as dynamically declaring arrays without using malloc or new operators.</p>  <p>So, after finding the error associated with how I wrongly defined my arrays - I tried to fix the problem using <code>malloc</code>, <code>calloc</code>, and <code>new</code>/<code>delete</code> and well - it kept giving me memory allocation errors. The whole 46981239487532-byte error. </p>  <p>Now, I tried to "return" the program to the way it used to be and now I can't even get that to work. I'm not even entirely sure how I set up the arrays to work in Dev C++ in the first place. Here the code:</p>  <pre><code>#include &lt;iostream&gt; #include &lt;stdlib.h&gt; #include &lt;math.h&gt; using namespace std;  float newton(float a, float b, float poly[],float n, float *fx, float *derfx); float horner(float poly[], int n, float x, float *derx); float bisection(float a, float b, float poly[], float n, float *fx);  int main(int argc, char *argv[]) {     float a, b, derr1 = 0, dummyvar = 0, fr1 = 0, fr0;     float constants[argc-3];     //float* constants = NULL;     //constants = new float[argc-3];     //constants = (float*)calloc(argc-3,sizeof(float));     //In order to get a and b from being a char to floating point, the following lines are used.     //The indexes are set relative to the size of argv array in order to allow for dynamically sized inputs. atof is a char to float converter.     a = atof(argv[argc-2]);     b = atof(argv[argc-1]);      //In order to get a easy to work with array for horners method,     //all of the values excluding the last two are put into a new floating point array     for (int i = 0; i &lt;= argc - 3; i++){         constants[i] = atof(argv[i+1]);     }      bisection(a, b, constants, argc - 3, &amp;fr0);     newton(a, b, constants, argc - 3, &amp;fr1, &amp;derr1);     cout &lt;&lt; "f(a) = " &lt;&lt; horner(constants,argc-3,a,&amp;dummyvar);     cout &lt;&lt; ", f(b) = " &lt;&lt; horner(constants,argc-3,b,&amp;dummyvar);     cout &lt;&lt; ", f(Bisection Root) = " &lt;&lt; fr0;     cout &lt;&lt; ", f(Newton Root) = "&lt;&lt;fr1&lt;&lt;", f'(Newton Root) = "&lt;&lt;derr1&lt;&lt;endl;     return 0; } // Poly[] is the polynomial constants, n is the number of degrees of the polynomial (the size of poly[]), x is the value of the function we want the solution for.  float horner(float poly[], int n, float x, float *derx) {     float fx[2] = {0, 0};     fx[0] = poly[0];  // Initialize fx to the largest degree constant.     float derconstant[n];     //float* derconstant = NULL;     //derconstant = new float[n];     //derconstant = (float*)calloc(n,sizeof(float));     derconstant[0] = poly[0];      // Each term is multiplied by the last by X, then you add the next poly constant. The end result is the function at X.     for (int i = 1; i &lt; n; i++){         fx[0] = fx[0]*x + poly[i];         // Each itteration has the constant saved to form the derivative function, which is evaluated in the next for loop.         derconstant[i]=fx[0];     }      // The same method is used to calculate the derivative at X, only using n-1 instead of n.     fx[1] = derconstant[0]; // Initialize fx[1] to the largest derivative degree constant.     for (int i = 1; i &lt; n - 1; i++){         fx[1] = fx[1]*x + derconstant[i];     }     *derx = fx[1];     return fx[0]; }  float bisection(float a, float b, float poly[], float n, float *fx) {     float r0 =0, count0 = 0;     float c = (a + b)/2; // c is the midpoint from a to b     float fc, fa, fb;     int rootfound = 0;     float *derx;     derx = 0; // Needs to be defined so that my method for horner's method will work for bisection.     fa = horner(poly, n, a, derx); // The following three lines use horner's method to get fa,fb, and fc.     fb = horner(poly, n, b, derx);     fc = horner(poly, n, c, derx);      while ((count0 &lt;= 100000) || (rootfound == 0)) { // The algorithm has a limit of 1000 itterations to solve the root.         if (count0 &lt;= 100000) {             count0++;             if ((c == r0) &amp;&amp; (fabs(fc) &lt;= 0.0001)) {                 rootfound=1;                 cout &lt;&lt; "Bisection Root: " &lt;&lt; r0 &lt;&lt; endl;                 cout &lt;&lt; "Iterations: " &lt;&lt; count0+1 &lt;&lt; endl;                 *fx = fc;                 break;             }             else             {                 if (((fc &gt; 0) &amp;&amp; (fb &gt; 0)) || ((fc &lt; 0) &amp;&amp; (fb &lt; 0))) { // Checks if fb and fc are the same sign.                     b = c; // If fc and fb have the same sign, thenb "moves" to c.                     r0 = c; // Sets the current root approximation to the last c value.                     c = (a + b)/2; // c is recalculated.                 }                 else                 {                     a=c; // Shift a to c for next itteration.                     r0=c; // Sets the current root approximation to the last c value.                     c=(a+b)/2; // Calculate next c for next itteration.                 }                 fa = horner(poly, n, a, derx); // The following three send the new a,b,and c values to horner's method for recalculation.                 fb = horner(poly, n, b, derx);                 fc = horner(poly, n, c, derx);             }         }         else         {             cout &lt;&lt; "Bisection Method could not find root within 100000 itterations" &lt;&lt; endl;             break;         }     }     return 0; }  float newton(float a, float b, float poly[],float n, float *fx, float *derfx){     float x0, x1;     int rootfound1 = 1, count1 = 0;     x0 = (a + b)/2;     x1 = x0;     float fx0, derfx0;     fx0 = horner(poly, n, x0, &amp;derfx0);     while ((count1 &lt;= 100000) || (rootfound1 == 0)) {         count1++;         if (count1 &lt;= 100000) {             if ((fabs(fx0) &lt;= 0.0001)) {                 rootfound1 = 1;                 cout &lt;&lt; "Newtons Root: " &lt;&lt; x1 &lt;&lt; endl;                 cout &lt;&lt; "Iterations: " &lt;&lt; count1 &lt;&lt; endl;                  break;             }             else             {                 x1 = x0 - (fx0/derfx0);                 x0 = x1;                 fx0 = horner(poly, n, x0, &amp;derfx0);                 *derfx = derfx0;                 *fx = fx0;             }         }         else         {             cout &lt;&lt; "Newtons Method could not find a root within 100000 itterations" &lt;&lt; endl;             break;         }     }     return 0; } </code></pre>  <p>So I've spent the past several hours trying to sort this out, and ultimately, I've given in to asking.Everywhere I look has just said to define as</p>  <pre><code>float* constants = NULL; constants = new float[size]; </code></pre>  <p>but this keeps crashing my programs - presumably from allocating too much memory somehow. I've commented out the things I've tried in various ways and combonations. If you want a more tl;dr to the "trouble spots", they are at the very beginning of the main and horner functions.</p>