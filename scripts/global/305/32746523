<p>The C standard library provides the <code>round</code>, <code>lround</code>, and <code>llround</code> family of functions in C99. However, these functions are not IEEE-754 compliant, because they do not implement the "banker's rounding" of half-to-even as mandated by IEEE. Half-to-even rounding requires the result to be rounded to the nearest even value if the fractional component is exactly 0.5. The C99 standard instead mandates half-away-from-zero as noted on <a href="http://en.cppreference.com/w/c/numeric/math/round" rel="nofollow">cppreference.com</a></p>  <blockquote>   <p>1-3) Computes the nearest integer value to arg (in floating-point format), rounding halfway cases away from zero, regardless of the current rounding mode.</p> </blockquote>  <p>The usual ad-hoc way to implement rounding in C is the expression <code>(int)(x + 0.5f)</code> which, despite being <a href="http://blog.frama-c.com/index.php?post/2013/05/02/nearbyintf1" rel="nofollow">incorrect</a> in strict IEEE-754 math, is usually translated by compilers into the correct <code>cvtss2si</code> instruction. However, this is certainly not a portable assumption.</p>  <p>How can I implement a function that will round any floating point value with half-to-even semantics? If possible, the function should only rely upon language and standard library semantic, so that it can operate on non-IEEE floating point types. If this is not possible, an answer defined in terms of IEEE-754 bit representations is also acceptable. Please characterize any constants in terms of <code>&lt;limits.h&gt;</code> or <code>&lt;limits&gt;</code>.</p>