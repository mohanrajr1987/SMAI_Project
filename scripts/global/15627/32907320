<p>When I'm trying to create a JSON response with message I get from the channel,  it just hangs when I <code>curl</code> it. </p>  <p>The idea was to write JSON response, when I receive on channel <code>msg</code>, so I need to pass the channel to handler, I tried to manage that with creating a wrapper function for http.HandlerFunc, here's what I have so far:</p>  <pre><code>var msg = make(chan string)  type Response struct {     message string }  func msgHandler(msg chan string) http.HandlerFunc {     return func(w http.ResponseWriter, r *http.Request) {         select {         case m := &lt;-msg:                 fmt.Println(m)                 resp := Response{m}                 js, err := json.Marshal(resp)                 if err != nil {                     log.Fatal(err)                 }                 w.Header().Set("Content-Type", "application/json")                 w.Write(js)         }      }   }  func main() {     http.HandleFunc("/msg", msgHandler(msg))     http.ListenAndServe(":8080", nil)     go startTcpServer() } </code></pre>  <p>When i <code>curl -i localhost:8080/msg</code> and send a message on channel (in different function), it gets printed out, but curl just hangs without receiving a response. What exactly is going on here?</p>  <p><strong>Edit</strong>: I send on channel in following function:</p>  <pre><code>func startTcpServer() {     l, err := net.Listen("tcp",":30000")     if err != nil {         log.Fatal(err)     }     defer l.Close()      for {         conn, err := l.Accept()         if err != nil {             log.Fatal(err)         }         go func(msg chan string, c net.Conn) {                m := make([]byte, 512)                _, err := c.Read(m)                if err != nil {                   log.Fatal(err)                }                msg &lt;- string(m[:msgLen])                c.Close()          }(msg, conn)       }  } </code></pre>