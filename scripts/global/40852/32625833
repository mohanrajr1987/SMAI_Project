<p>I'm writing C# application with typical scenario in which multiple threads use a local variable. I tried to be smart and instead of plainly using <em>lock</em> keyword, I came with following class:</p>  <pre><code>public class LockedVariable&lt;T&gt; {     T innerValue;     object lockObj;     public LockedVariable(T obj)     {         innerValue = obj;         lockObj = new object();     }       public T Value     {         get         {             lock (lockObj)             {                 return innerValue;             }         }         set         {             lock (lockObj)             {                 this.innerValue = value;             }             return;         }     } } </code></pre>  <p>After that, I started doubting a few things about it:</p>  <ol> <li>It's easy to use but will it even work correctly? Maybe it's not thread safe at all and would be only if I surrounded every reference to this class with <em>lock</em> keyword?</li> <li>Maybae somewhere in .NET framework there already is equivalent of such a class?</li> <li>What is the worst thing that can happen if multiple threads try to access the sample local variable (in my case variable of value type like simple Int32, bool, enumeration , etc.)? Will my application crash (throw an exception) right in the moment when two threads try to access the same variable, or what?</li> <li>(related to 3) What if this is a writer-reader scenario (one thread change's variable's value, the other reads it). May not using the <em>lock</em> keyword crash the application, or the worst thing that can happen is that the reader thread will see outdated value?</li> </ol>