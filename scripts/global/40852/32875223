<p>I have walked through the TPL DataFlow and have faced a very irritating problem occurred in the code using <code>TrasformBlock</code> linked to <code>ActionBlock</code>.</p>  <p>Eventually I have found that items got stuck in <code>TransformBlock</code>'s output queue, since its <code>OutputCount</code> property continuously returned the value higher than "0". That's why the whole application deadlocked. However, it unblocks as soon as I call <code>TransformBlock.TryReceiveAll()</code>.</p>  <p>Can anyone, please, let me know if there is something I missed or how to prevent such behavior?</p>  <pre><code>static void Main() {     int total = 0;     int itemsProcessing = 0;      TransformBlock&lt;int, Tuple&lt;int, double&gt;&gt; transformBlock = new TransformBlock&lt;int, Tuple&lt;int, double&gt;&gt;(         i =&gt; new Tuple&lt;int, double&gt;(i, Math.Sqrt(i)),         new ExecutionDataflowBlockOptions         {             BoundedCapacity = 20,             MaxDegreeOfParallelism = DataflowBlockOptions.Unbounded         });      ActionBlock&lt;Tuple&lt;int, double&gt;&gt; outputBlock = new ActionBlock&lt;Tuple&lt;int, double&gt;&gt;(async tuple =&gt;         {             await Task.Delay(1000); // simulating data output delay             Interlocked.Decrement(ref itemsProcessing);         },         new ExecutionDataflowBlockOptions         {             BoundedCapacity = 5,             MaxDegreeOfParallelism = DataflowBlockOptions.Unbounded         });      transformBlock.Completion.ContinueWith(t =&gt; outputBlock.Complete());      using (Timer timer = new Timer(o =&gt;         {             Console.Title = string.Format(                 "{0}: {1}/{2} {3}/{4}/{5}",                 Assembly.GetExecutingAssembly().GetName().Name,                 Volatile.Read(ref itemsProcessing), Volatile.Read(ref total),                 transformBlock.InputCount, transformBlock.OutputCount, outputBlock.InputCount);         }, null, 100, 100))     {         using (transformBlock.LinkTo(outputBlock, new DataflowLinkOptions { PropagateCompletion = true }))         {             for (int i = 0; i &lt; 40; i++)             {                 Thread.Sleep(100); // simulating new item retrieval delay                  Interlocked.Increment(ref total);                 Interlocked.Increment(ref itemsProcessing);                  transformBlock.SendAsync(i).Wait();             }         }          Console.WriteLine("Enqueued");          transformBlock.Complete();         outputBlock.Completion.Wait();          Console.WriteLine("Finish");          timer.Change(Timeout.Infinite, Timeout.Infinite);         timer.Dispose();     } } </code></pre>