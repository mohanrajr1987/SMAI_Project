<p><strong>Overview</strong></p>  <p>I have been working for quite some time trying to find a post that addresses my particular situation, but have come up empty. I am attempting to create a C# .NET console application that will parse an XML file with multiple database restore definitions, and then subsequently launch those restores in parallel using SQL Management Objects. After each restore, the user may specify zero to many SQL files that they would wish to run against the newly restored database. Whenever I attempt more than 4 of these jobs in parallel, the static method handling the execution of SQL files against the database chokes on calling the ExecuteNonQuery() method against the locally created ServerConnection. Am I implementing this incorrectly? Any suggestions on how I can make this work?</p>  <p><strong>Attempted solutions</strong></p>  <ul> <li>Using Parallel.ForEach loop to execute jobs</li> <li>Using Task.Factory.StartNew() to execute jobs</li> </ul>  <p>In both of the above methods, I am calling out to two static methods:</p>  <ol> <li>One that handles the restore using SMO.</li> <li>One that handles the execution of of SQL scripts against the database using SMO.</li> </ol>  <p><strong>Calling code</strong></p>  <pre><code>            Parallel.ForEach(restores.Restore,             //new ParallelOptions {MaxDegreeOfParallelism = 4},             restore =&gt;              {                 //Grab copies of the backup information                 string backup = restore.Backup;                 string server = restore.Server;                 string database = restore.Database;                 string[] patchFiles = restore.PatchFiles;                  //Begin by restoring the database from the backup file                 RestoreDatabaseFromBackup(backup, server, database);                  //Execute each patch file sequentially for the restore defintion                 foreach (string patchFile in patchFiles)                 {                     ExecutePatchFile(patchFile, server, database);                 }             }); </code></pre>  <p><strong>ExecutePathFile Method</strong></p>  <pre><code>private static void ExecutePatchFile(string patchFile, string server, string database)     {         //Create directory for the log file (if it doesn't already exist)         DirectoryInfo di = CreateLogFileDirectory(server, database);          //Create the log file         StreamWriter sw = File.CreateText(Path.Combine(di.FullName, Path.GetFileNameWithoutExtension(patchFile) + ".log"));          Console.WriteLine("{0} : Beginning execution of {1} for {2} on {3}.", DateTime.Now, patchFile, database, server);          //Verify that 'patchFile' exists and is of the right file extension         if (!File.Exists(patchFile) || Path.GetExtension(patchFile) != ".sql")         {             Console.WriteLine("{0} : Could not execute {1} for {2} on {3}. Invalid SQL file.", DateTime.Now, Path.GetFileName(patchFile), database, server);             sw.WriteLine("{0} : Could not execute {1} for {2} on {3}. Invalid SQL file.", DateTime.Now, Path.GetFileName(patchFile), database, server);             sw.Close();             return;         }          string script = File.ReadAllText(patchFile);          try         {             //Build out connection string             SqlConnectionStringBuilder sb = new SqlConnectionStringBuilder();             sb.DataSource = server;             sb.InitialCatalog = database;             sb.IntegratedSecurity = true;              //Create SqlConnection             SqlConnection sqlCon = new SqlConnection(sb.ToString());             //Set sqlCon to treat exceptions as infomessages             sqlCon.FireInfoMessageEventOnUserErrors = true;              //Create ServerConnection             ServerConnection serverCon = new ServerConnection(sqlCon);              serverCon.InfoMessage += new SqlInfoMessageEventHandler((sender, e) =&gt; ConnectionContext_InfoMessage(sender, e, sw));             serverCon.ExecuteNonQuery(script, ExecutionTypes.ContinueOnError);         }         catch (Exception e)         {             throw e;         }         finally         {             sw.Close();         }      } </code></pre>  <p><strong>Stack Trace</strong></p>  <pre><code>System.Reflection.TargetInvocationException was unhandled by user code   HResult=-2146232828   Message=Exception has been thrown by the target of an invocation.   Source=BatchDatabaseRestorer   StackTrace:        at BatchDatabaseRestorer.Program.ExecutePatchFile(String patchFile, String server, String database) in c:\Users\zannett\Documents\Visual Studio 2013\Projects\BatchDatabaseRestorer\BatchDatabaseRestorer\Program.cs:line 224        at BatchDatabaseRestorer.Program.&lt;Main&gt;b__0(RestoresRestore restore) in c:\Users\zannett\Documents\Visual Studio 2013\Projects\BatchDatabaseRestorer\BatchDatabaseRestorer\Program.cs:line 83        at System.Threading.Tasks.Parallel.&lt;&gt;c__DisplayClass21`2.&lt;ForEachWorker&gt;b__17(Int32 i)        at System.Threading.Tasks.Parallel.&lt;&gt;c__DisplayClassf`1.&lt;ForWorker&gt;b__c()   InnerException: Microsoft.SqlServer.Management.Common.ExecutionFailureException        HResult=-2146233087        Message=Parse error occurred while looking for GO statement. Line 0.        Source=Microsoft.SqlServer.BatchParserClient        StackTrace:             at Microsoft.SqlServer.Management.Common.ExecuteBatch.GetStatements(String sqlCommand)        InnerException: ManagedBatchParser.ParserException             HResult=-2146233088             Message=""             Source=Microsoft.SqlServer.BatchParser             StackTrace:                  at ManagedBatchParser.Parser.Parse()                  at Microsoft.SqlServer.Management.Common.ExecuteBatch.GetStatements(String sqlCommand)             InnerException:  </code></pre>