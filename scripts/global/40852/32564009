<p>I have a WPF application that communicate with the server via WCF. I execute a method on the remote server and the callback method initializes a list with the results which running on a different thread. - This is fine and this is exactly the purpose of my application.</p>  <p>But when I want to add some more items to this list, it throws an exception that I can't add items from a different thread which has initialized this list.</p>  <pre><code>public ObservableCollection&lt;ListBoxItemVM&lt;T&gt;&gt; Items {     get { return items; }     set     {         // This section runs on a separate thread.         items = value;         notify("Items");         if (allItems == null)             allItems = new ObservableCollection&lt;ListBoxItemVM&lt;T&gt;&gt;(items.Clone());          // I want to save the current context here and use it on the AddItem method          CollectionView view = (CollectionView)CollectionViewSource.GetDefaultView(Items);         view.Filter = searchFilter;     } }  public void AddItem(ListBoxItemVM&lt;T&gt;  {     this.items.Add(item); // The following exception throws here } </code></pre>  <blockquote>   <p>Exception: This type of CollectionView does not support changes to its SourceCollection from a thread different from the Dispatcher thread.</p> </blockquote>  <p>I'm looking for some way to save the thread (or thread's ExecuteContext) that  the list was initialized with, and add items to that list with this thread/context.</p>  <p>It should be mentioned that there is nothing to do with the UI thread, I handled the marshaling with the UI thread on another region in my code. I've tried to marshal the <code>this.items.Add(item);</code> code with the UI SynchronizationContext, buy they are different so it fails.</p>  <p>Thanks</p>