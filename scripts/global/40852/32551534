<p>Follow-up to <a href="http://stackoverflow.com/q/32542861/62600">this question</a>. I have a library with many async methods that thinly wrap <a href="https://msdn.microsoft.com/en-us/library/system.net.http.httpclient.aspx" rel="nofollow"><code>HttpClient</code></a>. Effectively they just do some setup and directly return the <code>Task</code> returned from the <code>HttpClient</code> call:</p>  <pre><code>public Task DoThingAsyc() {     // do some setup     return httpClient.DoThingAsync(); } </code></pre>  <p>I'm pondering whether to add <code>ConfigureAwait(false)</code> to these calls. The prevailing wisdom seems to be "yes, always do that in libraries." But in this case, it would introduce some (perhaps negligible) overhead, because <code>ConfigureAwait</code> returns a <code>ConfiguredTaskAwaitable</code> which would need to be wrapped back into a <code>Task</code> in order to not change the method signature. Certainly not hard to code:</p>  <pre><code>public async Task DoThingAsyc() {     // do some setup     return await httpClient.DoThingAsync().ConfigureAwait(false); } </code></pre>  <p>My question is, will the efficiency benefits of <code>ConfigureAwait(false)</code> likely outweigh the extra overhead introduced in this case? What example above would be considered the better practice?</p>