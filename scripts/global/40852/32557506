<p>I read some posts here on TPL but need some clarification. I have a long running process that sits and waits for the client connections.  When I want it to stop, it needs to finish whatever it's is doing to (successful) completion, end and release the resources.  Here is an example of what I am trying.</p>  <pre><code>private CancellationTokenSource cts = new CancellationTokenSource();           public void SomeMethod(){    var task = new Task(()=&gt; MethodA(cts), cts.Token, TaskCreationOptions.LongRunning);   task.Start();   //task.Wait(); }  public void MethodA() {    cts.Token.Register(() =&gt; {            SomeObj.Stop();     });     SomeObj.Start(); }  public void EndTheLongProcess() {     cts.Cancel();     cts.Dispose(); } </code></pre>  <p>When the token is canceled, the anonymous callback method inside MethodA calls the stop on the long running process. If I don't call the cancel, this process will run forever. Am I approaching this right?   </p>  <p>I see a lot of examples here showing just <code>task.Wait()</code> without <code>cts.Cancel()</code>.  Does <code>task.Wait()</code> wait for the task to finish and then invoke the <code>cts.Cancel()</code> and <code>cts.Dispose()</code> behind the scene? </p>  <p>Looks like I need a try/catch if I use the <code>task.Wait()</code></p>  <pre><code>try{   task.Wait(); } Catch(Exception ex) {   Log.Info("Task Cancelled before completion..."); } </code></pre>  <p>Is the main thread blocked at <code>task.Wait()</code> or do I need <code>task.Wait()</code> at all?</p>