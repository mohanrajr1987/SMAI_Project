<p>I have used the following code:</p>  <pre><code>var tuple = Tuple.Create("xxx.xx.xx.xxx", 6102, "109", "Metrix1", 1); var tuple1 = Tuple.Create("xxx.xx.xx.xxx", 6102, "110", "Metrix2", 1); var tuple2 = Tuple.Create("xxx.xx.xx.xxx", 6102, "111", "Metrix3", 1); var tuple3 = Tuple.Create("xxx.xx.xx.xxx", 6103, "106", "Metrix4", 2);  gateways.Add(tuple); gateways.Add(tuple1); gateways.Add(tuple2); gateways.Add(tuple3);  foreach (var gatewayId in gateways) {     Task.Factory.StartNew(         () =&gt; GetJobs(             gatewayId.Item1,             gatewayId.Item2,             gatewayId.Item3,             gatewayId.Item4,             gatewayId.Item5)); } </code></pre>  <p>This then calls GetJobs which calls <code>CallGateway</code> and if required <code>ProcessMessageNew</code></p>  <pre><code>private string GetJobs(string Url , int portNumber, string Engineer , string mEngineer , int GatewayId) {     ConfigLogger.Instance.LogInfo("info", "Calling Gateway Start: " + DateTime.Now.ToString("HH:mm:ss.ffff") + " for engineer: " + Engineer);     string gatewayResult = CallGateway(Engineer, Url, portNumber);     ConfigLogger.Instance.LogInfo("info", "Calling Gateway End: " + DateTime.Now.ToString("HH:mm:ss.ffff") + " for engineer: " + Engineer);     if (gatewayResult != null)     {         ConfigLogger.Instance.LogInfo("info", "Processing Request Message: " + DateTime.Now.ToString("HH:mm:ss.ffff") + " for engineer: " + Engineer);         ProcessMessageNew(gatewayResult, Engineer, Url, portNumber , MEngineer ,PGatewayId);     }     return gatewayResult; } </code></pre>  <p><code>CallGateway</code>:</p>  <pre><code>public string CallGateway(string gatewayUrl, int portNumber , string engineer) {      string result = null;      int streamBufferSize = 1000;       IPHostEntry ipHostInfo = Dns.Resolve(gatewayUrl.ToString());      IPAddress ipAddress = ipHostInfo.AddressList[0];      IPEndPoint remoteEP = new IPEndPoint(ipAddress, portNumber);       // Create a TCP/IP  socket.      Socket clientSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);      clientSocket.Connect(ipAddress, portNumber);       // Set these on app param      clientSocket.ReceiveTimeout = 300000;      clientSocket.SendTimeout = 60000;      // build message string to send to gateway      string message = BuildMessageGetJobsFromGateway(engineer, SendTypeIn);       // Create a NetworkStream that owns clientSocket and       // then create a BufferedStream on top of the NetworkStream.       // Both streams are disposed when execution exits the       // using statement.       using (var netStream = new NetworkStream(clientSocket, true),             var bufStream = new BufferedStream(netStream, streamBufferSize))      {           // Check whether the underlying stream supports seeking.           Console.WriteLine("NetworkStream {0} seeking.\n", bufStream.CanSeek ? "supports" : "does not support");            //variable used to only close once           bool doClose = true;            // Send and receive data.            if (bufStream.CanWrite)           {               try               {                   SendData(netStream, bufStream, SendTypeIn, message);               }               catch (Exception exSend)               {                   Console.WriteLine(exSend.Message.ToString());               }            }            if (bufStream.CanRead)            {                 try                 {                      result = ReceiveData(netStream, bufStream, clientSocket);                 }                 catch (Exception exRecieve)                 {                     //                 }                 finally                 {                     Console.WriteLine("Closing Stream");                     doClose = false;                     bufStream.Close();                     clientSocket.Close();                 }             }              // When bufStream is closed, netStream is in turn              // closed, which in turn shuts down the connection              // and closes clientSocket.             Console.WriteLine("\nShutting down the connection.");              // only close if no exception is raised             if (doClose)             {                 bufStream.Close();                 clientSocket.Close();             }         }         return result;     } } </code></pre>  <p>However, I get this in the log file 4 calls to the call gateway method and only one return for engineer 106, the call to gateway creates a Socket Client which then receive data but it is only happening for one out of the 4 calls :</p>  <pre><code>[MobileGateway.exe] - [Info] - [25/09/2015 16:47:19] - Calling Gateway Start: 16:47:19.6574 for engineer: 109 [MobileGateway.exe] - [Info] - [25/09/2015 16:47:19] - Processing Call Mobile Gateway: 16:47:19.6624 [MobileGateway.exe] - [Info] - [25/09/2015 16:47:20] - Calling Gateway Start: 16:47:20.6685 for engineer: 110 [MobileGateway.exe] - [Info] - [25/09/2015 16:47:20] - Processing Call Mobile Gateway: 16:47:20.6875 [MobileGateway.exe] - [Info] - [25/09/2015 16:47:21] - Calling Gateway Start: 16:47:21.6696 for engineer: 111 [MobileGateway.exe] - [Info] - [25/09/2015 16:47:21] - Processing Call Mobile Gateway: 16:47:21.6716 [MobileGateway.exe] - [Info] - [25/09/2015 16:47:22] - Calling Gateway Start: 16:47:22.6686 for engineer: 106 [MobileGateway.exe] - [Info] - [25/09/2015 16:47:22] - Processing Call Mobile Gateway: 16:47:22.6706 [MobileGateway.exe] - [Info] - [25/09/2015 16:47:23] - Processing Call Mobile Ended: 16:47:23.0476 [MobileGateway.exe] - [Info] - [25/09/2015 16:47:23] - Calling Gateway End: 16:47:23.0486 for engineer: 106 [MobileGateway.exe] - [Info] - [25/09/2015 16:47:23] - Processing Request Message: 16:47:23.0486 for engineer: 106 [MobileGateway.exe] - [Info] - [25/09/2015 16:47:23] - Message Recieved From Gateway: 16:47:23.0496 </code></pre>  <p>The calls should be processed in Parallel or Asyncronously as there is a requirement to call this method simultaneously over 1000 times and they are long running processes so I need to process multiple at a time.</p>  <p>Any ideas why I am getting 1 response instead of 4 ?</p>