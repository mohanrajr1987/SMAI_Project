<p>I currently am using observables to manage messages being generated on bus which are being pushed over various streams. </p>  <p>All works well but as messages can come in, it's possible for the system to try and write multiple messages to the stream at once (i.e. messages coming in from multiple threads) or that messages are published quicker than they can be written to the stream... as you can image, this causes issues when writing. </p>  <p>Hence I'm trying to figure out how I can organize things so that when messages come in only one will be processed at a time. Any thoughts?</p>  <pre><code>public class MessageStreamResource : IResourceStartup {     private readonly IBus _bus;     private readonly ISubject&lt;string&gt; _sender;      public MessageStreamResource(IBus bus)     {         _bus = bus;          _senderSubject = new Subject&lt;string&gt;();          //`All` can publish messages at the same time as it's         //collecting data being generated from different threads         _bus.All.Subscribe(message =&gt; Observable.Start(() =&gt; ProcessMessage(message), TaskPoolScheduler.Default));          //Note the above hops off the calls context so that the          //writing to the stream wont slow down the caller.     }      public void Configure(IAppBuilder app)     {         app.Map("/stream", async context =&gt;         {             ...              await context.Response.WriteAsync("Lets party!\n");             await context.Response.Body.FlushAsync();              var unSubscribe = _sender.Subscribe(async t =&gt;             {                 //PROBLEM HERE                 //I only want this callback to be executed                  //one at a time...                  await context.Response.WriteAsync($"{t}\n");                 await context.Response.Body.FlushAsync();             });              ...              await HoldOpenTask;         });     }      private void ProcessMessage(IMessage message)     {         _sender.OnNext(message.Payload);     } } </code></pre>