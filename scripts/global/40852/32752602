<p>I have to write a program where I'm reading from a database the queues to process and all the queues are run in parallel and managed on the parent thread using a ConcurrentDictionary.  I have a class that represents the queue, which has a constructor that takes in the queue information and the parent instance handle. The queue class also has the method that processes the queue. </p>  <p>Here is the Queue Class:</p>  <pre><code>Class MyQueue {  protected ServiceExecution _parent; protect string _queueID;  public MyQueue(ServiceExecution parentThread, string queueID) { _parent = parentThread; _queueID = queueID; } public void Process() {     try     {        //Do work to process     }     catch()     {        //exception handling     }     finally{        _parent.ThreadFinish(_queueID);     } </code></pre>  <p>The parent thread loops through the dataset of queues and instantiates a new queue class. It spawns a new thread to execute the Process method of the Queue object asynchronously. This thread is added to the ConcurrentDictionary and then started as follows:</p>  <pre><code>private ConcurrentDictionary&lt;string, MyQueue&gt; _runningQueues = new ConcurrentDictionary&lt;string, MyQueue&gt;();  Foreach(datarow dr in QueueDataset.rows) {    MyQueue queue = new MyQueue(this, dr["QueueID"].ToString());    Thread t = new Thread(()=&gt;queue.Process());    if(_runningQueues.TryAdd(dr["QueueID"].ToString(), queue)    {        t.start();    } }  //Method that gets called by the queue thread when it finishes public void ThreadFinish(string queueID) {     MyQueue queue;     _runningQueues.TryRemove(queueID, out queue); } </code></pre>  <p>I have a feeling this is not the right approach to manage the asynchronous queue processing and I'm wondering if perhaps I can run into deadlocks with this design? Furthermore, I would like to use Tasks to run the queues asynchronously instead of the new Threads. I need to keep track of the queues because I will not spawn a new thread or task for the same queue if the previous run is not complete yet. What is the best way to handle this type of parallelism?</p>  <p>Thanks in advance!</p>