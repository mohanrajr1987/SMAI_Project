<p>As part of a library using <a href="https://raw.githubusercontent.com/damianh/Obsolete-Cedar/master/src/Cedar.GetEventStore/Handlers/ResolvedEventDispatcher.cs" rel="nofollow">this code</a>, there is a <code>SimpleQueue</code> class to decouple the producer from consumer:</p>  <pre><code>private class SimpleQueue {     private readonly Func&lt;ResolvedEvent, CancellationToken, Task&gt; _onResolvedEvent;     private readonly CancellationToken _token;     private readonly ConcurrentQueue&lt;ResolvedEvent&gt; _events;     private readonly InterlockedBoolean _isPushing;     private static readonly ILog s_logger;      static SimpleQueue()     {         s_logger = LogProvider.For&lt;SimpleQueue&gt;();     }      public SimpleQueue(Func&lt;ResolvedEvent, CancellationToken, Task&gt; onResolvedEvent, CancellationToken token)     {         _onResolvedEvent = onResolvedEvent;         _token = token;         _events = new ConcurrentQueue&lt;ResolvedEvent&gt;();         _isPushing = new InterlockedBoolean();     }      public void Enqueue(ResolvedEvent resolvedEvent)     {         _events.Enqueue(resolvedEvent);         Push();     }      private void Push()     {         if(_isPushing.CompareExchange(true, false))         {             return;         }         Task.Run(async () =&gt;         {             ResolvedEvent resolvedEvent;             while (!_token.IsCancellationRequested &amp;&amp; _events.TryDequeue(out resolvedEvent))             {                 try                 {                     await _onResolvedEvent(resolvedEvent, _token);                 }                 catch(Exception ex)                 {                     s_logger.ErrorException(ex.Message, ex);                 }             }             _isPushing.Set(false);         }, _token);     } } </code></pre>  <p>I think I can see an issue here, in that if:</p>  <ol> <li>In the task thread, the call <code>events.TryDequeue(out resolvedEvent))</code> returns <code>false</code></li> <li>Then context switches to the other thread</li> <li>In the other thread event is enqueued, <code>Push()</code> is called but returns immediately as <code>_isPushing</code> is <code>true</code></li> <li>The context switches back to the task thread, <code>_isPushing</code> is set to <code>false</code> and the task exits</li> </ol>  <p>In this case there would be on event in the queue that is not dispatched until the next enqueue and loop in <code>Push()</code> to dequeue. If so I don't think I like this.</p>  <p><strong>So instead i rewrote to use a TPL BlockingQueue:</strong></p>  <pre><code>public class SimpleQueue&lt;T&gt; {     readonly BufferBlock&lt;T&gt; _queue = new BufferBlock&lt;T&gt;();      public SimpleQueue(Func&lt;T, CancellationToken, Task&gt; onItemQueued, CancellationToken token)     {         Task.Run(async () =&gt;         {             while (true)             {                 try                 {                     var item = await _queue.ReceiveAsync(token);                     if (token.IsCancellationRequested)                         return;                     await onItemQueued(item, token);                 }                 catch (Exception ex)                 {                     // log                 }             }         }, token);     }      public void Enqueue(T item)     {         _queue.Post(item);     } }  class Program {     private readonly static SimpleQueue&lt;string&gt; Queue;     private readonly static CancellationToken CancellationToken = new CancellationToken();      static async Task OnEvent(string item, CancellationToken cancellationToken)     {         await Task.Run(() =&gt;         {             Console.WriteLine("Rx from remote {0}", item);          }, cancellationToken);     }      static Program()     {         Queue = new SimpleQueue&lt;string&gt;(OnEvent, CancellationToken);     }      static void Main(string[] args)     {         // wire up code to call ExternalReceive from 3rd party lib         DevLinkImports.DLRegisterType2CallDeltas(0,CallEvent);          Console.ReadLine();     }      // this is called by 3rd party dll on demand     static void CallEvent(uint pbxh, string info)     {         // we must dispatch and return within 50ms or 3rd party lib will go ape         Queue.Enqueue(info);       } </code></pre>  <p><strong>Questions:</strong></p>  <ol> <li><p>For learning purposes am I correct in seeing the issue with the original SimpleQueue and items could be left depending on timing?</p></li> <li><p>Without "premature optimization" i feel it only sensible to ask, what is the overhead of spinning up a new thread for each call to <code>static async Task OnEvent(string item, CancellationToken cancellationToken)</code>?</p></li> <li><p>With the rewrite I am not holding threads open when sleeping, but in reality is there any benefit of using this async call or just instead spin up a single thread and use a <code>BlockingCollection</code> and blocking on dequeue? I don't want to save one thread for sacrificing time taken to spin up new threads.</p></li> </ol>