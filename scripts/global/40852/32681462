<p>I have the following code that start as a child task to get all files in given directory and do something on theme and call the event for each file to alert parent task :</p>  <pre><code>internal class FileFinder {     private readonly string _fileFormat;      public delegate void FileFoundDelegate(string filePath);      public event FileFoundDelegate OnFileFound;      public FileFinder(string fileFormat)     {         _fileFormat = fileFormat;     }      public bool Start(CancellationToken cancellationToken, string directory)     {         try         {             if (OnFileFound == null)                 return false;              var foundedFiles = new ThreadLocal&lt;IEnumerable&lt;string&gt;&gt;();             try             {                 foundedFiles.Value = Directory.EnumerateFiles(directory, _fileFormat, SearchOption.AllDirectories)                     .AsParallel();             }             catch (Exception ex)             {                 Debug.WriteLine("Parallel : " + ex.Message);             }              foreach (var file in foundedFiles.Value)             {                 if (cancellationToken.IsCancellationRequested)                     return true;                  // Call file found event with normalized file name                 OnFileFound?.Invoke(file);             }              return true;         }         catch (Exception ex)         {             Common.DebugLog(System.Reflection.MethodBase.GetCurrentMethod().Name,                 ex.InnerException?.Message ?? ex.Message);             return false;      }    } } </code></pre>  <p>and call it using a parent task called Scatter, the scatter run 5 seprate task that FileFinder is one of theme :</p>  <pre><code>internal class Scatter     {         private readonly CancellationToken _cancellationToken;         private readonly string _directory;         private readonly string _fileFormat;          private FileFinder _emailFinder;          public Scatter(CancellationToken cancellationToken, string directory, string fileFormat)         {             _cancellationToken = cancellationToken;             _directory = directory;             _fileFormat = fileFormat;         }          public Task Start()         {             try             {                 return Task.Factory.StartNew(StartProc,                     TaskCreationOptions.AttachedToParent | TaskCreationOptions.LongRunning);             }             catch (Exception)             {                 return null;             }         }          private void StartProc()         {             try             {                 // Find pdf files                 _emailFinder = new FileFinder(_fileFormat);                 _emailFinder.OnFileFound += FileFound;                 Task.Factory.StartNew(() =&gt; _emailFinder.Start(_cancellationToken, _directory),                     TaskCreationOptions.AttachedToParent | TaskCreationOptions.LongRunning);             }             catch (Exception ex)             {                 Common.DebugLog(System.Reflection.MethodBase.GetCurrentMethod().Name, ex.InnerException.Message);             }         }          private void FileFound(string filePath)         {             Debug.WriteLine("File Found");         }     } </code></pre>  <p>finally a master task run separate scatter for each directory :</p>  <pre><code>internal class Master     {         private readonly CancellationToken _cancellationToken;          internal delegate void ParseFinish();         public event ParseFinish OnParseFinish;          public Master(CancellationToken cancellationToken)         {             _cancellationToken = cancellationToken;         }          public bool Start(List&lt;string&gt; targetDirectories, string fileFormat)         {             try             {                 Task.Factory.StartNew(() =&gt; StartProc(targetDirectories, fileFormat), _cancellationToken);                 return true;             }             catch (Exception ex)             {                 Common.DebugLog(System.Reflection.MethodBase.GetCurrentMethod().Name,                     ex.InnerException?.Message ?? ex.Message);                 return false;             }         }          private bool StartProc(List&lt;string&gt; directories, string fileFormat)         {             try             {                 List&lt;Task&gt; targetScatterList = new List&lt;Task&gt;();                  foreach (string dir in directories)                 {                     var scatter = new Scatter(_cancellationToken,dir, fileFormat);                      targetScatterList.Add(scatter.Start());                 }                  // Wait for finish all tasks &amp; call parse finish event                 Task.WaitAll(targetScatterList.ToArray());                 OnParseFinish?.Invoke();                  return true;             }             catch (Exception ex)             {                 Common.DebugLog(System.Reflection.MethodBase.GetCurrentMethod().Name,                     ex.InnerException?.Message ?? ex.Message);                 return false;             }         }     } </code></pre>  <p>i have master task to wait for all directories's task to finish and don't involving the application main thread .</p>  <p>master task call from main thread like this :</p>  <pre><code>    List&lt;string&gt; directoryList = ListBox1.Items.Cast&lt;string&gt;().ToList();      // Create cancelation token     _cancellationTokenSource = new CancellationTokenSource();     _cancellationToken = _cancellationTokenSource.Token;      // Start master task that populate new task for each target     var masterTask= new Master(_cancellationToken);     masterTask.OnParseFinish += ParseFinish;     masterTask.Start(directoryList, tbFileFormat.Text); </code></pre>  <p>I have 287,198 PDF files in sample books directors, the FileFound event called random times in different run of project (287170, 287182, 287146 and etc) and do not iterate on all founded items .</p>  <p>in small file list it dose not show big difference</p>  <p>I think the parent task goes to finish and the child immediately goes to kill .</p>  <p>Any idea ?</p>  <p>Thanks .</p>