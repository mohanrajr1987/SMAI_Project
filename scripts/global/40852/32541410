<p>there have been some time since i worked with tasks and lambda expressions. Is this a good way to run a anonymous task with a lambda expression and then run code on the UI thread when task is finished?</p>  <pre><code>private void btn_mods_Click(object sender, RoutedEventArgs e) {     function_buttons_stackpanel.IsEnabled = false;     Loading();     Task task = new Task(() =&gt; {         if (IsServiceIsUp() != false)         {             webServiceMods = JsonConvert.DeserializeObject(_webServiceResponse).mods;             webServiceBaseUrl = JsonConvert.DeserializeObject(_webServiceResponse).basePath;             Console.Write(webServiceBaseUrl);          }     });     task.Start();     task.ContinueWith((foo) =&gt;     {         FinishedLoading();         function_buttons_stackpanel.IsEnabled = true;     }, TaskScheduler.FromCurrentSynchronizationContext());  }  private void Loading() {     img_loading.Visibility = Visibility.Visible; }  private void FinishedLoading() {     img_loading.Visibility = Visibility.Collapsed; } </code></pre>  <p>I tried to chain the task.Start directly but that gave me an error <code>Cannot Implicitly convert type void to System.Threading.Tasks.Task</code>.</p>  <p>Basically what i wanted to do was to chain the whole process from start to end.</p>  <pre><code>Task task = new Task(() =&gt; {     if (IsServiceIsUp() != false)     {         webServiceMods = JsonConvert.DeserializeObject(_webServiceResponse).mods;         webServiceBaseUrl = JsonConvert.DeserializeObject(_webServiceResponse).basePath;         Console.Write(webServiceBaseUrl);      } }).Start(); </code></pre>  <p>In PHP I would do something like this:</p>  <pre><code>$task = new Task(() =&gt; {     if (IsServiceIsUp() != false)     {         $webServiceMods = JsonConvert::DeserializeObject($_webServiceResponse).mods;         $webServiceBaseUrl = JsonConvert::DeserializeObject($_webServiceResponse).basePath;         Console::Write($webServiceBaseUrl);      } }) -&gt;Start() -&gt;ContinueWith(($foo) =&gt; {     FinishedLoading();     $function_buttons_stackpanel.IsEnabled = true; }, TaskScheduler::FromCurrentSynchronizationContext()); </code></pre>  <p>Is this possible? If so, is there any reason to not do it, and if there is a better way to do this, could you give me an example?</p>  <p>And thanks!</p>