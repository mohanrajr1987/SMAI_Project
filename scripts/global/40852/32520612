<p>Good day! I am writing a helper library for WinForms UI. Started using TPL async/await mechanism and got a problem with this kind of code example : </p>  <pre><code>    private SynchronizationContext _context;      public void UpdateUI(Action action)     {         _context.Post(delegate { action(); }, null);     }       private async void button2_Click(object sender, EventArgs e)     {          var taskAwait = 4000;         var progressRefresh = 200;         var cancellationSource = new System.Threading.CancellationTokenSource();          await Task.Run(() =&gt; { UpdateUI(() =&gt; { button2.Text = "Processing..."; }); });          Action usefulWork = () =&gt;         {             try             {                 Thread.Sleep(taskAwait);                 cancellationSource.Cancel();             }             catch { }         };         Action progressUpdate = () =&gt;         {             int i = 0;             while (i &lt; 10)             {                 UpdateUI(() =&gt; { button2.Text = "Processing " + i.ToString(); });                 Thread.Sleep(progressRefresh);                 i++;             }             cancellationSource.Cancel();         };          var usefulWorkTask = new Task(usefulWork, cancellationSource.Token);         var progressUpdateTask = new Task(progressUpdate, cancellationSource.Token);          try         {             cancellationSource.Token.ThrowIfCancellationRequested();             Task tWork = Task.Factory.StartNew(usefulWork, cancellationSource.Token);             Task tProgress = Task.Factory.StartNew(progressUpdate, cancellationSource.Token);             await Task.Run(() =&gt;             {                 try                 {                     var res = Task.WaitAny(new[] { tWork, tProgress }, cancellationSource.Token);                                         }                 catch { }             }).ConfigureAwait(false);         }         catch (Exception ex)         {         }         await Task.Run(() =&gt; { UpdateUI(() =&gt; { button2.Text = "button2"; }); });     } </code></pre>  <p>Basically, the idea is to run two parallel tasks - one is for, say, progress bar or whatever update and a sort of timeout controller, the other is the long running task itself. Whichever task finishes first cancels the other one. So, there should not be a problem to cancel the "progress" task as it has a loop in which I can check if task is marked cancelled. The problem is with the long running one. It could be Thread.Sleep() or SqlConnection.Open(). When I run CancellationSource.Cancel(), the long running task keeps working and does not cancel. After a timeout I am not interested in long running task or whatever it may result in.<br> As the cluttered code example may suggest, I have tried a bunch of variants and none given me a desired effect. Something like Task.WaitAny() freezes UI... Is there a way to make that cancellation work or may be even a different approach to code these things?</p>  <p><strong>UPD:</strong>    </p>  <pre><code>public static class Taskhelpers {     public static async Task&lt;T&gt; WithCancellation&lt;T&gt;(this Task&lt;T&gt; task, CancellationToken cancellationToken)     {         var tcs = new TaskCompletionSource&lt;bool&gt;();         using (cancellationToken.Register(s =&gt; ((TaskCompletionSource&lt;bool&gt;)s).TrySetResult(true), tcs))         {             if (task != await Task.WhenAny(task, tcs.Task))                 throw new OperationCanceledException(cancellationToken);         }         return await task;     }     public static async Task WithCancellation(this Task task, CancellationToken cancellationToken)     {         var tcs = new TaskCompletionSource&lt;bool&gt;();         using (cancellationToken.Register(s =&gt; ((TaskCompletionSource&lt;bool&gt;)s).TrySetResult(true), tcs))         {             if (task != await Task.WhenAny(task, tcs.Task))                 throw new OperationCanceledException(cancellationToken);         }         await task;     } } </code></pre>  <p>.....</p>  <pre><code>        var taskAwait = 4000;         var progressRefresh = 200;         var cancellationSource = new System.Threading.CancellationTokenSource();         var cancellationToken = cancellationSource.Token;          var usefulWorkTask = Task.Run(async () =&gt;         {             try             {                 System.Diagnostics.Trace.WriteLine("WORK : started");                  await Task.Delay(taskAwait).WithCancellation(cancellationToken);                  System.Diagnostics.Trace.WriteLine("WORK : finished");             }             catch (OperationCanceledException) { }  // just drop out if got cancelled             catch (Exception ex)             {                 System.Diagnostics.Trace.WriteLine("WORK : unexpected error : " + ex.Message);             }         }, cancellationToken);          var progressUpdatetask = Task.Run(async () =&gt;         {             for (var i = 0; i &lt; 25; i++)             {                 if (!cancellationToken.IsCancellationRequested)                 {                     System.Diagnostics.Trace.WriteLine("==== : " + i.ToString());                     await Task.Delay(progressRefresh);                 }             }         },cancellationToken);          await Task.WhenAny(usefulWorkTask, progressUpdatetask);          cancellationSource.Cancel(); </code></pre>  <p>By modifying <code>for (var i = 0; i &lt; 25; i++)</code> limit of <code>i</code> I imitate whether long running task finishes before the progress task or otherwise. Works as desired. The <code>WithCancellation</code> helper method does the job, although two sort of 'nested' <code>Task.WhenAny</code> look suspicious for now.</p>