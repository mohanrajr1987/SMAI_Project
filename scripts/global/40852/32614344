<p>I have the following code:</p>  <pre><code>const int MAX = 101; const int MIN_COMBINATORIC = 1000000;  int[,] pascalTriangle = new int[MAX, MAX];  Parallel.For(0, MAX, i =&gt; {      pascalTriangle[i, 0] = 1;      pascalTriangle[i, i] = 1; });   int counter = 0;  Parallel.For(0, MAX, x =&gt; Parallel.For(1, x, y =&gt;  {       int value = pascalTriangle[x - 1, y] + pascalTriangle[x - 1, y - 1];       Interlocked.Exchange(ref pascalTriangle[x, y], value &lt; MIN_COMBINATORIC ? value : MIN_COMBINATORIC);       if(value &gt; MIN_COMBINATORIC)           Interlocked.Increment(ref counter); }));  Console.WriteLine("Result: {0}", counter); </code></pre>  <p>The problem is that it sometimes prints out the correct answer (<code>Result: 4075</code>), but sometimes it prints a random (and wrong) answer, such as:</p>  <ul> <li><code>Result: 2076</code></li> <li><code>Result: 1771</code></li> <li><code>Result: 0</code></li> </ul>  <p>I'm guessing it has something to do with the fact that I'm reading and writing a shared array between multiple threads. As you can see, I tried adding <code>Interlocked.Exhange()</code> for thread-safe write operations, but I could not find a similar method for reading (There's a <code>Interlocked.Read()</code> but it can only read <code>long</code> variables)</p>  <p>How can I make the above code run concurrently in a thread-safe manner?</p>