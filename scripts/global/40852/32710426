<p>I have the following test application that simulates my application scenario:</p>  <pre><code>class Program {     static void Main()     {         Console.WriteLine("***Press R = record to new file, S = Stop Recording, E = Exit");         var timer = new Timer(Callback, null, 0, 1000);         while(!_Close) HandleInput(Console.ReadLine());         Console.WriteLine("Finished");     }      private static bool _Close;      private static void HandleInput(string input)     {         switch (input.ToLower())         {             case "r": CreateWriter();                 break;             case "s": Console.WriteLine("File Closed: {0}", _FileWriter.Name);                  _FileWriter.Dispose();                 _FileWriter = null;                 break;             case "e":                 _Close = true;                 break;         }     }      private static void CreateWriter()     {         if (_FileWriter != null)             _FileWriter.Dispose();         string filename = Path.Combine("C:\\", string.Format("{0:yyyy_MM_dd HH_mm_ss}.txt",DateTime.Now));         _FileWriter = new AsyncFileWriter(filename);         Console.WriteLine("New File Created: {0}", filename);     }      private static void Callback(object state)     {         if (_FileWriter != null)             _FileWriter.Produce(MakeData());     }      private static byte[] MakeData()     {         string data = string.Empty;         for (int i = 0; i &lt; 50; i++)         {             data += string.Format("{0:yyyy-MM-dd HH:mm:ss.fff}{1}", DateTime.Now, Environment.NewLine);         }         return Encoding.UTF8.GetBytes(data);     }      private static AsyncFileWriter _FileWriter; } </code></pre>  <p>It uses the following class as the Consumer(/producer):</p>  <pre><code>public class AsyncFileWriter : IDisposable {     private readonly FileStream _Filewriter;     private readonly Task _WriteTask;     private readonly BufferBlock&lt;byte[]&gt; _BufferBlock;      public AsyncFileWriter(string filename)     {         _Filewriter = new FileStream(filename, FileMode.CreateNew, FileAccess.Write, FileShare.None);         _BufferBlock = new BufferBlock&lt;byte[]&gt;();         _WriteTask = WriteToFile();     }      public void Produce(byte[] data)     {         _BufferBlock.Post(data);     }      public long Filesize { get; private set; }      public string Name { get { return _Filewriter.Name; } }      private async Task WriteToFile()     {         while (await _BufferBlock.OutputAvailableAsync())         {             byte[] data = _BufferBlock.Receive();             await _Filewriter.WriteAsync(data, 0, data.Length);             Filesize = _Filewriter.Length;         }     }      private async Task Complete()     {         _BufferBlock.Complete();         await Task.WhenAll(_WriteTask, _BufferBlock.Completion);         //now close the file         _Filewriter.Dispose();     }      public void Dispose()     {         Complete();     } } </code></pre>  <p>The important things to note are:</p>  <ul> <li>I have a continuous stream of bytes that are passed to me from a proprietary library via a callback. I do not know when I will receive this data.</li> <li>I need to be able to control when to start recording this data (press "R")</li> <li>I need to be able to switch to a new file, but ensure previous data has been written to the last file (press "R" again while already recording)</li> </ul>  <p>I have a few questions, as I am quite new to the TPL dataflow library.</p>  <ol> <li>Firstly, is my implementation of Producer/Consumer (i.e. AsyncFileWriter) sound?</li> <li>Is my implementation of IDisposable OK?</li> <li>How do I handle exceptions in the Consumer (i.e. WriteToFile)? I really need to be notified if something goes wrong, but as you can see the only public method is <code>Produce()</code>, and the exception won't happen here... Is there a best practise for this pattern?</li> </ol>