<p>this is a follow on from a previous question I posted <a href="http://stackoverflow.com/questions/32606485/calling-an-async-method-using-a-task-run-seems-wrong">Calling an async method using a Task.Run seems wrong?</a></p>  <p>I thought the code written by the contractor was wrong but following on from the answers provided I'm now wondering if it's the libraries fault. This library exposes two methods that I need to use. One returns a "template" and one consumes part of this template (it does in my implementation anyway). But both are <code>async</code> methods returning <code>Tasks</code>. </p>  <p>To explain my library has methods:</p>  <pre><code>public Task&lt;TemplateInfo&gt; TemplateInfo(TemplateInfoRequest request); public Task&lt;List&lt;EmailResult&gt;&gt; SendMessageTemplate(SendMessageTemplateRequest request); </code></pre>  <p>I need to call these thus:</p>  <pre><code>public bool SendMessage() {   var template = TemplateInfo(...);   var message = //use template to create message   var sendResponse = SendMessageTemplate(message);     return sendResponse.Count &gt; 0; } </code></pre>  <p>So the second call relies on the first. This is where the async doesn't make sense to me. <strike>I can't and don't want to run these in parallel. I want to run them in sequence.</strike> I want <strong>my</strong> method to by synchonous. </p>  <p>An <a href="http://stackoverflow.com/a/32607091/542251">answer in my previous question</a> also states:</p>  <blockquote>   <p>Since you're blocking on an async method (<strong>which you shouldn't do</strong>)   there is a chance you'll deadlock.</p> </blockquote>  <p>So how do I access these <code>async</code> methods in such a way that they are processed in turn and return a synconhonous result but do not cause deadlocks?</p>