<p>We have a processor that will receive a queue of elements, and for every element, it will run some actions that need to be guaranteed to be executed in a sequential manner. Each action to execute on an element is a Promise Task (<a href="http://blog.stephencleary.com/2014/04/a-tour-of-task-part-0-overview.html" rel="nofollow">http://blog.stephencleary.com/2014/04/a-tour-of-task-part-0-overview.html</a>). The processing of each element in the queue doesn't need to wait for completion of the previous one. The signature of the actions can be assumed to be something like this:</p>  <pre><code>Task MyAwaitableMethod(int delay) </code></pre>  <p>The way I'm seeing, the problem can be reduced to executing a loop, and inside the loop, executing sequential operations, and each iteration shouldn't block. I'm looking at 2 approaches: 1. </p>  <pre><code>for (var i = 0; i &lt; Iterations; i++) {     Task.Run(async () =&gt; {             await MyAwaitableMethod(DelayInMilliseconds);             await MyAwaitableMethod(DelayInMilliseconds);     }); } </code></pre>  <p>2.</p>  <pre><code>for (var i = 0; i &lt; Iterations; i++) {     MyAwaitableMethod(DelayInMilliseconds).ContinueWith(         antecedent =&gt; MyAwaitableMethod(DelayInMilliseconds)); } </code></pre>  <p>I was assuming, given the actions are Promises, that with approach #2, there would be less threads created, as opposed to Task.Run, which I'd assume would create more threads. But in tests I've run, the number of threads created for both when executing a high number of iterations tends to be the same, and not dependent of the given number of iterations.</p>  <p>Are both methods entirely equivalent? Or you guys have better suggestions?</p>  <p>EDIT (rephrasing the question) Are both methods equivalent in terms of the number of threads both require?</p>  <p>Thanks</p>