<p>I want to create a closed bezier path using an image. What I want to achieve basically is:     •   Input: A is an image having nonuniform borders, to illustrate an image of hearth     •   Output: B is the bezier path around the borders of the image, to illustrate a hearth shaped bezier path.</p>  <p>A possible solution I found on the internet is</p>  <ol> <li>Use the flood-fill algorithm.</li> <li>Invert the results within the image rect.</li> <li>Finally, the invert operation should give the path that hugs the center image</li> </ol>  <p>I have successfully implemented the flood fill algorithm referenced a post in the StackOverFlow. But I can not invert it within the image rect. </p>  <p>I would be glad if someone help me.</p>  <p>Here is the flood fill code:</p>  <pre><code>extension UIImageView {  func bucketFill(startPoint: CGPoint, newColor: UIColor) { var newRed, newGreen, newBlue, newAlpha: CUnsignedChar  let pixelsWide = CGImageGetWidth(self.image!.CGImage) let pixelsHigh = CGImageGetHeight(self.image!.CGImage) let rect = CGRect(x:0, y:0, width:Int(pixelsWide), height:Int(pixelsHigh))  let bitmapBytesPerRow = Int(pixelsWide) * 4  var context = createARGBBitmapContext(self.image!.CGImage)  //Clear the context CGContextClearRect(context, rect)  // Draw the image to the bitmap context. Once we draw, the memory // allocated for the context for rendering will then contain the // raw image data in the specified color space. CGContextDrawImage(context, rect, self.image!.CGImage)  var data = CGBitmapContextGetData(context) var dataType = UnsafeMutablePointer&lt;UInt8&gt;(data)  let newColorRef = CGColorGetComponents(newColor.CGColor) if(CGColorGetNumberOfComponents(newColor.CGColor) == 2) {     newRed = CUnsignedChar(newColorRef[0] * 255) // CUnsignedChar     newGreen = CUnsignedChar(newColorRef[0] * 255)     newBlue = CUnsignedChar(newColorRef[0] * 255)     newAlpha = CUnsignedChar(newColorRef[1]) } else {     newRed = CUnsignedChar(newColorRef[0] * 255)     newGreen = CUnsignedChar(newColorRef[1] * 255)     newBlue = CUnsignedChar(newColorRef[2] * 255)     newAlpha = CUnsignedChar(newColorRef[3]) }  let newColorStr = UIColor(red: CGFloat(newRed), green:   CGFloat(newGreen), blue: CGFloat(newBlue), alpha: 1.0)   var stack = Stack()  let offset = 4*((Int(pixelsWide) * Int(startPoint.y)) + Int(startPoint.x))  let startRed: UInt8 = dataType[offset+1] let startGreen: UInt8 = dataType[offset+2] let startBlue: UInt8 = dataType[offset+3]  stack.push(startPoint)  while(!stack.isEmpty()) {      let point: CGPoint = stack.pop() as! CGPoint      let offset = 4*((Int(pixelsWide) * Int(point.y)) + Int(point.x))     let alpha = dataType[offset]     let red: UInt8 = dataType[offset+1]     let green: UInt8 = dataType[offset+2]     let blue: UInt8 = dataType[offset+3]      if (red == newRed &amp;&amp; green == newGreen &amp;&amp; blue == newBlue) {         continue     }      if (red.absoluteDifference(startRed) &lt; 4 &amp;&amp;  green.absoluteDifference(startGreen) &lt; 4 &amp;&amp; blue.absoluteDifference(startBlue) &lt; 4) {          dataType[offset] = 255         dataType[offset + 1] = newRed         dataType[offset + 2] = newGreen         dataType[offset + 3] = newBlue          if (point.x &gt; 0) {             stack.push(CGPoint(x: point.x - 1, y: point.y))         }          if (point.x &lt; CGFloat(pixelsWide)) {             stack.push(CGPoint(x: point.x + 1, y: point.y))         }          if (point.y &gt; 0) {             stack.push(CGPoint(x: point.x, y: point.y - 1))         }          if (point.y &lt; CGFloat(pixelsHigh)) {             stack.push(CGPoint(x: point.x, y: point.y + 1))         }     } else {      } }  let colorSpace = CGColorSpaceCreateDeviceRGB() let bitmapInfo = CGBitmapInfo(rawValue:  CGImageAlphaInfo.PremultipliedFirst.rawValue) let finalContext = CGBitmapContextCreate(data, pixelsWide, pixelsHigh, CLong(8), CLong(bitmapBytesPerRow), colorSpace, bitmapInfo)  let imageRef = CGBitmapContextCreateImage(finalContext) self.image = UIImage(CGImage: imageRef, scale: self.image!.scale,orientation: self.image!.imageOrientation)  } }  extension UInt8 {  func absoluteDifference(subtrahend: UInt8) -&gt; UInt8 { if (self &gt; subtrahend) {     return self - subtrahend; } else {     return subtrahend - self; } } }  func createARGBBitmapContext(inImage: CGImageRef) -&gt; CGContext {  //Get image width, height  let pixelsWide = CGImageGetWidth(inImage)  let pixelsHigh = CGImageGetHeight(inImage)   // Declare the number of bytes per row. Each pixel in the bitmap in  this     example is represented by 4 bytes; 8 bits each of red, green, blue, and alpha.  let bitmapBytesPerRow = Int(pixelsWide) * 4  let bitmapByteCount = bitmapBytesPerRow * Int(pixelsHigh)   // Use the generic RGB color space.  let colorSpace = CGColorSpaceCreateDeviceRGB()   // Allocate memory for image data. This is the destination in memory where any drawing to the bitmap context will be rendered.  let bitmapData = UnsafeMutablePointer&lt;CUnsignedLong&gt;.alloc(bitmapByteCount)   //let bitmapData = malloc(CUnsignedLong(bitmapByteCount))  let bitmapInfo = CGBitmapInfo(rawValue:  CGImageAlphaInfo.PremultipliedFirst.rawValue)   // Create the bitmap context. We want pre-multiplied ARGB, 8-bits per component. Regardless of what the source image format is (CMYK, Grayscale, and so on) it will be converted over to the format  specified here by  CGBitmapContextCreate.   let context = CGBitmapContextCreate(bitmapData, pixelsWide, pixelsHigh,  Int(8), Int(bitmapBytesPerRow), colorSpace, bitmapInfo)  return context   } </code></pre>