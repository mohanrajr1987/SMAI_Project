<p>I want to build my own unit test library where I would like to setup test cases as follows:</p>  <pre><code>template &lt;typename... Args&gt; std::string concatenate(Args&amp;&amp;... args);  class my_test : public unit_test::test { public:     my_test(int i, float f, double d) : i_(i), f_(f), d_(d) { }     void test1() { assert_true(i_ % 5 == 0, concatenate("i(", i_, ") not divisible by 5")); }     void test2() { assert_true(i_ &gt; 0, concatenate("i(", i_, ") not greater than 0")); }     void test3() { assert_true(i_ % 2 == 0, concatenate("i(", i_, ") not divisible by 2")); } private:     int i_;     float f_;     double d_; };  int main() {     unit_test::test_case&lt;my_test,         &amp;my_test::test1         &amp;my_test::test2         &amp;my_test::test3&gt; my_test_case;     result r = my_test_case(1, 1.0f, 1.0); } </code></pre>  <p>To be able to define the test_case template class, I need to be able to declare variadic templates of pointers to member functions:</p>  <pre><code>class result {     unsigned int num_failures_;     unsigned int num_tests_; };  template &lt;typename Test, void(Test::*...MemFns)()&gt; class test_case; </code></pre>  <p>Unfortunately, g++-4.8 and above gives the following error:</p>  <pre><code>main.cpp:137:52: error: template argument 3 is invalid  class test_case &lt;Test, &amp;Test::First, &amp;Test::...Rest&gt; {                                                     ^ main.cpp: In function 'int main(int, char**)': main.cpp:194:28: error: template argument 2 is invalid              &amp;my_test::test3&gt;()(1, 1.0f, 1.0); </code></pre>  <p>And surprisingly, g++-4.7 compiles and runs some invalid code!</p>  <p>What is the correct way of declaring variadic templates of pointer to member functions?</p>  <p><a href="http://coliru.stacked-crooked.com/a/a3d313b218208bdc" rel="nofollow">Here is the full code</a></p>