<p>I have the following source compiled in g++ 4.8.2</p>  <pre><code>#include "mpmc.hpp" #include &lt;semaphore.h&gt; #include &lt;signal.h&gt;  using namespace std;  mpmc_bounded_queue&lt;std::string&gt; mq(2048) ; volatile int counter1=0 ; volatile int counter2=0 ; #define LOOP 1000000  void gexit(int gub) {     printf("(%d),(%d)\n",counter1,counter2) ;     exit( 0 ) ; }  int main(int argc, char* argv[]) {     signal(SIGINT, gexit);     signal(SIGTERM, gexit);      void    *func1(void *);     void    *func2(void *);     pthread_t tid ;     long int       icnt = 0;     pthread_create(&amp;tid, NULL, &amp;func1 , (void *) icnt );     pthread_create(&amp;tid, NULL, &amp;func1 , (void *) icnt );     pthread_create(&amp;tid, NULL, &amp;func1 , (void *) icnt );      pthread_create(&amp;tid, NULL, &amp;func2 , (void *) icnt );     pthread_create(&amp;tid, NULL, &amp;func2 , (void *) icnt );      while( 1 )         sleep( 500 ) ; }  void    *func2(void * inum) {     pthread_detach(pthread_self());     int iret = 0 ;     while(1){         while( 1 ){             std::string s ;             if( mq.dequeue(s) ){                 iret = __sync_add_and_fetch(&amp;counter2,1) ;                 break ;             }else{                 usleep( 1 ) ;                 continue ;             }             //usleep( 10 ) ;         }//while     }//while } void    *func1(void * inum) {     pthread_detach(pthread_self());     char ptr[11]={0} ;     sprintf(ptr,"%08d",0) ;     string s(ptr) ;      while(1){         while( 1 ){             if( mq.enqueue(s) ){                 __sync_add_and_fetch(&amp;counter1,1) ;                 break ;             }             usleep(100) ;             if( counter1 &gt;= LOOP )                 break ;             continue ;         }//while         if( counter1 &gt;= LOOP )             break ;         usleep(1) ;     } //while     printf("func1 done \n") ; } </code></pre>  <p>The mpmc.hpp is lock-free-bounded-queue from here : <a href="http://www.1024cores.net/home/lock-free-algorithms/queues/bounded-mpmc-queue" rel="nofollow">http://www.1024cores.net/home/lock-free-algorithms/queues/bounded-mpmc-queue</a></p>  <p>now , I compile it by : g++ --std=c++11 -Werror -O2 testprint.cpp -pthread -o testprint.exe</p>  <p>run it will get the following :</p>  <pre><code>func1 done </code></pre>  <p>only one "func1 done" , then press control-c print : (1000000),(1000000)</p>  <p>If I compile it by : g++ --std=c++11 -Werror  testprint.cpp -pthread -o testprint.exe</p>  <p>run it will get the following :</p>  <pre><code>func1 done  func1 done  func1 done </code></pre>  <p>all three "func1 done" , then press control-c print : (1000002),(1000002)</p>  <p>I think compiled without -O2 make more sense , also , -O2 would cost about 45 secs to get first "func1 done" , but without -O2 would cost only 17 secs to finish all "func1 done"</p>  <p>May I know what g++ optimizer do in this case to cause this happened ?</p>