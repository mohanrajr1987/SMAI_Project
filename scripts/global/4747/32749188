<p>Some "undefined reference error" questions are already posted on StackOverflow but I couldn't find solution to my problem.</p>  <p>My project contains 5 files: 5.cpp vector_base.h vector_base.cpp vector.h vector.cpp</p>  <p>I compile it with:</p>  <pre><code>g++ -std=c++11 vector_base.cpp vector.cpp 5.cpp -o 5 </code></pre>  <p>And get the following error:</p>  <pre><code>/tmp/ccO8NeGJ.o: In function `main': 5.cpp:(.text.startup+0x21): undefined reference to `Vector&lt;int, std::allocator&lt;int&gt; &gt;::Vector(unsigned int, int const&amp;, std::allocator&lt;int&gt; const&amp;)' 5.cpp:(.text.startup+0x2b): undefined reference to `Vector&lt;int, std::allocator&lt;int&gt; &gt;::destroy_elements()' collect2: error: ld returned 1 exit status </code></pre>  <p>well, code looks fine for me. Where did I mess up?</p>  <p>The code is as follows: </p>  <p>5.cpp</p>  <pre><code>#include "vector.h"  int main() {     Vector&lt;int&gt; a{10, 0}; } </code></pre>  <p>vector.h</p>  <pre><code>#ifndef VECTOR_H #define VECTOR_H  #include "vector_base.h"  template&lt;class T, class A = std::allocator&lt;T&gt;&gt; class Vector { private:     vector_base&lt;T,A&gt; vb;     void destroy_elements();  public:     using size_type = unsigned int;      explicit Vector(size_type n, const T&amp; val = T(), const A&amp; a = A());     ~Vector() { destroy_elements(); } };  #endif //VECTOR_H </code></pre>  <p>vector.cpp</p>  <pre><code>#include "vector.h"  #include &lt;algorithm&gt; #include &lt;memory&gt;  template&lt;class T, class A&gt; Vector&lt;T,A&gt;::Vector(size_type n, const T&amp; val, const A&amp; a)     :vb{a, n} {     std::uninitialized_fill(vb.elem, vb.elem + n, val); }  template&lt;class T, class A&gt; void Vector&lt;T,A&gt;::destroy_elements() {     for(T* p = vb.elem; p!=vb.space; ++p){         p-&gt;~T();     }     vb.space=vb.elem; } </code></pre>  <p>vector_base.h</p>  <pre><code>#ifndef VECTOR_BASE_H #define VECTOR_BASE_H  #include &lt;memory&gt;  template&lt;class T, class A = std::allocator&lt;T&gt;&gt; struct vector_base {      T* elem;     T* space;     T* last;     A alloc;      using size_type = unsigned int;      vector_base(const A&amp; a, typename A::size_type n)         :alloc{a}, elem{alloc.allocate(n)}, space{elem+n}, last{elem+n} {}      ~vector_base() { alloc.deallocate(elem, last-elem); } }; #endif //VECTOR_BASE_H </code></pre>  <p>vector_base.cpp</p>  <pre><code>#include "vector_base.h" #include &lt;algorithm&gt;  template&lt;class T, class A&gt; vector_base&lt;T,A&gt;::vector_base(const vector_base&amp;&amp; a)     :alloc{a.alloc}, elem{a.elem}, space{a.space}, last{a.last} {     a.elem = a.space = a.last = nullptr; }  template&lt;class T, class A&gt; vector_base&lt;T,A&gt;&amp; vector_base&lt;T,A&gt;::operator=(const vector_base&amp;&amp; a) {     swap(*this, a);     return *this; } </code></pre>  <p>I tried compile every cpp file separately and then link all but it didn't work also. </p>