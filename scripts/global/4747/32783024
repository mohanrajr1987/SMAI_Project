<p>So I have the following simple snippet:</p>  <pre><code>template &lt;typename T, size_t size&gt; struct SquareMatrix { public:     T data[size * size];     constexpr T &amp; operator()(const size_t row, const size_t col) noexcept {         return data[row * size + col];     } };  constexpr auto generate() {     auto result = SquareMatrix&lt;int, 2&gt;{};     result(0, 0) = 1;     result(1, 0) = 3;     result(0, 1) = 2;     result(1, 1) = 4;     return result; } </code></pre>  <p>The expected contents of the <code>data</code> array in the <code>SquareMatrix&lt;int, 2&gt;</code> produced by <code>generate()</code> is <code>1, 2, 3, 4</code>. However...</p>  <pre><code>constexpr auto test = generate();  int main() {     for (size_t i = 0; i &lt; 4; ++i) {         std::cout &lt;&lt; test.data[i] &lt;&lt; std::endl;     }     return 0; } </code></pre>  <p>If I compile and run this code using g++ 5.2 and <code>-std=c++14</code>, the result that is printed to the console is, bizarrely, <code>1032</code>.</p>  <p>If remove the constexpr qualifiers so it executes at runtime, or if I instead write either of the following slight variations:</p>  <pre><code>int main() {     constexpr auto test = generate();     for (size_t i = 0; i &lt; 4; ++i) {         std::cout &lt;&lt; test.data[i];     }     return 0; } </code></pre>  <p>... or ...</p>  <pre><code>constexpr auto generate() {     auto result = SquareMatrix&lt;int, 2&gt;{};     result(0, 0) = 1;     result(0, 1) = 2; // this line and     result(1, 0) = 3; // this line have been swapped     result(1, 1) = 4;     return result; }  constexpr auto test = generate();  int main() {     for (size_t i = 0; i &lt; 4; ++i) {         std::cout &lt;&lt; test.data[i];     }     return 0; } </code></pre>  <p>... the expected result, <code>1234</code>, is printed. Additionally, clang++ 3.7.0 prints the expected <code>1234</code> in all cases.</p>  <p>Have I hit a g++ bug or am I missing something here?</p>