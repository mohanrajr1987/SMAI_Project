<p>Consider the following code:</p>  <pre><code>template&lt;int N&gt; class Vector { };  #include &lt;array&gt;  template&lt;int N&gt; void doWork(const Vector&lt;N&gt;&amp;, const std::array&lt;int,N&gt;&amp;) { }  int main() {     std::array&lt;int,3&gt; arr;     Vector&lt;3&gt; vec;     doWork(vec,arr); } </code></pre>  <p>Here <code>Vector</code> represents a class which is defined in a third-party library, and <code>std::array</code> is known to take its element count as <code>std::size_t</code>.</p>  <p>I've tried compiling this with clang-3.6 and g++-5.1. Clang worked without any complaint, while g++ gives the following error:</p>  <pre><code>test.cpp: In function ‘int main()’: test.cpp:17:19: error: no matching function for call to ‘doWork(Vector&lt;3&gt;&amp;, std::array&lt;int, 3ul&gt;&amp;)’      doWork(vec,arr);                    ^ test.cpp:9:6: note: candidate: template&lt;int N&gt; void doWork(const Vector&lt;N&gt;&amp;, const std::array&lt;int, N&gt;&amp;)  void doWork(const Vector&lt;N&gt;&amp;, const std::array&lt;int,N&gt;&amp;)       ^ test.cpp:9:6: note:   template argument deduction/substitution failed: test.cpp:17:19: note:   mismatched types ‘int’ and ‘long unsigned int’      doWork(vec,arr);                    ^ test.cpp:17:19: note:   ‘std::array&lt;int, 3ul&gt;’ is not derived from ‘const std::array&lt;int, N&gt;’ </code></pre>  <p>I can work around this by doing a cast of <code>N</code> to <code>std::size_t</code> in second parameter of <code>doWork()</code> or calling <code>doWork&lt;3&gt;()</code>, but this wouldn't educate me.</p>  <p>So I rather ask first: which compiler is right here? Am I really doing something wrong in the code (so clang is too permissive), or is it indeed valid C++ (so that g++ has a bug)?</p>