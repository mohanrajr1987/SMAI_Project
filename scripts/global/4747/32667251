<p>IDE: Code::Blocks Compiler: g++ 4.5.4 (from Mingw32_i686) Type application: console type</p>  <p>Ok</p>  <pre><code>    // sourcefile: winfunctions.h      #ifndef __WINFUNCTIONS_H__     #define __WINFUNCTIONS_H__      #include &lt;windef.h&gt;     #include &lt;winbase.h&gt;      typedef void (__stdcall *F)();     void StdCall(char *mName, char *fName)();     typedef void (__stdcall *F_)();     void StdCall_(char *mName, char *fName)(auto *args[]);     typedef auto (__stdcall *_F)();     auto _StdCall(char *mName, char *fName)();     typedef auto (__stdcall *_F_)();     auto _StdCall_(char *mName, char *fName)(auto *args[]);      #endif // __WINFUNCTIONS_H__         // sourcefile: winfunctions.cpp      #include "winfunctions.h"      void StdCall(char *mName, char *fName)()     {         HMODULE hM = LoadLibrary(mName);         F f = (F)GetProcAddress(hM,fName)();         if (f) f();         FreeLibrary(hM);     }      void StdCall_(char *mName, char *fName)(auto *args[])     {         HMODULE hM = LoadLibrary(mName);         F_ f = (F_)GetProcAddress(hM,fName)(args);         if (f) f(args);         FreeLibrary(hM);     }      auto _StdCall(char *mName, char *fName)()     {         HMODULE hM = LoadLibrary(mName);         _F f = (_F)GetProcAddress(hM,fName)();         if (f) return f();         FreeLibrary(hM);     }      auto _StdCall_(char *mName, char *fName)(auto *args[])     {         HMODULE hM = LoadLibrary(mName);         _F_ f = (_F_)GetProcAddress(hM,fName)(args);         if (f) return f(args);         FreeLibrary(hM);     } </code></pre>  <p>I will give the code, it does not work as expected. This code should show my desire.</p>  <p>I want using four wrapper functions to cause any winapi function.</p>  <p><code>F</code> - function returns nothing and has no input parameters</p>  <p><code>F_</code> - function does not return anything, but it has the input parameters</p>  <p><code>_F</code> - function returns a value, but has no input parameters</p>  <p><code>_F_</code> - function returns a value, and has input parameters</p>  <p>I want to define the type of return value of the function and the types of parameters to be passed to the runtime functions, rather than at compile time.</p>  <p>Of course, I also do not want to determine the number of parameters to be passed to functions at compile time.</p>  <p>Any ideas? This is even possible?</p>  <p>UPD:</p>  <p>Thank you <a href="http://stackoverflow.com/users/865874/rodrigo">rodrigo</a></p>  <p>I downloaded the libffi 3.0.6 win32 (used libffi.dll.a and header files in my test console application), but given alert: "libffi-5.dll not found".</p>  <p>I downloaded <a href="http://rpm.pbone.net/index.php3/stat/4/idpl/24142309/dir/fedora_16/com/mingw32-libffi-3.0.9-2.fc15.noarch.rpm.html" rel="nofollow">http://rpm.pbone.net/index.php3/stat/4/idpl/24142309/dir/fedora_16/com/mingw32-libffi-3.0.9-2.fc15.noarch.rpm.html</a>, unpacked it, found libffi-5.dll an copy this .dll in C:\Mingw32\bin.</p>  <p>The code for the test:</p>  <pre><code>#include &lt;iostream&gt; #include &lt;stdio.h&gt; #include &lt;windows.h&gt; #include "ffi.h"  int main() {      ffi_cif cif;              HINSTANCE dllHandle = LoadLibrary("user32.dll");              int n = 4;              ffi_type *ffi_argTypes[4];             void *values[4];             UINT64 a=0;             UINT32 b=0;             TCHAR* s1= "hello";             TCHAR* s2= "hello2";             values[0] = &amp;a;             values[1] = &amp;s1;             values[2] = &amp;s2;             values[3] = &amp;b;             ffi_argTypes[0] = &amp;ffi_type_uint64;             ffi_argTypes[1] = &amp;ffi_type_pointer;             ffi_argTypes[2] = &amp;ffi_type_pointer;             ffi_argTypes[3] = &amp;ffi_type_uint;             ffi_type *c_retType = &amp;ffi_type_sint;             ffi_type rc; // return value             if (ffi_prep_cif(&amp;cif, FFI_DEFAULT_ABI, 4, &amp;ffi_type_sint, ffi_argTypes) == FFI_OK)             {                 ffi_call(&amp;cif, FFI_FN(GetProcAddress(dllHandle,"MessageBoxA")), &amp;rc, values);             }         return 0;       } </code></pre>  <p>Yes! I have a working code!</p>  <p>I will continue to study this question.</p>