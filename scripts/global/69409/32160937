<p>In my datamodel I have two enties:</p>  <p><strong>Person</strong></p>  <p>int : id</p>  <p>String : Name</p>  <p>Collection: pets</p>  <p><strong>Excerpt of the corresponding Java Code:</strong></p>  <hr>  <pre><code> @OneToMany(fetch = FetchType.EAGER, cascade = CascadeType.ALL) public Collection&lt;Pet&gt; getPets(){     return pets; } </code></pre>  <p><strong>Pet</strong></p>  <p>int : id</p>  <p>string : Name</p>  <p>Person : owner</p>  <p><strong>Excerpt of the corresponding Java Code:</strong></p>  <hr>  <pre><code>@ManyToOne(fetch = FetchType.EAGER, cascade = CascadeType.ALL) @JoinColumn(name = "PersonID", nullable = false) public Person getOwner(){     return owner.get(); } </code></pre>  <p>In my application I can load the data of these two entities in a separate ObservableList. </p>  <pre><code>ObservableList&lt;Person&gt; personList = FXCollections.observableArrayList(); ObservableList&lt;Pet&gt; petList = FXCollections.observableArrayList(); personList = (ObservableList&lt;Person&gt;) personController.getListPerson(); petList = (ObservableList&lt;Pet&gt;)petController.getPetList(); </code></pre>  <p>Now I want to go a step further and load all Persons with the corresponding Pets at the same time. </p>  <p>After hours of trying I realized, that my idea doesn't work.  Do child-elements like Pets in this case get automatically loaded from hibernate, when I load the Persons? Do I really have the instantiate two separate lists for the entities?</p>  <p>Any ideas how I can do this properly? </p>