<p><strong>TL;DR questions</strong></p>  <p>Here are some <code>.NET</code> things that I either currently use or have used in the past to implement some form of authentication:</p>  <ul> <li>ASP.NET Identity 2, ie <code>IUser&lt;T&gt;</code>, <code>IUserStore&lt;T&gt;</code></li> <li><code>OWIN</code></li> <li><code>DotNetOpenAuth</code></li> <li><code>System.Security</code>'s <code>IPrincipal</code>, <code>Thread.CurrentPrincipal</code>, etc.</li> <li><code>ApiController.User</code>, <code>Controller.User</code></li> <li>Classifications of authentication types and identities by Microsoft: Forms, Claims, Cookie, etc.</li> </ul>  <p>What I would like to know is the following:</p>  <ol> <li>Is there a succinct conceptual way to compartmentalize where these components fall into? <strong>This, above all, is my question; all others I feel are derivative to this one.</strong></li> <li>How can one application implement multiple <strong>simultaneous</strong> (not alternatives to each other) modes of authentication against different stores?</li> </ol>  <p>And a third set of questions: </p>  <p>Given the following "working" implementation of <code>OAuthAuthorizationServerProvider</code>'s <code>GrantResourceOwnerCredentials</code> method:</p>  <pre><code>public override async Task GrantResourceOwnerCredentials(OAuthGrantResourceOwnerCredentialsContext context) {     using (UserManager&lt;MyIdentityUser&gt; userManager = _UserManagerFactory())     {         MyIdentityUser user = await userManager.FindAsync(context.UserName, context.Password);          if (user == null)         {             context.SetError("invalid_grant", "The user name or password is incorrect.");             return;         }          ClaimsIdentity oAuthIdentity = await userManager.CreateIdentityAsync(user,             context.Options.AuthenticationType);         ClaimsIdentity cookiesIdentity = await userManager.CreateIdentityAsync(user,             CookieAuthenticationDefaults.AuthenticationType);         await userManager.AddClaimAsync(user.Id, new Claim(CookieAuthenticationDefaults.AuthenticationType, "name"));         AuthenticationProperties properties = CreateProperties(user.UserName);         AuthenticationTicket ticket = new AuthenticationTicket(oAuthIdentity, properties);         context.Validated(ticket);         context.Request.Context.Authentication.SignIn(cookiesIdentity);     } } </code></pre>  <ol> <li>Is there a reason this kind of code is always given as an example of how to secure <code>Web Api</code> rather than <code>Mvc</code> as well?</li> <li>Why is it creating multiple types of identities? Why not other types?</li> <li>What does the last line do?</li> </ol>  <p><strong>Disclaimer:</strong> I realize this is a very long-winded question but a good answer, even if only a sketch of an answer, would help myself and I believe many other developers conceptually understand some of the motivations for the tutorials and interfaces we sometimes follow and implement without seeing the big picture - or perhaps, thinking there is a big picture where there is not. So here goes...</p>  <p><strong>Background:</strong> I have an ASP.NET MVC 5 / Web Api 2 / <code>backbone.js</code> multi-tenant SPA that already contains an implementation of the <code>OAuthAuthorizationServerProvider</code> along with a custom set of <code>IUserStore&lt;MyIdentityUser&gt;</code> and related implementations. The SPA calls the <code>TokenEndpoint</code> (by default, <code>/token</code>) using <code>jQuery</code> to get a token and authenticate users. As you can probably tell, even though I coded this and have seen it work in production for almost two years, I am way too sketchy on the details of how it all actually works and whether what I am doing even makes sense.</p>  <p><strong>Motivation:</strong> The app is a multitenant app and I need to be able to "lock down" tenant sites prior to going live so they can test on a public-but-protected URL specific to the tenant. Let's say McDonald's and Wendy's are tenants. Then I have two MVC action URLs to lock down <code>/site/mcdonalds</code> and <code>/site/wendys</code> and every API route <code>/api/*</code> so that the server should not respond to requests on any API route and respond with a challenge on the MVC route to perform "tenant-level" login for the customer to view the site prior to deployment. That challenge could be basic auth, a form (I don't necessarily mean the technical term <code>Forms Authentication</code>), I don't care - but the result should be that for subsequent requests in a time period, they are authorized to access, say, any of the URL's. I figure that once I have this working I can restrict it further to make sure tenants cannot see each others' things. Let me also note that users are not tenant-specific in this application by design: multiple tenants can share a single user with one or more profiles in each tenant.</p>  <p><strong>Confusion:</strong> Since I do not understand the relationship between the aforementioned concepts, I am having trouble understanding whether and/or how I can segregate the two types of authentication - in my view, completely unrelated with different underlying stores - since it seems like the for a given app, you can only have one <code>OAuthAuthorizationServerProvider</code> and <code>Startup</code>-type class. I could try to mix in this new store and make the <code>IUser&lt;T&gt;</code> more complicated (carrying both a logged-in tenant and/or a logged-in user, and requiring neither necessarily). I could try to implement authentication somewhere else, say, as a <code>MessageHandler</code> that sends a Basic Authentication challenge and sets the <code>Thread.CurrentPrincipal</code> on a valid response. I could try to set some sort of cookie that is independent of the existing cookie that gets created when logging in via <code>/token</code>. But before I can really know what to do, and unless I am just told what to do, I really need to understand at a conceptual level what the relationship is between these things and <em>especially</em> <strong>which, if any, of these things must be unique in a given X</strong>, where <strong>X</strong> is application, request, thread, session, etc. I think that last part is the hardest for me to understand.</p>