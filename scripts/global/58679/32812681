<p>I'm trying to create a server with OAuth 2 but I have a problem. I configured OAuth, the user can authorize and get a token but the REST methods are always accesible, for example a user can use method POST when they didn't authorize.</p>  <p>How to configure OAuth so the REST methods run only when a user did authorize?</p>  <p>This is how some of my code looks like (I used this <a href="https://github.com/royclarkson/spring-rest-service-oauth" rel="nofollow">example code</a>):</p>  <p>OAuthConfiguration class</p>  <pre><code>@Configuration public class OAuth2ServerConfiguration {      private static final String RESOURCE_ID = "restservice";      @Configuration     @EnableResourceServer     protected static class ResourceServerConfiguration extends             ResourceServerConfigurerAdapter {          @Override         public void configure(ResourceServerSecurityConfigurer resources) {             // @formatter:off             resources                 .resourceId(RESOURCE_ID);             // @formatter:on         }          @Override         public void configure(HttpSecurity http) throws Exception {             // @formatter:off             http                 .authorizeRequests()                     .antMatchers("/users").hasRole("ADMIN")                     .antMatchers("/greeting").authenticated();             // @formatter:on         }  } </code></pre>  <p>AuthorizationServerConfiguration class:</p>  <pre><code>@Configuration @EnableAuthorizationServer protected static class AuthorizationServerConfiguration extends AuthorizationServerConfigurerAdapter {      private TokenStore tokenStore = new InMemoryTokenStore();      @Autowired     @Qualifier("authenticationManagerBean")     private AuthenticationManager authenticationManager;      @Autowired     private CustomUserDetailsService userDetailsService;      @Override     public void configure(AuthorizationServerEndpointsConfigurer endpoints)             throws Exception {         // @formatter:off         endpoints             .tokenStore(this.tokenStore)             .authenticationManager(this.authenticationManager)             .userDetailsService(userDetailsService);         // @formatter:on     }      @Override     public void configure(ClientDetailsServiceConfigurer clients) throws Exception {         // @formatter:off         clients             .inMemory()                 .withClient("clientapp")                     .authorizedGrantTypes("password", "refresh_token")                     .authorities("USER")                     .scopes("read", "write")                     .resourceIds(RESOURCE_ID)                     .secret("123456");         // @formatter:on     }      @Bean     @Primary     public DefaultTokenServices tokenServices() {         DefaultTokenServices tokenServices = new DefaultTokenServices();         tokenServices.setSupportRefreshToken(true);         tokenServices.setTokenStore(this.tokenStore);         return tokenServices;     }  } </code></pre>  <p>Rest controller:</p>  <pre><code>@RestController @RequestMapping("/ABC") final class Controller {      @Autowired     Repository repository;       @RequestMapping(method = RequestMethod.POST)     @ResponseStatus(HttpStatus.CREATED)     int create(@RequestBody @Valid Data myData) {         repository.create(myData);         return 1;      }      @RequestMapping(value = "{number}", method = RequestMethod.GET)     Data findByNumber(@PathVariable("number") String number) {         Data data = repository.findByNumber(number);         return data;     }      @RequestMapping(value = "{number}", method = RequestMethod.PUT)     int update(@RequestBody @Valid Data myData) {         int rows = repository.update(myData);         return 1;     }      @RequestMapping(value = "{number}", method = RequestMethod.DELETE)     int delete(@PathVariable("number") String number) {         repository.delete(serialNumber);         return 1;     } } </code></pre>