<p>I have a very simple application that goes through a list of hostnames and connects to each one of them on the HTTPS port to obtain fresh server data for client identified data.</p>  <p>In order to obtain the data i use OpenSSL but it seems like it is leaking the memory everytime.</p>  <p>Class responsible for connecting/putting/receivng the SSL data.</p>  <pre><code>class CConnector { public:      static std::string GetData (const std::string&amp; strHostName)     {         // Initialize malloc, free, etc for OpenSSL's use         CRYPTO_malloc_init();          // Initialize OpenSSL's SSL libraries         SSL_library_init();          // Load all available encryption algorithms         OpenSSL_add_all_algorithms();          //         std::string strRequest="GET /\r\n";          // Set up a SSL_CTX object, which will tell our BIO object how to do its work         SSL_CTX* ctx = SSL_CTX_new(SSLv23_client_method());          // Create our BIO object for SSL connections.         BIO* bio = BIO_new_ssl_connect(ctx);          // Create a SSL object pointer, which our BIO object will provide.         SSL* ssl = NULL;          // Failure?         if (bio == NULL)         {             CLogger::Instance()-&gt;Write(XLOGEVENT_LOCATION,CLogger::eState::ERROR, "BIO");             ERR_print_errors_fp(stderr);              if(ctx!=NULL)SSL_CTX_free(ctx);             if(bio!=NULL)BIO_free_all(bio);              return "";         }          // Makes ssl point to bio's SSL object.         BIO_get_ssl(bio, &amp;ssl);          // Set the SSL to automatically retry on failure.         SSL_set_mode(ssl, SSL_MODE_AUTO_RETRY);          // We're connection to google.com on port 443.         std::string strHost = GetHostFromURL(strHostName);         strHost+=":https";          //         BIO_set_conn_hostname(bio, strHost.data());          // Same as before, try to connect.         if (BIO_do_connect(bio) &lt;= 0)         {             CLogger::Instance()-&gt;Write(XLOGEVENT_LOCATION,CLogger::eState::ERROR, "cannot connect");              if(ctx!=NULL)SSL_CTX_free(ctx);             if(bio!=NULL)BIO_free_all(bio);              return "";         }          // Now we need to do the SSL handshake, so we can communicate.         if (BIO_do_handshake(bio) &lt;= 0)         {             CLogger::Instance()-&gt;Write(XLOGEVENT_LOCATION,CLogger::eState::ERROR, "SSL Handshake");              if(ctx!=NULL)SSL_CTX_free(ctx);             if(bio!=NULL)BIO_free_all(bio);              return "";         }          // Create a buffer for grabbing information from the page.         char buf[1024];         memset(buf, 0, sizeof(buf));          // BIO_puts sends a null-terminated string to the server.         BIO_puts(bio, strRequest.c_str());          int iChars = 0;         while (1)         {             iChars = BIO_read(bio, buf, sizeof(buf)-1);              // Close reading             if (iChars &lt;= 0)                 break;              // Terminate the string             buf[iChars] = 0;              // Add to the final output             strOutput.append(buf);         }          SSL_shutdown(ssl);         SSL_CTX_free(ctx);         BIO_free_all(bio);     }  private: }; </code></pre>  <p>And the main program calling the class method</p>  <pre><code>  while(1)     {         for(int a = 0; a &lt; m_vHostNames.size(); a++)         {             std::string strOutput = CConnector::GetData(m_vHostNames[a]);              // Process the data         }          sleep(10000);     } </code></pre>  <p>The debugger/profiler output:</p>  <p><a href="http://i.stack.imgur.com/Ubg5V.png" rel="nofollow"><img src="http://i.stack.imgur.com/Ubg5V.png" alt="OpenSSL Mem Alloc"></a></p>  <p><a href="http://i.stack.imgur.com/7bkuu.png" rel="nofollow"><img src="http://i.stack.imgur.com/7bkuu.png" alt="enter image description here"></a> Question: Do i free the OpenSSL correctly? Or there is something else required?</p>  <p>Thank you for any input into this.</p>