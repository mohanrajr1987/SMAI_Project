<p>I have read this link <a href="http://stackoverflow.com/questions/21657112/analyzing-kmemleak-result">Analyzing kmemleak result</a>, but it seems not give the final answer.</p>  <p>After scanning the memory leak by kmemleak. I can derive the result of unreferenced object's address, say 0xffff880060bb3060 [in the update].</p>  <p>and I use the following gdb command to see the location of this address. Note I found the .text_address in /sys/module/hello/session/.text, and the value is 0xffffffffa038c000</p>  <pre><code>sudo insmod hello.ko         gdb hello.ko /proc/kcore  add-symbol-file hello.ko 0xffffffffa038c000 list *0xffff880060bb3060 </code></pre>  <p>However the list command show nothing.  I have used these steps to debug of kernel oops message, so I'm sure the command I type is correct. </p>  <p>So how can I use gdb to analyze the result given by kmemleak?</p>  <p><strong>Update</strong></p>  <p>I think I should also provide my sample code hello.c:</p>  <pre><code>#include &lt;linux/module.h&gt; #include &lt;linux/list.h&gt; #include &lt;linux/slab.h&gt;   struct num {     struct list_head node;     int number; };  static int __init hello_init(void) {     LIST_HEAD(my_list);     struct num *tmp;     struct list_head *iterator;     u8 i;      for(i=0; i&lt;5; i++) {         tmp = kmalloc(sizeof(struct num), GFP_KERNEL); //I expect this line will be output as memory leak         tmp-&gt;number = i;         list_add(&amp;tmp-&gt;node, &amp;my_list);     }      list_for_each(iterator, &amp;my_list) {         printk("%d\n", list_entry(iterator, struct num, node)-&gt;number);     }      return 0; }  static void hello_exit(void) {     printk(KERN_ALERT "Good, haha\n"); }  module_init(hello_init); module_exit(hello_exit); </code></pre>  <p>And the following is the scan result:</p>  <pre><code> unreferenced object 0xffff880060bb3060 (size 32):       comm "swapper/0", pid 1, jiffies 4294895149 (age 802.568s)       hex dump (first 32 bytes):         00 01 10 00 00 00 ad de 00 02 20 00 00 00 ad de  .......... .....         00 28 b1 57 00 88 ff ff 01 4f 0a 56 00 00 00 00  .(.W.....O.V....       backtrace:         [&lt;ffffffff8170ea7e&gt;] kmemleak_alloc+0x4e/0xc0         [&lt;ffffffff811a5de8&gt;] kmem_cache_alloc_trace+0xb8/0x160         [&lt;ffffffff810b0ed6&gt;] pm_vt_switch_required+0x76/0xb0         [&lt;ffffffff813c1e61&gt;] register_framebuffer+0x1d1/0x370         [&lt;ffffffff813db3fc&gt;] vesafb_probe+0x5bc/0xa70         [&lt;ffffffff814870cc&gt;] platform_drv_probe+0x3c/0x70         [&lt;ffffffff81484d74&gt;] driver_probe_device+0x94/0x3d0         [&lt;ffffffff8148517b&gt;] __driver_attach+0x8b/0x90         [&lt;ffffffff81482913&gt;] bus_for_each_dev+0x73/0xb0         [&lt;ffffffff814847ae&gt;] driver_attach+0x1e/0x20         [&lt;ffffffff814842f8&gt;] bus_add_driver+0x208/0x2e0         [&lt;ffffffff81485844&gt;] driver_register+0x64/0xf0         [&lt;ffffffff81486eca&gt;] __platform_driver_register+0x4a/0x50         [&lt;ffffffff81d923f1&gt;] vesafb_driver_init+0x12/0x14         [&lt;ffffffff810020f2&gt;] do_one_initcall+0xf2/0x1b0         [&lt;ffffffff81d50f24&gt;] kernel_init_freeable+0x144/0x1cc </code></pre>