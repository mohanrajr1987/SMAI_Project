<p>I'm trying to solve a standard interview question. I've a vector where each element is a vector itself of ints. V[0] is employee 0 and the vector of ints in v[0] is the number of employees reporting to him, say 2,3,5. Now if v[2] has 7 then indirectly 7 reports to employee 0 through 2. The question is to find a function that takes in two ints a and b and the vector of dependencies and say if a reports to b, directly or indirectly.</p>  <p>Here's the BFS logic</p>  <pre><code>bool dependencyList(int a, int b, std::vector&lt;std::vector&lt;int&gt;&gt;&amp; v){      std::queue&lt;int&gt; Q;     std::vector&lt;int&gt; D;     std::unordered_map&lt;int, int&gt; M;      for(auto it = v[b].begin(); it!= v[b].end(); it++){         Q.push(*it);         D.push_back(*it);         M[*it] = 1;      }     while(!Q.empty()){         int num = Q.front();         for(auto it = v[num].begin(); it != v[num].end(); it++){             if(M.find(*it) == M.end()){                 D.push_back(*it);                 M[*it] =1;                 Q.push(*it);             }         }         Q.pop();     }      for(auto it= D.begin(); it!= D.end(); it++){         if(*it == a) return true;     }     return false;  } </code></pre>  <p>Here's the driver code</p>  <pre><code>int main() {      std::vector&lt;int&gt; v0;     v0.push_back(2);     v0.push_back(3);     v0.push_back(7);      std::vector&lt;int&gt; v1;     v1.push_back(4);     v1.push_back(9);     v1.push_back(11);      std::vector&lt;int&gt; v2;     v2.push_back(3);     v2.push_back(5);      std::vector&lt;int&gt; v3;     v3.push_back(8);     v3.push_back(6);      std::vector&lt;std::vector&lt;int&gt;&gt; v;     v.push_back(v0);     v.push_back(v1);     v.push_back(v2);     v.push_back(v3);      bool check = dependencyList(6,0,v);      std::cout&lt;&lt;check&lt;&lt;std::cout;      return 0; } </code></pre>  <p>Here's the error that I get</p>  <pre><code>invalid operands to binary expression ('std::__1::basic_ostream&lt;char&gt;' and 'ostream' (aka 'basic_ostream&lt;char&gt;'))     std::cout&lt;&lt;check&lt;&lt;std::cout;     ~~~~~~~~~~~~~~~~^ ~~~~~~~~~ </code></pre>