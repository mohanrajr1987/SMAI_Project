<p>I am trying to write a c++ program that assembles MIPS instructions. While debugging, it keeps throwing an error at line 74 of my main: </p>  <p><code>myassembler.add(lexed[i].labels[0], lexed[i].name, tokens, i);</code></p>  <p>my main is here:</p>  <pre><code>#include &lt;fstream&gt; #include &lt;iostream&gt; #include &lt;iomanip&gt; #include &lt;memory&gt; #include &lt;stdexcept&gt; #include &lt;string&gt; #include &lt;sstream&gt; #include &lt;vector&gt;  #include "exceptions.h" #include "lexer.h" #include "util.h" #include "assembler.h"  std::string read_file(const std::string&amp; name) {   std::ifstream file(name);   if (!file.is_open()) {     std::string error = "Could not open file: ";     error += name;     throw std::runtime_error(error);   }   std::stringstream stream;   stream &lt;&lt; file.rdbuf();   return std::move(stream.str()); }  int main(int argc, char** argv) {   // Adjusting -- argv[0] is always filename.   --argc;   ++argv;    if (argc == 0) {     std::cerr &lt;&lt; "Need a file" &lt;&lt; std::endl;     return 1;   }    assembler myassembler;     for (int i = 0; i &lt; argc; ++i) {     std::string asmName(argv[i]);      if (!util::ends_with_subseq(asmName, std::string(".asm"))) {       std::cerr &lt;&lt; "Need a valid file name (that ends in .asm)" &lt;&lt; std::endl;       std::cerr &lt;&lt; "(Bad name: " &lt;&lt; asmName &lt;&lt; ")" &lt;&lt; std::endl;       return 1;     }      // 4 is len(".asm")     auto length = asmName.size() - string_length(".asm");     std::string baseName(asmName.begin(), asmName.begin() + length);     std::string objName = baseName + ".obj";     try {       auto text = read_file(asmName);       try {         auto lexed = lexer::analyze(text);      // Parses the entire file and returns a vector of instructions          for (int i =0; i &lt; (int)lexed.size(); i++){              if(lexed[i].labels.size() &gt; 0)      // Checking if there is a label in the current instruction                 std::cout &lt;&lt; "label = " &lt;&lt; lexed[i].labels[0] &lt;&lt; "\n";      // Prints the label              std::cout&lt;&lt; "instruction name = " &lt;&lt; lexed[i].name&lt;&lt; "\n";      // Prints the name of instruction               std::cout &lt;&lt; "tokens = ";             std::vector&lt;lexer::token&gt; tokens = lexed[i].args;                for(int j=0; j &lt; (int)tokens.size(); j++){       // Prints all the tokens of this instruction like $t1, $t2, $t3                 if (tokens[j].type == lexer::token::Integer)                     std::cout &lt;&lt; tokens[j].integer() &lt;&lt; " ";                 else                     std::cout &lt;&lt; tokens[j].string() &lt;&lt; " ";             }             myassembler.add(lexed[i].labels[0], lexed[i].name, tokens, i);             myassembler.p();             std::cout &lt;&lt; "\n\n\n";         }        } catch(const bad_asm&amp; e) {         std::stringstream error;         error &lt;&lt; "Cannot assemble the assembly code at line " &lt;&lt; e.line;         throw std::runtime_error(error.str());         } catch(const bad_label&amp; e) {          std::stringstream error;         error &lt;&lt; "Undefined label " &lt;&lt; e.what() &lt;&lt; " at line " &lt;&lt; e.line;         throw std::runtime_error(error.str());         }      } catch (const std::runtime_error&amp; err) {       std::cout &lt;&lt; err.what() &lt;&lt; std::endl;       return 1;     }   }   /*getchar();*/   return 0; } </code></pre>  <p>assembler.h:</p>  <pre><code>#include "lexer.h" #include &lt;fstream&gt; #include &lt;vector&gt; #include &lt;string&gt;  struct symbol {     std::string label = "";     int slinenum;  };  struct relocation {     std::string instruct = "";     std::string label = "";     int rlinenum;     int rt = 0;     int rs = 0; };  struct opcode {     std::string instruct = "";     int opc = 0;     bool isloadstore = false;     int extType = 0;     bool isbranch = false; };  struct function {     std::string instruct = "";     int funct = 0;     bool isjr = false;     bool isshift = false; };  struct regs {     std::string name;     int num; };  enum instrtype {     R, I, neither };  class assembler { public:     assembler();     void oinit(void);     void finit(void);     void rinit(void);     void printToFile(std::fstream &amp;file);     void savesymb(std::string label, int line);     void saverel(std::string instr, std::string label, int line, int rt, int rs);     std::vector&lt;int&gt; formatr(std::string instr, lexer::token toke1, lexer::token toke2, lexer::token toke3, int line);     int formatr(std::string instr, lexer::token toke, int line);     std::vector&lt;int&gt; formati(std::string instr, lexer::token toke1, lexer::token toke2, lexer::token toke3, int line);     std::vector&lt;int&gt; formati(std::string instr, lexer::token toke1, lexer::token toke2, int line);     int findnum(std::string regname);     void add(std::string label, std::string instr, const std::vector&lt;lexer::token&gt; &amp;tokens, int linen);     void secAdd(void);     int rassemble(std::string instr, int rd, int rs, int rt, int shamt);     int iassemble(std::string instr, int rt, int rs, int imm);     void p(); private:     std::vector&lt;int&gt; results;     std::vector&lt;symbol&gt; symbtable;     std::vector&lt;relocation&gt; reloctable;     std::vector&lt;opcode&gt; ops;     std::vector&lt;function&gt; functions;     std::vector&lt;regs&gt; registers;     instrtype type = neither; }; </code></pre>  <p>and assembler.cpp:</p>  <pre><code>// ECE 2500 // Project 1: myAssembler // assembler.cpp // Sheila Zhu  #include "lexer.h" #include &lt;iostream&gt; #include &lt;fstream&gt; #include &lt;vector&gt; #include &lt;string&gt; #include "assembler.h"  assembler::assembler() {     oinit();     finit();     rinit(); }  void assembler::oinit() {     opcode myop;     myop.instruct = "addi";     myop.opc = 8;     myop.extType = 1;     ops.push_back(myop);     // more of the same }  void assembler::finit() {     function myfunc;     myfunc.instruct = "add";     myfunc.funct = 32;     functions.push_back(myfunc);     // more of the same }  void assembler::rinit() {     regs myreg;     myreg.name = "$zero";     myreg.num = 0;     registers.push_back(myreg);     //more of the same }  void assembler::printToFile(std::fstream &amp;file) {     for (int i = 0; i &lt; (int)results.size(); i++)         file &lt;&lt; results.at(i) &lt;&lt; std::endl; }  void assembler::savesymb(std::string label, int line) {     symbol symb;     symb.label = label;     symb.slinenum = line * 4;     symbtable.push_back(symb); }  void assembler::saverel(std::string instr, std::string label, int line, int rt, int rs) {     relocation re;     re.instruct = instr;     re.label = label;     re.rlinenum = line;     re.rt = rt;     re.rs = rs; }  int assembler::findnum(std::string regname) {     for (int i = 0; i &lt; (int)registers.size(); i++)     {         if (regname == registers.at(i).name)             return registers.at(i).num;     }     return -1; }  std::vector&lt;int&gt; assembler::formatr(std::string instr, lexer::token toke1, lexer::token toke2, lexer::token toke3, int line) {     int rd = 0, rs = 0, rt = 0, shamt = 0;     std::vector&lt;int&gt; x;     function currf;     for (int i = 0; i &lt; (int)functions.size(); i++)     {         if (instr == functions.at(i).instruct)             currf = functions.at(i);     }     try     {         if (currf.isshift)         {             if (toke1.type == lexer::token::Integer)                 throw 1;             else             {                 rd = findnum(toke1.string());                 if (rd == -1)                     throw 2;             }             if (toke2.type == lexer::token::Integer)                 throw 1;             else             {                 rs = findnum(toke2.string());                 if (rs == -1)                     throw 2;             }             if (toke3.type == lexer::token::Integer)             {                 shamt = toke3.integer();                 if (shamt &lt; 0)                     throw 3;             }             else                 throw 1;         }         else         {             if (toke1.type == lexer::token::Integer)                 throw 1;             else             {                 rd = findnum(toke1.string());                 if (rd == -1)                     throw 2;             }             if (toke2.type == lexer::token::Integer)                 throw 1;             else             {                 rs = findnum(toke2.string());                 if (rs == -1)                     throw 2;             }             if (toke3.type == lexer::token::Integer)                 throw 1;             else             {                 rt = findnum(toke3.string());                 if (rt == -1)                     throw 2;             }         }     }     catch (int e)     {         if (e == 1)             std::cerr &lt;&lt; "Wrong argument in line " &lt;&lt; line &lt;&lt; std::endl;         else if (e == 2)             std::cerr &lt;&lt; "Invalid register name in line " &lt;&lt; line &lt;&lt; std::endl;         else             std::cerr &lt;&lt; "Shift amount cannot be negative in line " &lt;&lt; line &lt;&lt; std::endl;     }     x.push_back(rd);     x.push_back(rs);     x.push_back(rt);     x.push_back(shamt);     return x; }  int assembler::formatr(std::string instr, lexer::token toke, int line) {     int rs = 0;     try     {         if (toke.type == lexer::token::Integer)             throw 1;         else         {             rs = findnum(toke.string());             if (rs == -1)                 throw 2;         }     }     catch (int e)     {         if (e == 1)             std::cerr &lt;&lt; "Wrong argument in line " &lt;&lt; line &lt;&lt; std::endl;         else             std::cerr &lt;&lt; "Invalid register name in line " &lt;&lt; line &lt;&lt; std::endl;      }     return rs; }      std::vector&lt;int&gt; assembler::formati(std::string instr, lexer::token toke1, lexer::token toke2, lexer::token toke3, int line) {     int rt = 0, rs = 0, imm = 0;     std::vector&lt;int&gt; x;     opcode currop;     for (int i = 0; i &lt; (int)ops.size(); i++)     {         if (instr == ops.at(i).instruct)             currop = ops.at(i);     }     try     {         if (currop.isbranch)         {             if (toke1.type == lexer::token::Integer)                 throw 1;             else             {                 rt = findnum(toke1.string());                 if (rt == -1)                     throw 2;             }             if (toke2.type == lexer::token::Integer)                 throw 1;             else             {                 rs = findnum(toke2.string());                 if (rs == -1)                     throw 2;             }             if (toke3.type == lexer::token::Integer)                 imm = toke3.integer();             else                 saverel(instr, toke3.string(), line, rt, rs);         }         else if (currop.isloadstore)         {             if ((instr == "lbu") || (instr == "sb"))             {                 if (toke2.type == lexer::token::String)                     throw 1;                 else                 {                     if (toke2.integer() &lt; 0)                         imm = (0xFFFF &lt;&lt; 16) + (0xFF &lt;&lt; 8) + toke2.integer();                     else                         imm = toke2.integer();                 }                 if (toke1.type == lexer::token::Integer)                     throw 1;                 else                 {                     rt = findnum(toke1.string());                     if (rt == -1)                         throw 2;                 }                 if (toke3.type == lexer::token::Integer)                     throw 1;                 else                 {                     rs = findnum(toke2.string());                     if (rs == -1)                         throw 2;                 }             }             else             {                 if (toke2.type == lexer::token::String)                     throw 1;                 else                 {                     if (toke2.integer() &lt; 0)                         imm = (0xFFFF &lt;&lt; 16) + toke2.integer();                     else                         imm = toke2.integer();                 }                 if (toke1.type == lexer::token::Integer)                     throw 1;                 else                 {                     rt = findnum(toke1.string());                     if (rt == -1)                         throw 2;                 }                 if (toke3.type == lexer::token::Integer)                     throw 1;                 else                 {                     rs = findnum(toke2.string());                     if (rs == -1)                         throw 2;                 }             }         }         else         {             if ((instr == "andi") || (instr == "ori"))             {                 if (toke1.type == lexer::token::Integer)                     throw 1;                 else                 {                     rt = findnum(toke1.string());                     if (rt == -1)                         throw 2;                 }                 if (toke2.type == lexer::token::Integer)                     throw 1;                 else                 {                     rs = findnum(toke2.string());                     if (rs == -1)                         throw 2;                 }                 if (toke3.type == lexer::token::Integer)                     imm = toke3.integer();                 else                     throw 1;             }             else             {                 if (toke1.type == lexer::token::Integer)                     throw 1;                 else                 {                     rt = findnum(toke1.string());                     if (rt == -1)                         throw 2;                 }                 if (toke2.type == lexer::token::Integer)                     throw 1;                 else                 {                     rs = findnum(toke2.string());                     if (rs == -1)                         throw 2;                 }                 if (toke3.type == lexer::token::Integer)                 {                     if (toke3.integer() &lt; 0)                         imm = (0xFFFF &lt;&lt; 16) + toke2.integer();                     else                         imm = toke3.integer();                 }                 else                     throw 1;             }         }     }     catch (int e)     {         if (e == 1)             std::cerr &lt;&lt; "Wrong argument in line " &lt;&lt; line &lt;&lt; std::endl;         else             std::cerr &lt;&lt; "Invalid register name in line " &lt;&lt; line &lt;&lt; std::endl;     }     x.push_back(rt);     x.push_back(rs);     x.push_back(imm);     return x; }  std::vector&lt;int&gt; assembler::formati(std::string instr, lexer::token toke1, lexer::token toke2, int line) {     int rt = 0, imm = 0;     std::vector&lt;int&gt; rval;     try     {         if (toke1.type == lexer::token::Integer)             throw 1;         else         {             rt = findnum(toke1.string());             if (rt == -1)                 throw 2;         }         if (toke2.type == lexer::token::String)             throw 1;         else             imm = toke2.integer();     }     catch (int e)     {         if (e == 1)             std::cerr &lt;&lt; "Wrong argument in line " &lt;&lt; line &lt;&lt; std::endl;         else             std::cerr &lt;&lt; "Invalid register name in line " &lt;&lt; line &lt;&lt; std::endl;      }     rval.push_back(rt);     rval.push_back(imm);     return rval; }  void assembler::add(std::string label, std::string instr, const std::vector&lt;lexer::token&gt; &amp;token, int linen) {     int assembled = 0, rd = 0, rt = 0;     std::vector&lt;int&gt; argh;     int arg;     if (label.length() &gt; 0)         savesymb(label, linen);     for (int i = 0; i &lt; (int)functions.size(); i++)     {         if (instr == functions.at(i).instruct)             type = R;     }     for (int i = 0; i &lt; (int)ops.size(); i++)     {         if (instr == ops.at(i).instruct)             type = I;     }     if (type == R)     {         try         {             if (instr == "jr")             {                 if ((int)token.size() == 1)                 {                     arg = formatr(instr, token.at(0), linen);                     assembled = rassemble(instr, rd, arg, rt, 0);                 }                 else                     throw 1;             }             else             {                 if ((int)token.size() == 3)                 {                     argh = formatr(instr, token.at(0), token.at(2), token.at(3), linen);                     assembled = rassemble(instr, argh[0], argh[1], argh[2], argh[3]);                 }                 else                     throw 1;             }         }         catch (int e)         {             if (e == 1)                 std::cerr &lt;&lt; "Wrong number of arguments at line " &lt;&lt; linen &lt;&lt; std::endl;         }     }     else if (type == I)     {         try         {             if (instr == "lui")             {                 if ((int)token.size() == 2)                 {                     argh = formati(instr, token.at(0), token.at(1), linen);                     assembled = iassemble(instr, argh[0], 0, argh[1]);                 }                 else                     throw 1;             }             else             {                 if ((int)token.size() == 3)                 {                     argh = formati(instr, token.at(0), token.at(1), token.at(2), linen);                     assembled = iassemble(instr, argh[0], argh[1], argh[2]);                 }                 else                     throw 1;             }         }         catch (int e)         {             if (e == 1)                 std::cout &lt;&lt; "Wrong number of arguments at line " &lt;&lt; linen &lt;&lt; std::endl;         }     }     else         std::cerr &lt;&lt; "Instruction not recognized at line " &lt;&lt; linen &lt;&lt; std::endl;     results.push_back(assembled); }  void assembler::secAdd(void) {     std::vector&lt;int&gt;::iterator iter = results.begin();     for (int i = 0; i &lt; (int)reloctable.size(); i++)     {         for (unsigned int j = 0; j &lt; symbtable.size(); j++)         {             if (reloctable.at(i).label == symbtable.at(j).label)             {                 int assembled = 0;                 iter += (reloctable.at(i).rlinenum / 4);                 for (unsigned int k = 0; k &lt; ops.size(); k++)                 {                     if (reloctable.at(i).instruct == ops.at(k).instruct)                         type = I;                 }                 if (type == I)                     assembled = iassemble(reloctable.at(i).instruct, reloctable.at(i).rt, reloctable.at(i).rs, symbtable.at(i).slinenum);                 else                     std::cerr &lt;&lt; "Instruction not recognized at line " &lt;&lt; reloctable.at(i).rlinenum &lt;&lt; std::endl;                 results.erase(iter);                 results.insert(iter, assembled);             }         }     } }  int assembler::rassemble(std::string instr, int rd, int rs, int rt, int shamt) {     int func = 0;     int code = 0;     for (int i = 0; i &lt; (int)functions.size(); i++)     {         if (instr == functions.at(i).instruct)         {             func = functions.at(i).funct;             break;         }         else         {             if (i == (functions.size() - 1))                 return -1;         }     }     code = (rs &lt;&lt; 21) + (rt &lt;&lt; 16) + (rd &lt;&lt; 11) + (shamt &lt;&lt; 6) + func;     return code; }  int assembler::iassemble(std::string instr, int rt, int rs, int imm) {     int op = 0;     int code = 0;     for (int i = 0; i &lt; (int)ops.size(); i++)     {         if (instr == ops.at(i).instruct)         {             op = ops.at(i).opc;             break;         }         else         {             if (i == (ops.size() - 1))                 return -1;         }     }     code = (op &lt;&lt; 26) + (rs &lt;&lt; 21) + (rt &lt;&lt; 16) + imm;     return code; }  void assembler::p() {     for (int i = 0; i &lt; (int)results.size(); i++)         std::cout &lt;&lt; results.at(i) &lt;&lt; " ";     std::cout &lt;&lt; std::endl; } </code></pre>  <p>When debugging, the tokens parameter triggers the error, and the this pointer in the vector code shows that the vector size changes to 0 at these lines:</p>  <pre><code>#if _ITERATOR_DEBUG_LEVEL == 2         if (size() &lt;= _Pos) </code></pre>  <p>What exactly is happening?</p>  <p>Sorry if my formatting is bad/wrong, etc., and please let me know if I should make any edits/provide more code.</p>  <p>Thanks in advance.</p>