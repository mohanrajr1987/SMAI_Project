<p>I've been trying to compile my program which should push a string and a float pair back on a vector:</p>  <pre><code>typedef std::pair&lt;string, float&gt; Prediction;  std::vector&lt;Prediction&gt; predictions;   for ( int i = 0 ; i &lt; output.size(); i++ ) {     std::vector&lt;int&gt; maxN = Argmax(output[i], 1);     int idx = maxN[0];     predictions.push_back(std::make_pair(labels_[idx], output[idx]));   }   return predictions; </code></pre>  <p>However, every time I try to compile this, I get this error:</p>  <blockquote>   <p>error: no matching member function for call to 'push_back'   predictions.push_back(std::make_pair(labels_[idx], output[idx]));</p> </blockquote>  <p>I also get a few other warnings saying things like</p>  <blockquote>   <p>candidate function not viable: no known conversion from 'pair&lt;[...],   typename __make_pair_return >   &amp;>::type>' to 'const pair&lt;[...], float>' for 1st argument   _LIBCPP_INLINE_VISIBILITY void push_back(const_reference __x);</p> </blockquote>  <p>and</p>  <blockquote>   <p>candidate function not viable: no known conversion from 'pair&lt;[...],   typename __make_pair_return >   &amp;>::type>' to 'pair&lt;[...], float>' for 1st argument   _LIBCPP_INLINE_VISIBILITY void push_back(value_type&amp;&amp; __x);</p> </blockquote>  <p>I've been trying to rewrite things and modify my functions but I can't work out why this error remains, does anyone know what I can do to fix this?</p>  <p>Here is the code in context if that helps, the header file:</p>  <pre><code>/**  * Classification System  */  #ifndef __CLASSIFIER_H__ #define __CLASSIFIER_H__  #include &lt;caffe/caffe.hpp&gt; #include &lt;opencv2/core/core.hpp&gt; #include &lt;opencv2/highgui/highgui.hpp&gt; #include &lt;opencv2/imgproc/imgproc.hpp&gt; #include &lt;algorithm&gt; #include &lt;iosfwd&gt; #include &lt;memory&gt; #include &lt;string&gt; #include &lt;utility&gt; #include &lt;vector&gt;   using namespace caffe;  // NOLINT(build/namespaces) using std::string;  /* Pair (label, confidence) representing a prediction. */ typedef std::pair&lt;string, float&gt; Prediction;  class Classifier {  public:   Classifier(const string&amp; model_file,              const string&amp; trained_file,              const string&amp; label_file);    std::vector&lt; Prediction &gt; Classify(const std::vector&lt;cv::Mat&gt;&amp; img);   private:    std::vector&lt; std::vector&lt;float&gt; &gt; Predict(const std::vector&lt;cv::Mat&gt;&amp; img, int nImages);    void WrapInputLayer(std::vector&lt;cv::Mat&gt;* input_channels, int nImages);    void Preprocess(const std::vector&lt;cv::Mat&gt;&amp; img,                   std::vector&lt;cv::Mat&gt;* input_channels, int nImages);   private:   shared_ptr&lt;Net&lt;float&gt; &gt; net_;   cv::Size input_geometry_;   int num_channels_;   std::vector&lt;string&gt; labels_; };  #endif /* __CLASSIFIER_H__ */ </code></pre>  <p>Class File:</p>  <pre><code>#define CPU_ONLY #include "Classifier.h"  using namespace caffe;  // NOLINT(build/namespaces) using std::string;  Classifier::Classifier(const string&amp; model_file,                        const string&amp; trained_file,                        const string&amp; label_file) { #ifdef CPU_ONLY   Caffe::set_mode(Caffe::CPU); #else   Caffe::set_mode(Caffe::GPU); #endif    /* Load the network. */   net_.reset(new Net&lt;float&gt;(model_file, TEST));   net_-&gt;CopyTrainedLayersFrom(trained_file);    CHECK_EQ(net_-&gt;num_inputs(), 1) &lt;&lt; "Network should have exactly one input.";   CHECK_EQ(net_-&gt;num_outputs(), 1) &lt;&lt; "Network should have exactly one output.";    Blob&lt;float&gt;* input_layer = net_-&gt;input_blobs()[0];   num_channels_ = input_layer-&gt;channels();   CHECK(num_channels_ == 3 || num_channels_ == 1)     &lt;&lt; "Input layer should have 1 or 3 channels.";   input_geometry_ = cv::Size(input_layer-&gt;width(), input_layer-&gt;height());    /* Load labels. */   std::ifstream labels(label_file.c_str());   CHECK(labels) &lt;&lt; "Unable to open labels file " &lt;&lt; label_file;   string line;   while (std::getline(labels, line))     labels_.push_back(string(line));    Blob&lt;float&gt;* output_layer = net_-&gt;output_blobs()[0];   CHECK_EQ(labels_.size(), output_layer-&gt;channels())     &lt;&lt; "Number of labels is different from the output layer dimension."; }  static bool PairCompare(const std::pair&lt;float, int&gt;&amp; lhs,                         const std::pair&lt;float, int&gt;&amp; rhs) {   return lhs.first &gt; rhs.first; }  /* Return the indices of the top N values of vector v. */ static std::vector&lt;int&gt; Argmax(const std::vector&lt;float&gt;&amp; v, int N) {   std::vector&lt;std::pair&lt;float, int&gt; &gt; pairs;   for (size_t i = 0; i &lt; v.size(); ++i)     pairs.push_back(std::make_pair(v[i], i));   std::partial_sort(pairs.begin(), pairs.begin() + N, pairs.end(), PairCompare);    std::vector&lt;int&gt; result;   for (int i = 0; i &lt; N; ++i)     result.push_back(pairs[i].second);   return result; }  std::vector&lt;Prediction&gt; Classifier::Classify(const std::vector&lt;cv::Mat&gt;&amp; img) {   std::vector&lt; std::vector&lt;float&gt; &gt; output = Predict(img, img.size());    std::vector&lt;Prediction&gt; predictions;   for ( int i = 0 ; i &lt; output.size(); i++ ) {     std::vector&lt;int&gt; maxN = Argmax(output[i], 1);     int idx = maxN[0];     predictions.push_back(std::make_pair(labels_[idx], output[idx]));   }   return predictions; }  std::vector&lt; std::vector&lt;float&gt; &gt; Classifier::Predict(const std::vector&lt;cv::Mat&gt;&amp; img, int nImages) {   Blob&lt;float&gt;* input_layer = net_-&gt;input_blobs()[0];   input_layer-&gt;Reshape(nImages, num_channels_,                        input_geometry_.height, input_geometry_.width);   /* Forward dimension change to all layers. */   net_-&gt;Reshape();    std::vector&lt;cv::Mat&gt; input_channels;   WrapInputLayer(&amp;input_channels, nImages);    Preprocess(img, &amp;input_channels, nImages);    net_-&gt;ForwardPrefilled();    /* Copy the output layer to a std::vector */    Blob&lt;float&gt;* output_layer = net_-&gt;output_blobs()[0];   std::vector &lt;std::vector&lt;float&gt; &gt; ret;   for (int i = 0; i &lt; nImages; i++) {     const float* begin = output_layer-&gt;cpu_data() + i*output_layer-&gt;channels();     const float* end = begin + output_layer-&gt;channels();     ret.push_back( std::vector&lt;float&gt;(begin, end) );   }   return ret; }  /* Wrap the input layer of the network in separate cv::Mat objects  * (one per channel). This way we save one memcpy operation and we  * don't need to rely on cudaMemcpy2D. The last preprocessing  * operation will write the separate channels directly to the input  * layer. */ void Classifier::WrapInputLayer(std::vector&lt;cv::Mat&gt;* input_channels, int nImages) {   Blob&lt;float&gt;* input_layer = net_-&gt;input_blobs()[0];    int width = input_layer-&gt;width();   int height = input_layer-&gt;height();   float* input_data = input_layer-&gt;mutable_cpu_data();   for (int i = 0; i &lt; input_layer-&gt;channels()* nImages; ++i) {     cv::Mat channel(height, width, CV_32FC1, input_data);     input_channels-&gt;push_back(channel);     input_data += width * height;   } }  void Classifier::Preprocess(const std::vector&lt;cv::Mat&gt;&amp; img,                             std::vector&lt;cv::Mat&gt;* input_channels, int nImages) {   for (int i = 0; i &lt; nImages; i++) {       vector&lt;cv::Mat&gt; channels;       cv::split(img[i], channels);       for (int j = 0; j &lt; channels.size(); j++){            channels[j].copyTo((*input_channels)[i*num_channels_[0]+j]);       }   } } </code></pre>  <p>Thanks so much!</p>