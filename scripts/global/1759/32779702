<p>I'm trying to replace values in a ComboBox but I always get an error when trying to clear the Items.<br> I'm using the WPF from .Net Framework 4.6. </p>  <p>Here's the code (I'm starting using PowerShell, so it can be fuzzy) :</p>  <pre><code>[void][System.Reflection.Assembly]::LoadWithPartialName('presentationframework') [xml]$XAMLMainWindow = @' &lt;Window          xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"         xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"         xmlns:d="http://schemas.microsoft.com/expression/blend/2008"         xmlns:local="clr-namespace:WpfApplication2"         Title="Folder rights" Height="600" Width="800"&gt;     &lt;Grid&gt;         &lt;Grid.ColumnDefinitions&gt;             &lt;ColumnDefinition Width="247*"/&gt;             &lt;ColumnDefinition Width="545*"/&gt;         &lt;/Grid.ColumnDefinitions&gt;         &lt;TreeView Name="tvFolders" HorizontalAlignment="Left" Height="520" Margin="10,32,0,0" VerticalAlignment="Top" Width="189"/&gt;         &lt;TextBox Name="txtFolder" HorizontalAlignment="Left" Height="24" Margin="216,32,0,0" TextWrapping="Wrap" VerticalAlignment="Top" Width="554" FontSize="13.333" Grid.ColumnSpan="2" VerticalContentAlignment="Center"/&gt;         &lt;Label Name="lblFolder" Content="Folder :" HorizontalAlignment="Left" Margin="216,4,0,0" VerticalAlignment="Top" FontSize="13.333" Grid.ColumnSpan="2"/&gt;         &lt;Button Name="btnSearch" Content="Search" HorizontalAlignment="Left" Height="25" Margin="462,61,0,0" VerticalAlignment="Top" Width="61" FontSize="13.333" VerticalContentAlignment="Center" Grid.Column="1"/&gt;         &lt;Button Name="btnExit" Content="Exit" HorizontalAlignment="Left" Height="23" Margin="462,529,0,0" VerticalAlignment="Top" Width="61" FontSize="13.333" Grid.Column="1"/&gt;         &lt;ListBox Name="lbReadWrite" HorizontalAlignment="Left" Height="396" Margin="216,128,0,0" VerticalAlignment="Top" Width="272" Grid.ColumnSpan="2"/&gt;         &lt;ListBox Name="lbRead" HorizontalAlignment="Left" Height="396" Margin="268,128,0,0" VerticalAlignment="Top" Width="255" Grid.Column="1"/&gt;         &lt;Label Name="lblReadWrtie" Content="Read/Write :" HorizontalAlignment="Left" Margin="216,66,0,0" VerticalAlignment="Top" FontSize="13.333" Grid.ColumnSpan="2"/&gt;         &lt;Label Name="lblRead" Content="Read :" HorizontalAlignment="Left" Margin="268,67,0,0" VerticalAlignment="Top" FontSize="13.333" Grid.Column="1"/&gt;         &lt;Button Name="btnExport" Content="Export" HorizontalAlignment="Left" Margin="395,529,0,0" VerticalAlignment="Top" Width="61" FontSize="13.333" Height="23" Grid.Column="1"/&gt;         &lt;Label Name="lblTree" Content="Tree :" HorizontalAlignment="Left" Margin="10,4,0,0" VerticalAlignment="Top" FontSize="13.333"/&gt;         &lt;ComboBox Name="cbxReadWrite" Grid.ColumnSpan="2" HorizontalAlignment="Left" Margin="216,95,0,0" VerticalAlignment="Top" Width="272"/&gt;         &lt;ComboBox Name="cbxRead" Grid.Column="1" HorizontalAlignment="Left" Margin="270,96,0,0" VerticalAlignment="Top" Width="253"/&gt;         &lt;Label Name="lblError" HorizontalAlignment="Left" Height="23" Margin="216,52,0,0" VerticalAlignment="Top" Width="180" RenderTransformOrigin="0.167,0.641" Grid.ColumnSpan="2" FontSize="9.333" Foreground="Red"/&gt;     &lt;/Grid&gt; &lt;/Window&gt; '@  $ErrorActionPreference = 'Stop'  #Read XAML $reader=(New-Object System.Xml.XmlNodeReader $XAMLMainWindow)  $formMainWindow=[Windows.Markup.XamlReader]::Load( $reader )  # Store Form Objects In PowerShell $XAMLMainWindow.SelectNodes("//*[@Name]") | %{Set-Variable -Name ($_.Name) -Value $formMainWindow.FindName($_.Name)}  #=============================================================================== # Add events to Form Objects #===============================================================================  $btnExit.Add_Click({$formMainWindow.Close()})  $btnSearch.Add_Click({retrieveData;})  $cbxReadWrite.Add_SelectionChanged({populateCList;})  $cbxRead.Add_SelectionChanged({populateRList;})  #=============================================================================== # Functions #===============================================================================  Function retrieveData() {      # get folder object     try {         # initialization         $lblError.Content = "";         $global:allRGroups = @();         $global:allRUsers = @();         $global:allCGroups = @();         $global:allCUsers = @();          $folder = Get-Item -Path $txtFolder.Text.ToString() -ErrorAction Continue          # get "Read" groups         $Raccess = (Get-Acl $folder).Access |              Where-Object {$_.IdentityReference -like 'D1*_R'} |              Select-Object @{n='GroupName';e={(($_.IdentityReference).ToString()).Substring(3)}} |             Sort-Object GroupName         If ($Raccess) {             foreach($access in $Raccess)             {                 $global:allUsers = @()                 $global:allGroups = @()                 getGroupMembers($access.GroupName)                 $global:allRGroups += $global:allGroups                 $global:allRUsers += $global:allUsers             }         }          # get "Read/Write" groups         $Caccess = (Get-Acl $folder).Access |              Where-Object {$_.IdentityReference -like 'D1*_C'} |              Select-Object @{n='GroupName';e={(($_.IdentityReference).ToString()).Substring(3)}}             Sort-Object GroupName         If ($Caccess) {             foreach($access in $Caccess)             {                 $global:allUsers = @()                 $global:allGroups = @()                 getGroupMembers($access.GroupName)                 $global:allCGroups += $global:allGroups                 $global:allCUsers += $global:allUsers             }         }           $cbxRead.Items.Clear();         $cbxReadWrite.Items.Clear();         populateCombos;         $cbxRead.SelectedIndex = 0 ;         $cbxReadWrite.SelectedIndex = 0;        } catch {         $lblError.Content = "Erreur"     } }  Function populateCombos() {     if ($Global:allRGroups) {         $cbxRead.Items.Add("&lt;All&gt;")         $groupsToAdd = $Global:allRGroups | Sort-Object         foreach ($group in $groupsToAdd) {                         $cbxRead.items.add($group)                     }     }      if ($Global:allCGroups) {         $cbxReadWrite.Items.Add("&lt;All&gt;")         $groupsToAdd = $Global:allCGroups | Sort-Object         foreach ($group in $groupsToAdd) {                         $cbxReadWrite.items.add($group)                     }     }  }  Function getGroupMembers([String]$groupToScan)  {     $users = Get-ADGroupMember $groupToScan |          Where-Object {($_.objectClass -eq 'user') -and ($_.distinguishedName -like '*MYUSERS*')}     if ($users) {         $global:allUsers += $users         $global:allGroups += $groupToScan     }     $groups = Get-ADGroupMember $groupToScan |          Where-Object {$_.objectClass -eq 'group'}     if ($groups) {         foreach($group in $groups)         {             getGroupMembers($group.name)         }     }  }  Function populateCList() {     ($lbReadWrite.Items).Clear()     $selection = $cbxReadWrite.SelectedValue     if ($selection -ne '&lt;All&gt;')     {         $members = Get-ADGroupMember -Identity $selection -Recursive |             Where-Object {$_.distinguishedName -like '*MYUSERS*'}     } else {         $members = $Global:allCUsers     }     if ($members)      {         $membersToDsiplay = $members |              Select-Object @{n='DisplayName';e={$_.name + " (" + $_.SamAccountName + ")"}} |             Sort-Object DisplayName |              Select -Unique DisplayName         foreach ($member in $membersToDsiplay)          {             $lbReadWrite.AddText($member.DisplayName)         }     } }  Function populateRList() {     ($lbRead.Items).Clear()     $selection = $cbxRead.SelectedValue     if ($selection -ne '&lt;All&gt;')     {         $members = Get-ADGroupMember -Identity $selection -Recursive |             Where-Object {$_.distinguishedName -like '*MYUSERS*'}      } else {         $members = $Global:allRUsers     }     if ($members)      {         $membersToDsiplay = $members |              Select-Object @{n='DisplayName';e={$_.name + " (" + $_.SamAccountName + ")"}} |              Sort-Object DisplayName |              Select -Unique DisplayName         foreach ($member in $membersToDsiplay)          {             $lbRead.AddText($member.DisplayName)         }     } }  #===============================================================================  # Shows the form $formMainWindow.ShowDialog() | out-null </code></pre>  <p>What I'm trying to do is to fill the ComboBox based an another value.<br> The problem is when I try to clear the control to replace the items in it, it gives me an error. The first time it goes through, $cbxRead.Items is empty and it works. The second time, it contains a System.String object which is in fact an array of String. The Clear() method gives this :</p>  <pre><code>Exception calling "Clear" with "0" argument(s): "Cannot validate argument on parameter 'Identity'. The argument is null or empty. Supply an argument that is not null or empty and then try  the command again." At D:\WorkingDir\PS\fa.ps1:106 char:9 +         ($cbxRead.Items).Clear(); +         ~~~~~~~~~~~~~~~~~~~~~~~~     + CategoryInfo          : NotSpecified: (:) [], ParentContainsErrorRecordException     + FullyQualifiedErrorId : ParameterBindingValidationException </code></pre>  <p>What is stange is : if I put a breakpoint on the faulty command, and I type it manually in the command line frame in ISE, it executes whitout giving any error.</p>  <p>I also tried removing items with a foreach{xxx.Items.Remove()}, setting Items to $null, none worked.</p>  <p>If someone has an idea, he's welcome ! (thanks)</p>  <p>DDF</p>