<p>We are using Spring and IBatis and I have discovered something interesting in the way a service method with @Transactional handles multiple DAO calls that return the same record.  Here is an example of a method that does not work.</p>  <pre><code>@Transactional public void processIndividualTrans(IndvTrans trans) { Individual individual = individualDAO.selectByPrimaryKey(trans.getPartyId());         individual.setFirstName(trans.getFirstName()); individual.setMiddleName(trans.getMiddleName()); individual.setLastName(trans.getLastName());  Individual oldIndvRecord = individualDAO.selectByPrimaryKey(trans.getPartyId()); individualHistoryDAO.insert(oldIndvRecord);  individualDAO.updateByPrimaryKey(individual); } </code></pre>  <p>The problem with the above method is that the 2nd execution of the line     individualDAO.selectByPrimaryKey(trans.getPartyId()) returns the <strong><em>exact object</em></strong> returned from the first call.  </p>  <p>This means that oldIndvRecord and individual are the same object, and the line     individualHistoryDAO.insert(oldIndvRecord); adds a row to the history table that contains the changes (which we do not want).</p>  <p>In order for it to work it must look like this.</p>  <pre><code>@Transactional public void processIndividualTrans(IndvTrans trans) { Individual individual = individualDAO.selectByPrimaryKey(trans.getPartyId());        individualHistoryDAO.insert(individual);  individual.setFirstName(trans.getFirstName()); individual.setMiddleName(trans.getMiddleName()); individual.setLastName(trans.getLastName()); individualDAO.updateByPrimaryKey(individual); } </code></pre>  <p>We wanted to write a service called updateIndividual that we could use for all updates of this table that would store a row in the IndividualHistory table before performing the update.</p>  <pre><code>@Transactional public void updateIndividual(Individual individual) { Individual oldIndvRecord = individualDAO.selectByPrimaryKey(trans.getPartyId()); individualHistoryDAO.insert(oldIndvRecord); individualDAO.updateByPrimaryKey(individual); } </code></pre>  <p>But it does not store the row as it was before the object changed. We can even explicitly instantiate different objects before the DAO calls and the second one becomes the same object as the first. </p>  <p>I have looked through the Spring documentation and cannot determine why this is happening.  </p>  <p>Can anyone explain this?  </p>  <p>Is there a setting that can allow the 2nd DAO call to return the database contents and not the previously returned object?</p>