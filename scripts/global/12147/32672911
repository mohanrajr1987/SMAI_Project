<p>Context: I'm writing something to process log data which involves loading several GB of data into memory and cross checking various things, finding correlations in data and writing the results out to another file.  (This is essentially a cooking/denormalization step before loading into a Druid.io cluster.)  I want to avoid having to write the information to a database for both performance and code simplicity - it is assumed that in the foreseeable future the volume of data processed at one time can be handled by adding memory to the machine.</p>  <p>My question is if it is a good idea to attempt to explicitly deduplicate strings in my code; and if so, what is a good approach.  Many of the values in these log files are the same exact pieces of text (probably about 25% of the total text values in the file are unique, rough guess).</p>  <p>Since we're talking about gigs of data, and while ram is cheap and swap is possible, there is still a limit and if I'm careless I will very likely hit it. If I do something like this:</p>  <pre><code>strstore := make(map[string]string)  // do some work that involves slicing and dicing some text, resulting in: var a = "some string that we figured out that has about a 75% chance of being duplicate"  // note that there are about 10 other such variables that are calculated here, only "a" shown for simplicity  if _, ok := strstore[a]; !ok {     strstore[a] = a } else {     a = strstore[a] }  // now do some more stuff with "a" and keep it in a struct which is in // some map some place </code></pre>  <p>It would seem to me that this would have the effect of "reusing" existing strings, at the cost of a hash lookup and compare.  Seemingly a good trade off.</p>  <p>However, this might not be that helpful if the strings that are in fact new cause memory to be fragmented and have various holes that are left unclaimed.</p>  <p>I could also try to keep one big byte array/slice which has the character data and index into that, but it would make the code hard to write (esp having to mess around with conversion between []byte and strings, which involves it's own allocation) and I would probably just be doing a poor job of something that is really the Go runtime's domain anyway.</p>  <p>Looking for any advice on approaches to this problem, or if anyone's experience with this sort of thing has yielded particularly useful mechanisms to address this.</p>