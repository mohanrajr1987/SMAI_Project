<p>I want to create a method that returns all ads within a radius, so I'm trying to add functions: <code>earth_distance_operator</code>, <code>earth_box</code>, <code>ll_to_earth</code> the postgress.</p>  <p>config.yml</p>  <pre><code>orm:         auto_generate_proxy_classes: "%kernel.debug%"         auto_mapping: true         dql:             numeric_functions:                 earth_box: Delivve\WebBundle\DQL\EarthBox                 ll_to_earth: Delivve\WebBundle\DQL\LLToEarth                 earth_distance_operator: Delivve\WebBundle\DQL\EarthDistanceOperator </code></pre>  <p>EarthBox.php</p>  <pre><code>class EarthBox extends FunctionNode {     private $earth;     private $radius;      public function getSql(SqlWalker $sqlWalker)     {         return 'earth_box(' . $this-&gt;earth-&gt;dispatch($sqlWalker) . ', ' . $this-&gt;radius-&gt;dispatch($sqlWalker) . ')';     }      public function parse(Parser $parser)     {         $parser-&gt;match(Lexer::T_IDENTIFIER);         $parser-&gt;match(Lexer::T_OPEN_PARENTHESIS);          $this-&gt;earth = $parser-&gt;StringPrimary();         $parser-&gt;match(Lexer::T_COMMA);          $this-&gt;radius = $parser-&gt;ArithmeticPrimary();         $parser-&gt;match(Lexer::T_CLOSE_PARENTHESIS);     } }  </code></pre>  <p>EarthDistanceOperator.php</p>  <pre><code>class EarthDistanceOperator extends FunctionNode {     private $operator;     private $first;     private $second;      /**      * @param SqlWalker $sqlWalker      *      * @return string      */     public function getSql(SqlWalker $sqlWalker)     {         return sprintf("%s %s %s",             $this-&gt;first-&gt;dispatch($sqlWalker),             $this-&gt;operator-&gt;value,             $this-&gt;second-&gt;dispatch($sqlWalker)         );     }     /**      * @param Parser $parser      *      * @return void      */     public function parse(Parser $parser)     {         $parser-&gt;match(Lexer::T_IDENTIFIER);         $parser-&gt;match(Lexer::T_OPEN_PARENTHESIS);          $this-&gt;first = $parser-&gt;StringPrimary();         $parser-&gt;match(Lexer::T_COMMA);          $this-&gt;operator = $parser-&gt;StringExpression();         $parser-&gt;match(Lexer::T_COMMA);          $this-&gt;second = $parser-&gt;StringPrimary();         $parser-&gt;match(Lexer::T_CLOSE_PARENTHESIS);     } }  </code></pre>  <p>LLToEath.php</p>  <pre><code>class LLToEarth extends FunctionNode {     private $latitude;     private $longitude;      public function getSql(SqlWalker $sqlWalker)     {         return 'll_to_earth(' . $this-&gt;latitude-&gt;dispatch($sqlWalker) . ', ' . $this-&gt;longitude-&gt;dispatch($sqlWalker) . ')';     }      public function parse(Parser $parser)     {         $parser-&gt;match(Lexer::T_IDENTIFIER);         $parser-&gt;match(Lexer::T_OPEN_PARENTHESIS);          $this-&gt;latitude = $parser-&gt;ArithmeticPrimary();         $parser-&gt;match(Lexer::T_COMMA);          $this-&gt;longitude = $parser-&gt;ArithmeticPrimary();         $parser-&gt;match(Lexer::T_CLOSE_PARENTHESIS);     } }  </code></pre>  <p>My problem is that when I create the function in the repository he's not giving function ll_to_eath as indefinite</p>  <p>AdRepository.php</p>  <pre><code>    public function findByExceptOwner($paramFetcher)     {         $departureOriginal = $paramFetcher['departure'];         $departureArray = preg_split('/ - /', $departureOriginal);         $departureCityArray = preg_split('/,/', $departureArray[count($departureArray) - 2]);         $departureUFArray = preg_split('/,/', $departureArray[count($departureArray) - 1]);         $departure = $departureCityArray[count($departureCityArray) -1].' - '.$departureUFArray[0];          $destinationOriginal = $paramFetcher['destination'];         $destinationArray = preg_split('/ - /', $destinationOriginal);         $destinationCityArray = preg_split('/,/', $destinationArray[count($destinationArray) - 2]);         $destinationUFArray = preg_split('/,/', $destinationArray[count($destinationArray) - 1]);         $destination = $destinationCityArray[count($destinationCityArray) -1].' - '.$destinationUFArray[0];          dump($departure);         dump($destination);          $query = $this-&gt;getEntityManager()-&gt;createQueryBuilder('ad');          // par√¢metros iniciais da query: status, departure de destination         $query-&gt;select('ad')             -&gt;from('DelivveWebBundle:'.$paramFetcher['type'], 'ad')             -&gt;where('ad.owner &lt;&gt; :ownerId')             -&gt;andWhere($query-&gt;expr()-&gt;eq('ad.status', ':status'))             -&gt;andWhere($query-&gt;expr()-&gt;like('ad.departure', ':departure'))             -&gt;andWhere($query-&gt;expr()-&gt;like('ad.destination', ':destination'))             -&gt;andWhere('ad.dateFinal &lt;= :today')             -&gt;setParameter('ownerId', $paramFetcher['ownerId'])             -&gt;setParameter('status', 'new')             -&gt;setParameter('departure', "%{$departure}%")             -&gt;setParameter('destination', "%{$destination}%")             -&gt;setParameter('today', new \DateTime("now"));          // raio de busca com centro nas coordenadas de departure         if ($paramFetcher['departure_latitude'] &amp;&amp; $paramFetcher['departure_longitude'] &amp;&amp; $paramFetcher['radius']) {             $query                 -&gt;andWhere('earth_distance_operator(earth_box(ll_to_earth(:departure_lat, :departure_lon), :radius), \'@&gt;\', ll_to_earth(ad.departureLatitude, ad.departureLongitude)) = true')                 -&gt;setParameter('departure_lat', floatval($paramFetcher['departure_latitude']), \Doctrine\DBAL\Types\Type::FLOAT)                 -&gt;setParameter('departure_lon', floatval($paramFetcher['departure_longitude']), \Doctrine\DBAL\Types\Type::FLOAT)                 -&gt;setParameter('radius', floatval($paramFetcher['radius']) / 1.609, \Doctrine\DBAL\Types\Type::FLOAT);         }          // raio de busca com centro nas coordenadas de destionation         if ($paramFetcher['destination_latitude'] &amp;&amp; $paramFetcher['destination_longitude'] &amp;&amp; $paramFetcher['radius']) {             $query                 -&gt;andWhere('earth_distance_operator(earth_box(ll_to_earth(:destination_lat, :destination_lon), :radius), \'@&gt;\', ll_to_earth(ad.destinationLatitude, ad.destinationLongitude)) = true')                 -&gt;setParameter('destination_lat', floatval($paramFetcher['destination_latitude']), \Doctrine\DBAL\Types\Type::FLOAT)                 -&gt;setParameter('destination_lon', floatval($paramFetcher['destination_longitude']), \Doctrine\DBAL\Types\Type::FLOAT)                 -&gt;setParameter('radius', floatval($paramFetcher['radius']) / 1.609, \Doctrine\DBAL\Types\Type::FLOAT);         }          dump($query-&gt;getQuery());         dump($query-&gt;getQuery()-&gt;getResult());         die();         return ;     } </code></pre>  <p>This is the mistake that this giving, someone help me?</p>  <pre><code>SQLSTATE[42883]: Undefined function: 7 ERROR: function ll_to_earth(unknown, unknown) does not exist </code></pre>  <p>`</p>  <pre><code>[2/2] DBALException: An exception occurred while executing 'SELECT m0_.created_at AS created_at0, m0_.updated_at AS updated_at1, m0_.id AS id2, m0_.departure AS departure3, m0_.departure_latitude AS departure_latitude4, m0_.departure_longitude AS departure_longitude5, m0_.destination AS destination6, m0_.destination_latitude AS destination_latitude7, m0_.destination_longitude AS destination_longitude8, m0_.landmark AS landmark9, m0_.transportation AS transportation10, m0_.date AS date11, m0_.price AS price12, m0_.status AS status13, m0_.responsible AS responsible14, m0_.package_type AS package_type15, m0_.date_final AS date_final16, m0_.type AS type17, m0_.user_id AS user_id18 FROM Sender s1_ INNER JOIN my_ad m0_ ON s1_.id = m0_.id WHERE m0_.user_id &lt;&gt; ? AND m0_.status = ? AND m0_.departure LIKE ? AND m0_.destination LIKE ? AND m0_.date_final &lt;= ? AND earth_box(ll_to_earth(?, ?), ?) @&gt; ll_to_earth(m0_.departure_latitude, m0_.departure_longitude) = true AND earth_box(ll_to_earth(?, ?), ?) @&gt; ll_to_earth(m0_.destination_latitude, m0_.destination_longitude) = true' with params [2, "new", "% S\u00e3o Carlos - SP%", "%S\u00e3o Carlos - SP%", "2015-09-22 10:10:04", "-22.0087082", "-47.89092629999999", 18.645121193288, "-22.0087082", "-47.89092629999999", 18.645121193288]:  SQLSTATE[42883]: Undefined function: 7 ERROR: function ll_to_earth(unknown, unknown) does not exist LINE 1: ...on LIKE $4 AND m0_.date_final &lt;= $5 AND earth_box(ll_to_eart... ^ HINT: No function matches the given name and argument types. You might need to add explicit type casts. </code></pre>