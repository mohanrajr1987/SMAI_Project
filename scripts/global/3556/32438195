<p>For the sake of simplicity, say I have a private field that caches my collection's count:</p>  <pre><code>private int _count; </code></pre>  <p>I would like to ensure that the count is never below zero. I can check this in the invariant:</p>  <pre><code>[ContractInvariantMethod] private void invariant(){     Contract.Invariant(_count &gt;= 0); } </code></pre>  <p>However, this is only going to catch the mistake when exiting a public method â€“ not when it happens. The value could be assign by a more complicate algorithm, so getting the exact time where it fails can be valuable.</p>  <p>I could wrap the contract in a property like this:</p>  <pre><code>public int Count {     get {         Contract.Ensures(Contract.Result&lt;int&gt;() &gt;= 0);         return _count;     }     private set {         Contract.Requires(value &gt;= 0);         _count = value;     } } </code></pre>  <p>But this doesn't really ensure that I don't access the field directly, and it add the extra overhead of going through a property when altering the value internally. Since the setter is private I can't stick the contract on an interface either.</p>  <p>Is it possible to maybe annotate the field with a contract to ensure it is check when setting it?</p>