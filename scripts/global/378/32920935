<p>At work I've suffered from quite a few memory leaks in a Silverlight 5 project so I thought I'd run an idea by you for resolving this issue.</p>  <p>The idea stems from implementing a 'Dispose' pattern across all view models. One area in particular I think is a major headache as far as memory leaks are concerned are events, and therefore I believe this solution should address this nicely.</p>  <p>The way I think about it is that this should allow 1 and only one subscriber to subscribe to events at a time. Meaning that the same object shouldn't be able to subscribe for the same event twice and having the subsequent side effects.</p>  <p>Second, since I keep a reference to the subscribers of the event - when dispose comes around I can get rid of those references, regardless of the fact that the EventHandler internally keeps the same references. I get a chance to unhook the event completely by unhooking all of it's subscribers and thus preventing the pesky memory leaks.</p>  <p>Does anyone think this will introduce issues in the app? I mean it's rather large and I don't want to push experimental stuff without researching a bit more.</p>  <p>Thanks!</p>  <p>Start with the <code>DisposableObject</code> base class:</p>  <pre><code>public class DisposableObject : IDisposable {   private bool disposed = false; // to detect redundant calls    /// &lt;summary&gt;   /// Default constructor   /// &lt;/summary&gt;   public DisposableObject() { }    /// &lt;summary&gt;   /// Object that inherit from this base class should override this method instead,   /// since it's called from the Dispose() method by the base.   /// &lt;/summary&gt;   /// &lt;param name="disposing"&gt;&lt;/param&gt;   protected virtual void Dispose(bool disposing)   {     if (!disposed)     {       if (disposing)       {         // dispose-only, i.e. non-finalizable logic       }        // shared cleanup logic       disposed = true;     }   }    /// &lt;summary&gt;   /// Destructor   /// &lt;/summary&gt;   ~DisposableObject()   {     Dispose(false);   }    /// &lt;summary&gt;   /// Implementation of IDisposable. Object that inherit from this base class   /// should override the Dispose(bool) method instead.   /// &lt;/summary&gt;   public void Dispose()   {     Dispose(true);     GC.SuppressFinalize(this);   } } </code></pre>  <p>And then the actual implementation: <code>DelegateCommand</code> (or rather it's base class).</p>  <pre><code>public abstract class DelegateCommandBase : DisposableObject, ICommand {   private bool _isDisposed = false;   private event EventHandler _canExecuteChanged;   private List&lt;EventHandler&gt; _subscribers = new List&lt;EventHandler&gt;();    /* OTHER NON-IMPLEMENTATION DETAILS */    public event EventHandler CanExecuteChanged   {     add     {       lock (_canExecuteChanged)       {         if (this._subscribers.Contains(value))           return;          this._subscribers.Add(value);         _canExecuteChanged += value;       }     }     remove     {       lock (_canExecuteChanged)       {         if (this._subscribers.Contains(value))           this._subscribers.Remove(value);          _canExecuteChanged -= value;       }     }   }    protected override void Dispose(bool disposing)   {     if (!_isDisposed &amp;&amp; disposing)     {       this._executeMethod = null;       this._canExecuteMethod = null;        if (!this._subscribers.Any())       {         this._isDisposed = true;         base.Dispose(disposing);         return;       }        lock(this._canExecuteChanged)       {         for(int i = this._subscribers.Count - 1; i &gt;= 0; i--)         {           var subscriber = this._subscribers[i];           this._subscribers.RemoveAt(i);           this._canExecuteChanged -= subscriber;           subscriber = null;         }          this._subscribers = null;         this._isDisposed = true;       }     }     base.Dispose(disposing);   } } </code></pre>