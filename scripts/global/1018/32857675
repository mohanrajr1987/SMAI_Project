<p>I want to loop through different indexed tables by only passing the initial table as an argument. I currently have this table:</p>  <pre><code>local table = { stuff_1 = {     categories = {},     [1] = {          name = 'wui',         time = 300     } }, stuff_2 = {     categories = {'stuff_10', 'stuff_11', 'stuff_12'},     stuff_10 = {         categories = {},         [1] = {             name = 'peo',             time = 150         },         [2] = {              name = 'uik',             time = 15         },         [3] = {              name = 'kpk',             time = 1230         },           [4] = {                  name = 'aer',             time = 5000         }     },     stuff_11 = {         categories = {},         [1] = {              name = 'juio',             time = 600         }     },     stuff_12 = {         categories = {},         [1] = {             name = 'erq',             time = 980         },         [2] = {             name = 'faf',             time = 8170         }     } } </code></pre>  <p>I wanted to make a recursive function to check if the name in any of those tables was equal to some certain thing and return a string. The recursivity lies in the idea of updating this table with whatever ammount I'd like (or until a certain limit). I don't understand exactly what's wrong since when I try:</p>  <pre><code>for k, v in pairs(table) do     print(k, v, #v.categories) end  </code></pre>  <p>It correctly prints:</p>  <pre><code>stuff_2 table: 0x10abb0 3 stuff_1 table: 0x10aab8 0 </code></pre>  <p>But when passing the table as a parameter to the the function below, it gives this error:</p>  <pre><code>[string "stdin"]:84: attempt to get length of field 'categories' (a nil value) </code></pre>  <p>Function:</p>  <pre><code>function checkMessage(table)     local i = 1     local message = ""      for k, v in pairs(table) do          if(#v.categories == 0) then               while(v[i]) do                  if(v[i].name == 'opd') then                      if(v[i].time ~= 0) then                          message = "return_1"                     else                          message = "return_2"                     end                  end                  i = i + 1              end         else             checkMessage(table[k])         end      end      return message  end </code></pre>  <p>EDIT: The problem lies in not ignoring that when using pairs onto the table, this doesn't just have tables with a category subtable but it also has a table named category, if this is ignored then the problem is fixed.</p>