<p>I apologize ahead of time for the verbosity of the code.</p>  <p>I have been writing a small Lua bindings generator in C++ using TMP and I have encountered a need for partial template specialization of a function that I don't think can be resolved with a function overload. For clarity, I have omitted the actual Lua code.</p>  <p><strong>EDIT: I understand that functions cannot be partially specialized.</strong></p>  <p><strong>Here is the code I want to write:</strong></p>  <pre><code>template&lt;typename _Result, class _Class, typename ..._Args&gt; class LuaMethodRegistrar { public:         typedef _Result (_Class::*Func)(_Args...);         using _This = LuaMethodRegistrar&lt;_Result, _Class, _Args...&gt;;         enum { N_ARGS = std::tuple_size&lt;std::tuple&lt;_Args...&gt;&gt;::value }; public:         template &lt;Func _Func&gt;         static typename NamedRegistrar::RegisterFunc GetWrapper()         {                 return Register&lt;_Func&gt;;         }  private:         template &lt;Func _Func&gt;         static bool Register(lua_State* L, char const* className, char const* methodName)         {                 // register _This::LuaCallWrapper&lt;_Result, _Func&gt;                 return true;         }          template&lt;Func _Func&gt;         static _Result MethodWrapper(void* object, _Args... args)         {                 return (static_cast&lt;_Class*&gt;(object)-&gt;*_Func)(args...);         }         /////////////////// Key functions are down here ///////////////////           template &lt;typename _Result, Func _Func&gt;         static int LuaCallWrapper(lua_State* L)         {                 // grab obj                 int nArgs = N_ARGS;                 return LuaReturn(L, MethodWrapper&lt;_Func&gt;(obj, LuaExtract&lt;_Args&gt;(L, nArgs)...)); // this line works fine here         }          template &lt;Func _Func&gt;         static int LuaCallWrapper&lt;void, _Func&gt;(lua_State* L)         {                 // grab obj                 MethodWrapper&lt;_Func&gt;(obj, LuaExtract&lt;_Args&gt;(L, nArgs)...));                 return 0;         }    }; </code></pre>  <p><strong>The Problems</strong></p>  <ol> <li><p>Depending on the function that the client is trying to register, _Result could be void, which would result in an "invalid use of void expression" error when passing the result of LuaExtract (shown later) as the 2nd to 2+Nth arguments to MethodWrapper.</p></li> <li><p>I cannot overload LuaWrapper because Lua expects a function pointer of type: <code>int(*)(lua_State*)</code>.</p></li> </ol>  <p><strong>My Attempted Solution:</strong></p>  <p>I decided to make a new struct that I can partially specialize.</p>  <pre><code>////////////////// Forward declared above but defined below LuaMethodRegistrar ///////////////////  template &lt;typename _Result, typename _Class, typename ..._Args&gt; struct LuaCallWrapper {         using Registrar = LuaMethodRegistrar&lt;_Result, _Class, _Args...&gt;;         enum { N_ARGS = std::tuple_size&lt;std::tuple&lt;_Args...&gt;&gt;::value };          template&lt;_Result(_Class::*_Func)(_Args...)&gt;         static int Call(lua_State* L)         {                 // I can't use Registrar here because it gives me the "does not name a type error"                 // Yet, when I use the full type, it finds it.                 int nArgs = N_ARGS;                 return LuaReturn(L, LuaMethodRegistrar&lt;_Result, _Class, _Args...&gt;::MethodWrapper&lt;_Func&gt;(obj, LuaExtract&lt;_Args&gt;(L, nArgs)...));         } };  template &lt;typename _Class, typename ..._Args&gt; struct LuaCallWrapper&lt;void, _Class, _Args...&gt; {         using Registrar = LuaMethodRegistrar&lt;void, _Class, _Args...&gt;;         enum { N_ARGS = std::tuple_size&lt;std::tuple&lt;_Args...&gt;&gt;::value };          template&lt;void(_Class::*_Func)(_Args...)&gt;         static int Call(lua_State* L)         {                 int nArgs = N_ARGS;                 LuaMethodRegistrar&lt;void, _Class, _Args...&gt;::MethodWrapper&lt;_Func&gt;(obj, LuaExtract&lt;_Args&gt;(L, nArgs)...);                 return 0;         } };  ////////////////////// Back in LuaMethodRegistrar::Register ////////////// // register LuaCallWrapper&lt;_Result, _Class, _Args...&gt;::Call&lt;_Func&gt; </code></pre>  <p><strong>Oddities/Problems</strong></p>  <ol> <li>Types aren't being resolved correctly. e.g Registrar and consequently Registrar::Func "don't name a type".</li> <li>On the call sites that use parameter pack expansion on a function call, I am getting "parameter packs not expanded with '...' " even though they look identical to the ones that worked in my original code.</li> </ol>  <p><strong>Compilers: Clang 3.7.0, GCC 4.8.1</strong></p>  <p><strong>LuaExtract (the expansion context):</strong></p>  <pre><code>template &lt;typename T&gt; inline T LuaExtract(lua_State* L, int&amp; argCount);  template &lt;&gt; inline int LuaExtract&lt;int&gt;(lua_State* L, int&amp; argCount) {         // get result         return result; } </code></pre>  <p>It seems to me that either the compilers are just getting bogged down with types, or, more likely, I am missing something. Thanks for your time.</p>  <p><strong>EDIT: <strike>It looks like compiler can't resolve the types because LuaMethodRegistar&lt;_Result, _Class, _Args...> and LuaCallWrapper&lt;_Result, _Class, _Args...> depend on each other. How do I break that dependency?</strike></strong></p>  <p><strong>It turns out, it only seemed like the types depended on each other because omitting the ::template in the call sites produces seemingly bizarre error messages.</strong></p>