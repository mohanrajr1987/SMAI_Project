<p>I am trying to make one of elements named as core-splitter which is deprecated in 1.0 because this plays a key role in our project.</p>  <p>If you are not aware of what core-splitter does i can provide a short description. core-splitter provides a split bar and dragging on the split bar will resize the sibling element. Usually you would want to use core-splitter along with flex layout so that the other sibling element can be flexible.Unfortunately this works for only Polymer 0.5 but this got deprecated in 1.0. Here is the demo in Polymer 0.5 version. <a href="https://www.polymer-project.org/0.5/components/core-splitter/demo.html" rel="nofollow">Demo for core-splitter in Polymer 0.5</a></p>  <p>I am able to do that in normal javascript but unable to make it work in Polymer 1.0.</p>  <p>Here is a <a href="http://codepen.io/harshakakumanu/pen/MaJKNp" rel="nofollow">fiddle</a></p>  <pre><code>&lt;link rel="import"       href="https://cdn.rawgit.com/Polymer/polymer/master/polymer.html"&gt;     &lt;dom-module id="splitter-element"&gt;       &lt;template&gt;         &lt;div id="div1" class="split"&gt;Bacon ipsum dolor amet beef ribs         meatloaf picanha pork loin pork chop rump pig sausage bacon shank boudin beef fatback. Pork loin turducken t-bone chicken.&lt;/div&gt;         &lt;div class="gutter" style="width: 10px;"&gt;&lt;/div&gt;         &lt;div id="div2" class="split"&gt;Brisket andouille cow ball tip. Ham ground round short loin tri-tip ribeye t-bone boudin, pork loin turkey drumstick tongue pork chop. Kielbasa doner picanha turducken, swine bacon shank pastrami andouille.&lt;/div&gt;       &lt;/template&gt;      &lt;style&gt;     .gutter {        background-color: #eee;        background-image: url('https://ssl.gstatic.com/ui/v1/icons/mail/grippy_large.png');        background-repeat: no-repeat;        background-position: 50%;        cursor: move;        cursor: grab;        cursor: -moz-grab;        cursor: -webkit-grab;     }   .split, .gutter {       height: 100%;       float: left;   } .gutter:active {     cursor: grabbing;     cursor: -moz-grabbing;     cursor: -webkit-grabbing;  } .split {     box-sizing: border-box;     padding: 20px;     overflow-y: scroll;     overflow-x: hidden; }   &lt;/style&gt;   &lt;script&gt;   Polymer({     is: 'splitter-element',     properties:{       "dragging":{        Value:false      }     },     "split":function(ids, options){     options = typeof options !== 'undefined' ?  options : {};      if (!options.gutterWidth) options.gutterWidth = 10;     if (!options.minWidth) options.minWidth = 100;     if (!options.snapOffset) options.snapOffset = 30;    // Event listeners for drag events, bound to a pair object.   // Save the pair's left position and width when dragging starts.   // Prevent selection on start and re-enable it when done.      var startDragging = function (e) {         console.log('start');         e.preventDefault();           this.dragging = true;          this.width = this.left.clientWidth + this.right.clientWidth + options.gutterWidth;         this.x = this.left.getBoundingClientRect().left;          this.left.addEventListener('selectstart', preventSelection);         this.left.addEventListener('dragstart', preventSelection);         this.right.addEventListener('selectstart', preventSelection);         this.right.addEventListener('dragstart', preventSelection);          this.left.style.userSelect = 'none';         this.left.style.webkitUserSelect = 'none';         this.left.style.MozUserSelect = 'none';          this.right.style.userSelect = 'none';         this.right.style.webkitUserSelect = 'none';         this.right.style.MozUserSelect = 'none';          if (options.onDragStart) {             options.onDragStart();         }     },      stopDragging = function () {         this.dragging = false;          this.left.removeEventListener('selectstart', preventSelection);         this.left.removeEventListener('dragstart', preventSelection);         this.right.removeEventListener('selectstart', preventSelection);         this.right.removeEventListener('dragstart', preventSelection);          this.left.style.userSelect = '';         this.left.style.webkitUserSelect = '';         this.left.style.MozUserSelect = '';          this.right.style.userSelect = '';         this.right.style.webkitUserSelect = '';         this.right.style.MozUserSelect = '';          if (options.onDragEnd) {             options.onDragEnd();         }     },      drag = function (e) {         if (!this.dragging) return;          // Get the relative position of the event from the left side of the         // pair.          var offsetX = e.clientX - this.x;          // If within snapOffset of min or max, set offset to min or max          if (offsetX &lt;=  this.leftMin + options.snapOffset) {             offsetX = this.leftMin;         } else if (offsetX &gt;= this.width - this.rightMin - options.snapOffset) {             offsetX = this.width - this.rightMin;         }          // Left width is the same as offset. Right width is total width - left width.          this.left.style.width = 'calc(' + (offsetX / this.width * 100) + '% - ' + options.gutterWidth / 2 + 'px)';         this.right.style.width = 'calc(' + (100 - (offsetX / this.width * 100)) + '% - ' + options.gutterWidth / 2 + 'px)';          if (options.onDrag) {             options.onDrag();         }     },      preventSelection = function () { return false; },      // Given a list of DOM element ids and a list of percentage widths,     // assign each element a width allowing for a gutter between each     // pair. The number of gutters is ids.length - 1, and the total gutter     // width is gutterWidth * (ids.length - 1). Before calculating     // each width, subtract the total gutter width for the parent width.      parent = document.getElementById(ids[0]).parentNode;  if (!options.widths) {     var percent = 100 / ids.length;      options.widths = [];      for (var i = 0; i &lt; ids.length; i++) {         options.widths.push(percent);     }; }  if (!Array.isArray(options.minWidth)) {     var minWidths = [];      for (var i = 0; i &lt; ids.length; i++) {         minWidths.push(options.minWidth);     };      options.minWidth = minWidths; }  for (var i = 0; i &lt; ids.length; i++) {     var el = document.getElementById(ids[i]);      if (i &gt; 0) {         var pair = {                 left: document.getElementById(ids[i - 1]),                 right: el,                 leftMin: options.minWidth[i - 1],                 rightMin: options.minWidth[i],                 dragging: false,                 parent: parent             },             gutter = document.createElement('div');          gutter.className = 'gutter';         gutter.style.width = options.gutterWidth + 'px';          gutter.addEventListener('mousedown', startDragging.bind(pair));          parent.addEventListener('mouseup', stopDragging.bind(pair));         parent.addEventListener('mousemove', drag.bind(pair));         parent.addEventListener('mouseleave', stopDragging.bind(pair));          parent.insertBefore(gutter, el);          pair.gutter = gutter;     }      el.style.width = 'calc(' + options.widths[i] + '% - ' + options.gutterWidth / 2 + 'px)'; }   },   "ready":function(){       this.split(['div1', 'div2'], {         widths: [25, 75],         minWidth: 200     });   } }); &lt;/script&gt; &lt;/dom-module&gt; &lt;splitter-element&gt; &lt;/splitter-element&gt; </code></pre>