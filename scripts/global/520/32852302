<p>I'm using the <code>CURLOPT_READFUNCTION</code> and <code>CURLOPT_READDATA</code> flags to stream requests to my .Net service running on an IIS server. The "read function" is a pretty straightforward callback. Here's a little pseudo code to describe what's going on:</p>  <pre><code>size_t a_callback(char* bodyPtr, size_t bytesPerItem, size_t numItems, void* userData) {   request rqst = *static_cast&lt;request*&gt;(userData);    const readSize = std::min(bytesPerItem * numItems, rqst.bytesRemaining);   if (!readSize)     return 0;    char* orig = rqst.ptr;   rqst.ptr += readSize;   rqst.bytesRemaining -= readSize;    memcpy(bodyPtr, orig, readSize);   return readSize; } </code></pre>  <p>The thing is, doing it this way is <em>way</em> slower than just using <code>CURLOPT_POSTFIELDS</code>. For instance:</p>  <pre><code>curl_easy_setopt(m_curl, CURLOPT_POSTFIELDS, rqst.ptr); curl_easy_setopt(m_curl, CURLOPT_POSTFIELDSIZE, rqst.bytesRemaining); </code></pre>  <p>Does anyone know streaming requests in C++ <code>libcurl</code> would be vastly slower than just sending the request data in a big chunk? Is there some option I can tune to try to increase the speed? Am I missing some setting on the server to resolve some kind of bottleneck? I'd appreciate any insights people have.</p>