<p>I have a WCF service which exposes two endpoints (one TCP and another REST). I have a method in WCF which return a Stream of file. From my client application, I use Async calls to start download the file  and save it as a local file. After the completion of the thread I need to return to the main thread so that I can update the UI. For this I use Dispatcher.Invoke. </p>  <p>The problem is that the rest endpoint seems to download and save the file, but TCP endpoint throws me time out error. Another issue I have is in both endpoints when the code completes and return to line Dispatcher.Invoke it just hangs and does not proceed.</p>  <p>I have debugged it and the service call is working on a worker thread as expected but somehow the whole application hangs when I try to use the Dispatcher.Invoke to come back to main thread(UI). I have also tried Dispatcher.BeginInvoke but the same result.</p>  <p>The same application and code works fine when I call any other WCF method (which return me JSON or data contract). In that case I am able to move back to main thread using Dispatcher.Invoke. But some how when I am calling the WCF method to download a file it just hangs.</p>  <p>I have tried to list down the code below. Not sure what I am doing wrong here. My webConfig is set to max sizes. I am not expecting huge files though (typically between 2-5 MB). </p>  <p>Can you please let me know what I am doing wrong here ? I expect the download and write to file complete and then move to main thread. I would want it to be streaming so that even in future the file size increases, I can handle that as well. </p>  <p>Any pointers/suggestion would help.</p>  <ul> <li>Girija</li> </ul>    <pre><code>public static class Holder {     public static Dispatcher CurrentDispatcher { get; set; } // Set when application loads }  public class Downloader {       public Downloader()     {      }      public void DownloadFileAndAct(string fileName)     {         AsyncCallback callback = new AsyncCallback(this.DownloadComplete);         Func&lt;string, string&gt; del = new Func&lt;string, string&gt;(this.DownloadStream);         del.BeginInvoke(fileName, callback, this);     }      private void DownloadComplete(IAsyncResult ar)     {         AsyncResult res = (AsyncResult)ar;         Func&lt;string, string&gt; objCaller = (Func&lt;string, string&gt;)res.AsyncDelegate;         var filePath = objCaller.EndInvoke(ar);          // The below code is where it just hangs         Holder.CurrentDispatcher.Invoke(new Action(() =&gt;         {             // Do some stuff on main thread like display the file in a selction list         }));      }      private string DownloadStream(string fileName)     {         TestServiceClient client = new TestServiceClient();          //1st approach         var stream = client.DownloadFile(fileName);         client.Close();          var savePath = @"D:\MySavedLocation\" + fileName;          using (var file = File.Create(savePath))         {             stream.CopyTo(file);         }          // 2nd approach (tried this too)         //const int bufferSize = 2048;         //byte[] buffer = new byte[bufferSize];         //using (FileStream outputStream = new FileStream(savePath,         //    FileMode.Create, FileAccess.Write))         //{         //    int bytesRead = client.DownloadFile(fileName).Read(buffer, 0, bufferSize);         //    while (bytesRead &gt; 0)         //    {         //        outputStream.Write(buffer, 0, bytesRead);         //        bytesRead = client.DownloadFile(fileName).Read(buffer, 0, bufferSize);         //    }         //    outputStream.Close();         //}         //client.Close();           return savePath;     } } </code></pre>