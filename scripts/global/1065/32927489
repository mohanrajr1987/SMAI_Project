<p>I am trying to use a <code>UIImage</code> as a path for a marble game.  I am using <code>CoreMotion</code> and <code>QuartzCore</code> to handle moving the marble on the screen.  The <code>UIImage</code> is a simple black and white image where the path is black and the rest of the image is a white background.  I have the code to move the marble, but when I try to check the color of the path image beneath it, the animation on the marble stops and it no longer moves.  If I comment out the line of code that determines the pixel color of the Path image the marble moves fine.  What am I missing to keep the marble moving when I check the color of the pixel?</p>  <pre><code>- (void)viewDidLoad {     [super viewDidLoad];      // Movement of marble1     self.lastUpdateTime = [[NSDate alloc] init];     self.curPoint  = CGPointMake(443, 350);     self.motionManager = [[CMMotionManager alloc]  init];     self.queue         = [[NSOperationQueue alloc] init];     self.motionManager.accelerometerUpdateInterval = kUpdateInterval;     [self.motionManager startAccelerometerUpdatesToQueue:self.queue withHandler:      ^(CMAccelerometerData *accelerometerData, NSError *error) {          [(id) self setAcceleration:accelerometerData.acceleration];          [self performSelectorOnMainThread:@selector(update) withObject:nil waitUntilDone:NO];      }]; }  - (void)update {     NSTimeInterval secondsSinceLastDraw = -([self.lastUpdateTime timeIntervalSinceNow]);     self.marble1YVelocity = self.marble1YVelocity - (self.acceleration.x * secondsSinceLastDraw);     self.marble1XVelocity = self.marble1XVelocity - (self.acceleration.y * secondsSinceLastDraw);     CGFloat xDelta = secondsSinceLastDraw * self.marble1XVelocity * 500;     CGFloat yDelta = secondsSinceLastDraw * self.marble1YVelocity * 500;     self.curPoint = CGPointMake(self.curPoint.x + xDelta,                                     self.curPoint.y + yDelta);     [self moveMarble1];     self.lastUpdateTime = [NSDate date]; }  - (void)moveMarble1 {     [self collisionWithWalls];     [self collisionWithBoundaries];     self.prevPoint = self.curPoint;     CGRect frame = self.marble1.frame;     frame.origin.x = self.curPoint.x;     frame.origin.y = self.curPoint.y;     self.marble1.frame = frame; }  - (void)collisionWithWalls {        CGRect frame = self.marble1.frame;     frame.origin.x = self.curPoint.x;     frame.origin.y = self.curPoint.y;     NSLog(@"x=%f,y=%f",frame.origin.x,frame.origin.y);     CALayer *pathLayer = [self.Path.layer presentationLayer];     //if I comment out the following line the marble moves with no issues on the screen     NSLog(@"Color of path is %@",[self pixelColorInImage:pathLayer atX:self.curPoint.x atY:self.curPoint.y]);   }  - (UIColor*)pixelColorInImage:(CALayer*)layer atX:(int)x atY:(int)y {     UIImage* image=[self imageFromLayer:layer];        CFDataRef pixelData = CGDataProviderCopyData(CGImageGetDataProvider(image.CGImage));     const UInt8* data = CFDataGetBytePtr(pixelData);     int pixelInfo = ((image.size.width  * y) + x ) * 4; // 4 bytes per pixel     UInt8 red   = data[pixelInfo + 0];     UInt8 green = data[pixelInfo + 1];     UInt8 blue  = data[pixelInfo + 2];     UInt8 alpha = data[pixelInfo + 3];     CFRelease(pixelData);     return [UIColor colorWithRed:red/255.0f                            green:green/255.0f                             blue:blue/255.0f                            alpha:alpha/255.0f]; }  - (UIImage *)imageFromLayer:(CALayer *)layer{        if ([[UIScreen mainScreen] respondsToSelector:@selector(scale)])         UIGraphicsBeginImageContextWithOptions([layer frame].size, NO, [UIScreen mainScreen].scale);     else         UIGraphicsBeginImageContext([layer frame].size);      [layer renderInContext:UIGraphicsGetCurrentContext()];     UIImage *outputImage = UIGraphicsGetImageFromCurrentImageContext();         UIGraphicsEndImageContext();     return outputImage; } </code></pre>