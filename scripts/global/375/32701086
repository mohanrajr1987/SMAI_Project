<p>I am having some trouble solving a problem with generics.  I have a list of "Cat" objects and a list of "Dog" objects that I need to pass into the same method.  The return type for that method is a Map of "String" and a "List of Animals"  I am trying to figure out a way to convert the Maps with the list of animals into a Map with a list of Cats or Dogs.  </p>  <p>This works fine if I have a separate method for Cats and Dogs but I'm looking for a more flexible solution. </p>  <p>Lines getting the error in title:</p>  <pre><code>catMap = PetStore.groupAnimalsByOwner(cats);  dogMap = PetStore.groupAnimalsByOwner(dogs); </code></pre>  <p>Note: this is a simplified example, I have to be able to use the Lists in the Maps as "Cat" or "Dog" objects.</p>  <pre><code>    public class Start {      public static void main(String[] args) {          Cat cat1 = new Cat("Jerry", "cat1");         Cat cat2 = new Cat("Jerry", "cat2");         Cat cat3 = new Cat("Fred", "cat3");          List&lt;Cat&gt; cats = new LinkedList&lt;Cat&gt;();         cats.add(cat1);         cats.add(cat2);         cats.add(cat3);          Dog dog1 = new Dog("Frank", "dog1");         Dog dog2 = new Dog("Jerry", "dog2");         Dog dog3 = new Dog("Bob", "dog3");          List&lt;Dog&gt; dogs = new LinkedList&lt;Dog&gt;();         dogs.add(dog1);         dogs.add(dog2);         dogs.add(dog3);          Map&lt;String, List&lt;Dog&gt;&gt; dogMap = new HashMap&lt;String, List&lt;Dog&gt;&gt;();         Map&lt;String, List&lt;Cat&gt;&gt; catMap = new HashMap&lt;String, List&lt;Cat&gt;&gt;();          // catMap should have 2 key/value pairs - key "Jerry" with a list containing cat1 and cat2         // and a pair - key "Fred" with a list containing only cat3         catMap = PetStore.groupAnimalsByOwner(cats);           // dogMap should have 3 key/value pairs - key "Frank" with a list containing dog1         // key "Jerry" with a list containing dog2         // Key "Bob" with a list containing dog3         dogMap = PetStore.groupAnimalsByOwner(dogs);      }  } </code></pre>  <p><br></p>  <pre><code>public class PetStore {      //Grouping by owner     public static Map&lt;String, List&lt;Animal&gt;&gt; groupAnimalsByOwner(List&lt;? extends Animal&gt; animals) {         Map&lt;String, List&lt;Animal&gt;&gt; groupedMap = new HashMap&lt;String, List&lt;Animal&gt;&gt;();         List&lt;Animal&gt; tempList = null;          for (Animal summary : animals) {             String consolidatedInvoiceId = summary.getOwner();             tempList = groupedMap.get(consolidatedInvoiceId);             if (tempList == null) {                 tempList = new LinkedList&lt;Animal&gt;();             }             tempList.add(summary);             groupedMap.put(consolidatedInvoiceId, tempList);         }          return groupedMap;     } } </code></pre>  <p><br></p>  <pre><code>public interface Animal {      public String getOwner(); } </code></pre>  <p><br>    </p>  <pre><code>  public class Cat implements Animal {      private String owner;     private String name;      public Cat(String owner, String name) {         this.owner = owner;         this.name = name;     }       @Override     public String getOwner() {         return owner;     }      public String getName() {         return name;     }      public void doCatStuff() {         System.out.println("Do cat stuff");     }  } </code></pre>  <p>The Dog class is the same as Cat but with a doCatStuff method.</p>  <p>Thank you in advance.</p>