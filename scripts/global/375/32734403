<p>I'm facing a problem regarding protocols methods dispatch.</p>  <p>I have a class hierarchy that looks like that: </p>  <pre><code>protocol E {     func test() }  extension E {     func test() {         print("jello")     } }  class A: E {  }  class B: A {     func test() {         print("hello")     } } </code></pre>  <p>But when I call <code>test</code> on an instance of class <code>B</code> statically forced to be typed <code>A</code>, "jello" gets printed, not "hello".</p>  <pre><code>let b: A = B()  // prints "jello" not "hello" b.test() </code></pre>  <p>My understanding is that <code>test</code> method printing "jello" gets "integrated" into instances of <code>A</code> (since <code>A</code> conforms to <code>E</code> protocol). I'm then providing another implementation of <code>test</code> inside <code>B</code> (that inherits form <code>A</code>). I thought polymorphism would work here and calling <code>test</code> on <code>B</code> instance that are stored inside <code>A</code> references would print <code>hello</code>. What's happening here?</p>  <p>It's perfectly working when not using any protocol:</p>  <pre><code>class A {     func test() {         print("jello")     } }  class B: A {     override func test() {         print("hello")     } }  let b: A = B() // prints "hello" b.test()  </code></pre>  <p>What's different from adopting a protocol that adds new methods to my parent class and providing a new implementation in a subclass, than having directly written this method in the parent class and then overriding it in a subclass?</p>  <p>Do you guys have any workaround?</p>