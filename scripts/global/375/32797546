<p>I've searched a lot and only find questions about polymorphic deserialization on the content inside a map. Is it possible to polymorphic deserializing the map itself?</p>  <p>For example, I have a Book class contains a Map as a member variable.</p>  <pre><code>public class Book {     @JsonProperty     private Map&lt;String, Object&gt; reviews;      @JsonCreator     public Book(Map&lt;String, Object&gt; map) {         this.reviews = map;     } } </code></pre>  <p>Another class have a list of Book class.</p>  <pre><code>public class Shelf {      @JsonProperty     private List&lt;Book&gt; books = new LinkedList&lt;&gt;();      public void setBooks(List&lt;Book&gt; books) {         this.books = books;     }      public List&lt;Book&gt; getBooks() {        return this.books;     } } </code></pre>  <p>And a test class. One book's review map is a Hashtable and another book's review map is a HashMap.</p>  <pre><code>public class Test {      private Shelf shelf;      @BeforeClass     public void init() {         Map&lt;String, Object&gt; review1 = new Hashtable&lt;&gt;(); // Hashtable here         review1.put("test1", "review1");         Map&lt;String, Object&gt; review2 = new HashMap&lt;&gt;(); // HashMap here         review2.put("test2", "review2");          List&lt;Book&gt; books = new LinkedList&lt;&gt;();         books.add(new Book(review1));         books.add(new Book(review2));         shelf = new Shelf();         shelf.setBooks(books);     }      @Test     public void test() throws IOException{         ObjectMapper mapper = new ObjectMapper();         mapper.configure(SerializationFeature.INDENT_OUTPUT, true); //        mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);         String json = mapper.writeValueAsString(shelf);         System.out.println(json);          Shelf sh = mapper.readValue(json, Shelf.class);         for (Book b : sh.getBooks()) {             System.out.println(b.getReviews().getClass());         }     } } </code></pre>  <p>The test output</p>  <pre><code>{   "name" : "TestShelf",   "books" : [ {     "reviews" : {       "test1" : "review1"     }   }, {     "reviews" : {       "test2" : "review2"     }   } ] } class java.util.LinkedHashMap class java.util.LinkedHashMap </code></pre>  <p>The serialization works fine. But after deserialization, both review1 and review2 are LinkedHashMap. I want review1 and review2 to be their actual types which are Hashtable to review1 and HashMap to review2.  Is there any way to achieve this?</p>  <p>I don't want to use <code>mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</code> because it will add the type info for all json properties in the json message. And if there is any better way to do it I don't want to use customized deserializer either. Thanks in advance.</p>