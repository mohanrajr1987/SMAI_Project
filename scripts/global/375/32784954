<p>I am having a wicked problem with exposing a polymorphic class hierarchy via a factory. I have created an example that demonstrates the problem. </p>  <p>This is all being hosted in a executable with an embedded python(stackless 2.7) interpreter. When I run the executable and get the Python code I can create a variable from the factory (a = MakeB()) this returns a smart pointer to the TestA class but holds an instance of TestB. The problem I have is that when I access the base class member variables/functions it works, but accessing TestB variables/functions generates a segment fault 11 (osx). </p>  <p>The returned instance reports to python that its class is TestB (<strong>class</strong> reports the same) and the print messages show that TestB was constructed and returned. Of note that it I create TestB directly (opposed to the factory) the base class's variables/functions work correctly. </p>  <p>My actual production code is more complex, but this has boiled it down to this test example. I can provide a backtrace of the segfault if anyone thinks it will help. </p>  <p>Thanks. </p>  <pre><code>&gt;print sys.version 2.7.6a1 Stackless 3.1b3 060516 (default, Jan 10 2014, 13:13:51)  [GCC 4.2.1 Compatible Apple LLVM 5.0 (clang-500.2.79)] </code></pre>  <p>hpp File</p>  <pre><code>class TestA; typedef boost::shared_ptr&lt;TestA&gt; TestAPtr; class TestB; typedef boost::shared_ptr&lt;TestB&gt; TestBPtr; class TestA { public:      TestA();     virtual ~TestA();     static void Boost(void);     string Aprop;     void FuncA();  };  class TestB : public TestA { public:      TestB();     virtual ~TestB();     static void Boost(void);     string Bprop;     void FuncB(); }; </code></pre>  <p>cpp File</p>  <pre><code>TestA::TestA() : Aprop("Test A") {     printf("Create TestA\n"); } TestA::~TestA() {     printf("Destroy TestA\n"); } void TestA::Boost(void) {     class_&lt; TestA &gt;("TestA", init&lt;&gt;())         .def("FuncA", &amp;TestA::FuncA)         .def_readwrite("Aprop", &amp;TestA::Aprop)         ;     register_ptr_to_python&lt; boost::shared_ptr&lt;TestA&gt; &gt;(); } void TestA::FuncA() {     printf("Hi From Test A\n");  }  // ------ Test B  TestB::TestB() : TestA(), Bprop("Test B") {     printf("Create TestB\n"); }  TestB::~TestB() {     printf("Destroy TestB\n"); } void TestB::Boost(void) {     class_&lt; TestB, bases&lt;TestA&gt; &gt;("TestB", init&lt;&gt;())     .def("FuncB", &amp;TestB::FuncB)     .def_readwrite("Bprop", &amp;TestB::Bprop)         ;     register_ptr_to_python&lt; boost::shared_ptr&lt;TestB&gt; &gt;(); } void TestB::FuncB() {     printf("Hi From Test B\n"); }  // Factory... TestAPtr MakeB() {     return boost::shared_ptr&lt;TestA&gt;(new TestB()); }  BOOST_PYTHON_MODULE(__builtin__) {     TestA::Boost();     TestB::Boost();      def("MakeB", MakeB); } </code></pre>