<p>This is a traditional example of runtime polymorphism</p>  <pre><code>#include&lt;iostream&gt; using namespace std;  class Base { public:     virtual void show() { cout&lt;&lt;" In Base \n"; }     void show(int x) { cout&lt;&lt;"over loaded method base";} };  class Derived: public Base { public:     void show() { cout&lt;&lt;"In Derived \n"; }      void show(int x) { cout&lt;&lt;"over loaded method derived";} };  int main(void) {        Base *bp = new Derived;     Base *bp2=new Base;     bp2-&gt;show(10); //Case 1: COMPILE-TIME POLYMORPHISM (overloading)     bp-&gt;show();  //Case 2: RUN-TIME POLYMORPHISM (overriding)     return 0; } </code></pre>  <p>//Output : overloaded method base //         in derived</p>  <p>why can compiler understand which method to call during compile time in case 1 and not in case 2. in Case 2-As it is clear to the compiler that derived class obj is stored in bp and show is virtual so why cant it decide which show() to call at compile time itself.</p>