<p>Numpy has a sophisticated indexing/slicing/stepping functionality in its array access operator. See this: <a href="http://docs.scipy.org/doc/numpy/reference/arrays.indexing.html">http://docs.scipy.org/doc/numpy/reference/arrays.indexing.html</a></p>  <p>While experimenting with Haskell, I thought it would educational to try replicating a subset of this indexing functionality. Specifically it's "tuple selection objects" or n-dimensional projection" (<a href="https://en.wikipedia.org/wiki/Projection_%28relational_algebra%29">https://en.wikipedia.org/wiki/Projection_%28relational_algebra%29</a>).</p>  <p>Basically you can do:</p>  <pre><code>two_d_array[0:1:1, 0:4:2] </code></pre>  <p>And this will give you the first row stepped by 1 containing the first 2 columns stepped by 2 (skipping 1 column).</p>  <p>In order words it can project an original 2 dimensional array into a smaller 2 dimensional array. The result remains as a 2 dimensional array.</p>  <p>So here's what I tried in Haskell.</p>  <p>The type of such a function should be something like:</p>  <pre><code>(!!!) :: (Functor f) =&gt;  f a -&gt; [(Int, Int, Int)] -&gt; f a </code></pre>  <p>So you could see something like:</p>  <pre><code>three_d_tensor !!! [(s1,e1,st1), (s2,e2,st2), (s3,e3,st3)] </code></pre>  <p>Where sx, ex, stx are start, end, step respectively.</p>  <p>The example should project the original tensor into a smaller tensor, with the first dimension restricted by <code>s1 to e1, stepping by st1</code>, second dimension restricted by <code>s2 to e2, stepping by st2</code>... etc.</p>  <p>So here's what I got:</p>  <pre><code>slicing from to xs = take (to - from + 1) (drop from xs)  stepping n = map head . takeWhile (not . null) . iterate (drop n)  (!!!) tensor ((start, end, step):tail) =      project (stepSlice start end step tensor) tail map     where          project tensor ((start, end, step):tail) projection =              project (projection (stepSlice start end step) tensor) tail (projection . map)         project tensor [] _ =              tensor         stepSlice start end step tensor =              ((stepping step) . (slicing start end)) tensor </code></pre>  <p>The above does not work due to a problem of "polymorphic recursion". Basically I cannot infinitely compose the <code>map</code> function, the specific expression that does this is the <code>(projection . map)</code>. If this kind of polymorphic recursion were possible, I believe it would work. But I am open to alternative implementations which doesn't involve polymorphic recursion.</p>  <p>I have researched this problem and have still come up short:</p>  <ul> <li><a href="https://byorgey.wordpress.com/2007/08/16/mapping-over-a-nested-functor/">https://byorgey.wordpress.com/2007/08/16/mapping-over-a-nested-functor/</a></li> <li><a href="http://okmij.org/ftp/Haskell/typecast.html#deepest-functor">http://okmij.org/ftp/Haskell/typecast.html#deepest-functor</a></li> <li><a href="http://stackoverflow.com/questions/32536837/haskell-polymorphic-recursion-with-composed-maps-causes-infinite-type-error">Haskell Polymorphic Recursion with Composed Maps causes Infinite Type Error</a></li> </ul>