<p>I've this LINQ query:</p>  <pre><code>var q =        from defect in DataService.Query&lt;Defect&gt;()        join defectSize in DataService.Query&lt;DefectSize&gt;() on defect.DefectSize.Id equals defectSize.Id        where defectSize.UserCode == "def1"        select defect; </code></pre>  <p>All I want is to create this query at runtime and pass it to NHibernate for execution, I want to create and replicate that expression's tree.</p>  <p>So let's start by looking at the expression tree created by the compiler:</p>  <pre><code>.Call System.Linq.Queryable.Select(     .Call System.Linq.Queryable.Where(         .Call System.Linq.Queryable.Join(             .Constant&lt;NHibernate.Linq.NhQueryable`1[ObjectModel.Defect.Defect]&gt;(NHibernate.Linq.NhQueryable`1[ObjectModel.Defect.Defect]),             .Constant&lt;NHibernate.Linq.NhQueryable`1[ObjectModel.Defect.DefectSize]&gt;(NHibernate.Linq.NhQueryable`1[ObjectModel.Defect.DefectSize]),             '(.Lambda #Lambda1&lt;System.Func`2[ObjectModel.Defect.Defect,System.Int32]&gt;),             '(.Lambda #Lambda2&lt;System.Func`2[ObjectModel.Defect.DefectSize,System.Int32]&gt;),             '(.Lambda #Lambda3&lt;System.Func`3[ObjectModel.Defect.Defect,ObjectModel.Defect.DefectSize,&lt;&gt;f__AnonymousType0`2[ObjectModel.Defect.Defect,ObjectModel.Defect.DefectSize]]&gt;))         ,         '(.Lambda #Lambda4&lt;System.Func`2[&lt;&gt;f__AnonymousType0`2[ObjectModel.Defect.Defect,ObjectModel.Defect.DefectSize],System.Boolean]&gt;))     ,     '(.Lambda #Lambda5&lt;System.Func`2[&lt;&gt;f__AnonymousType0`2[ObjectModel.Defect.Defect,ObjectModel.Defect.DefectSize],ObjectModel.Defect.Defect]&gt;))  .Lambda #Lambda1&lt;System.Func`2[ObjectModel.Defect.Defect,System.Int32]&gt;(ObjectModel.Defect.Defect $defect) {     ($defect.DefectSize).Id }  .Lambda #Lambda2&lt;System.Func`2[ObjectModel.Defect.DefectSize,System.Int32]&gt;(ObjectModel.Defect.DefectSize $defectSize) {     $defectSize.Id }  .Lambda #Lambda3&lt;System.Func`3[ObjectModel.Defect.Defect,ObjectModel.Defect.DefectSize,&lt;&gt;f__AnonymousType0`2[ObjectModel.Defect.Defect,ObjectModel.Defect.DefectSize]]&gt;(     ObjectModel.Defect.Defect $defect,     ObjectModel.Defect.DefectSize $defectSize) {     .New &lt;&gt;f__AnonymousType0`2[ObjectModel.Defect.Defect,ObjectModel.Defect.DefectSize](         $defect,         $defectSize) }  .Lambda #Lambda4&lt;System.Func`2[&lt;&gt;f__AnonymousType0`2[ObjectModel.Defect.Defect,ObjectModel.Defect.DefectSize],System.Boolean]&gt;(&lt;&gt;f__AnonymousType0`2[ObjectModel.Defect.Defect,ObjectModel.Defect.DefectSize] $&lt;&gt;h__TransparentIdentifier0) {     ($&lt;&gt;h__TransparentIdentifier0.defectSize).UserCode == "ext1" }  .Lambda #Lambda5&lt;System.Func`2[&lt;&gt;f__AnonymousType0`2[ObjectModel.Defect.Defect,ObjectModel.Defect.DefectSize],ObjectModel.Defect.Defect]&gt;(&lt;&gt;f__AnonymousType0`2[ObjectModel.Defect.Defect,ObjectModel.Defect.DefectSize] $&lt;&gt;h__TransparentIdentifier0) {     $&lt;&gt;h__TransparentIdentifier0.defect } </code></pre>  <p>as you can see, to represent the join and the where clauses the compiler creates the anonymous type <em>&lt;>f__AnonymousType0`2</em> to contain both members of the joins, it instantiates the class and the members with the <em>New</em> expression and then, in the where clause, it uses the <em>&lt;>h__TransparentIdentifier0</em> to represent the where.</p>  <p>Well, I've replicated all of this tree, in my code I create a dynamic type at runtime with the exact members found on the type created by the compiler, my expression tree looks equal to the one posted here, but when I try to materialize the query, NH throws <em>NotSupportedException</em> !</p>  <p>Interesting to note is that if I first do: <em>q.ToArray()</em>, q is the expression tree created by the compiler, and then later I do <em>myTree.ToArray()</em> well in this case it works! The explanation is that the second time, to execute my tree NH uses the query plan created previously, this indicates the it thinks the two query are the same!</p>  <p>I tried some attempts of investigation by looking at the NH source code, I find out that NH creates a query model from the expression by using the method <em>NhRelinqQueryParser.Parse(_expression)</em> found in <em>NHibernate.Linq.NhLinqExpression</em>, here I found out that the two models are different, the exact model should be:</p>  <pre><code>from Defect defect in value(NHibernate.Linq.NhQueryable`1[ObjectModel.Defect.Defect]) join DefectSize defectSize in value(NHibernate.Linq.NhQueryable`1[ObjectModel.Defect.DefectSize]) on [defect].DefectSize.Id equals [defectSize].Id where ([defectSize].UserCode == \"def1\") select [defect] </code></pre>  <p>but with my expression it becomes:</p>  <pre><code>from Defect defect in value(NHibernate.Linq.NhQueryable`1[ObjectModel.Defect.Defect]) join DefectSize defectSize in value(NHibernate.Linq.NhQueryable`1[ObjectModel.Defect.DefectSize]) on [defect].DefectSize.Id equals [defectSize].Id where (new &lt;&gt;f__AnonymousType0`2([defect], [defectSize]).defectSize.UserCode == \"def1\") select new &lt;&gt;f__AnonymousType0`2([defect], [defectSize]).defect </code></pre>  <p>Here I gave up, I can't debug any further into the remotion classes.</p>  <p>If you have any clue here I'd appreciate any tips. I'm using NH 3.3.3 GA</p>  <p>Thanks for reading.</p>