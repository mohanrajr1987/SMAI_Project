<p>Before this gets marked as duplicate I have seen many answers like this one <a href="http://stackoverflow.com/questions/1253725/convert-ienumerable-to-datatable">Convert IEnumerable to DataTable</a> and have attempted doing something similar in the way of creating an extension method. I ask my question as the issue im having may lie somewhere else.</p>  <p>Essentially I have quite a large IEnumerable (around 16 - 17 mil items) up to this point i have not really had any issues with this, until i tried converting to a datatable using an extension method:</p>  <pre><code>/// &lt;summary&gt; /// Converts IEnumberable to datatable. Mainly for use when using SQLBulkCopy/&gt; /// &lt;/summary&gt; /// &lt;typeparam name="T"&gt;&lt;/typeparam&gt; /// &lt;param name="collection"&gt;&lt;/param&gt; /// &lt;param name="customColumnOrder"&gt;Custom order for columns allows me to make sure that the order of columns will always be the same. Am open for suggestions for better ways to do this&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static DataTable ToDataTable&lt;T&gt;(this IEnumerable&lt;T&gt; collection, List&lt;Tuple&lt;string, int, int&gt;&gt; customColumnOrder) {     DataTable dt = new DataTable();     var type = collection.First().GetType();     foreach (var column in customColumnOrder)     {         dt.Columns.Add(column.Item1, Nullable.GetUnderlyingType(type.GetProperty(column.Item1).PropertyType) ?? type.GetProperty(column.Item1).PropertyType);     }     //Populate the table     foreach (T item in collection)     {         DataRow dr = dt.NewRow();         dr.BeginEdit();         foreach (var column in customColumnOrder)         {             dr[column.Item1] = type.GetProperty(column.Item1).GetValue(item) ?? DBNull.Value;         }         dr.EndEdit();         dt.Rows.Add(dr);     }     return dt; } </code></pre>  <p>This works fine for smaller tables of around 100,000 items, but begins to really struggle when it gets into the millions. I just keep getting time outs. Is there a more effecient/generally better way to do convert from a IEnumerable to a datatable?  I am converting to DataTable so I can use SQLBulkCopy to get the data into a DataBase.</p>  <p>EDIT 0: Heres where the data is being passed through from</p>  <pre><code>    /// &lt;summary&gt;     /// SqlBulkCopy for saving large amounts of data     /// &lt;/summary&gt;     /// &lt;typeparam name="T"&gt;&lt;/typeparam&gt;     /// &lt;param name="dataToSave"&gt;&lt;/param&gt;     /// &lt;param name="modelManager"&gt;Custom manager to use alongside the model&lt;/param&gt;     /// &lt;param name="conn"&gt;Connection string to DB&lt;/param&gt;     public void BatchSave&lt;T&gt;(IEnumerable&lt;T&gt; dataToSave, IData modelManager, string conn)     {         var model = dataToSave.First();         using (SqlConnection sqlconn= new SqlConnection(conn))         {             sqlconn.Open();             using (SqlCommand cmd = new SqlCommand(GetCreateScript(modelManager, model), sqlconn))             {                 //Create temp table to do initial insert into                 cmd.ExecuteNonQuery();                  SqlBulkCopy copy = new SqlBulkCopy(cmd.Connection);                  copy.DestinationTableName = "#tempTableForImport";                  //Convert data to DataTable                 DataTable dt = dataToSave.ToDataTable(modelManager.GetDataColumnsOrder());                  //Copy to temp table                 copy.WriteToServer(dt);             }             using (SqlCommand cmd = new SqlCommand(modelManager.GetInsertSproc(), sqlconn) { CommandType=CommandType.StoredProcedure })             {                 //Clean up data and move to final table                 cmd.ExecuteNonQuery();             }             sqlconn.Close();         }     } </code></pre>  <p>EDIT 1: Newly amended code using a suggestion made, its now using Fastmember:</p>  <pre><code>public void BatchSave&lt;T&gt;(IEnumerable&lt;T&gt; dataToSave, IData modelManager, string conn) {     var model = dataToSave.First();     using (SqlConnection sqlconn = new SqlConnection(conn))     {         sqlconn.Open();         using (var bcp = new SqlBulkCopy(sqlconn))         {             using (var reader = ObjectReader.Create(dataToSave, modelManager.GetDataColumnsOrder().Select(s =&gt; s.Item1).ToArray() /*modelManager.GetDataColumnsOrder().Select(obj=&gt;obj.Item1).ToString()*/))             {                 using (SqlCommand cmd= new SqlCommand(GetCreateScript(modelManager, model), sqlconn))                 {                     cmd.ExecuteNonQuery();                     bcp.DestinationTableName = "#tempTableForImport";                     bcp.WriteToServer(reader);                 }                 using (SqlCommand cmd = new SqlCommand(modelManager.GetInsertSproc(), sqlconn) { CommandType = CommandType.StoredProcedure })                 {                     cmd.ExecuteNonQuery();                 }             }         }         sqlconn.Close();     } } </code></pre>  <p>This has sped things up however I am still getting a 'Timeout Expired' on this line <code>bcp.WriteToServer(reader);</code>. Thanks all for the help so far after about 30secs, anymore ideas on this? Maybe someway to increase length of time before timeout?</p>