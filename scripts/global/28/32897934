<p>EDIT  Summary after solution had been given</p>  <p>*Linq query results are almost always presented with "<em>var</em>" implicit type or with typed <em>IENumerable&lt; T></em> like <em>IEnumerable&lt; int></em>. However simple more  generic <em>IEnumerable</em> is sufficient</p>  <p>*String.Join() does not have specialization for <em>IEnumerable</em> ( but has naturally one for <em>IEnumerable&lt; T></em> ) and fall back to <em>String.Join Method (String, Object[] ...)</em>. It then assumes that the linq query result <em>res</em> is an array of Object of size 1. I do not know why there is no overload for IEnumerable!</p>  <p>/EDIT</p>  <p>I had imagine that it would be possible to write generic linq query return types. A first idea was to write a code like this:</p>  <pre class="lang-C# prettyprint-override"><code>class exLinq {     Func&lt;IEnumerable&gt;[] fun_list = new Func&lt;IEnumerable&gt;[]     { () =&gt; {   int[]   data    =       { 1, 2, 5, 8, 11 };                 var     result  =       from d in data                                         where 0 == d % 2                                         select d;                 return result;             }       //() =&gt; Other queries that could be on string, double... collections      };        static void Main(string args[])     {                  foreach (var fun in fun_list)         {             var f = fun;             var res = f();             Console.WriteLine(String.Join(", ",res));         }     } } </code></pre>  <p>However I got the result</p>  <blockquote>   <p>System.Linq.Enumerable+WhereArrayIterator`1[System.Int32]</p> </blockquote>  <p>My linq query return type would be more adequat with <em>IEnumerable &lt; int ></em> ( It works when I do this ) but I was wondering if I could mix in the same array/list queries that would have handle <em>strings</em>,<em>double</em> or whatsoever...</p>  <p>Up to now I got a correct code output with the modification</p>  <pre class="lang-C# prettyprint-override"><code>if ( res is IEnumerable&lt;int&gt;)     Console.WriteLine(String.Join(", ",res.Cast&lt;int&gt;())); </code></pre>  <blockquote>   <p>2, 8</p> </blockquote>  <p>More accustomed with C++, I had believed that I would be able to handle any "groups of object" with the "higher" class.</p>  <p>Any idea of how to correctly achieve this?</p>