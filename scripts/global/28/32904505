<p>I have a piece of LINQ code that results in Stack Overflow Exception and I can't figure why. I will keep the code as is since I can't tell which part is the cause.</p>  <p>Consider we have a list of booking records:</p>  <pre><code>Class BookRecords     Public START_DATE As String     Public END_DATE As String     Public BOOK_NUM As String End Class </code></pre>  <p>And the task is to find out all records which (1)Start time is within 15 minutes from now &amp; (2)Is consecutive to records in (1).</p>  <p>Here's how I do it:</p>  <pre><code>Private Function ValidRec(RecordList As List(Of BookRecords)) As List(Of BookRecords)     Dim timeNow = Date.Now     'Valid records by itself     Dim validRecords = RecordList.Where(         Function(r)             Dim startDate As DateTime             'VVVVV stack overflow thrown at this return             Return DateTime.TryParse(r.START_DATE, startDate) AndAlso                    ((startDate - timeNow).TotalMinutes &lt; 15)         End Function)      Do         'consecutive records         Dim conseRecords = RecordList.Except(validRecords).Where(                             Function(r) validRecords.Any(                             Function(vr) vr.END_DATE.Equals(r.START_DATE)))          If Not conseRecords.Any() Then Exit Do         validRecords = validRecords.Concat(conseRecords.Except(validRecords))     Loop      validRecords = validRecords.OrderBy(Function(vr) vr.START_DATE) _                                .ThenBy(Function(vr) vr.BOOK_NUM)      'stack overflow after the ToList line      Return validRecords.ToList End Function </code></pre>  <p>The code works fine until after the last line validRecords.ToList. And then stack overflow occurs at the Return DateTime.TryParse ... statement. Size of RecordList and validRecords are small (both 2 in testing) and there're no other threads modifying these Lists/Objects. </p>  <p>Why is this using up the stack? I know the LINQ statements are probably badly structured and creating lots of lists(IEnumerables?) unnecessarily but is that the cause? (that would be genuine stack overflow then, cool)</p>  <p>I figured making validRecords a list instead of IEnumerable would avoid the problem but I'd appreciate if someone could point out the real cause.</p>