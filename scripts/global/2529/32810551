<p>I have a bug with my collision code and I can't seem to find the problem. When my character is colliding with top block face, the algorithm detects that I'm also colliding with left side.</p>  <p>So in effect, I can't move right and sometimes left because of faulty collision detection.</p>  <pre><code>def BlockCollision(self, vector):      pos           = self.GetPos()     predicted_pos = Vector.Add(pos, self.GetVelocity())      top           = predicted_pos[1] - (self.Entity.h / 2)     bottom        = predicted_pos[1] + (self.Entity.h / 2)     left          = predicted_pos[0] - (self.Entity.w/2)     right         = predicted_pos[0] + (self.Entity.w/2)       collision_direction = "NaN"      for k, v in enumerate(ents.FindByClass("block")):          ent     = ents.FindByClass("block")[k]         ent_pos = ent.GetPos()          block_top, block_bottom = ent_pos[1] - (1/2 * ent.Entity.h),  ent_pos[1] + (1/2 * ent.Entity.h)         block_left, block_right = ent_pos[0] - (1/2 * ent.Entity.w),  ent_pos[0] + (1/2 * ent.Entity.w)          colliding_left_noz, colliding_right_noz = (predicted_pos[0] &lt; ent_pos[0] and (right &gt; block_left and right &lt; block_right)), ( not(predicted_pos[0] &lt; ent_pos[0]) and (left &gt; block_left and left &lt; block_right))         colliding_left, colliding_right = colliding_left_noz and (bottom &gt; block_top and bottom &lt; block_bottom) or (top &gt; block_top and top &lt; block_bottom), colliding_right_noz and (bottom &gt; block_top and bottom &lt; block_bottom) or (top &gt; block_top and top &lt; block_bottom)          colliding_top_nox, colliding_bottom_nox = (predicted_pos[1] &lt; ent_pos[1]) and (bottom &gt; block_top and bottom &lt; block_bottom), not(predicted_pos[1] &lt; ent_pos[1]) and (top &gt; block_top and top &lt; block_bottom)         colliding_top, colliding_bottom = colliding_top_nox and ((right &gt; block_left and right &lt; block_right) or (left &gt; block_left and left &lt; block_right)), colliding_bottom_nox and ((right &gt; block_left and right &lt; block_right) or (left &gt; block_left and left &lt; block_right))            if colliding_left:              if self.Velocity[0] &gt; 0:                 self.Velocity = [0, self.Velocity[1]]             else:                 pass         elif colliding_right:              if self.Velocity[0] &lt; 0:                 self.Velocity = [0, self.Velocity[1]]             else:                 pass         if colliding_top:              if self.Velocity[1] &gt; 0:                 self.Velocity = [self.Velocity[0], 0]             else:                 pass         elif colliding_bottom:              if self.Velocity[1] &lt; 0:                 self.Velocity =[self.Velocity[0], 0]             else:                 pass </code></pre>  <p>So does anyone know what's wrong with it?</p>