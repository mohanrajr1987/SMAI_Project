<p>I've a simple <code>PyGame</code> game taken from the net where I'm doing some changes in order to learn game programing.</p>  <p>It's a very simple game. A character (class <code>Player</code>) is shown in the level, and if you press <code>CTRL</code> he <em>shoots</em> a bullet (it's an image loaded from the  <code>Bullet</code> class). The bullet just takes the position of the character and increments it's <code>X</code> axis (moves horizontaly) until forever.</p>  <p>If I push, for example, two times <code>CTRL</code>, the first bullet gets stucked, and the second bullet keeps moving until I press again <code>CTRL</code>, and so on.</p>  <p>This is my code so far. Im sorry for posting everything but as I'm new in <code>PyGame</code> I can't difference which can be relevant code for the problem or not.</p>  <pre><code>#! /usr/bin/python  import pygame from pygame import *  #WIN_WIDTH = 800 #WIN_HEIGHT = 640 WIN_WIDTH = 400 WIN_HEIGHT = 340 HALF_WIDTH = int(WIN_WIDTH / 2) HALF_HEIGHT = int(WIN_HEIGHT / 2)  DISPLAY = (WIN_WIDTH, WIN_HEIGHT) DEPTH = 32 FLAGS = 0 CAMERA_SLACK = 30  def main():     global cameraX, cameraY     pygame.init()     screen = pygame.display.set_mode(DISPLAY, FLAGS, DEPTH)     pygame.display.set_caption("Use arrows to move!")     timer = pygame.time.Clock()      up = down = left = right = running = shoot = False     bg = Surface((32,32))     bg.convert()     bg.fill(Color("#000000"))     entities = pygame.sprite.Group()     player = Player(32, 32)     #bullet = Bullet(30,7)     platforms = []      x = y = 0     level = [         "PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP",         "P                                          P",         "P                                          P",         "P                                          P",         "P         PP         PPPPPPPPPPP           P",         "P                                          P",         "P                                          P",         "P                                          P",         "P    PPPPPPPP                              P",         "P                                          P",         "P                          PPPPPPP         P",         "P                 PPPPPP                   P",         "P                                          P",         "P         PPPPPPP                          P",         "P                                          P",         "P                     PPPPPP               P",         "P                                          P",         "P   PPPPPPPPPPP                            P",         "P                                          P",         "P                 PPPPPPPPPPP              P",         "P                                          P",         "P                                          E",         "P                                          E",         "P                                          E",         "PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP",]     # build the level     for row in level:         for col in row:             if col == "P":                 p = Platform(x, y)                 platforms.append(p)                 entities.add(p)             if col == "E":                 e = ExitBlock(x, y)                 platforms.append(e)                 entities.add(e)             x += 32         y += 32         x = 0      total_level_width  = len(level[0])*32     total_level_height = len(level)*32     camera = Camera(complex_camera, total_level_width, total_level_height)     entities.add(player)      while 1:         timer.tick(60)          for e in pygame.event.get():             if e.type == QUIT: raise SystemExit, "QUIT"             if e.type == KEYDOWN and e.key == K_ESCAPE:                 raise SystemExit, "ESCAPE"             if e.type == KEYDOWN and e.key == K_UP:                 up = True             if e.type == KEYDOWN and e.key == K_DOWN:                 down = True             if e.type == KEYDOWN and e.key == K_LEFT:                 left = True             if e.type == KEYDOWN and e.key == K_RIGHT:                 right = True             if e.type == KEYDOWN and e.key == K_SPACE:                 running = True             if e.type == KEYDOWN and e.key == K_LCTRL:                 shoot = True                 player_pos = player.returnPlayerPos()                 bullet = Bullet(player_pos[0]+50, player_pos[1]+30)                 entities.add(bullet)              if e.type == KEYUP and e.key == K_UP:                 up = False             if e.type == KEYUP and e.key == K_DOWN:                 down = False             if e.type == KEYUP and e.key == K_RIGHT:                 right = False             if e.type == KEYUP and e.key == K_LEFT:                 left = False          # draw background         for y in range(32):             for x in range(32):                 screen.blit(bg, (x * 32, y * 32))         camera.update(player)         #camera.update(bullet)          # update player, draw everything else         player.update(up, down, left, right, running, platforms)          # update bullet         if shoot == True:             bullet.update()          for e in entities:             screen.blit(e.image, camera.apply(e))         pygame.display.update()   class Camera(object):     def __init__(self, camera_func, width, height):         self.camera_func = camera_func         self.state = Rect(0, 0, width, height)      def apply(self, target):         return target.rect.move(self.state.topleft)      def update(self, target):         self.state = self.camera_func(self.state, target.rect)  def simple_camera(camera, target_rect):     l, t, _, _ = target_rect     _, _, w, h = camera     return Rect(-l+HALF_WIDTH, -t+HALF_HEIGHT, w, h)  def complex_camera(camera, target_rect):     l, t, _, _ = target_rect     _, _, w, h = camera     l, t, _, _ = -l+HALF_WIDTH, -t+HALF_HEIGHT, w, h      l = min(0, l)                           # stop scrolling at the left edge     l = max(-(camera.width-WIN_WIDTH), l)   # stop scrolling at the right edge     t = max(-(camera.height-WIN_HEIGHT), t) # stop scrolling at the bottom     t = min(0, t)                           # stop scrolling at the top     return Rect(l, t, w, h)  class Entity(pygame.sprite.Sprite):     def __init__(self):         pygame.sprite.Sprite.__init__(self)  class Player(Entity):     def __init__(self, x, y):         Entity.__init__(self)         self.xvel = 0         self.yvel = 0         self.onGround = False         self.image = pygame.image.load('images/character.png')  # @UndefinedVariable         self.rect = Rect(x, y, 75, 89)       def update(self, up, down, left, right, running, platforms):         if up:             # only jump if on the ground             if self.onGround: self.yvel -= 10         if down:             pass         if running:             self.xvel = 12         if left:             self.xvel = -8         if right:             self.xvel = 8         if not self.onGround:             # only accelerate with gravity if in the air             self.yvel += 0.3             # max falling speed             if self.yvel &gt; 100: self.yvel = 100         if not(left or right):             self.xvel = 0         # increment in x direction         self.rect.left += self.xvel          # do x-axis collisions         self.collide(self.xvel, 0, platforms)         # increment in y direction         self.rect.top += self.yvel         # assuming we're in the air         self.onGround = False;         # do y-axis collisions         self.collide(0, self.yvel, platforms)      def returnPlayerPos(self):         m = []         m.append(self.rect[0])         m.append(self.rect[1])         return m        def collide(self, xvel, yvel, platforms):         for p in platforms:             if pygame.sprite.collide_rect(self, p):                 if isinstance(p, ExitBlock):                     pygame.event.post(pygame.event.Event(QUIT))                 if xvel &gt; 0:                     self.rect.right = p.rect.left                     print "collide right"                 if xvel &lt; 0:                     self.rect.left = p.rect.right                     print "collide left"                 if yvel &gt; 0:                     self.rect.bottom = p.rect.top                     self.onGround = True                     self.yvel = 0                 if yvel &lt; 0:                     self.rect.top = p.rect.bottom  class Bullet(Entity):     def __init__(self, x, y):         Entity.__init__(self)         self.image = pygame.image.load('images/bullet.png')           self.rect = Rect(x, y, 30, 7)      def update(self):         self.rect.right += 4   class Platform(Entity):     def __init__(self, x, y):         Entity.__init__(self)         self.image = Surface((32, 32))         self.image.convert()         self.image.fill(Color("#DDDDDD"))         self.rect = Rect(x, y, 32, 32)      def update(self):         pass  class ExitBlock(Platform):     def __init__(self, x, y):         Platform.__init__(self, x, y)         self.image.fill(Color("#0033FF"))  if __name__ == "__main__":     main() </code></pre>  <p>So I want to know if someone can give me a hand and tell me how can I shoot <em>unlimited</em> bullets in my game and keep all of the moving horizontally at the same time, and not only one.</p>  <p>Thanks in advance,</p>