<p>I have found many pages that bear on this in one way or another, but have still not discovered how to achieve it.  Here is my XAML:</p>  <pre><code>&lt;TreeView ItemsSource="{Binding Document}" HorizontalAlignment="Stretch" BorderThickness="0" Background="#FFC2A2A2"&gt;     &lt;TreeView.ItemContainerStyle&gt;         &lt;Style TargetType="{x:Type TreeViewItem}"&gt;             &lt;Setter Property="IsExpanded" Value="{Binding IsExpanded, Mode=TwoWay}" /&gt;             &lt;Setter Property="IsSelected" Value="{Binding IsSelected, Mode=TwoWay}" /&gt;             &lt;Setter Property="FontWeight" Value="Normal" /&gt;             &lt;Style.Triggers&gt;                 &lt;Trigger Property="IsSelected" Value="True"&gt;                     &lt;Setter Property="FontWeight" Value="Bold" /&gt;                 &lt;/Trigger&gt;             &lt;/Style.Triggers&gt;         &lt;/Style&gt;     &lt;/TreeView.ItemContainerStyle&gt;     &lt;TreeView.ItemTemplate&gt;         &lt;HierarchicalDataTemplate ItemsSource="{Binding Children}"&gt;             &lt;StackPanel Orientation="Horizontal"&gt;                 &lt;Image Source="{Binding ImageFile}" Height="16" Width="16"/&gt;                 &lt;TextBlock Text="{Binding Name}" Margin="5,0,0,0"/&gt;             &lt;/StackPanel&gt;         &lt;/HierarchicalDataTemplate&gt;     &lt;/TreeView.ItemTemplate&gt;     &lt;TreeView.ContextMenu&gt;         &lt;ContextMenu&gt;             &lt;MenuItem Header="Add" Command="{Binding AddCommand}"/&gt;             &lt;MenuItem Header="Delete" Command="{Binding DeleteCommand}"/&gt;         &lt;/ContextMenu&gt;     &lt;/TreeView.ContextMenu&gt; &lt;/TreeView&gt; </code></pre>  <p>I implemented the AddCommand and DeleteCommand based roughly on the Search button implementation in <a href="http://www.codeproject.com/Articles/26288/Simplifying-the-WPF-TreeView-by-Using-the-ViewMode" rel="nofollow">this</a>.</p>  <p>Both commands require the SelectedItem from the tree, so I implemented it in the tree MVVM, added a pointer to the tree MVVM to each item MVVM, and maintain it via the IsSelected property in the item MVVM.</p>  <pre><code>public bool IsSelected {     get { return mIsSelected; }     set      {         if (value != mIsSelected)         {             mIsSelected = value;             this.OnPropertyChanged("IsSelected");         }         if (mIsSelected)         {             mDocViewModel.SelectedItem = this;         }     } } </code></pre>  <p>(We use mAbc for data members, rather than _abc.)</p>  <p>This all works.  However, the context menus have a context.  Based on which is selected, the AddCommand may not be valid, and I want that represented as disabled and enabled in the view.</p>  <p>I put my tests for this condition in the CanExecute method of each command.  But at run time, CanExecute seems never to be invoked, and both menu item always appear disabled.</p>  <p>Is there a way to get this done?  Is there a simple way?</p>  <p>Thanks, Art</p>  <p>LATER:</p>  <p>Editing my question appears to be the way to make a longer reply.  Here, then, is one of the Command classes ... with respect to the CanExecute mentioned afterwards.</p>  <pre><code>#region DeleteCommand public ICommand DeleteCommand {     get { return mDeleteCommand; } }  void DeleteNode() {     if (mSelectedItem != null)     {         mSelectedItem.Remove();         mSelectedItem = null;     } }  private class DeleteNodeCommand : RoutedCommand {     DocumentRulesViewModel mDocumentViewModel;      public DeleteNodeCommand (DocumentRulesViewModel _docViewModel)     {         mDocumentViewModel = _docViewModel;     }      void SelectedItem_PropertyChanged(object sender, PropertyChangedEventArgs e)     {         throw new NotImplementedException();     }      public bool CanExecute(object parameter)     {         DesignObjectViewModel current = mDocumentViewModel.SelectedItem;         return (current != null);     }      event EventHandler CanExecuteChanged     {         // I intentionally left these empty because         // this command never raises the event, and         // not using the WeakEvent pattern here can         // cause memory leaks.  WeakEvent pattern is         // not simple to implement, so why bother.         add { }         remove { }     }      public void Execute(object parameter)     {         mDocumentViewModel.DeleteNode();     }      public event PropertyChangedEventHandler PropertyChanged; } #endregion </code></pre>  <p>I didn't do anything with the event stuff at the bottom, just copied it from an example.  And, in that example, the command would always be valid.  So maybe the issue lies there.</p>  <p>But I did some prowling for CanExecuteChange, and did not really see what to do with it.</p>  <p>Jim, I guess all I can do it show it all (I'll have to omit the application/model parts, of course.</p>  <p>Main xaml:</p>  <pre><code>&lt;Window x:Class="xDesign.MainWindow"          xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"         xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"         xmlns:local="clr-namespace:xDesign.View"         Title="{StaticResource thisAppName}" Height="350" Width="525"&gt;     &lt;DockPanel&gt;         &lt;Menu VerticalAlignment="Top" DockPanel.Dock="Top" BorderThickness="0"&gt;             &lt;MenuItem Header="{StaticResource fileMenu}" Name="FileMenu"&gt;                 &lt;MenuItem Header="{StaticResource newFileMenu}" Click="NewDocumentMenuItem_Click" Name="FileMenuNewDoc"/&gt;                 &lt;MenuItem Header="{StaticResource openFileMenu}" Click="OpenDocumentMenuItem_Click" Name="FileMenuOpenDoc" /&gt;                 &lt;MenuItem Header="{StaticResource closeFileMenu}" Click="CloseDocumentMenuItem_Click" IsEnabled="False" Name="FileMenuCloseDoc" /&gt;                 &lt;Separator /&gt;                 &lt;MenuItem Name="FileMenuCheckout" Header="{StaticResource checkoutFileMenu}" Click="FileMenuCheckout_Click"/&gt;                 &lt;MenuItem Name="FileMenuCheckin" Header="{StaticResource checkinFileMenu}" Click="FileMenuCheckin_Click" IsEnabled="False"/&gt;                 &lt;MenuItem Name="FileMenuDeleteFromServer" Header="{StaticResource deleteFromServerFileMenu}" Click="FileMenuDeleteFromServer_Click" IsEnabled="False"/&gt;                 &lt;MenuItem Name="FileMenuLogon" Header="{StaticResource logonFileMenu}" Click="FileMenuLogon_Click"/&gt;                 &lt;MenuItem Name="FileMenuLogoff" IsEnabled="False" Header="{StaticResource logoffFileMenu}" Click="FileMenuLogoff_Click"/&gt;             &lt;/MenuItem&gt;             &lt;MenuItem Header="{StaticResource editMenu}" IsEnabled="False" Name="EditMenu"&gt;                 &lt;MenuItem Header="{StaticResource findEditMenu}" Click="FindEditMenuItem_Click"/&gt;             &lt;/MenuItem&gt;             &lt;MenuItem Header="{StaticResource viewMenu}" IsEnabled="False" Name="ViewMenu"&gt;                 &lt;MenuItem Header="{StaticResource expandViewMenu}" Click="ExpandViewMenuItem_Click"/&gt;                 &lt;MenuItem Header="{StaticResource collapseViewMenu}" Click="CollapseViewMenuItem_Click"/&gt;             &lt;/MenuItem&gt;         &lt;/Menu&gt;         &lt;Grid Name="DesignPanel" DockPanel.Dock="Top"&gt;             &lt;Grid.ColumnDefinitions &gt;                 &lt;ColumnDefinition /&gt;                 &lt;ColumnDefinition /&gt;             &lt;/Grid.ColumnDefinitions &gt;             &lt;local:DocumentTreeView x:Name="DocTreeView" Grid.Column="0"/&gt;             &lt;GridSplitter Grid.Column="0" HorizontalAlignment="Right" VerticalContentAlignment="Stretch" Width="3" ResizeDirection="Columns"  /&gt;             &lt;WebBrowser x:Name="objectPreviewBrowser" Grid.Column="1" Margin="6,6,0,0" HorizontalAlignment="Stretch" VerticalAlignment="Stretch" OpacityMask="#FF9B8E8E"/&gt;         &lt;/Grid&gt;     &lt;/DockPanel&gt; &lt;/Window&gt; </code></pre>  <p>Control xaml:</p>  <pre><code>&lt;UserControl x:Class="xDesign.View.DocumentTreeView"              xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"              xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"              xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"               xmlns:d="http://schemas.microsoft.com/expression/blend/2008"               mc:Ignorable="d"               d:DesignHeight="300" d:DesignWidth="300"&gt;     &lt;TreeView ItemsSource="{Binding Document}" HorizontalAlignment="Stretch" BorderThickness="0" Background="#FFC2A2A2"&gt;         &lt;TreeView.ItemContainerStyle&gt;             &lt;Style TargetType="{x:Type TreeViewItem}"&gt;                 &lt;Setter Property="IsExpanded" Value="{Binding IsExpanded, Mode=TwoWay}" /&gt;                 &lt;Setter Property="IsSelected" Value="{Binding IsSelected, Mode=TwoWay}" /&gt;                 &lt;Setter Property="FontWeight" Value="Normal" /&gt;                 &lt;Style.Triggers&gt;                     &lt;Trigger Property="IsSelected" Value="True"&gt;                         &lt;Setter Property="FontWeight" Value="Bold" /&gt;                     &lt;/Trigger&gt;                 &lt;/Style.Triggers&gt;             &lt;/Style&gt;         &lt;/TreeView.ItemContainerStyle&gt;         &lt;TreeView.ItemTemplate&gt;             &lt;HierarchicalDataTemplate ItemsSource="{Binding Children}"&gt;                 &lt;StackPanel Orientation="Horizontal"&gt;                     &lt;Image Source="{Binding ImageFile}" Height="16" Width="16"/&gt;                     &lt;TextBlock Text="{Binding Name}" Margin="5,0,0,0"/&gt;                 &lt;/StackPanel&gt;             &lt;/HierarchicalDataTemplate&gt;         &lt;/TreeView.ItemTemplate&gt;         &lt;TreeView.ContextMenu&gt;             &lt;ContextMenu&gt;                 &lt;MenuItem Header="Add rule" Command="{Binding AddRuleCommand}"/&gt;                 &lt;MenuItem Header="Delete" Command="{Binding DeleteCommand}"/&gt;             &lt;/ContextMenu&gt;         &lt;/TreeView.ContextMenu&gt;     &lt;/TreeView&gt; &lt;/UserControl&gt; </code></pre>  <p>Primary view model:</p>  <pre><code>using System; using System.Collections.ObjectModel; using System.ComponentModel; using System.Windows.Input; using xDesign.Actions; using xDesign.API.Model;  namespace xDesign.ViewModel {     public class DocumentRulesViewModel : INotifyPropertyChanged     {         #region data members         DesignObjectViewModel mRootObject = null;         ObservableCollection&lt;DesignObjectViewModel&gt; mDocument = null;         DesignObjectViewModel mSelectedItem = null;         ICommand mDeleteCommand = null;         ICommand mAddRuleCommand = null;         #endregion          #region consructors         public DocumentRulesViewModel(DocumentObject _rootObject)         {             mRootObject = new DesignObjectViewModel(_rootObject, this);             mDocument = new ObservableCollection&lt;DesignObjectViewModel&gt;             (new DesignObjectViewModel[] { mRootObject });             mRootObject.IsExpanded = true; // We start with the top node expanded             mDeleteCommand = new DeleteNodeCommand(this);             mAddRuleCommand = new AddRuleCommandClass(this);         }          ~DocumentRulesViewModel()         {             Close();         }          public void Close()         {             Document = null;         }         #endregion          #region properties         public ObservableCollection&lt;DesignObjectViewModel&gt; Document         {              get { return mDocument; }             set             {                 if (value != mDocument)                 {                     mDocument = value;                     this.OnPropertyChanged("Document");                 }             }         }          public DesignObjectViewModel SelectedItem         {             get { return mSelectedItem; }             set             {                 if (value != mSelectedItem)                 {                     mSelectedItem = value;                     this.OnPropertyChanged("SelectedItem");                 }             }         }          public IDesignObject CurrentDesignObject         {             get             {                 if (mSelectedItem == null)                 {                     return null;                 }                 else                 {                     return mSelectedItem.DesignObject;                 }             }             set             {                 DesignObjectViewModel dovm = SearchForNode(value);                 if (dovm != null)                 {                     if (dovm.Parent != null &amp;&amp; !dovm.Parent.IsExpanded)                     {                         dovm.Parent.IsExpanded = true;                     }                     dovm.IsSelected = true;                 }             }         }         #endregion         #region DeleteCommand         public ICommand DeleteCommand         {             get { return mDeleteCommand; }         }          public void DeleteItem ()         {             DesignObjectViewModel node = this.SelectedItem;             node.Remove();         }          private class DeleteNodeCommand : RoutedCommand         {             DocumentRulesViewModel mTree;              public DeleteNodeCommand(DocumentRulesViewModel _tree)             {                 mTree = _tree;             }              public bool CanExecute(object parameter)             {                 DesignObjectViewModel node = mTree.SelectedItem;                 return (node != null);             }              public void Execute(object parameter)             {                 mTree.DeleteItem();             }              // allows for constant updating if the event can execute or not.             public event EventHandler CanExecuteChanged             {                 add                 {                     CommandManager.RequerySuggested += value;                 }                 remove                 {                     CommandManager.RequerySuggested -= value;                 }             }              public void RaiseCanExecuteChanged()             {                 // we should not have to reevaluate every can execute.                   // but since there are too many places in product code to verify                 // we will settle for all or nothing.                 CommandManager.InvalidateRequerySuggested();             }         }         #endregion          #region AddRuleCommand         public ICommand AddRuleCommand         {             get { return mAddRuleCommand; }         }          void AddRule()         {             int index = -1; // Where to insert; -1 = inside selected item             if (mSelectedItem.Parent != null)             {                 index = mSelectedItem.Parent.Children.IndexOf(mSelectedItem) + 1;  // Insert after selected item             }              // Call the application logic             IDesignObject dobj = DocStructureManagement.AddRule(mSelectedItem.DesignObject, ref index);              if (dobj != null)             {                 DesignObjectViewModel newItemParent;                 if (index == -1)                 {                     newItemParent = mSelectedItem;                     index = 0;                 }                 else                 {                     newItemParent = mSelectedItem.Parent;                 }                 DesignObjectViewModel newItem = new DesignObjectViewModel(dobj, this, newItemParent);                 newItemParent.InsertChild(newItem, index);             }         }          private class AddRuleCommandClass : RoutedCommand         {             DocumentRulesViewModel mTree;              public AddRuleCommandClass(DocumentRulesViewModel _tree)             {                 mTree = _tree;             }              public bool CanExecute(object parameter)             {                 DesignObjectViewModel node = mTree.SelectedItem;                 return (node != null &amp;&amp; node.DesignObject.CanContainOrPrecede(eDesignNodeType.ContentRule));             }              public void Execute(object parameter)             {                 mTree.AddRule();             }              // allows for constant updating if the event can execute or not.             public event EventHandler CanExecuteChanged             {                 add                 {                     CommandManager.RequerySuggested += value;                 }                 remove                 {                     CommandManager.RequerySuggested -= value;                 }             }              public void RaiseCanExecuteChanged()             {                 // we should not have to reevaluate every can execute.                   // but since there are too many places in product code to verify                 // we will settle for all or nothing.                 CommandManager.InvalidateRequerySuggested();             }         }         #endregion           #region Search         private DesignObjectViewModel SearchForNode(IDesignObject _dobj)         {             return SearchNodeForNode(mRootObject, _dobj);         }          private DesignObjectViewModel SearchNodeForNode(DesignObjectViewModel _node, IDesignObject _dobj)         {             if (_node.DesignObject == _dobj)             {                 return _node;             }             foreach (DesignObjectViewModel child in _node.Children)             {                 DesignObjectViewModel childNode = SearchNodeForNode(child, _dobj);                 if (childNode != null)                 {                     return childNode;                 }             }             return null;         }         #endregion          #region INotifyPropertyChanged Members          public event PropertyChangedEventHandler PropertyChanged;          protected virtual void OnPropertyChanged(string propertyName)         {             if (this.PropertyChanged != null)                 this.PropertyChanged(this, new PropertyChangedEventArgs(propertyName));         }          #endregion // INotifyPropertyChanged Members     } } </code></pre>  <p>TreeViewItem view model:</p>  <pre><code>using System; using System.Collections.ObjectModel; using System.Linq; using xDesign.API.Model; using xDesign.Actions; using System.ComponentModel; using System.Windows.Input;  namespace xDesign.ViewModel {     public class DesignObjectViewModel : INotifyPropertyChanged     {         #region data         DocumentRulesViewModel mDocViewModel = null;         IDesignObject mDesignObject = null;         DesignObjectViewModel mParent = null;         ObservableCollection&lt;DesignObjectViewModel&gt; mChildren = null;         bool mIsSelected = false;         bool mIsExpanded = false;         #endregion          #region constructors         public DesignObjectViewModel(IDesignObject _dobj, DocumentRulesViewModel _docViewModel)             : this(_dobj, _docViewModel, null)         {         }          public DesignObjectViewModel(IDesignObject _dobj, DocumentRulesViewModel _docViewModel, DesignObjectViewModel _parent)         {             mDesignObject = _dobj;             mDocViewModel = _docViewModel;             mParent = _parent;             if (_dobj.Type != eDesignNodeType.ContentGroup)             {                 mChildren = new ObservableCollection&lt;DesignObjectViewModel&gt;(                         (from child in mDesignObject.Children                          select new DesignObjectViewModel(child, mDocViewModel, this))                          .ToList&lt;DesignObjectViewModel&gt;());             }             else             {                 ContentHolder ch = (ContentHolder)_dobj;                 mChildren = new ObservableCollection&lt;DesignObjectViewModel&gt;(                         (from child in ch.Contents                          select new DesignObjectViewModel(child, mDocViewModel, this))                          .ToList&lt;DesignObjectViewModel&gt;());             }         }         #endregion          #region properties         public ObservableCollection&lt;DesignObjectViewModel&gt; Children         {             get { return mChildren; }         }          public DesignObjectViewModel Parent         {             get { return mParent; }         }          public String Name         {             get { return mDesignObject.Name; }         }          public IDesignObject DesignObject         {             get { return mDesignObject; }         }          public Type DataType         {             get { return mDesignObject.GetType(); }         }          // Can we use DataType for this, and task the View with finding a corresponding image?         // And do we want to?  We could end up with file names that include Model type names.         // Better?  Worse?  The same?         public String ImageFile         {             get { return GetImageUri(mDesignObject); }         }          public bool IsExpanded         {             get { return mIsExpanded; }             set             {                 if (value != mIsExpanded)                 {                     mIsExpanded = value;                     this.OnPropertyChanged("IsExpanded");                 }                 // Expand all the way up to the root.                 if (mIsExpanded &amp;&amp; mParent != null)                     mParent.IsExpanded = true;             }         }          public bool IsSelected         {             get { return mIsSelected; }             set              {                 if (value != mIsSelected)                 {                     mIsSelected = value;                     this.OnPropertyChanged("IsSelected");                     if (mIsSelected)                     {                         mDocViewModel.SelectedItem = this;                     }                     CommandManager.InvalidateRequerySuggested();                 }             }         }         #endregion          #region public methods         public void Remove()         {             DocStructureManagement.DeleteNode(mDesignObject); // Remove from application              if (mParent != null) // Remove from ViewModel             {                 mParent.Children.Remove(this);                 mParent.OnPropertyChanged("Children");             }         }          public void InsertChild(DesignObjectViewModel _newChild, int _insertIndex)         {             Children.Insert(_insertIndex, _newChild);             this.OnPropertyChanged("Children");         }         #endregion          #region INotifyPropertyChanged Members          public event PropertyChangedEventHandler PropertyChanged;          protected virtual void OnPropertyChanged(string propertyName)         {             if (this.PropertyChanged != null)                 this.PropertyChanged(this, new PropertyChangedEventArgs(propertyName));         }          #endregion // INotifyPropertyChanged Members          internal static string GetImageUri(IDesignObject _dobj)         {             string name = null;             switch (_dobj.Type)             {                 case eDesignNodeType.Document:                     name = "xDesign.ico";                     break;                 case eDesignNodeType.ContentRule:                     name = "Content Rule.png";                     break;                 case eDesignNodeType.Section:                     name = "section rule.png";                     break;                 case eDesignNodeType.Table:                     name = "Table Rule.bmp";                     break;                 case eDesignNodeType.Read:                     name = "Read Rule.bmp";                     break;                 case eDesignNodeType.Goto:                     name = "Goto Rule.bmp";                     break;                 case eDesignNodeType.Label:                     name = "Label Rule.bmp";                     break;                 case eDesignNodeType.ContentGroup:                     name = "ContentGroup.png";                     break;                 case eDesignNodeType.Content:                     name = "content.png";                     break;                 case eDesignNodeType.Criteria:                     name = "Criteria.bmp";                     break;             }              if (name == null)             {                 throw new Exception("No image found for " + _dobj.Name);             }              return string.Format(@"C:\DEVPROJECTS\XDMVVM\XDMVVM\Images\{0}", name);         }     } } </code></pre>  <p>Finally, a code snippet from main window code behind, where I create and connect the main view model.</p>  <pre><code>            mDocumentRulesViewModel = new DocumentRulesViewModel(mCurrentDocument);             this.DocTreeView.DataContext = mDocumentRulesViewModel; </code></pre>  <p>Again, I set breakpoints in the CanExecute method of each of the two command classes, and control never stops there.</p>