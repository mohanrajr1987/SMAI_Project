<p>For part of my thesis I must implement (in Java) a Chan, Frankel, Tsiounis range-bounded commitment protocol as quoted in Boudot's paper <a href="https://www.iacr.org/archive/eurocrypt2000/1807/18070437-new.pdf" rel="nofollow" title="Efficient Proofs that a Committed Number Lies in an Interval">Efficient Proofs that a Committed Number Lies in an Interval</a> ยง1.2.3 which I've quoted below for convenience:</p>  <blockquote>   <p>The main idea of this proof is roughly the same as the one of [2]. Let $t$, $l$, and $s$ be three security parameters. This protocol (due to Chan, Frankel, and Tsiounis [7], and corrected in [8], and also due to [14] in another form) proves that a committed number in $x \in I$ belongs to $J$, where the expansion rate $\#J/\#I$ is equal to $2^{t+l+1}$. Let $n$ be a large composite number whose factorization is unknown by Alice and Bob, $g$ be an element of large order in $\mathbb{Z}^{*}_{n}$ and $h$ be an element of the group generated by $g$ sucht hat both the discrete logarithm of $g$ in bade $h$ and the discrete logarithm of $h$ in base $g$ are unknown by Alice. Let $H$ be a hash-function which outputs $2t$-bit strings. We denote by $E=E(x,r)=g^{x}h^{r}\mod n$ a commitment to $x \in [0,b]$, where $r$ is randomly selected over $[-2^{s}n+1,2^{s}n-1]$. This commitment, from [13], statistically reveals no information about $x$ to Bob.</p>      <p><strong>Protocol:</strong> $PK_{[CFT]}(x,r: E=E(x,r) \wedge x \in [-2^{t+l}b,2^{t+l}b])$.</p>      <ol>   <li>Alice picks random $\omega \in _{R}[0,2^{t+l}b-1]$ and $\eta \in _{R}[-2^{t+l+s}n+1,2^{t+l+s}n-1]$, and then computes $W=g^{\omega}h^{\eta} \mod n$.</li>   <li>Then, she computes $C=H(W)$ and $c=C \mod 2^{t}$.</li>   <li>Finally, she computes $D_{1}= \omega + xc$ and $D_{2}= \eta +rc$ (in $\mathbb{Z}$). If $D_{1} \in [cb,2^{t+l}b-1]$, she sends $(C,D+{1},D_{2})$ to Bob, otherwise she starts again the protocol.</li>   <li>Bob checks that $D_{1} \in [cb,2^{t+l}b-1]$ and that $C=H(g^{D_{1}}h^{D_{2}}E^{-c})$. This convinces Bob that $x \in [-2^{t+l}b, 2^{t+l}b]$.</li>   </ol> </blockquote>  <p>I have implemented other protocols in this paper successfully, however in this case I haven't had any success, specifically because Alice's check of $D_{1} \in [cb,2^{t+l}b-1]$ always fails no matter how many times it is retried. I am curious if the logic in the protocol as written is invalid, or if it is something in my code. I've looked over the code for days and had a couple peers review it, and neither have found anything that should be causing this to fail. I've quoted code below. </p>  <pre><code>/**  * Produces a CFT proof as defined in Boudot paper.   * @param x The original message committed to in e.  * @param r The random value in the commitment e of x.  * @param e The value of the commitment.  * @param b The bounding value such that x is in [0, b]  * @param commit Object containing all the FO commitment parameters (e.g. g, h, n) and access to commit()  * @return An array {C, D1, D2} that satisfies the CFT range-bounded commitment proof.  */ public static BigInteger[] proofCFT(BigInteger x, BigInteger r, BigInteger e, BigInteger b, FujisakiOkamotoCommitment commit) {     SecureRandom rand = new SecureRandom();      // Security parameters     int t = 128; // Because SHA-256 is 256-bit     int l = rand.nextInt(100);     int s = rand.nextInt(100);      // 2^(t+l+s)     BigInteger tls2 = BigInteger.valueOf(2L).pow(t+l+s);      // 2^(t+l)*b-1     BigInteger b2tl_minus1 = BigInteger.valueOf(2L).pow(t+l).multiply(b).subtract(BigInteger.ONE);      while(true)     {         BigInteger omega = getRandomInRange(BigInteger.ZERO, b2tl_minus1); // omega in [0, 2^(t+l)*b-1]         BigInteger eta   = getRandomInRange( // eta in [-2^(t+l+s)*n+1, 2^(t+l+s)*n-1]                 commit.n().multiply(tls2).negate().add(BigInteger.ONE),                 commit.n().multiply(tls2).subtract(BigInteger.ONE));          BigInteger w = commit.commit(omega, eta); // g^(omega)*h^(eta) mod n          byte[] hash = new byte[0];         try         {             hash = MessageDigest.getInstance("SHA-256").digest(w.toByteArray());         }         catch(NoSuchAlgorithmException nsae){} // Never occurs          BigInteger bigC = new BigInteger(1, hash);         BigInteger littleC = bigC.mod(BigInteger.valueOf(2L).pow(t)); // bigC mod 2^t          BigInteger d1 = x.multiply(littleC).add(omega); // d1 = omega + xc         BigInteger d2 = r.multiply(littleC).add(eta);   // d2 = eta + rc          // Keep going until D1 in [c*b, b*2^(t+l)-1]         BigInteger lowerBound = b.multiply(littleC);         if(d1.compareTo(lowerBound) &gt;= 0 &amp;&amp; d1.compareTo(b2tl_minus1) &lt;= 0) // Never succeeds??             return new BigInteger[]{bigC, d1, d2};     } } </code></pre>  <p>Note that <code>getRandomInRange(BigInteger max, BigInteger min)</code> has been thoroughly tested and always uniformly returns a value in that range (inclusive).</p>  <p>Also, <code>FujisakiOkamotoCommitment</code> always generates $n$ such that its large prime factors $p$ and $q$ are safe primes.</p>