<p><strong>A list of N strings, the task is to remove all the duplicate strings from the list and the resulting list of strings in a sorted order. String size is 5, and N can be 5000</strong></p>  <p><strong>What I've tried:</strong>   use a 5-D array to do a successful hashing of the names, as the maximum length of their names is 5. Let 'a' be represented as 1,' b' as 2 and so on... 'z' as 26. Hash[i][j][k][l][m]=1 if the corresponding name is present or else it will be 0. </p>  <pre><code>public class SortString {  static int [][][][][]Hash = new int [27][27][27][27][27]; public static void  main(String [] args) throws IOException {     int N,a,b,c,d,e,Count=0;     BufferedReader br = new BufferedReader(new InputStreamReader(System.in));     String line = br.readLine();     N = Integer.parseInt(line);     while(N!=0)     {         --N;         String str = br.readLine();         a=b=c=d=e=0;         for(int i=0;i&lt;str.length();i++)         {             if(i==0)                 a=str.charAt(i)-'a'+1;             if(i==1)                 b=str.charAt(i)-'a'+1;             if(i==2)                 c=str.charAt(i)-'a'+1;             if(i==3)                 d=str.charAt(i)-'a'+1;             if(i==4)                 e=str.charAt(i)-'a'+1;         }         if((Hash[a][b][c][d][e])==0)             Count++;         Hash[a][b][c][d][e]=1;     }     System.out.println(Count);     for(a=0;a&lt;27;a++)         for(b=0;b&lt;27;b++)             for(c=0;c&lt;27;c++)                 for(d=0;d&lt;27;d++)                     for(e=0;e&lt;27;e++)                         if(Hash[a][b][c][d][e]!=0)                         {                             System.out.print((char)(a+'a'-1));                             if(b!=0)                                 System.out.print((char)(b+'a'-1));                              if(c!=0)                                 System.out.print((char)(c+'a'-1));                              if(d!=0)                                 System.out.print((char)(d+'a'-1));                             if(e!=0)                                 System.out.print((char)(e+'a'-1));                             System.out.println();                         }                        }                      } </code></pre>  <p><strong>For example:</strong> if 'nandu' is present, Hash[14][1][14][4][21]=1. Note that for names of length less than 5, last few of i,j,k,l,m will be 0. For example, if 'rani' is present, Hash[18][1][14][9][0]=1 Now we can traverse the Hash array using 5 nested for-loops. This traversal will be such that lexicographically smaller words will be accessed first</p>  <p>And also tried with <strong>TreeSet</strong> </p>  <p><strong>But I want most Efficient for String Size 100</strong></p>  <p>Strings can be store using Prefix Trie, and Store Strings retrieve one by one in List Collector.</p>