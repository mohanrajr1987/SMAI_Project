<h2>Intro</h2>  <p>I use <em><a href="https://developer.gnome.org/glib/stable/glib-Balanced-Binary-Trees.html" rel="nofollow">GLib Balanced Binary Trees</a></em> in my project. <em><a href="https://en.wikipedia.org/wiki/GLib" rel="nofollow">GLib</a></em> has quite nice balanced tree implementation, but I guess it doesn't allow me to implement my tree-based logic.</p>  <p>I want you to clarify if I'm right that my application's logic can't be implemented with <em>GLib Balanced Binary Trees</em>. If I'm wrong, that is my logic can be implemented using <em>GLib</em>, please write how it can be done.</p>  <p>I'm implementing some objects duplication detection algorithm based on balanced tree. I want to implement following tree insertion algorithm:</p>  <hr>  <h2>Algorithm</h2>  <p>Every tree's node is a structure (let me call this structure: <strong>S</strong>) which contains among others:</p>  <ol> <li>object's <a href="https://en.wikipedia.org/wiki/Hash_function" rel="nofollow">hash</a> (which is node's <strong>key</strong>),</li> <li>object's content (which is used as a input for above hash function),</li> <li>list of object's duplicates of type <strong>S</strong> (possibly empty list).</li> </ol>  <p>Let's say I want to insert new object into <em>GLib</em> tree. Let's assume that this new object has hash equal to <strong>X</strong>. There are 2 possibilities:</p>  <ol> <li>there is already node with hash (key) <strong>X</strong>, or:</li> <li>there isn't.</li> </ol>  <p>In 1st case I want to append new structure with hash <strong>X</strong> to list of object's duplicates (which seems to be difficult to do optimally with <em>GLib</em>).</p>  <p>In 2nd case I want to simply insert new node into tree (which is easy to do with <em>GLib</em>).</p>  <hr>  <h2>Notes</h2>  <p><strong>Note 1:</strong> Above scenario is simplified - in fact it's designed more wisely. In particular: in my implementation list of duplication is not type of <strong>S</strong> in order to not duplicate object's content.</p>  <p><strong>Note 2:</strong> I know that above algorithm can be implemented by traversing tree <strong>twice</strong>, that is:</p>  <ol> <li>Searching for node with key equal to <strong>X</strong>,</li> <li>If above node doesn't exist, then insert new node into tree, doing <strong>second</strong> tree traversal (which is in fact <strong>redundant</strong> after above step).</li> <li>If node exist, then append new node to found node.</li> </ol>  <p>I want to traverse tree <strong>only once</strong> during node insertion.</p>