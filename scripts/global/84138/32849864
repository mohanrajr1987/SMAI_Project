<p>When using traditional {Binding} syntax you could specify element name to point to a specific control on the page, and be able to access its properties. For example if the page is named <code>page</code> you could do:</p>  <pre><code>{Binding ElementName=Page, Path=Name} </code></pre>  <p>With the <a href="https://msdn.microsoft.com/en-us/library/windows/apps/mt204783.aspx" rel="nofollow">{x:Bind}</a> syntax it says</p>  <blockquote>   <p>With x:Bind, you do not need to use ElementName=xxx as part of the   binding expression. With x:Bind, you can use the name of the element   as the first part of the path for the binding because named elements   become fields within the page or user control that represents the root   binding source.</p> </blockquote>  <p>So for the example above in {x:Bind} would be</p>  <pre><code>{x:Bind page.Name} </code></pre>  <p>Which works fine, until it is inside a data template (for example a ListView's ItemTemplate). In which case it no longer works as it is looking for <code>Page</code> on the data type specified which leads to the following error (assuming my data type is <code>customer</code>):</p>  <blockquote>   <p>XamlCompiler error WMC1110: Invalid binding path 'Page.Name' :   Property 'Page' can't be found on type 'Customer'</p> </blockquote>  <p>What is the solution to use {x:Bind} syntax with datatemplates and access controls outside the data template?</p>  <p>Example code is available <a href="https://github.com/rmaclean/x-BindFun/tree/b648abd5831562e579334e9ac4734b40c1992c49" rel="nofollow">here</a> (note specific commit)</p>