<p>I have a custom subclass of <code>QSortFilterProxyModel</code>. I overrode <code>filterAcceptsRow</code> with the custom filter I wanted. Then I used it as such:</p>  <pre><code>proxy = new MyFilterModel(); proxy-&gt;setSourceModel(...); proxy-&gt;setDynamicSortFilter(true); proxy-&gt;setFilterParams(...); // my custom function comboBox-&gt;setModel(proxy); </code></pre>  <p>However, when the underlying source model updated such that rows that previously were filtered should no longer be filtered, the combo box was not updated with those rows. Why is that?</p>  <p>Eventually I overrode <code>setSourceModel</code> in <code>MyFilterModel</code> like so:</p>  <pre><code>void MyFilterModel::setSourceModel(QAbstractItemModel *sourceModel) {     QSortFilterProxyModel::setSourceModel(sourceModel);      connect(sourceModel, SIGNAL(dataChanged(const QModelIndex&amp;, const QModelIndex&amp;)), this, SLOT(doInvalidateFilter()));     connect(sourceModel, SIGNAL(modelReset()), this, SLOT(doInvalidateFilter()));      invalidateFilter(); } </code></pre>  <p>... where all <code>doInvalidateFilter()</code> does is call <code>invalidateFilter</code>. This worked - now when the model updated, the filter rows themselves also updated.</p>  <p>I figure that <code>setDynamicSortFilter</code> should have already taken care of this, though. Is this a bug in Qt? </p>