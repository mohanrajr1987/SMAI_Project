<p>For the past hour or more I have been trying to do something that I thought will be really simple. Unfortunately it seems it`s too complex for my brain to comprehend :/</p>  <p>I'm trying to evaluate an expression which is composed out of integers and names of objects:</p>  <pre><code>    ...       QScripEngine engine;     MyClass first = new MyClass("A",6);     MyClass second = new MyClass("B",6);     qDebug() &lt;&lt; engine.evaluate("2 + A / B").toString();     ... </code></pre>  <p>This is my basic class:</p>  <pre><code>class MyClass : public QObject {    Q_OBJECT    public:         MyClass(const QString&amp; n, const int&amp; val) : QObject(NULL)        {            value = val;            name  = n;        }        QString get_name() const        {            return name;        }        int get_value() const        {            return value;        }     private:        QString name;        int     value; } </code></pre>  <p>I want to be flexible so that even if a value on one of the objects changes I can call the engine again with the same expression and get the new result. In a way if I can write the expression as <code>engine.evaluate("2+A-&gt;get_value()/B-&gt;get_value())</code> all my problems will be gone. I did try to represent each one of the objects as a function which looked something like this:</p>  <pre><code>QScriptValue func = engine.newFunction(get_val); myEngine.globalObject().setProperty("A", func, A); myEngine.globalObject().setProperty("B", func, B); </code></pre>  <p>But from the "get_val" function I couldn't find how to access the QObject so that I can refer to it. Also setting it as a function makes the identifier to require brackets ( "A(...)" instead of "A" ) which is definitely something that I dont want :/</p>  <p>Can anybody please explain what I'm doing wrong?</p>  <p>Thanks</p>