<p>I'm trying to use openlGL to convert my rgb image which is in (*buf) into a YUV image. Using a fragment shader. Currently I am only calculating the Y part of the image in the shader. I was wondering how to get this Y value back into my c++ code and potentially into an array or buffer. Or if anyone could direct me to how variables in the shader communicate with c++ code.</p>  <pre><code>int main() {      void* buf //assume buf has the rgb image.      SDL_Surface *Win=NULL;     SDL_Event evt;     int i;     GLhandleARB FSHandle,PHandle;     char *s;      const char *FProgram=             "uniform sampler2DRect rgba;\n"             "void main(void) {\n"             "float Y;\n"             "vec4 new_rgba = texture2DRect(rgba, gl_TexCoord[0].xy);\n"              "new_rgba.rgba = vec4(new_rgba.g, new_rgba.b, new_rgba.a , 1);\n"              "Y = ((55.0 * new_rgba.r + 183.0 * new_rgba.g + 18.0 * new_rgba.b + 128.0)* 256.0);\n"              "gl_FragColor = new_rgba;"             "}\n";       if(!SDL_Init(SDL_INIT_VIDEO)) {          SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER,1);          Win=SDL_SetVideoMode(B_WIDTH,B_HEIGHT,32,SDL_HWSURFACE|SDL_ANYFORMAT|SDL_OPENGL);          if(Win) {             glMatrixMode(GL_PROJECTION);             glLoadIdentity();             glOrtho(0,B_WIDTH,0,B_HEIGHT,-1,1);             glViewport(0,0,B_WIDTH,B_HEIGHT);             glClearColor(0,0,0,0);             //glColor3f(1.0,0.84,0.0);             glHint(GL_POLYGON_SMOOTH_HINT,GL_NICEST);              /* Set up program objects. */             PHandle=glCreateProgramObjectARB();             FSHandle=glCreateShaderObjectARB(GL_FRAGMENT_SHADER_ARB);              /* Compile the shader. */             glShaderSourceARB(FSHandle,1,&amp;FProgram,NULL);             glCompileShaderARB(FSHandle);              /* Print the compilation log. */             glGetObjectParameterivARB(FSHandle,GL_OBJECT_COMPILE_STATUS_ARB,&amp;i);             s=new char(32768);             glGetInfoLogARB(FSHandle,32768,NULL,s);             printf("Compile Log: %s\n", s);             delete[] s;              /* Create a complete program object. */             glAttachObjectARB(PHandle,FSHandle);             glLinkProgramARB(PHandle);              /* And print the link log. */             s=new char(32768);             glGetInfoLogARB(PHandle,32768,NULL,s);             printf("Link Log: %s\n", s);             delete[] s;              /* Finally, use the program. */             glUseProgramObjectARB(PHandle);               /* This might not be required, but should not hurt. */             glEnable(GL_TEXTURE_2D);              /* Select texture unit 1 as the active unit and bind the U texture. */             glActiveTexture(GL_TEXTURE1);             glBindTexture(GL_TEXTURE_RECTANGLE_NV,1);             glTexParameteri(GL_TEXTURE_RECTANGLE_NV,GL_TEXTURE_MAG_FILTER,GL_LINEAR);             glTexParameteri(GL_TEXTURE_RECTANGLE_NV,GL_TEXTURE_MIN_FILTER,GL_LINEAR);             glTexEnvf(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE,GL_DECAL);             glTexImage2D(GL_TEXTURE_RECTANGLE_NV,0,GL_RGBA8,1920,1080,0,GL_RGBA,GL_UNSIGNED_INT_8_8_8_8, buf);              i=glGetUniformLocationARB(PHandle,"rgba");             glUniform1iARB(i,1);              /* Simple loop, just draws the image and waits for quit. */             while(!Quit) {                 if(SDL_PollEvent(&amp;evt)) {                     switch(evt.type) {                     case  SDL_KEYDOWN:                     case  SDL_QUIT:                         Quit=1;                         break;                     }                 }                  glClear(GL_COLOR_BUFFER_BIT);                  /* Draw image (again and again). */                  glBegin(GL_QUADS);                 glTexCoord2i(0,1080);                 glVertex2i(0,0);                 glTexCoord2i(1920,1080);                 glVertex2i(B_WIDTH,0);                 glTexCoord2i(1920,0);                 glVertex2i(B_WIDTH,B_HEIGHT);                 glTexCoord2i(0,0);                 glVertex2i(0,B_HEIGHT);                 glEnd();                  /* Flip buffers. */                  glFlush();                 SDL_GL_SwapBuffers();                  SDL_Delay(50);             } /* while(!Quit) */              /* Clean up before exit. */              glUseProgramObjectARB(0);             glDeleteObjectARB(PHandle);            } else {             fprintf(stderr,"Unable to create primary surface. \"%s\".\n",SDL_GetError());         }         SDL_Quit();     } else {         fprintf(stderr,"Initialisation failed. \"%s\".\n",SDL_GetError());     }      return(0); } </code></pre>