<p>Is there a way to automatically wrap a CUDA math function in a functor so that one can apply thrust::transform without having to write a functor manually?  Something like the functionality that (I gather) std::function provides?</p>  <p>thrust::placeholders doesn't seem to like math functions. std::function doesn't seem to be available.</p>  <p>Example code:</p>  <pre><code>#include &lt;thrust/transform.h&gt; #include &lt;thrust/device_vector.h&gt; #include &lt;iostream&gt; #include &lt;functional&gt; #include &lt;math.h&gt;  struct myfunc{     __device__      double operator()(double x,double y){     return hypot(x,y);     } };  int main(){      double x0[10] = {3.,0.,1.,2.,3.,4.,5.,6.,7.,8.};     double y0[10] = {4.,0.,1.,2.,3.,4.,5.,6.,7.,8.};      thrust::device_vector&lt;double&gt; x(x0,x0+10);     thrust::device_vector&lt;double&gt; y(y0,y0+10);     thrust::device_vector&lt;double&gt; r(10);      for (int i=0;i&lt;10;i++) std::cout &lt;&lt; x0[i] &lt;&lt;" ";    std::cout&lt;&lt;std::endl;     for (int i=0;i&lt;10;i++) std::cout &lt;&lt; y0[i] &lt;&lt;" ";    std::cout&lt;&lt;std::endl;      // this works:     thrust::transform(x.begin(),x.end(),y.begin(),r.begin(), myfunc());      // this doesn't compile:     using namespace thrust::placeholders;     thrust::transform(x.begin(),x.end(),y.begin(),r.begin(), hypot(_1,_2));      // nor does this:     thrust::transform(x.begin(),x.end(),y.begin(),r.begin(), std::function&lt;double(double,double)&gt;(hypot));       for (int i=0;i&lt;10;i++) std::cout &lt;&lt; r[i] &lt;&lt;" ";    std::cout&lt;&lt;std::endl; } </code></pre>  <p>Thanks!</p>  <p>Sean</p>