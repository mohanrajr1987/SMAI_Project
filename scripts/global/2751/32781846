<p>I have a kernel that needs to apply a stencil operation on an array and store the result on another array. The stencil could be expressed in a function as:</p>  <pre><code>float stencil(const float* data) {     return *(data-1) + *(data+1); } </code></pre>  <p>I want every thread to produce 4 contiguous values of the output array by loading 6 contiguous values of the input array. By doing so I would be able to use the float4 type for loading and storing in chunks of 128 bytes. This is my program (you can download and compile it, but please consider the kernel in first place):</p>  <pre><code>#include&lt;iostream&gt; #include&lt;cstdlib&gt; #include&lt;thrust/host_vector.h&gt; #include&lt;thrust/device_vector.h&gt;  __global__ void kernel(const float* input, float* output, int size) {     int i = 4*(blockDim.x*blockIdx.x + threadIdx.x);     float values[6];     float res[4];      // Load values     values[0] = *(input+i-1);     *reinterpret_cast&lt;float4*&gt;(values+1) = *reinterpret_cast&lt;const float4*&gt;(input+i);     values[5] = *(input+i+4);      // Compute result     res[0] = values[0]+values[2];     res[1] = values[1]+values[3];     res[2] = values[2]+values[4];     res[3] = values[3]+values[5];      // Store result     *reinterpret_cast&lt;float4*&gt;(output+i) = *reinterpret_cast&lt;const float4*&gt;(res); }  int main() {     // Parameters     const int nBlocks = 8;     const int nThreads = 128;     const int nValues = 4 * nThreads * nBlocks;      // Allocate host and device memory     thrust::host_vector&lt;float&gt; input_host(nValues+64);     thrust::device_vector&lt;float&gt; input(nValues+64), output(nValues);      // Generate random input     srand48(42);     thrust::generate(input_host.begin(), input_host.end(), []{ return drand48()+1.; });     input = input_host;      // Run kernel     kernel&lt;&lt;&lt;nBlocks, nThreads&gt;&gt;&gt;(thrust::raw_pointer_cast(input.data()+32), thrust::raw_pointer_cast(output.data()), nValues);      // Check output     for (int i = 0; i &lt; nValues; ++i)     {         float ref = input_host[31+i] + input_host[33+i];          if (ref != output[i])         {             std::cout &lt;&lt; "Error at " &lt;&lt; i &lt;&lt; " : " &lt;&lt; ref &lt;&lt; "  " &lt;&lt; output[i] &lt;&lt; "\n";             std::cout &lt;&lt; "Abort with errors\n";             std::exit(1);         }     }      std::cout &lt;&lt; "Success\n"; } </code></pre>  <p>The program works perfectly.</p>  <p>I would expect the compiler to generate one <code>LD.E.128</code> instruction for the central part of the local array <code>values</code>, and the registers for this central part to be contiguous (e.g. R4, R5, R6, R7); to have two <code>LD.E</code> instructions for both ends of <code>values</code>; to have one <code>ST.E.128</code> for the <code>output</code> array.</p>  <p>What happens in reality is the following:</p>  <pre><code>code for sm_21     Function : _Z6kernelPKfPfi      /*0000*/         MOV R1, c[0x1][0x100];                /* 0x2800440400005de4 */     /*0008*/         NOP;                                  /* 0x4000000000001de4 */     /*0010*/         MOV32I R3, 0x4;                       /* 0x180000001000dde2 */     /*0018*/         S2R R0, SR_CTAID.X;                   /* 0x2c00000094001c04 */     /*0020*/         S2R R2, SR_TID.X;                     /* 0x2c00000084009c04 */     /*0028*/         IMAD R0, R0, c[0x0][0x8], R2;         /* 0x2004400020001ca3 */     /*0030*/         SHL R6, R0, 0x2;                      /* 0x6000c00008019c03 */     /*0038*/         IMAD R10.CC, R6, R3, c[0x0][0x20];    /* 0x2007800080629ca3 */     /*0040*/         IMAD.HI.X R11, R6, R3, c[0x0][0x24];  /* 0x208680009062dce3 */     /*0048*/         IMAD R2.CC, R6, R3, c[0x0][0x28];     /* 0x20078000a0609ca3 */     /*0050*/         LD.E R4, [R10+0xc];                   /* 0x8400000030a11c85 */     /*0058*/         IMAD.HI.X R3, R6, R3, c[0x0][0x2c];   /* 0x20868000b060dce3 */     /*0060*/         LD.E R7, [R10+0x4];                   /* 0x8400000010a1dc85 */     /*0068*/         LD.E R9, [R10+-0x4];                  /* 0x87fffffff0a25c85 */     /*0070*/         LD.E R5, [R10+0x8];                   /* 0x8400000020a15c85 */     /*0078*/         LD.E R0, [R10+0x10];                  /* 0x8400000040a01c85 */     /*0080*/         LD.E R8, [R10];                       /* 0x8400000000a21c85 */     /*0088*/         FADD R6, R7, R4;                      /* 0x5000000010719c00 */     /*0090*/         FADD R4, R9, R7;                      /* 0x500000001c911c00 */     /*0098*/         FADD R7, R5, R0;                      /* 0x500000000051dc00 */     /*00a0*/         FADD R5, R8, R5;                      /* 0x5000000014815c00 */     /*00a8*/         ST.E.128 [R2], R4;                    /* 0x9400000000211cc5 */     /*00b0*/         EXIT;                                 /* 0x8000000000001de7 */     ................................ </code></pre>  <p>All loads are 32-bit wide (<code>LD.E</code>). On the other side, there is just one store instruction <code>ST.E.128</code>, as expected.</p>  <p>I don't show the whole code here again, but I did a test where the stencil does not need a value to the left, but only one to the right (e.g. <code>*data + *(data+1)</code>), in which case my <code>values</code> array contains just 5 values and the <code>float4</code> load operation modifies the first 4 values of the array (I still have one extra load for the last value). In that case the compiler uses <code>LD.E.128</code>.</p>  <p>My question is why doesn't the compiler understand that it can use the 128-bit wide read if the target register is not the first one in the local array. After all the local array <code>values</code> is just a programming way to say that I need 6 floats to be stored in the registers. There is no such a thing like an array in the resulting ptx or SASS code. I thought I gave the compiler enough hints for it to understand <code>LD.E.128</code> was the right instruction here.</p>  <p>Second question: how can I make it use the 128-wide load here without having to manually write low-level code? (However if a couple of asm instructions help I'm open to receive suggestions.)</p>  <p>Side note: the decision of using 32-bit load for reading the input and 128-bit store for writing the input is taken while producing ptx code. ptx code already shows this pattern of multiple small loads and a single large store.</p>  <p>I am using CUDA 7.5 under linux.</p>  <hr>  <p>Based on the suggestions given in the comments, I did some experiments.</p>  <p>Declaring either <code>input</code> or <code>output</code> as <code>__restrict__</code> (or both) solves the problem: the compiler generated a <code>LD.E.128</code> and two <code>LD.E</code>, which is what I wanted to achieve, when generating code for the architecture <code>sm_35</code>. Strangely enough, when generating for <code>sm_21</code> it still prduces six <code>LD.E</code>, but it produces one <code>ST.E.128</code>. It sounds like a compiler bug to me, because the instruction <code>LD.E.128</code> should be perfectly usable in the older architecture as it is in the newest.</p>  <p>The code presented above uses the 128-bit loads just with the small change of using the <code>__restrict__</code> keyword as suggested by njuffa and works. I did also follow the suggestion of m.s. I reproduced the same results shown in the pastebin snippet (one <code>LD.E.128</code> + one <code>LD.E.64</code>). But at runtime it crashes with the following error:</p>  <pre><code>terminate called after throwing an instance of 'thrust::system::system_error'   what():  an illegal memory access was encountered </code></pre>  <p>I'm pretty sure the misalignment is the cause of this problem.</p>  <p>Update: after using cuda-memcheck I'm sure the problem is misalignment:</p>  <pre><code>========= Invalid __global__ read of size 16 =========     at 0x00000060 in kernel(float const *, float*, int) =========     by thread (4,0,0) in block (7,0,0) =========     Address 0xb043638bc is misaligned </code></pre>