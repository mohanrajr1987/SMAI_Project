<p>I am writing a function to search for the first occurrence that matches a specific criteria.  In my particular problem, I am interested in finding the array index corresponding to a circle that intersects with a given point.  I have three arrays that collectively describe the circles: x coordinates, y coordinates, and radii (<code>cx</code>, <code>cy</code>, <code>cz</code>).  Given an input point I calculate whether or not it will intersect each of the circles defined by the 3 arrays.  I chose to declare the x, y, radii arrays in global memory because my <code>search</code> function will be called often and these arrays will not change.  </p>  <p>This function seems pretty straight forward, but I'm getting the following error:  </p>  <p><code>cudaMemcpy(&amp;res, dev_idx, sizeof(int), cudaMemcpyDeviceToHost) returned the launch timed out and was terminated(6)</code></p>  <pre><code>static void CheckCudaErrorAux (const char *, unsigned, const char *, cudaError_t); #define HANDLE_ERROR(value) CheckCudaErrorAux(__FILE__,__LINE__, #value, value)  // global memory arrays on the device __device__ __constant__ double* cx; __device__ __constant__ double* cy; __device__ __constant__ double* cr;  __global__ void _cuda_find_containing_circle(double px, double py, int* fidx, int count){     // px, py: x and y coordinates of the search point     // fidx:   a device variable to return the index of the matching circle     // count:  total number of circle elements in the device arrays      // get the current thread id     int tid = threadIdx.x + blockIdx.x * blockDim.x;      if(tid &lt; count){         // calculate the hypotenuse of the point and grab the radius         float hypot = (float)hypot(cx[tid] - px, cy[tid] - py);         float radius = (float)cr[tid];          // if the hypotenuse is within the radius, return the current index         // this looks like the problem, i.e. hardcoding to "if(tid = 10){" does not result in an error         if (hypot &lt;= radius){               atomicMin(fidx, tid);              // I've also tried setting the idx directly             //*fidx = tid;         }          // increment thread id         tid += blockDim.x * gridDim.x;     } }      void main(){     // define a search point for testing     int px = 100;     int py = 150;      // initialize cx, cy, cz device values using the following arrays     double *circlex;     double *circley;     double *circler;     int count = 100;      circlex = (double *) malloc(sizeof(double) * count);     circley = (double *) malloc(sizeof(double) * count);     circler = (double *) malloc(sizeof(double) * count);      // populate arrays with values that will not pass the search criteria     for (int i = 0; i &lt; count; i++) {         circlex[i] = 2.1;         circley[i] = 3.2;         circler[i] = 0.0;     }      // add a single value that will pass the search criteria (for testing)     circlex[count - 5] = 101.0;     circley[count - 5] = 160.0;     circler[count - 5] = 11.0;  //hypot should result in 10.0498 &lt; 11      // copy these data onto the device      HANDLE_ERROR(cudaMemcpyToSymbol(cx, &amp;circlex, sizeof(circlex), 0, cudaMemcpyHostToDevice));     HANDLE_ERROR(cudaMemcpyToSymbol(cy, &amp;circley, sizeof(circley), 0, cudaMemcpyHostToDevice));     HANDLE_ERROR(cudaMemcpyToSymbol(cr, &amp;circler, sizeof(circler), 0, cudaMemcpyHostToDevice));      // create an object on the device to store the search index result     int* dev_idx;     int idx = 999;  // initial condition.  If -999 is returned then I know that a match was not found     HANDLE_ERROR(cudaMalloc((void **) &amp;dev_idx, sizeof(int)));     HANDLE_ERROR(cudaMemcpy(dev_idx, &amp;idx, sizeof(int), cudaMemcpyHostToDevice));      // call the search function     _cuda_find_containing_circle &lt;&lt;&lt;128, 128&gt;&gt;&gt; (px, py, dev_idx, count);      // get the search result     // this line throws the following error: cudaMemcpy(&amp;res, dev_idx, sizeof(int), cudaMemcpyDeviceToHost) returned the launch timed out and was terminated(6)      int res;     HANDLE_ERROR(cudaMemcpy(&amp;res, dev_idx, sizeof(int), cudaMemcpyDeviceToHost));      cout &lt;&lt; "IDX = " &lt;&lt; res &lt;&lt; endl;      static void CheckCudaErrorAux (const char *file, unsigned line, const char *statement, cudaError_t err) {     if (err == cudaSuccess)         return;     std::cerr &lt;&lt; statement&lt;&lt;" returned " &lt;&lt; cudaGetErrorString(err) &lt;&lt; "("&lt;&lt;err&lt;&lt; ") at "&lt;&lt;file&lt;&lt;":"&lt;&lt;line &lt;&lt; std::endl;     exit (1); } </code></pre>  <p>Is there something fundamentally incorrect with my approach?  </p>