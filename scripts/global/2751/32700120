<p>I really tried to implement a function in C to multiply to row-major matrix in cublas. I don't know where I mistaking. In the function below A, B and C are pointers to an row matrix correctly allocated. I'd like to keep the option of translate a matrix before perform the product. The function below is not working.</p>  <pre><code>void matrixMul(cublasHandle_t handle,float *A,float *B,float *C, int m,int n,int k,int transA,int transB){      cublasStatus_t stat ; // CUBLAS functions status     float alfa = 1;     float beta = 0;      int     ma = transA ? n:m,     na = transA ? m:n,       nb = transB ? k:n,     mb = transB ? n:k;       if(na!=mb){         puts("Something wrong");     }      //(mb,nb)(ma,na) = (mb,na)     stat= cublasSgemm_v2(handle, (cublasOperation_t) transB, (cublasOperation_t)transA,                 nb,ma,mb,&amp;alfa,                 B,k,                 A,n,&amp;beta,                 C,m);      switch (stat) {         case CUBLAS_STATUS_SUCCESS:             puts("Sucess");             break;         default:             printf("&gt;&gt;&gt;&gt;ERRO  %d&lt;&lt;&lt;&lt;\n",stat);             break;     }  } </code></pre>  <p>The entire source code</p>  <pre><code>// Utilities and system includes #include &lt;assert.h&gt; #include &lt;helper_string.h&gt;  // helper for shared functions common to CUDA Samples  // CUDA runtime #include &lt;cuda_runtime.h&gt; #include &lt;cublas_v2.h&gt;  // CUDA and CUBLAS functions #include &lt;helper_functions.h&gt;  void getFromDevice(float *h_A,float *d_A,int size){     //printf("Copy input data from the host memory to the CUDA device\n");     cudaError_t err  = cudaMemcpy(h_A, d_A, size, cudaMemcpyDeviceToHost);      if (err != cudaSuccess)     {         fprintf(stderr, "Failed to copy vector A from host to device (error code %s)!\n", cudaGetErrorString(err));         exit(EXIT_FAILURE);     } } //A = (m,n) //B = (n,k) //C = (m,k) void matrixMul(cublasHandle_t handle,float *A,float *B,float *C, int m,int n,int k,int transA,int transB){      cublasStatus_t stat ; // CUBLAS functions status     float alfa = 1;     float beta = 0;      int     ma = transA ? n:m,     na = transA ? m:n,       nb = transB ? k:n,     mb = transB ? n:k;       if(na!=mb){         puts("Something wrong");     }      //(mb,nb)(ma,na) = (mb,na)     stat= cublasSgemm_v2(handle, (cublasOperation_t) transB, (cublasOperation_t)transA,                 nb,ma,mb,&amp;alfa,                 B,k,                 A,n,&amp;beta,                 C,m);      switch (stat) {         case CUBLAS_STATUS_SUCCESS:             puts("Sucess");             break;         default:             printf("&gt;&gt;&gt;&gt;ERRO  %d&lt;&lt;&lt;&lt;\n",stat);             break;     }  }   float *mallocfDevice(int size){     float *d_C = NULL;     cudaError_t err  = cudaMalloc((void **)&amp;d_C, size * sizeof(float));      if (err != cudaSuccess)     {         fprintf(stderr, "Failed to allocate device vector C (error code %s)!\n", cudaGetErrorString(err));         exit(EXIT_FAILURE);     }else{         size_t freeM,  total;         cudaMemGetInfo  (   &amp;freeM, &amp;total);         printf("MEM:%.3f\n",freeM,total,100 - ((double)freeM/total)*100 );     }     return d_C; }    void printHostMatrix(int nl, int nc, float *h_s){     for(int j = 0; j &lt; nl ; j++) {         for(int i = 0; i &lt; (nc) ; i++){             int idx = j*nc + i;             printf("%.2f ", h_s[idx]);         }         printf("\n");     }  }   void printfDeviceMatrix(float *d_s,int m, int p){     float *h_s =(float*) malloc(sizeof(float)*m*p);     getFromDevice(h_s,d_s,sizeof(float)*m*p);     printHostMatrix(m,p,h_s);     free(h_s); }   void sendTofDevice(float *h_A,float *d_A,int size){     //printf("Copy input data from the host memory to the CUDA device\n");     cudaError_t err  = cudaMemcpy(d_A, h_A, size*sizeof(float), cudaMemcpyHostToDevice);      if (err != cudaSuccess)     {         fprintf(stderr, "Failed to copy vector A from host to device (error code %s)!\n", cudaGetErrorString(err));         exit(EXIT_FAILURE);     } }   int main(int argc,char **argv){      int ma = 2,         na = 3,         mb = 3,         nb = 2;      float A[] = { 1,2,3,                  4,5,6};     float B[] = {7, 8,                 9,10,                 11,12};      float *C = new float[ma*nb];        float *d_a = mallocfDevice(ma*mb),           *d_b = mallocfDevice(mb*nb),           *d_c = mallocfDevice(ma*nb);      sendTofDevice(A,d_a,ma*na);     sendTofDevice(B,d_b,mb*nb);      cublasHandle_t handle ; // CUBLAS context     cublasCreate (&amp;handle );      puts("A");     printfDeviceMatrix(d_a,ma,na);     puts("B");     printfDeviceMatrix(d_b,mb,nb);      matrixMul(handle,  d_a,d_b,d_c,                        ma,na,nb,0,0);      puts("AB=C");     printfDeviceMatrix(d_c,ma,nb);   } </code></pre>