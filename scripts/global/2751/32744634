<p>I am using just-in-time linking of compiled PTX resources in my CUDA-powered application and I am attempting to migrate a lot of the code from the old Driver API to the newer Runtime API.</p>  <p>My linking routine goes something like this:</p>  <ol> <li>Call <code>cudaFree(0);</code> to be sure that there is an active, initialised context on the current thread.</li> <li>Use the methods from the Driver API to link the PTX inputs into a cubin: <code>cuLinkCreate(.)</code>, <code>cuLinkAddData(.)</code>, <code>cuLinkComplete(.)</code> and <code>cuLinkDestroy(.)</code></li> <li>Use <code>cuModuleLoadData(.)</code> to load the linker output into a module.</li> <li>Find kernel function pointers with <code>cuModuleGetFunction(.)</code></li> </ol>  <p>My question is this: what happens if the Runtime API were to destroy this context and create a new one? I understand that the Runtime API usually keeps track of the modules it loads so that they are available in newer contexts but will it do so for those loaded by hand? Do I need to hold on to the cubin and load it into new contexts?</p>  <p>I am struggling to find information on JIT linking with the Runtime API so any assistance will be greatly appreciated. What are the best practices, here?</p>