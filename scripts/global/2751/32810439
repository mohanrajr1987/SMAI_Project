<h2>THE GOAL</h2>  <p>I implemented a long-running CUDA kernel that writes results to a page-locked (host) memory queue a la: </p>  <pre><code>// SAMPLE KERNEL CODE int result = /*...*/; queue[atomicInc(atomic_result_counter)] = result; </code></pre>  <p>As I don't want to wait for the kernel execution to be completed, but rather try to process results as soon as they're written, I decided to introduce two CUDA streams: </p>  <ol> <li>Stream #1: Execute kernel that is writing out the results (aforementioned)</li> <li>Stream #2: Repeatedly poll the device side <code>atomic_result_counter</code> and check how many results can currently be expected. </li> </ol>  <h2>THE CATCH:</h2>  <p>The problem is that the <code>atomic_result_counter</code> gives only an indication of how many results can be expected, but they're not necessarily available yet (but may still need to be written).</p>  <h2>POSSIBLE APPROACHES:</h2>  <h2>Bitmap Index for written results</h2>  <p>Introduce a bitmap index and set a bit once the according result has been written. <strong>Works but slow.</strong></p>  <pre><code>// MODIFIED SAMPLE KERNEL CODE unsigned int r_idx = atomicInc(atomic_result_counter); queue[r_idx] = result; __threadfence_system(); setBit(&amp;result_bitmap_index, r_idx); </code></pre>  <h2>Init queue with 0 and check if value is different from 0</h2>  <p>Before starting the kernel execution I'd init all the bytes in the queue with 0 and then, during the kernel execution on the host side, I'd iterate over the results that potentially could already be available. And, to make sure that the result has already been written, I'd check if the value is different from 0 (as 0 is no valid result). <strong>My concern &amp; key question</strong>: A result is an int (4 byte long). Even if we'd neglect the fact that we're using page-locked memory, I am afraid that I might run into a situation where only the first 2 byte of the result have been written to device memory, therefore yielding a non-zero value, but not yet the final result. Can that happen? E.g. that the result would be 0xc004c003, but in global memory only 0xc0040000 has been written so far?</p>  <h2>Somehow observe the queue's memory on the host</h2>  <p>I really don't know if that's possible and how, but if I could observe the queue's memory or get notified by the driver when the kernel has written some data to the page-locked memory. Is that possible, in theory / via API.</p>  <p>Thanks a lot!</p>