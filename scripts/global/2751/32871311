<p><strong>PROBLEM</strong></p>  <p>I have an FFT-based application that uses FFTW3. I am working on porting the application to a CUDA-based implementation using CUFFT. Compiling and running the FFT core of the application standalone within Nsight works fine. I have moved from there to integrating the device code into my application.</p>  <p>When I run using with the CUFFT core code integrated into my application, <code>cudaGetDeviceCount</code> returns a <code>cudaErrorInsufficientDriver</code> error, although I did not get it with the Nsight standalone run. This call is made at the beginning of the run when I'm initializing the GPU.</p>  <p><strong>BACKGROUND</strong></p>  <p>I am running on CentOS 6, using CUDA 7.0 on a GeForce GTX 750, and <code>icpc</code> 12.1.5. I have also successfully tested a small example using a GT 610. Both cards work in Nsight (and I've also compiled and run command-line without problems, though not as extensively as from within Nsight).</p>  <p>To integrate the CUFFT implementation of the FFT core into my application, I compiled and device-linked with <code>nvcc</code> and then used <code>icpc</code> (the Intel C++ Compiler) to compile the host code and to link the device and host code to create a .so. I finally completed that step without errors or warnings (relying on <a href="http://devblogs.nvidia.com/parallelforall/separate-compilation-linking-cuda-device-code/" rel="nofollow">this tutorial</a>).</p>  <p>(The reasoning as to why I'm using a .so has a fair amount of history and additional background. Suffice it to say that making a .so is required for my application.)</p>  <p>The tutorial points out that compilation steps are different between generating the standalone executable (as I do in Nsight) and generating a device-linked library for inclusion in a .so. To get through the compilation, I had to add <code>-lcudart</code> as described in the tutorial, as well as <code>-lcuda</code>, to my <code>icpc</code> linking call (as well as the <code>-L</code> to add <code>.../cuda-7.0/lib64</code> and <code>.../cuda-7.0/lib64/stubs</code> as the paths to those libraries).</p>  <p>NOTE: <code>nvcc</code> links in <code>libcudart</code> by default. I'm assuming it does the same for <code>libcuda</code> since Nsight doesn't include either of these libraries in any of the compile and linking steps.. As an aside, I do find it strange that although <code>nvcc</code> links them in by default, they don't show up from a call to <code>ldd</code> on the executable.</p>  <p>I also had to add <code>--compiler-options '-fPIC'</code> to my <code>nvcc</code> commands to avoid errors described <a href="http://stackoverflow.com/questions/19364969/compilation-fails-with-relocation-r-x86-64-32-against-rodata-str1-8-can-not">here</a>.</p>  <p>I have seen some chatter (for one example, see <a href="http://stackoverflow.com/questions/23464046/has-anyone-actually-gotten-nvcc-and-the-intel-compiler-to-work-together">this post</a>) about Intel/NVCC compatibilities, but it looks like they arise at compile-time with older versions of NVCC, so...I <em>think</em> I'm ok on that account.</p>  <p>Finally, here are the compile commands for compilation of three .cu files (all are identical except for the name of the .cu file and the name of the .o file):</p>  <pre><code>nvcc -ccbin g++ -Iinc -I/path/to/cuda/samples/common/inc -m64 -O3 -gencode arch=compute_20,code=sm_20 -gencode arch=compute_30,code=sm_30 -gencode arch=compute_35,code=sm_35 -gencode arch=compute_37,code=sm_37 -gencode arch=compute_50,code=sm_50 -gencode arch=compute_52,code=sm_52 -gencode arch=compute_52,code=compute_52 --relocatable-device-code=true --compile --compiler-options '-fPIC' -o my_object_file1.o -c my_source_code_file1.cu </code></pre>  <p>And here are the flags I pass to the device linking step:</p>  <pre><code>nvcc -ccbin g++ -Iinc -I/path/to/cuda/samples/common/inc -m64 -O3 -gencode arch=compute_20,code=sm_20 -gencode arch=compute_30,code=sm_30 -gencode arch=compute_35,code=sm_35 -gencode arch=compute_37,code=sm_37 -gencode arch=compute_50,code=sm_50 -gencode arch=compute_52,code=sm_52 -gencode arch=compute_52,code=compute_52 --compiler-options '-fPIC' --device-link my_object_file1.o my_object_file2.o my_object_file3.o -o my_device_linked_object_file.o </code></pre>  <p>I probably don't need the <code>-gencode</code> flags for 30, 37, and 52, at least currently, but they shouldn't cause any problems, and eventually, I will likely compile that way.</p>  <p>And here are my compiling flags (minus the -o flag, and all my -I flags) that I use for the .cc file that uses calls my CUDA library:</p>  <pre><code>-c -fpic -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64 -fno-operator-names -D_REENTRANT -D_POSIX_PTHREAD_SEMANTICS -DM2KLITE -DGCC_ -std=gnu++98 -O2 -fp-model source -gcc -wd1881 -vec-report0 </code></pre>  <p>Finally, here are my linking flags:</p>  <pre><code>-pthread -shared </code></pre>  <p>Any ideas on how to fix this problem?</p>