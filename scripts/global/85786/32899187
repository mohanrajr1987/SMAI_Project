<p>Ok.  Asked this question yesterday and since started a whole new rails app to see if starting from scratch helps.  </p>  <p>Here's how this app works.  A user will create a new countertop and enter their zip code, the countertop size and the type of countertop.  Possible countertop types are stored in a model called "Countertype".  Users select the countertype through a collection_select method, which lists all the entries in the Countertype table.  The responses to this Countertop form are saved in a Countertop table, which has a "countertop_id" integer column.</p>  <p>When the user lands on the Show and then the Index page, I'd like the name of the countertype to be visible instead of the integer.  </p>  <p>How do I do this?  It's killing me.  </p>  <p>Here's my schema:</p>  <pre><code>create_table "countertops", force: :cascade do |t|  t.string   "counterzip"  t.string   "countersize"  t.datetime "created_at",     null: false  t.datetime "updated_at",     null: false  t.integer  "countertype_id" end  create_table "countertypes", force: :cascade do |t|  t.string   "name"  t.datetime "created_at", null: false  t.datetime "updated_at", null: false end </code></pre>  <p>Here's my index and show</p>  <pre><code>def index  @countertops = Countertop.all  @countertops = Countertop.includes(:countertype).all end  def show  @countertops = Countertop.all  @countertops = Countertop.includes(:countertype).all end </code></pre>  <p>Countertop.rb:</p>  <pre><code>class Countertop &lt; ActiveRecord::Base  has_one :countertype end </code></pre>  <p>Countertype.rb</p>  <pre><code>class Countertype &lt; ActiveRecord::Base  belongs_to :countertop end </code></pre>  <p>Show:</p>  <pre><code>&lt;p&gt;   &lt;strong&gt;Counter Type:&lt;/strong&gt;   &lt;%= @countertop.countertype.name %&gt; &lt;/p&gt; </code></pre>  <p>Index:</p>  <pre><code>&lt;% @countertops.each do |countertop| %&gt;   &lt;tr&gt;     &lt;td&gt;&lt;%= countertop.counterzip %&gt;&lt;/td&gt;     &lt;td&gt;&lt;%= countertop.countertype.name %&gt; </code></pre>  <p>Here's a readout from my console for both tables.</p>  <pre><code>Countertop.last   Countertop Load (0.2ms)  SELECT  "countertops".* FROM "countertops"  ORDER            BY "countertops"."id" DESC LIMIT 1 =&gt; #&lt;Countertop id: 1, counterzip: "19111", countersize: "100", created_at:    "2015-10-01 20:44:29", updated_at: "2015-10-01 20:44:29", Countertype_Id: 1&gt;  2.2.1 :029 &gt;   Countertype.last  Countertype Load (0.7ms)  SELECT  "countertypes".* FROM "countertypes"  ORDER BY "countertypes"."id" DESC LIMIT 1   =&gt; #&lt;Countertype id: 1, name: "Granite", created_at: "2015-10-01 20:15:12", updated_at: "2015-10-01 20:15:12"&gt;  </code></pre>  <p>Heres's the error message:     SQLite3::SQLException: no such column: countertypes.countertop_id: SELECT  "countertypes".* FROM "countertypes" WHERE "countertypes"."countertop_id" = ? LIMIT 1</p>  <p>Changing the show to &lt;%= @countertops.countertype_id %> displays a "1".</p>  <p>What do I need to fix to have it display "Granite" instead of "1" ??</p>  <p>Thanks!!</p>