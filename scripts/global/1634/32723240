<p>I would like to use a single PHP file that uses a request's URI to decide what content to display, while making sure that the URL is user-friendly. The former is easy to achieve, however I am having trouble when I try to implement the latter.</p>  <p>I believe this is exactly the kind of thing the <a href="http://nginx.org/en/docs/http/ngx_http_rewrite_module.html" rel="nofollow">Nginx Rewrite Module</a> is made for, but I am having trouble understanding the documentation and I cannot get it to work in the way I was expecting it to. So at this point I am questioning whether my understanding of the module is correct.</p>  <p>Here is what I am trying to achieve, at its most simple:</p>  <ol> <li>A user goes to <code>http://www.example.com/another-page</code>. This is the only URL the user ever sees, it is very nice and neat.</li> <li>Nginx understands this as <code>http://www.example.com/index.php?page=another-page</code> and passes the request to <code>index.php</code>.</li> <li><code>index.php</code> uses the query's parameter to decide what content to display.</li> <li>Nginx responds to the user with the output of <code>index.php</code>.</li> </ol>  <p>Here is how I have attempted to do this:</p>  <h2>Nginx.conf</h2>  <pre><code>server {      listen                        80;     listen                        [::]:80;     server_name                   localhost;      try_files                     $uri $uri/ =404;     root                          /path/to/root;      # Rewrite the URL so that is can be processed by index.php     rewrite ^/(.*)$ /index.php?page=$1? break;      # For processesing PHP scripts and serving their output     location ~* \.php$ {         fastcgi_pass    unix:/var/run/php5-fpm.sock;          fastcgi_split_path_info ^(.+\.php)(/.+)$;         try_files $fastcgi_script_name =404;         set $path_info $fastcgi_path_info;         fastcgi_param PATH_INFO $path_info;         fastcgi_index index.php;         include fastcgi.conf;     }      # For serving static files     location ^~ /static/ {     root            /path/to/static;     } } </code></pre>  <h2>index.php</h2>  <pre><code>$uri = $_SERVER['REQUEST_URI'];  switch ($uri){      case '/index.php?page=':     echo 'Welcome home';     break;      case '/index.php?page=another-page':     echo 'Welcome to another page';     break; }  return; </code></pre>  <p><strong>Where have I gone wrong?</strong></p>  <p>I have tried using the multiple versions of this rewrite rule and <code>var_dump($_SERVER['REQUEST_URI'])</code> to see how the rule effects the URI, but it never does how I would like or expect it to. I have tried putting the rule in the <code>~* \.php$</code> location context, making slight alterations to the regex, removing and adding <code>try_files</code> from contexts, etc. I have done these things always by first checking my regex with <a href="http://regexpal.com/" rel="nofollow">regexpal</a> and then reloading the Nginx configuration file. In any case, I have either gotten a 500 error, or the URI was left unchanged.</p>