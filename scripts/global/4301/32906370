<p>I'm making a small change to a legacy project, and I need to pass a define that has more than one word to the command line, like so:</p>  <pre><code>CFLAGS += -DXXX="A B" </code></pre>  <p>Unfortunately, with the way this project was structured, my makefile fragment doesn't have access to the <code>CFLAGS</code> variable, or any other global for that matter. I only have something like <code>CUSTOM_DEFINES</code> exposed, which gets appended to <code>CFLAGS</code> later.</p>  <p>From what I've understood, the makefiles eventually do an equivalent of</p>  <pre><code>CFLAGS += $(addprefix -D,$(CUSTOM_DEFINES)) </code></pre>  <p>which results in this command line option: <code>-DXXX="A -DB"</code>, the equivalent of <code>#define XXX A -DB</code> instead of <code>#define XXX A B</code>.</p>  <p>Is there some magic sequence I can add to <code>CUSTOM_DEFINES</code> to end up with the correct result?</p>  <hr>  <p>Avoiding the XY problem, here's some context:</p>  <p>I'm trying to force a fragile old system to swallow a broken system header (which I also can't change). The header in one place doesn't define the return type:</p>  <pre><code>/*implicit int */ SomeLegacyFunction(int a, int b) { return a + b; } </code></pre>  <p>The compiler will not accept this (and I can't really change the compiler params). Since <code>SomeLegacyFunction</code> is never used, I want to just do something like:</p>  <pre><code>#define SomeLegacyFunction int SomeLegacyFunction </code></pre>  <p>and get it compiling. Any suggestions how to do this another way are just as welcome.</p>