<p>In order to understand my question I'll give you a brief description of my project. I'm working on a project that involves an external test bench which has an interface made on the PC in Java AWT. The interface has a main window ( "HMI with scenarios" class) therefore a class  that manages the serial connection with the test bench and data reception / transmission by using RXTX library. From the main window the user can select from a list of scenarios to be performed by the test bench.</p>  <p>Each scenario has it's own class and application window where the user has to enter some timing parameters or press the random generate button. Every time the user presses the random button or enters new values to the fields , The duration of the test is calculated automatically therefore Event listeners with action events are attached to each text box.</p>  <p>After each test is finished , the test bench signals to the application with a message which  starts a thread in the main window which makes a log with the test results<br> The problem : </p>  <p>All the actions are performed as a result of Action events ( button press / field modification ) and the main method has only a thread running in the background and doing nothing.</p>  <p>For each scenarios I create an object whenever the random button is pressed and all it's fields are set by the random generate function or timing calculation function. And when I start the thread that performs the log in my main window's class I have to create a new object to start it and therefore al it's fields are reinitialized and the data is lost. </p>  <pre><code>    public class Scenario3 extends SerialClass implements Runnable {        public JFrame frame;         private JTextField accSTARTmin;         private JTextField accSTARTsec;            public int AccSTARTmin;            public int AccSTARTsec;             public String accstartmin ;             public String accstartsec ;         public volatile boolean suspendFlag =false;         public Thread S3Thread ;          public static  void main(String[] args) {                EventQueue.invokeLater(new Runnable() {                 public void run() {                     try {                  } catch (Exception e) {                             e.printStackTrace();                         }                     }                 });             }          public Scenario3() {                 initialize();             }         /**          * Initialize the contents of the frame.          */         private void initialize() {             frame = new JFrame("Normal Operation Scenario 3");             frame.setBounds(100, 100, 928, 591);             frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);             frame.getContentPane().setLayout(null);              accSTARTmin = new JTextField();             accSTARTmin.addMouseListener(new MouseAdapter() {                 @Override                 public void mouseClicked(MouseEvent arg0) {                     timing_calculation();                 }             });             accSTARTmin.setBounds(115, 73, 86, 20);             frame.getContentPane().add(accSTARTmin);             accSTARTmin.setColumns(10);              accSTARTsec = new JTextField();               accSTARTsec.addMouseListener(new MouseAdapter() {                 @Override                 public void mouseClicked(MouseEvent arg0) {                     timing_calculation();                 }             });                accSTARTsec.setColumns(10);             accSTARTsec.setBounds(226, 73, 86, 20);             frame.getContentPane().add(accSTARTsec);                   ..... // other fields     }          void random() {             Random randomtimings = new Random();              S3= new Scenario3();                              S3.AccSTARTmin=randomtimings.nextInt(1); // 30     accSTARTmin.setText(String.valueOf( S3.AccSTARTmin));        S3.AccSTARTsec=randomtimings.nextInt(59);         accSTARTsec.setText(String.valueOf( S3. AccSTARTsec));                    .... // other fields      }       void timing_calculation() {        Accstartmin=accSTARTmin.getText();      S3.AccSTARTmin=Integer.parseInt(accstartmin);     accstartsec=accSTARTsec.getText();      S3.    AccSTARTsec=Integer.parseInt(accstartsec);     ..// other calculations      }         public void run() {               System.out.println("S1 running");         try{    WriteExcel WE = new WriteExcel();              WE.setOutputFile("c:/Users/Laur/Desktop/Scenario1_log.xls");                 WE.write(log_parameters,row_index,fields_columns ;                  System.out.println("Please check the result file .. ");                   synchronized(HMI_with_scenarios.S3){                     while(HMI_with_scenarios.S3.suspendFlag)                         S3Thread.wait();                     }         }          catch (Exception e) {             e.printStackTrace();          }           }             public void start () { System.out.println("Starting scenario1 thread" );          if (S3Thread == null)          {             S3Thread = new Thread (this, "S3Thread");             S3Thread.start ();             }         }           void threadsuspend()         {             suspendFlag = true;         }          void threadresume()         {             suspendFlag=false;             notify();         }           }        public class HMI_with_scenarios extends  TestClass implements SerialPortEventListener {  // main window      public Scenario3 S3 = new Scenario3 ();         public static void main(String args[]) {           HMI_with_scenarios HMI = new  HMI_with_scenarios();          String labels[] = { "Custom scenario", "Custom timing", "Predefined scenarios"};         JFrame frame1 = new JFrame("HMI");         frame1.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // Dispose terminates the app when the last frame is closed         Container contentPane = frame1.getContentPane();         frame1.getContentPane().setLayout(null);          JList jlist = new JList(labels);         JScrollPane scrollPane1 = new JScrollPane(jlist);         scrollPane1.setBounds(0, 0, 121, 241);          contentPane.add(scrollPane1);          JButton connectTOcom = new JButton("Connect");         connectTOcom.addActionListener(new ActionListener() {             public void actionPerformed(ActionEvent e) {             HMI.initialize(HMI.COM);             }           });     // other awt components     }      public synchronized void serialEvent(SerialPortEvent oEvent) {                   HMI_with_scenarios HMI = new  HMI_with_scenarios();              if (oEvent.getEventType() == SerialPortEvent.DATA_AVAILABLE) {              try {                    inputLine = input.readLine();                  sc = new Scanner(inputLine);               HMI_with_scenarios.Scenario1_finish = sc.hasNext "Finish");                     while(HMI_with_scenarios.Scenario1_finish)                     {   System.out.println( "Scenario 1 has finished");                              S3.start();  // start thread to create log                              S3.threadsuspend();                                                ....                               } } </code></pre>  <p>What I tried : </p>  <p>I tried making the fields static , and it works , but after finishing the tests , if I want to change the values they can't be reinitialized and I have to close and open my application.  I also tried to declare the object static which leads to the same result</p>  <p>The question : Is there a way of keeping the scenario's object's fields in my main window's class even if a new object is created , or static modifier is the only solution ?  ( all the classes inherit a so called Serial class which has the serial communications functions so I can't extend anymore ) </p>