<p>I am trying to write my own interactive shell for an EXE on my Windows 8.1 box, using C# and Visual Studio 2013, Update 4.  The code runs without any errors, but I never see anything back from the Read call in either the loop that reads from stdout or the loop that reads stderr.  The read calls never return.  What is wrong with my approach?</p>  <p>I saw this related SO post but I am not getting any Exceptions thrown at all:</p>  <p><a href="http://stackoverflow.com/questions/2085778/c-sharp-read-stdout-of-child-process-asynchronously">C# Read stdout of child process asynchronously</a></p>  <pre><code>public partial class frmMain : Form {     private const string DIR_CHILDPROCESS = @"C:\Users\Robert\Documents\Visual Studio 2012\ChildProcess-5.3.1 - IDAvatars\";     private const string EXE_NAME = @"childprocess.exe";      Process _childProcess = null;      public frmMain()     {         InitializeComponent();     }      private async Task ReadOutputFromChildProcess()     {         char[] aryC = new char[1];          while (true)         {             // Get output from ChildProcess.             int count = await this._childProcess.StandardOutput.ReadAsync(aryC, 0, 1);              Debug.Write(aryC[0]);              // await Task.Delay(50);         }     }      private async Task ReadFromErrorsChildProcess()     {         char[] aryC = new char[1];          while (true)         {             // Get output from ChildProcess.             int count = await this._childProcess.StandardError.ReadAsync(aryC, 0, 1);              Debug.Write(aryC[0]);              // await Task.Delay(50);         }     }      private void frmShell_Load(object sender, EventArgs e)     {         string target = Path.Combine(DIR_CHILDPROCESS, EXE_NAME);          this._childProcess = new Process();          this._childProcess.StartInfo.UseShellExecute = false;         this._childProcess.StartInfo.RedirectStandardOutput = true;         this._childProcess.StartInfo.RedirectStandardError = true;         this._childProcess.StartInfo.RedirectStandardInput = true;         this._childProcess.StartInfo.CreateNoWindow = true;           this._childProcess.EnableRaisingEvents = true;          this._childProcess.StartInfo.FileName = target;          this._childProcess.Exited += this._childProcess_Exited;          // this._childProcess.StartInfo.Arguments = arguments;         // this._childProcess.StartInfo.         this._childProcess.StartInfo.WorkingDirectory = DIR_CHILDPROCESS;         //this._childProcess.StartInfo.FileName = Path.Combine(DIR_CHILDPROCESS, EXE_NAME);         //this._childProcess.StartInfo.UseShellExecute = false;         //this._childProcess.StartInfo.RedirectStandardOutput = true;         //this._childProcess.StartInfo.RedirectStandardError = true;         //this._childProcess.StartInfo.RedirectStandardInput = true;         //this._childProcess.StartInfo.CreateNoWindow = true;           if (!this._childProcess.Start())             MessageBox.Show("ChildProcess failed to start.", "Error");          // Start the loop that reads output from ChildProcess.         this.ReadOutputFromChildProcess();          // Start the loop that reads error messages from ChildProcess.         this.ReadFromErrorsChildProcess();          Debug.WriteLine("ChildProcess launched successfully.");          // this._childProcess.WaitForExit();      }      void _childProcess_Exited(object sender, EventArgs e)     {         Debug.WriteLine("Child process exited with exit code: " + this._childProcess.ExitCode.ToString());     }      private void frmMain_FormClosing(object sender, FormClosingEventArgs e)     {         this._childProcess.Kill();     } } </code></pre>