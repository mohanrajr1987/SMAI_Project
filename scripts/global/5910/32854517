<p>In the case of establishing a pipe between two processes, if those two have a brother to brother relationship rather than a father-child, will they be more error prone ?</p>  <p>My question for this arose when I investigated the code example below:</p>  <pre><code>#include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #include &lt;sys/wait.h&gt;  void runpipe();  int main(int argc, char **argv) {     int pid, status;     int fd[2];      pipe(fd);      switch (pid = fork())     {      case 0: /* child */         runpipe(fd);         exit(0);      default: /* parent */         while ((pid = wait(&amp;status)) != -1) {             fprintf(stderr, "process %d exits with %d\n", pid, WEXITSTATUS(status));             exit(0);         }      case -1:         perror("fork");         exit(1);     }     exit(0); }  char *cmd1[] = { "ls", "-al", "/", 0 }; char *cmd2[] = { "tr", "a-z", "A-Z", 0 };  void runpipe(int pfd[]) {     int pid;      switch (pid = fork())     {      case 0: /* child */         dup2(pfd[0], 0);         close(pfd[1]);  /* the child does not need this end of the pipe */         execvp(cmd2[0], cmd2);         perror(cmd2[0]);      default: /* parent */         dup2(pfd[1], 1);         close(pfd[0]);  /* the parent does not need this end of the pipe */         execvp(cmd1[0], cmd1);         perror(cmd1[0]);       case -1:         perror("fork");         exit(1);     } } </code></pre>  <p>In the example above, parent(grandpa) forks a child(parent), which then forks another child(grandchild). Grandpa waits for dad but dad does not wait for grandson because they both execute execvp. What happens if child finishes earlier than dad (zombie) or dad finishes earlier than child (orphan) ? On the other hand if we had two brothers connected with the pipe and one father and waiting for them (total three processes), even if they both brothers executed execvp, ones exit would not harm the other.</p>