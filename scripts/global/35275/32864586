<p>I'm using <code>Microsoft.Office.Interop.Access.Dao.DBEngine</code> to write data into an existing <code>accdb</code> template. This is done by certain class in a certain assembly.</p>  <p>Now I'm observing two cases: When I start my routine (debug build) within a xunit (1.9.2 with VS runner 2.0.1) test as a 32bit process within TE.ProcessHost.Managed.exe it needs about a minute to complete. Starting it as release build from a console application in 32 bit mode it needs more than 12 minutes. I'm just instantiating a <code>new DbEngine()</code> and later call <code>OpenTable(name)</code> per table to fill and table.Update() per row to insert (no updates, inserts only). The assembly references <code>Microsoft.Office.interop.access.dao.dll</code> version 15.0.4420.1017 (Access 2010).</p>  <p>I'm looking for a clue where to start digging for the reason for these massive discrepancy. </p>  <p><strong>EDIT:</strong> Basically, it's a copy job from SQL-Server to an access db, thus it first reads the data via ADO from SQL-Server and than inserts this into the accdb. Like this (not the exact code):</p>  <pre><code>foreach(var tableName in tables) {   readSqlIntoArray(tablename, tableData);   var daoTable = daoDb.OpenTable(tableName);   foreach(var row in tableData)   {     // ... add new record and copy data      daoTable.Update();  // this is the expensive call in console app   } } </code></pre>  <p>The unit test just creates the parameters for the copy job, creates the relevant object and starts the job. The console app does right the same. Profiling, timing and debugging always lead to <code>table.Update()</code> being the call with most cost. The SQL read shows no differences and ist therefor ruled out as cause of the problem.</p>  <p>The reason for asking here was actually, that I need an idea, where I can further investigate, since the code itself shows no obvious differences.</p>  <p>There is no reflection, generics, unsafe code or hidden artifacts in the calling methods (runner vs console app), that could explain such behavior, since both of them only build the runtime parameters and call the job. I even compared these parameters by char. So I wondered, if there is some 'environmental difference' between console app and VS test runner, since I'm dealing with a COM object here.</p>