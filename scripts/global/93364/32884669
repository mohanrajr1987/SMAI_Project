<p>The following code when compiled with MSVC++2013 and run in Debug configuration, triggers an assert inside the STL library shipped with MSVC++2013:</p>  <pre><code>atomic&lt;uint64_t&gt; a = 0; uint64_t b = 1, c = 2; a.compare_exchange_weak(b, c, memory_order_acq_rel); </code></pre>  <p>The assert that fails is in file xxatomic line 631:</p>  <pre><code>inline bool atomic_compare_exchange_weak_explicit(     _ATOMIC_ITYPE *_Atom, _ITYPE *_Exp, _ITYPE _Value,     memory_order _Order1, memory_order _Order2) _NOEXCEPT     {   // compare and exchange value stored in *_Atom with *_Exp, _Value     assert(_Order2 != memory_order_release);     assert(_Order2 != memory_order_acq_rel);     assert(_Order2 &lt;= _Order1);     _ATOMIC_UINT _Temp = (_ATOMIC_UINT)*_Exp;     bool res = _ATOMIC_COMPARE_EXCHANGE_WEAK(_Atom, &amp;_Temp, _Value,         _Order1, _Order2);     *_Exp = (_ITYPE)_Temp;     return res;     } </code></pre>  <p>However, cppreference says that <code>std::memory_order_acq_rel</code> must not be used only as <code>failure</code> parameter in 4-argument versions of the functions: <a href="http://en.cppreference.com/w/cpp/atomic/atomic/compare_exchange" rel="nofollow">http://en.cppreference.com/w/cpp/atomic/atomic/compare_exchange</a> . I am using 3-argument version of the function, but still the code compiled with MSVC++2013 fails in that <code>assert</code>. Is this a bug in MSVC++2013.</p>