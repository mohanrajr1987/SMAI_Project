<p>My problem at hand is that I am working on an optimized bottom-up (iterative) merge sort. In order to save some computation, I need a buffer that is of the same length as the input range. My aim is that my implementation can sort not just arrays, but arbitrary containers also (<code>std::vector</code>, <code>std::array</code>, or even <code>std::list</code> if need be).</p>  <p>So, <strong>my main question is</strong>: Using generics, how can I copy not just the content passed to the sort, but copy the structure that was passed to it. Of course, I don't want to explicitly deal with the container types, but rather be able to replicate the data and the data structure holding the data.</p>  <p><strong>Note</strong>: My aim, also, is to come up with the implementation that can accept any input <code>std::stable_sort</code> can.</p>  <p><strong>Note 2</strong>: So basically, given </p>  <pre><code>template&lt;class _RandomAccessIterator&gt; void sort(_RandomAccessIterator first, _RandomAccessIterator last) {     Container&lt;...&gt; buffer = ...; } </code></pre>  <p>I want the <code>Container</code> to be of the same container type as <code>first</code> and <code>last</code> are computed from; is this possible in the first place?</p>  <p>(Don't ask me why I want to do it that way; the reason is good.)</p>