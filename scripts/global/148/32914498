<p>It so happens that I need to support in Java JSON data coming from external data sources. There is one common pattern. It's an array containing fixed number of elements of certain different types. We call it tuple. Here is my example of de-serialization for 3-element tuple with particular expected types of elements using FasterXML Jackson:</p>  <pre><code>public class TupleTest {     public static void main(String[] args) throws Exception {         String person = "{\"name\":\"qqq\",\"age\":35,\"address\":\"nowhere\",\"phone\":\"(555)555-5555\",\"email\":\"super@server.com\"}";         String jsonText = "[[" + person + ",[" + person + "," + person + "],{\"index1\":" + person + ",\"index2\":" + person + "}]]";         ObjectMapper om = new ObjectMapper().registerModule(new TupleModule());         List&lt;FixedTuple3&gt; data = om.readValue(jsonText, new TypeReference&lt;List&lt;FixedTuple3&gt;&gt;() {});         System.out.println("Deserialization result: " + data);         System.out.println("Serialization result: " + om.writeValueAsString(data));     } } </code></pre>  <hr>  <pre><code>class Person {     public String name;     public Integer age;     public String address;     public String phone;     public String email;      @Override     public String toString() {         return "Person{name=" + name + ", age=" + age + ", address=" + address                 + ", phone=" + phone + ", email=" + email + "}";     } } </code></pre>  <hr>  <pre><code>class FixedTuple3 {     public Person e1;     public List&lt;Person&gt; e2;     public Map&lt;String, Person&gt; e3;      @Override     public String toString() {         return "Tuple[" + e1 + ", " + e2 + ", " + e3 + "]";     } } </code></pre>  <hr>  <pre><code>class TupleModule extends SimpleModule {     public TupleModule() {         super(TupleModule.class.getSimpleName(), new Version(1, 0, 0, null, null, null));         setSerializers(new SimpleSerializers() {             @Override             public JsonSerializer&lt;?&gt; findSerializer(SerializationConfig config,                     JavaType type, BeanDescription beanDesc) {                 if (isTuple(type.getRawClass()))                     return new TupleSerializer();                 return super.findSerializer(config, type, beanDesc);             }         });         setDeserializers(new SimpleDeserializers() {             @Override             public JsonDeserializer&lt;?&gt; findBeanDeserializer(JavaType type,                     DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException {                 Class&lt;?&gt; rawClass = type.getRawClass();                 if (isTuple(rawClass))                     return new TupleDeserializer(rawClass);                 return super.findBeanDeserializer(type, config, beanDesc);             }         });     }      private boolean isTuple(Class&lt;?&gt; rawClass) {         return rawClass.equals(FixedTuple3.class);     }      public static class TupleSerializer extends JsonSerializer&lt;Object&gt; {         public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonProcessingException {             try {                 jgen.writeStartArray();                 for (int i = 0; i &lt; 3; i++) {                     Field f = value.getClass().getField("e" + (i + 1));                     Object res = f.get(value);                     jgen.getCodec().writeValue(jgen, res);                 }                 jgen.writeEndArray();             } catch (Exception ex) {                 throw new IllegalStateException(ex);             }         }     }    </code></pre>  <hr>  <pre><code>    public static class TupleDeserializer extends JsonDeserializer&lt;Object&gt; {         private Class&lt;?&gt; retClass;          public TupleDeserializer(Class&lt;?&gt; retClass) {             this.retClass = retClass;         }          public Object deserialize(JsonParser p, DeserializationContext ctx) throws IOException, JsonProcessingException {             try {                 Object res = retClass.newInstance();                 if (!p.isExpectedStartArrayToken()) {                     throw new JsonMappingException("Tuple array is expected but found " + p.getCurrentToken());                 }                 JsonToken t = p.nextToken();                 for (int i = 0; i &lt; 3; i++) {                     final Field f = res.getClass().getField("e" + (i + 1));                     TypeReference&lt;?&gt; tr = new TypeReference&lt;Object&gt;() {                         @Override                         public Type getType() {                             return f.getGenericType();                         }                     };                     Object val = p.getCodec().readValue(p, tr);                     f.set(res, val);                 }                 t = p.nextToken();                 if (t != JsonToken.END_ARRAY)                     throw new IOException("Unexpected ending token in tuple deserializer: " + t.name());                 return res;             } catch (IOException ex) {                 throw ex;             } catch (Exception ex) {                 throw new IllegalStateException(ex);             }         }     } } </code></pre>  <p>But this approach means I have to make new class every time I face new type configuration in tuple of certain size. So I wonder if there is any way to define deserializer dealing with generic typing. So that it will be enough to have one tuple class per tuple size. For instance my generic tuple of size 3 could be defined like:</p>  <pre><code>class Tuple3 &lt;T1, T2, T3&gt; {     public T1 e1;     public T2 e2;     public T3 e3;      @Override     public String toString() {         return "Tuple[" + e1 + ", " + e2 + ", " + e3 + "]";     } } </code></pre>  <p>And usage of it would look like:</p>  <pre><code>List&lt;Tuple3&lt;Person, List&lt;Person&gt;, Map&lt;String, Person&gt;&gt;&gt; data =         om.readValue(jsonText,                 new TypeReference&lt;List&lt;Tuple3&lt;Person, List&lt;Person&gt;, Map&lt;String, Person&gt;&gt;&gt;&gt;() {}); </code></pre>  <p>Is it something doable or not?</p>