<p>Building off of the work done <a href="http://stackoverflow.com/questions/3453326/is-there-an-alternative-to-the-curiously-recurring-template-pattern">here</a>, I've defined a generic, abstract base class for enumerations, like so:</p>  <pre><code>public abstract class Enumeration&lt;T&gt; : IEquatable&lt;T&gt; where T : Enumeration&lt;T&gt; {     private static IEnumerable&lt;T&gt; enumerateAllValues()     {         // Obviously use some caching here         var fields = typeof(T).GetFields(BindingFlags.Public | BindingFlags.Static | BindingFlags.DeclaredOnly);         return fields.Select(f =&gt; f.GetValue(null)).OfType&lt;T&gt;();     }      internal static IEnumerable&lt;T&gt; AllValues {get { return enumerateAllValues();}}      protected Enumeration(int value, string displayName)     {         if (!typeof(T).IsSealed)             throw new NotSupportedException($"Value objects must be sealed, {typeof(T).Name} is not.");         this.Value = value;         this.DisplayName = displayName;     }      protected int Value { get; }      protected string DisplayName { get; }      public override string ToString() { return DisplayName; }            // IEquatable implementation based solely on this.Value } </code></pre>  <p>And a static, non-generic helper class to parse and list values of an enum:</p>  <pre><code>public static class Enumeration  {     public static IEnumerable&lt;T&gt; GetAllValues&lt;T&gt;() where T : Enumeration&lt;T&gt;         {             return Enumeration&lt;T&gt;.AllValues;         }     // Other helper methods, e.g. T Parse(int), bool TryParse(int, out T), etc. } </code></pre>  <p>Now, I derive from this with another abstract class to represent a certain class of enumerations that have something in common:</p>  <pre><code>public abstract class AnimalTrait&lt;T&gt; : Enumeration&lt;AnimalTrait&lt;T&gt;&gt; {     protected AnimalTrait(int value, string displayName) : base(value, displayName) { ; } } </code></pre>  <p>So far so good. As an example the concrete class deriving from this might be DogTrait, or FishTrait, etc. Knowing that all animal traits can be paired with a value, and supposing that the value of an animal trait is always a string, I then define another abstract class like so:</p>  <pre><code>public struct AnimalTraitValuePair&lt;TAnimalTrait&gt; where TAnimalTrait : AnimalTrait&lt;TAnimalTrait&gt; {      public TAnimalTrait AnimalTrait { get; }      public string Value { get; } // Analogy breaks down here, but lets assume we know that the values of animal traits are always strings.      public AnimalTraitValuePair(TAnimalTrait animalTrait, string value)     {         this.AnimalTrait = animalTrait;         this.Value = value;     }      public override string ToString()     {         return $"[{AnimalTrait}, {Value}]";     } } </code></pre>  <p>Similar to deriving from <code>KeyValuePair&lt;TAnimalTrait, string&gt; where TAnimalTrait : AnimalTrait&lt;TAnimalTrait&gt;</code>, which I would do if it wasn't a struct.</p>  <p>Now when I go to define the Animal class that holds the name of the animal and it's list of AnimalTrait's with their associated values, i.e. a list of <code>AnimalTraitValuePair&lt;TAnimal&gt;</code>, I run into a problem:</p>  <pre><code>public abstract class Animal&lt;TAnimal, TAnimalTrait&gt; :     where TAnimal : Animal&lt;TAnimal, TAnimalTrait&gt;     where TAnimalTrait : AnimalTrait&lt;TAnimalTrait&gt; {     private readonly IList&lt;AnimalTraitValuePair&lt;TAnimalTrait&gt;&gt; animalTraitValuePairList;      // All animals have a name     public string Name {get;}      protected Animal(string name, IEnumerable&lt;AnimalTraitValuePair&lt;TAnimalTrait&gt;&gt; animalTraitValuePairs)     {         animalTraitValuePairList = animalTraitValuePairs.ToList();         this.Name = name;     }      public string this[TAnimalTrait animalTrait]     {         get         {             return animalTraitValuePairList.First(atvp =&gt; atvp.AnimalTrait == animalTrait).Value;         }     }      public override string ToString()     {         StringBuilder sb = new StringBuilder();         // !!!! BREAKS HERE !!!!         foreach (var animalTrait in Enumeration.GetAllValues&lt;AnimalTrait&lt;TAnimalTrait&gt;&gt;()) // This works...         //foreach (var animalTrait in Enumeration.GetAllValues&lt;TAnimalTrait&gt;()) // ...but this doesn't         {             sb.AppendLine($"{this.Name}'s traits:");             sb.AppendLine($"[{animalTrait}, {animalTrait.Value}]");         }         return sb.ToString();     } } </code></pre>  <p>I get this compiler error: </p>  <blockquote>   <p><code>The type 'TAnimalTrait' cannot be used as type parameter 'T' in the generic type or method 'Enumeration.GetAllValues&lt;T&gt;()'. There is no implicit reference conversion from 'TAnimalTrait' to 'Maxim.Common.Enums.Enumeration&lt;TAnimalTrait&gt;'</code></p> </blockquote>  <p>Why can't I use TAnimalTrait directly?  Is not TAnimalTrait restricted to be a class of <code>AnimalTrait&lt;TAnimalTrait&gt;</code>, which we know is an Enumeration and therefore can be upcasted two levels to the base <code>Enumeration&lt;T&gt;</code>? Is the one that compiles "correct" and give me the behavior I want?</p>