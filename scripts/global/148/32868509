<p>I want to write a <em>generic</em> function <code>functionChooser</code> which will choose which function to use from a few options, based on a String argument. </p>  <p>This works:</p>  <pre><code>def a (arg: String) = arg + " with a" def b (arg: String) = arg + " with b" def c (arg: String) = arg + " with c"  def functionChooser(func: String, additionalArg: String) = {     val f = func match {       case "a" =&gt; a _       case "b" =&gt; b _       case _ =&gt; c _     }      f(additionalArg) }  scala&gt; functionChooser("a", "foo") res18: String = foo with a </code></pre>  <p>I'm having trouble in making <code>functionChooser</code> generic, e.g. when functions <code>a</code>, <code>b</code>, and <code>c</code> return different case classes:</p>  <pre><code>case class A(s: String) case class B(s: String) case class C(s: String)  def a (arg: String) = A(arg) def b (arg: String) = B(arg) def c (arg: String) = C(arg)  //functionChooser def as before  scala&gt; functionChooser("a", "foo") res19: Product with Serializable = A(foo) </code></pre>  <p>I don't quite understand what I got there, I know I get an error when calling <code>functionChooser("a", "foo").s</code> ("<code>error: value s is not a member of Product with Serializable</code>").</p>  <p>Lastly, what I really want is that the functions would return Lists of these case classes, e.g.:</p>  <pre><code>def a (arg: String) = List(A(arg)) def b (arg: String) = List(B(arg)) def c (arg: String) = List(C(arg)) </code></pre>  <p>So <code>functionChooser</code> should be generic to <code>List[T]</code> where <code>T</code> is some class.</p>