<p>I am trying to implement a DSL in F# for a small language. Unfortunately the compiler stops me dead in my tracks when I attempt to constrain nodes to hold additional type information (via phantom types).</p>  <p>The following lines of code illustrate the issue: </p>  <pre><code>type Expr&lt;'a&gt; = | Int of int | Eq  of Expr&lt;int&gt; * Expr&lt;int&gt; | Not of Expr&lt;bool&gt;  let rec to_string (expr: Expr&lt;'a&gt;) =    match expr with   | Int(n)   -&gt; string n   | Eq(x, y) -&gt; sprintf "%s == %s" (to_string x) (to_string y)   | Not(b)   -&gt; sprintf "!%s" (to_string b) </code></pre>  <p>According to the compiler the construct <code>to_string x</code> issues the following warning:</p>  <blockquote>   <p>construct causes code to be less generic than indicated by the type annotations. The type variable 'a has been constrained to be type 'int'.</p> </blockquote>  <p>Following that, on the next line, the construct <code>to_string b</code> issues this error:</p>  <blockquote>   <p>Type mismatch. Expecting a <code>Expr&lt;int&gt;</code> but given a <code>Expr&lt;bool&gt;</code> The type <code>int</code> does not match the type <code>bool</code></p> </blockquote>  <p>I can't seem to find any way to circumvent this behavior, and in fact I can't find the cause this code being less generic than what I had expected. If possible I would prefer a solution that doesn't entirely abandon the phantom types.</p>  <p>Am I doing something fundamentally wrong? Could this be a compiler bug?</p>