<p>I sometimes run into this scenario and not sure if I'm using a bad approach or I just don't know how to solve it.</p>  <p>Let's say I have two classes and two beans like this:</p>  <pre><code>public class BeanOne {     public void methodBeanOne() {         //...     } }  public class BeanTwo {     public void methodBeanTwo() {         //...     } }  public class ClassOne {     private BeanOne bean;      public ClassOne(BeanOne bean) {         this.bean = bean;     }      public void methodclassOne() {         bean.methodBeanOne();     } }  public class ClassTwo {     private BeanTwo bean;      public ClassTwo(BeanTwo bean) {         this.bean = bean;     }      public void methodClassTwo() {         bean.methodBeanTwo();     } } </code></pre>  <p>I want to make a generic abstract class , so I can extract some logic from <code>ClassOne</code> and <code>ClassTwo</code> to it, and an abstract bean with common methods as well:</p>  <pre><code>public abstract class AbstractBean {     public void commonMethod() {         //...     } }  public class BeanOne extends AbstractBean {     public void methodBeanOne() {         //...     } }  public class BeanTwo extends AbstractBean {     public void methodBeanTwo() {         //...     } }  public abstract class AbstractClass&lt;T extends AbstractBean&gt; {     protected T bean;      public AbstractClass(T bean) {         this.bean = bean;     }      public void commonClassMethod(){         bean.commonMethod();     } }  public class ClassOne extends AbstractClass&lt;BeanOne&gt; {      public ClassOne(BeanOne bean) {         super(bean);     }      public void methodclassOne() {         bean.methodBeanOne();     } }  public class ClassTwo extends AbstractClass&lt;BeanTwo&gt; {      public ClassTwo(BeanTwo bean) {         super(bean);     }      public void methodClassTwo() {         bean.methodBeanTwo();     } } </code></pre>  <p>So far, so good.</p>  <p>The next step would be to create a factory to get one implementation based on an <code>enum</code> for instance, and here is where I start getting errors:</p>  <pre><code>public class ClassFactory {      public enum MyEnum {         ONE, TWO;     }      private ClassFactory() {     }      public static AbstractClass newInstance(MyEnum value, AbstractBean bean) {         switch(value){         case ONE:             return new ClassOne(bean);         case TWO:             return new ClassTwo(bean);         default:             throw new IllegalArgumentException();         }     } } </code></pre>  <p>This gives the following compilation errors:</p>  <pre><code>The constructor ClassOne(AbstractBean) is undefined The constructor ClassTwo(AbstractBean) is undefined </code></pre>  <p>I've also tried:</p>  <pre><code>public class ClassFactory {      public enum MyEnum {         ONE, TWO;     }      private ClassFactory() {     }      public static &lt;T extends AbstractBean&gt; AbstractClass&lt;T&gt; newInstance(MyEnum value, T bean) {         switch(value){         case ONE:             return new ClassOne(bean);         case TWO:             return new ClassTwo(bean);         default:             throw new IllegalArgumentException();         }     } } </code></pre>  <p>But then I get:</p>  <pre><code>Type mismatch: cannot convert from ClassOne to AbstractClass&lt;T&gt; Type mismatch: cannot convert from ClassTwo to AbstractClass&lt;T&gt; </code></pre>  <p>And I'm pretty much stuck there. I think I understand this error, but then, is it possible to create such a factory class <strong>trying to avoid castings</strong>?</p>  <p>I've also checked <a href="http://stackoverflow.com/questions/12628251/java-factory-pattern-with-generics">this post</a>, but can't fully understand how it'd help me.</p>  <p><strong>EDIT: Visitor Pattern</strong></p>  <p>Ok, so I've tried the Visitor Pattern described in the previos post:</p>  <pre><code>public interface Visitor&lt;T&gt; {     T visit(BeanOne bean);      T visit(BeanTwo bean); }  public abstract class AbstractBean {     public void commonMethod() {         // ...     }      public abstract &lt;T&gt; T accept(Visitor&lt;T&gt; visitor); }  public class BeanOne extends AbstractBean {     public void methodBeanOne() {         // ...     }      @Override     public &lt;T&gt; T accept(Visitor&lt;T&gt; visitor) {         return visitor.visit(this);     } }  public class BeanTwo extends AbstractBean {     public void methodBeanTwo() {         // ...     }      @Override     public &lt;T&gt; T accept(Visitor&lt;T&gt; visitor) {         return visitor.visit(this);     } }  public class ClassFactory {     private ClassFactory() {     }      public static AbstractClass&lt;? extends AbstractBean&gt; newInstance(AbstractBean bean) {         return bean.accept(new AbstractClassVisitor());     } }  public class AbstractClassVisitor implements Visitor&lt;AbstractClass&lt;? extends AbstractBean&gt;&gt; {      @Override     public AbstractClass&lt;? extends AbstractBean&gt; visit(BeanOne bean) {         return ClassFactory.newInstance(bean);     }      @Override     public AbstractClass&lt;? extends AbstractBean&gt; visit(BeanTwo bean) {         return ClassFactory.newInstance(bean);     } } </code></pre>  <p>But using it like this:</p>  <pre><code>AbstractBean bean = new BeanOne(); AbstractClass&lt;? extends AbstractBean&gt; clazz = ClassFactory.newInstance(bean); clazz.commonClassMethod(); </code></pre>  <p>I'm getting the following exception:</p>  <pre><code>Exception in thread "main" java.lang.StackOverflowError     at test.AbstractClassVisitor.&lt;init&gt;(AbstractClassVisitor.java:3)     at test.ClassFactory.newInstance(ClassFactory.java:9)     at test.AbstractClassVisitor.visit(AbstractClassVisitor.java:7)     at test.AbstractClassVisitor.visit(AbstractClassVisitor.java:1)     at test.BeanOne.accept(BeanOne.java:10)     at test.ClassFactory.newInstance(ClassFactory.java:9)     at test.AbstractClassVisitor.visit(AbstractClassVisitor.java:7)     at test.AbstractClassVisitor.visit(AbstractClassVisitor.java:1)     at test.BeanOne.accept(BeanOne.java:10)     at test.ClassFactory.newInstance(ClassFactory.java:9)     at test.AbstractClassVisitor.visit(AbstractClassVisitor.java:7)     at test.AbstractClassVisitor.visit(AbstractClassVisitor.java:1)     at test.BeanOne.accept(BeanOne.java:10)     ... </code></pre>  <p>I can see why this is happening, am I missing something?</p>