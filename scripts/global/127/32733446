<p>I'm new to GTK, and I'm having trouble with something that should be considered elemental. I'm working in C. Not C++, but C. I can't find out how to allow widgets to dynamically resize, in both horizontal and vertical, when a user maximizes or resizes a window.  I tried with vboxes, and now I've tried with tables, but I can't get it working.</p>  <p>Here's my code, sorry it's a little long, just look for stuff relating to tables. This draws the entire base GUI.</p>  <p>I don't want to use gtk_widget_set_size_request() because that disallows resize. Is there an event I should be catching when a window resizes, and if so, what do I have the code do upon receiving the event? `</p>  <pre><code>GtkWidget *GUI_InitGUI() {     GtkWidget *Win = GuiInfo.Win = gtk_window_new(GTK_WINDOW_TOPLEVEL);     GUI_LoadIcon();      //Connect the destroy signal to allow quitting when we close the window.     g_signal_connect(G_OBJECT(Win), "destroy", G_CALLBACK(GTK_Destroy), NULL);      //Window title     gtk_window_set_title(GTK_WINDOW(Win), "WZBlue");      gtk_widget_set_size_request(Win, -1, -1);      //gtk_window_set_resizable((GtkWindow*)Win, false);      //Create the main vertical box.     GtkWidget *Table = GuiInfo.Table = gtk_table_new(6, 4, FALSE);      //Create a scrolled window.     GtkWidget *ScrolledWindow = GuiInfo.ScrolledWindow = gtk_scrolled_window_new(NULL, NULL);     gtk_scrolled_window_set_policy((GtkScrolledWindow*)ScrolledWindow, GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);      //gtk_widget_set_size_request(ScrolledWindow, 800, 400);     gtk_container_set_border_width((GtkContainer*)ScrolledWindow, 5);       ///Add to the main vertical box.     GUI_DrawMenus();     gtk_table_attach((GtkTable*)Table, ScrolledWindow, 0, 6, 1, 4, GTK_FILL, GTK_FILL, 0, 0);       //Status bar     GtkWidget *StatusBar = GuiInfo.StatusBar = gtk_statusbar_new();     GuiInfo.StatusBarContextID = gtk_statusbar_get_context_id((GtkStatusbar*)StatusBar, "global");       //Mostly here because I wanna make sure it works     GUI_SetStatusBar(NULL);      //The refresh button, aligned to the right.     GtkWidget *Align = gtk_alignment_new(0.0, 0.5, 0.5, 0.01);     GtkWidget *Button1 = gtk_button_new_from_stock(GTK_STOCK_REFRESH);     GtkWidget *Button2 = gtk_button_new_with_mnemonic("H_ost Game");     GtkWidget *B2Image = gtk_image_new_from_stock(GTK_STOCK_NETWORK, GTK_ICON_SIZE_BUTTON);      gtk_button_set_image((GtkButton*)Button2, (void*)B2Image);      //The refresh delay slider     GtkWidget *RefreshSlider = GuiInfo.Slider = gtk_hscale_new_with_range(5.0, 120.0, 1.0);     gtk_scale_set_digits((GtkScale*)RefreshSlider, 0);     gtk_scale_set_value_pos((GtkScale*)RefreshSlider, GTK_POS_LEFT);     gtk_range_set_value((GtkRange*)RefreshSlider, RefreshRate);      GtkWidget *HBox = gtk_hbox_new(FALSE, 4);      //Baby vbox     GtkWidget *BabyVBox = gtk_vbox_new(FALSE, 3);     GtkWidget *BabyLabel = gtk_label_new("Auto-Refresh delay in seconds");     GtkWidget *BabySep = gtk_hseparator_new();      gtk_box_pack_start((GtkBox*)BabyVBox, RefreshSlider, FALSE, FALSE, 0);     gtk_box_pack_start((GtkBox*)BabyVBox, BabySep, FALSE, FALSE, 0);     gtk_box_pack_start((GtkBox*)BabyVBox, BabyLabel, FALSE, FALSE, 0);       gtk_box_pack_start((GtkBox*)HBox, Button1, FALSE, FALSE, 0);     gtk_box_pack_start((GtkBox*)HBox, Button2, FALSE, FALSE, 0);     gtk_box_pack_start((GtkBox*)HBox, BabyVBox, TRUE, TRUE, 0);      gtk_container_add((GtkContainer*)Align, HBox);      g_signal_connect_swapped(G_OBJECT(Button1), "clicked", (GCallback)Main_LoopFunc, &amp;False);     g_signal_connect_swapped(G_OBJECT(Button2), "clicked", (GCallback)GUI_LaunchGame, NULL);      gtk_table_attach((GtkTable*)Table, Align, 0, 3, 4, 5, GTK_FILL, GTK_SHRINK, 0, 0);     gtk_table_attach((GtkTable*)Table, StatusBar, 0, 6, 5, 6, GTK_FILL, GTK_SHRINK, 0, 0);      gtk_container_add((GtkContainer*)Win, Table);     gtk_widget_show_all(Win);     return ScrolledWindow; } </code></pre>  <p>`</p>