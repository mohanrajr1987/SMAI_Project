<p>I have a WPF window that needs to react to <code>SizeChanged</code> events. However, it should only perform processing when there are no further <code>SizeChanged</code> events for a 500â€¯ms period (similar to the behaviour offered by <a href="https://msdn.microsoft.com/en-us/library/system.windows.data.bindingbase.delay%28v=vs.110%29.aspx" rel="nofollow"><code>BindingBase.Delay</code></a>).</p>  <pre><code>private CancellationTokenSource lastCts;  private async void Window_SizeChanged(object sender, SizeChangedEventArgs e) {     if (lastCts != null)         lastCts.Cancel();     lastCts = new CancellationTokenSource();      try     {         await Task.Delay(500, lastCts.Token);     }     catch (OperationCanceledException)     {         return;     }      myTextBox.Text = string.Format("({0}, {1})", this.Width, this.Height);             } </code></pre>  <p>However, I have noticed that, when compiled as x64 under Debug mode, this code causes to UI to start lagging when being resized; there are perceptible delays in the window getting redrawn. I assume that this is due to the <code>OperationCanceledException</code> getting serialized, thrown, and caught on the UI thread. The code below eliminates the problem:</p>  <pre><code>    Task.Delay(500, lastCts.Token).ContinueWith(         _ =&gt;         {             myTextBox.Text = string.Format("({0},{1})", this.Width, this.Height);         },         lastCts.Token,         TaskContinuationOptions.NotOnCanceled,         TaskScheduler.FromCurrentSynchronizationContext()); </code></pre>  <p>My question is: Is there a clean way of configuring an async method to only resume processing on the UI thread if the awaited task wasn't cancelled? Or is this one of the border cases where, due to the frequency of the <code>SizeChanged</code> events, we should not use await, but revert to the old <code>ContinueWith</code> pattern which affords more control (like <code>TaskContinuationOptions.NotOnCanceled</code>)?</p>