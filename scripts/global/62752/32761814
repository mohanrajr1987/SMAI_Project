<p>In short, I have a Task enumerable, and I would like to run each Task within the array in an <em>await</em> fashion. Each Task will perform a slow network operation and from my end I simply need to update the WinForm UI once the task is finished.</p>  <p>Below is the code I'm currently using, however I think this is more of a hack than an actual solution:</p>  <pre><code>private void btnCheckCredentials_Click(object sender, EventArgs e) {     // GetNetCredentials() is irrelevant to the question...     List&lt;NetworkCredential&gt; netCredentials = GetNetCredentials();      // This call is not awaited. Displays warning!     netCredentials.ForEach(nc =&gt; AwaitTask(ValidateCredentials(nc))); }  public async Task&lt;bool&gt; ValidateCredentials(NetworkCredential netCredential) {     // Network-reliant, slow code here... }  public async Task AwaitTask(Task&lt;bool&gt; task) {     await task;      // Dumbed-down version of displaying the task results     txtResults.Text += task.Result.ToString(); } </code></pre>  <p>2nd line of btnCheckCredentials_Click() warning is shown:</p>  <blockquote>   <p>Because this call is not awaited, execution of the current method continues before the call is completed. Consider applying the 'await' operator to the result of the call.</p> </blockquote>  <p>This actually works the way I wanted to, since I do not want to wait for the operation to complete. Instead I just want to fire away the tasks, and then do something as soon as each one of them finishes.</p>  <p>The Task.WhenAny() or Task.WhenAll() methods do function as I expect, since I would like to know of every task finishing - as soon as it finishes. Task.WaitAll() or Task.WaitAny() are blocking and therefore undesirable as well.</p>  <p><strong>Edit:</strong> All tasks should start simultaneously. They may then finish in any order.</p>