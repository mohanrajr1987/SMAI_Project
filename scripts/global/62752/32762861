<h2>Situation</h2>  <p>I have a raspberry pi set up as a server taking json via HTTP as input. The "API" allows to set leds connected to the pi. That all works, I can send requests from the browser and everything is great.</p>  <p>It takes a while for the response to arrive. That's why I want to communicate asynchrounously.</p>  <p><a href="https://msdn.microsoft.com/en-us/library/hh191443.aspx" rel="nofollow">I found this on msdn that explains how it's done.</a></p>  <blockquote> <pre><code>// Three things to note in the signature: //  - The method has an async modifier.  //  - The return type is Task or Task&lt;T&gt;. (See "Return Types" section.) //    Here, it is Task&lt;int&gt; because the return statement returns an integer. //  - The method name ends in "Async." async Task&lt;int&gt; AccessTheWebAsync() {      // You need to add a reference to System.Net.Http to declare client.     HttpClient client = new HttpClient();      // GetStringAsync returns a Task&lt;string&gt;. That means that when you await the     // task you'll get a string (urlContents).     Task&lt;string&gt; getStringTask = client.GetStringAsync("http://msdn.microsoft.com");      // You can do work here that doesn't rely on the string from GetStringAsync.     DoIndependentWork();      // The await operator suspends AccessTheWebAsync.     //  - AccessTheWebAsync can't continue until getStringTask is complete.     //  - Meanwhile, control returns to the caller of AccessTheWebAsync.     //  - Control resumes here when getStringTask is complete.      //  - The await operator then retrieves the string result from getStringTask.     string urlContents = await getStringTask;      // The return statement specifies an integer result.     // Any methods that are awaiting AccessTheWebAsync retrieve the length value.     return urlContents.Length; } </code></pre> </blockquote>  <p>For the top level overview, here's how my Main method looks like (it doesn't compile):</p>  <pre><code>var pi1 = new RaspberryPi(@"http://192.168.0.100:8080");    // specify IP var led = new Led(255, 100, 180);                           // r, g, b values wrapped in an Led object  Led result = await pi1.setLedAsync(2, led);      // FAIL    // what should be an async POST, awaiting the response </code></pre>  <p>I hope that makes sense. </p>  <p>The <code>Led</code> class is just a data object holding 3 <code>byte</code>s for the 3 channels and some conversion methods to and from json.</p>  <p>The <code>setLedAsync</code> method:</p>  <pre><code>async public Task&lt;Led&gt; setLedAsync(uint n, Led led) {     var client = new HttpClient();     client.BaseAddress = _uri;      var content = new StringContent(led.ToJson(), Encoding.UTF8, "application/json");      Task&lt;HttpResponseMessage&gt; response = client.PutAsync("/led/" + n, content);     HttpResponseMessage responseMessage = await response;      string json = await responseMessage.Content.ReadAsStringAsync();      return new Led(json); } </code></pre>  <h2>Error</h2>  <p>This line is where I get an error for using <code>await</code>:</p>  <pre><code>Led result = await pi1.setLedAsync(2, led); </code></pre>  <p><code>await</code> can only be used in an <code>async</code> method.</p>  <h2>Questions</h2>  <ol> <li><p>Why do I get this error? The last comment line in the example code</p>  <blockquote>   <p>// Any methods that are awaiting AccessTheWebAsync retrieve the length value.</p> </blockquote>  <p>makes me think that this is how it should be done. As I understand it, the <code>await</code> basically unwrapps the <code>Task&lt;T&gt;</code> into a <code>T</code>.</p>  <p>If I do not use <code>await</code>, I get a type missmatch, because the method returns <code>Task&lt;Led&gt;</code>, not <code>Led</code>.</p></li> <li><p>What's confusing for me is to understand the difference between the example and my situation. I have to use <code>await</code> twice in my <code>async</code> method:</p>  <ul> <li><code>HttpResponseMessage responseMessage = await response;</code></li> <li><code>string json = await responseMessage.Content.ReadAsStringAsync();</code></li> </ul>  <p>The thing is that I have to deal with this <code>HttpResponseMessage</code> as a middleman. I suspect that I'm prematurely giving up the asynchronousity with this second await somehow (if that makes any sense) I think this is the origin of the problem, but I'm not sure how to solve it.</p></li> </ol>  <h2>Edit</h2>  <p>I wrapped the function call in an asyn method, which allows to compile the code. But it's not asynchronous. I added a delay on the server side to test this.</p>  <pre><code>class Program {     static void Main(string[] args)     {         var prog = new Program();         Console.WriteLine("before init");         prog.init();         Console.WriteLine("after init");   // not happening before the response arrives         Console.Read();     }      private async void init()     {         var pi1 = new RaspberryPi(@"http://192.168.0.100:8080");    // specify IP         var led = new Led(255, 0, 0);                               // r, g, b values wrapped in an Led object         Console.WriteLine("before await");         Led result = await pi1.setLedAsync(2, led);                 // what should be an async POST, awaiting the response         Console.WriteLine("after await");     } } </code></pre>  <p>None of the "after" messages are written to the console before the response from the request arrives.</p>