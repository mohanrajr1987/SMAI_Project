<p>I am writing a game, and using OpenGL I require that some work be offloaded to the rendering thread where an OpenGL context is active, but everything else is handled by the normal thread pool.</p>  <p>Is there a way I can force a Task to be executed in a special thread-pool, and any new tasks created from an <code>async</code> also be dispatched to that thread pool?</p>  <p>I want a few specialized threads for rendering, and I would like to be able to use <code>async</code> and <code>await</code> for example for creating and filling a vertex buffer.</p>  <p>If I just use a custom task scheduler and a <code>new Factory(new MyScheduler())</code> it seems that any subsequent <code>Task</code> objects will be dispatched to the thread pool anyway where <code>Task.Factory.Scheduler</code> suddenly is <code>null</code>.</p>  <p>The following code should show what I want to be able to do:</p>  <pre><code>public async Task Initialize() {     // The two following tasks should run on the rendering thread pool     // They cannot run synchronously because that will cause them to fail.     this.VertexBuffer = await CreateVertexBuffer();     this.IndexBuffer = await CreateIndexBuffer();      // This should be dispatched, or run synchrounousyly, on the normal thread pool     Vertex[] vertices = CreateVertices();     // Issue task for filling vertex buffer on rendering thread pool     var fillVertexBufferTask = FillVertexBufffer(vertices, this.VertexBuffer);      // This should be dispatched, or run synchrounousyly, on the normal thread pool     short[] indices = CreateIndices();      // Wait for tasks on the rendering thread pool to complete.     await FillIndexBuffer(indices, this.IndexBuffer);     await fillVertexBufferTask; // Wait for the rendering task to complete. } </code></pre>  <p>Is there any way to achieve this, or is it outside the scope of <code>async</code>/<code>await</code>?</p>