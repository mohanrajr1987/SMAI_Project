<p>With late static binding in PHP v5.3, one can usefully declare <code>static</code> methods in interfaces; with traits in PHP v5.4, methods can be either <code>static</code> or <code>abstract</code> but not both.  This appears to be illogical and inconsistent.</p>  <p>In particular, suppose one has an interface for which a trait provides all implementation, except for a static method; unless that method is declared in the trait, static analysers balk at any references thereto from within the trait.  But providing a concrete implementation within the trait no longer forces implementing/using classes to provide their own implementationâ€”which is dangerous; <code>abstract static</code> would be ideal, but is not allowed.</p>  <p>What is the explanation for this contradiction?  How would you recommend resolving this problem?</p>  <pre><code>interface MyInterface {     public static function getSetting();     public function doSomethingWithSetting(); }  trait MyTrait {     public abstract static function getSetting(); // I want this...      public function doSomethingWithSetting() {         $setting = static::getSetting(); // ...so that I can do this         /* ... */     } }  class MyClass implements MyInterface {     use MyTrait;     public static function getSetting() { return /* ... */ } } </code></pre>