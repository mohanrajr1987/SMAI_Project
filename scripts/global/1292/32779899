<p>I have a crash problem with my Visual C++ program (VC11) when it tries access a static variable which is returned by a virtual function.</p>  <p>in .h file: (detail skipped)</p>  <pre><code>class BaseAggregateFunction  {   public:     static const ClassHandle handle;     virtual const ClassHandle&amp; GetClassHandle() const { return handle; } }; class RowAggregateFunction : public BaseAggregateFunction {   public:     static const ClassHandle handle;     virtual const ClassHandle&amp; GetClassHandle() const { return handle; } }; class RowSum : public RowAggregateFunction {   public:     static const ClassHandle handle;     virtual const ClassHandle&amp; GetClassHandle() const { return handle; } }; </code></pre>  <p>(There are a bunch of similar classes)</p>  <p>and in .c file the static members are initialized</p>  <pre><code>const ClassHandle BaseAggregateFunction::handle("BaseAggregateFunction"); const ClassHandle RowAggregateFunction::handle("RowAggregateFunction", BaseAggregateFunction::handle); const ClassHandle RowSum::handle("RowSum", RowAggregateFunction::handle); </code></pre>  <p>And now there are cases to new a</p>  <pre><code>BaseAggregateFunction&amp; f = new RowSum(...); const ClassHandle&amp; h = f.GetClassHandle(); Logger::Instance() &lt;&lt; LogHeader &lt;&lt; MsgClass(MsgClass::Information)   &lt;&lt; "Function is a " &lt;&lt; h.Name() &lt;&lt; EndMsg; </code></pre>  <p>And in the crash dump file I see h address is 0x000005, which of course is not accessible! How can a virtual class return an invalid variable? It is suppose to be static! What could be the case? How can I fix it?</p>  <p>BTW, this program runs same logic thousands times one day, it crashes in the middle of the day.</p>  <p>I added logs to trace and see f is created and deleted several times. This is normal. When problem happens, same memory address is new'd to f, but with a different type -- could that be a problem?</p>  <p>Please help me, thanks.</p>