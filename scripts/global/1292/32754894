<p>What is the best way to declare global instances of a function object so I can import and use the instances as callables throughout my program?</p>  <p>Specifically, I have created a template class which serves as a custom deleter for a shared pointer. Several pointer types in a third party library need to be deleted with a "Free" function that takes a reference to the pointer. An instance of the class is instantiated with the type of the pointer to delete, and a pointer to a function with the signature of the Free function.  I am declaring the instances as const because there is no need for the member function pointer to ever change.</p>  <pre><code>template &lt;class T&gt; class Deleter { public:   typedef typename bool(CALLING_CONVENTION *DeleterFunc)(T**);   Deleter(DeleterFunc deleter) : deleter_(deleter) {}   void operator() (T* t) { if (t) { deleter_(&amp;t) }  private:   DeleterFunc deleter_; };  static const Deleter&lt;I_x&gt; x_deleter(FreeXInterface); </code></pre>  <p>My first attempt was a create instances for each of the pointer types in the .h file, but this resulted in multiply defined symbols if I include this header file in other code.  So I changed the declaration of the instances to "static" and this compiles and seems to work fine, but I have seen warnings that this is not a good idea (especially if the objects belong to a namespace) because static is causing the linkage to be file-only, and that each compilation unit will have its own copy.</p>  <p>My question is does this matter if I don't really care if they are the same instance between files? I am not using this as global data, and the function objects don't really have any state. Would I have any concerns about threading if these objects are declared static? Is there a better way to implement this without using the static keyword?</p>