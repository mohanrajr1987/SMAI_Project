<p><strong><em>Rewrite template classes to use inheritance without changing the calling environment which required a static function call, but static functions can't be virtual.</em></strong></p>  <p>I have came across this question from a C++ coding test. Actually, this question is not stated so clearly and I haven't got the solution so far. Sorry for any ambiguity. To help anyone better understand this question. The following is my personal interpretation. <strong><em>Welcome to point out my misunderstanding.</em></strong></p>  <p>This template class is an encapsulated library in server side, some APIs such as  static function is called in client side. However, static function cannot be virutal. In other words, <strong><em>no dynamic bounding(overriding) is allowed for static function.</em></strong></p>  <ol> <li><p>Try to rewrite a template class, and this class uses inheritance. So this class has a derived class. But We don't want to change the API calling environment. In other words, we plan to upgrade the code in server side, but we don't want to any code change in client side.</p></li> <li><p>Try to use inheritance, to rewrite a tempalte class. But We don't want to change the API calling environment. In other words, we plan to upgrade the code in server side, but we don't want to any code change in client side.</p></li> </ol>  <p>I am not sure whether 1 or 2 is the correct interpretation. But I more incline to 1. In my opinion, this quesion mainly test the concept of </p>  <ol> <li>Code maintenance in server side</li> <li>Design pattern, mainly for factory method</li> <li>Any trick to overide static function in class inheritance</li> </ol>  <p><strong>The original code in server side:</strong></p>  <pre><code>#include&lt;iostream&gt;  using namespace std;  template&lt;class T&gt; class Base {     public:         Base(){}         Base(T B):m_B(B){}         virtual ~Base(){}          // Static method         static void speak()         {             cout &lt;&lt; "I am Base class" &lt;&lt; endl;         }      private:         T m_B;  };   template&lt;class T&gt; class Derived: public Base&lt;T&gt; {     public:         Derived(){}         Derived(T B, T D): Base&lt;T&gt;(B), m_D(D){}         ~Derived(){}          // Static method         static void speak()         {             cout &lt;&lt; "I am Derived class" &lt;&lt; endl;         }      private:         T m_D;  }; </code></pre>  <p><strong>The calling environment in client side:</strong></p>  <pre><code>int main(int argc, char* argv[]) {     Base&lt;int&gt; *bPtr = new Derived&lt;int&gt;(5, 10);     bPtr-&gt;speak();     delete bPtr;     return 0; } </code></pre>  <p><strong>Output:</strong></p>  <p><strong>I am Base class</strong></p>  <p>(obviously no overrding for static function)</p>  <p>////////////////////////////////////////////////////////////////////////////////</p>  <p><strong>My rewrote code in server side:</strong></p>  <pre><code>#include&lt;iostream&gt;  using namespace std;  template&lt;class T&gt; class Base {     public:         Base(){}         Base(T B):m_B(B){}         virtual ~Base(){}          // Static method         static void speak()         {             cout &lt;&lt; "I am Base class" &lt;&lt; endl;         }         // Non-static method         virtual void call_speak()         {             speak();             }        private:         T m_B;  };   template&lt;class T&gt; class Derived: public Base&lt;T&gt; {     public:         Derived(){}         Derived(T B, T D): Base&lt;T&gt;(B), m_D(D){}         ~Derived(){}          // Static method         static void speak()         {             cout &lt;&lt; "I am Derived class" &lt;&lt; endl;         }         // Non-static method         void call_speak()         {             speak();             }        private:         T m_D;  };  template&lt;class T&gt; class Factory {     public:         // Return a base instance         static Base&lt;T&gt;* getInstance(T B)         {             Base&lt;T&gt; *bPtr = new Base&lt;T&gt;(B);             return bPtr;         }          // Return a derived instance         static Base&lt;T&gt;* getInstance(T B, T D)         {             Base&lt;T&gt; *bPtr = new Derived&lt;T&gt;(B, D);             return bPtr;         } }; </code></pre>  <p><strong>The calling environment in client side:</strong></p>  <pre><code>int main(int argc, char* argv[]) {     Base&lt;int&gt; *bPtr = Factory&lt;int&gt;::getInstance(5, 10);     bPtr-&gt;speak();     bPtr-&gt;call_speak();     delete bPtr;     return 0; } </code></pre>  <p><strong>Output:</strong></p>  <p><strong>I am Base class</strong></p>  <p><strong>I am Derived class</strong></p>  <p><strong>My modification:</strong></p>  <ol> <li>To "override" a static function, I add a virutal to call the static function as a trick.</li> <li>I use factory method to hide the instance creation from the client side. </li> </ol>  <p>But I am not sure such modificaiton can meet the requirement for not changing the calling environment. <strong>Because I do change the API call in client side. Based on my effort, that is my best sollution. Greatly appreciate any comment and improvement.</strong> </p>