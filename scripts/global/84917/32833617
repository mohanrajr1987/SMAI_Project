<p>I am having trouble implementing my pipe. It reads Unix terminal commands from a text file for commands such as "ls|wc" where it opens a pipe so that the output of ls can be used for wc.</p>  <p>I have implemented it to parse program names ("ls", "wc") and store them in two separate arrays (arguments and arguments2), fork a child process, then have that child fork another child process, then the second child process calls the execvp() command and passes the first program to be executed.</p>  <p>The output from ("ls") is then written to the pipe by changing the standard output. The former child process then execvp()'s the other process ("wc") and reads from the pipe by changing the standard input.</p>  <p>However, wc loops indefinitely and does not seem to count the number of words from ls. Ls executes in a directory where there are words to be counted.</p>  <p>Any tips? Thank you so much and sorry for the long explanation. </p>  <p>Here is a simpler example: It forks, creates a pipe, and implements "ls" and writes its output to the pipe, goes back to the parent and reads from the pipe the output of "ls". It still seems to be reading forever or not working right.</p>  <pre><code>// //  main.cpp //  Pipe_Test // //  Created by Dillon Sheffield on 9/28/15. //  Copyright © 2015 Dillon Sheffield. All rights reserved. //  #include &lt;iostream&gt; using namespace std;  int main() {     char* arguments[2];     char* programArguments[1];     int fd[2];      arguments[0] = new char[2];     arguments[1] = new char[2];     programArguments[0] = new char[1];     programArguments[0][0] = '\0';     string ls = "ls";     string wc = "wc";     for (int i = 0; i &lt; 1; i++) {         arguments[0] = &amp;ls.at(i);         arguments[1] = &amp;wc.at(i);     }      pid_t pid = fork();     pipe(fd);      if (pid &lt; 0) {         perror("Failed.\n");     } else if (pid == 0) {         dup2(fd[1], STDOUT_FILENO);          execvp(arguments[0], programArguments);     }      wait(NULL);      dup2(fd[0], STDIN_FILENO);     execvp(arguments[1], programArguments);      close(0);     close(1);      return 0; } </code></pre>  <p>Here is my original code:</p>  <pre><code>// //  main.cpp //  homework2 // //  Created by Dillon Sheffield on 9/19/15. //  Copyright © 2015 Dillon Sheffield. All rights reserved. //  #include &lt;iostream&gt; #include &lt;fstream&gt; #include &lt;stdio.h&gt; #include &lt;sys/types.h&gt; #include &lt;unistd.h&gt; using namespace std;  // Global Variable(s) const short inputLineSize = 10; // Size of programName, arguments, and argument name. char *arguments[inputLineSize]; char *arguments2[inputLineSize]; ifstream inputFile; char* input;  void readLine() {     // Create new char array(s)     input = new char[inputLineSize];      // Initialize the char array(s)     for (int i = 0; i &lt; inputLineSize; i++)     {         input[i] = '\0';     }      // Read a line and skip tabs, spaces, and new line characters     for (int i = 0; !inputFile.eof() &amp;&amp; inputFile.peek() != '\n'; i++)     {         while (inputFile.peek() == '\n' || inputFile.peek() == '\t' || inputFile.peek() == ' ') inputFile.get();         inputFile.get(input[i]);     }      // If the file is multi-spaced, keep reading new line char(s) to clear them     while (inputFile.peek() == '\n') inputFile.get(); }  void parseTokens() {     //----------Parse the read line into tokens--------------------------------------------//      // Get the program name     for (int i = 0; i &lt; inputLineSize; i++)     {         arguments[i] = new char[inputLineSize];         for (int j = 0; j &lt; inputLineSize; j++)             arguments[i][j] = '\0';     }      int i = 0;     int j = 0;     while (input[i] != '\0' &amp;&amp; input[i] != '-' &amp;&amp; input[i] != '|')     {         arguments[j][i] = input[i];         i++;     }      // Tokenize arguments if supplied     j++;     int k;     while (input[i] == '-')     {         k = 0;         arguments[j][k] = input[i];         i++;         k++;          while (input[i] != '-' &amp;&amp; input[i] != '\0')         {             arguments[j][k] = input[i];             i++;             k++;         }         j++;     }      // Delete unused arguments     while (j &lt; inputLineSize)     {         delete arguments[j];         arguments[j] = NULL;         j++;     }      // Check if the pipe command '|' is supplied     if (input[i] == '|')     {         i++;          // Get the other program name         for (int x = 0; x &lt; inputLineSize; x++)         {             arguments2[x] = new char[inputLineSize];             for (int y = 0; y &lt; inputLineSize; y++)                 arguments2[x][y] = '\0';         }          int x = 0;         int j = 0;         while (input[i] != '\0' &amp;&amp; input[i] != '-' &amp;&amp; input[i] != '|')         {             arguments2[j][x] = input[i];             i++;             x++;         }          // Tokenize arguments if supplied         j++;         int k;         while (input[i] == '-')         {             k = 0;             arguments2[j][k] = input[i];             i++;             k++;              while (input[i] != '-' &amp;&amp; input[i] != '\0')             {                 arguments2[j][k] = input[i];                 i++;                 k++;             }             j++;         }          // Delete unused arguments         while (j &lt; inputLineSize)         {             delete arguments2[j];             arguments2[j] = NULL;             j++;         }     } }  int main() {     // Variable(s)     pid_t pid;     pid_t pid2;     int fd[2];  //--Open the file named "input"-------------------------------------------------------//      inputFile.open("input", ios::in);      // Check if opening the file was successful     if (inputFile.is_open())     {         // Read until the file has reached the end         while (!inputFile.eof())         {             // Read a line and parse tokens             readLine();             parseTokens();  //----------Now create a new process with parsed Program Name and Arguments-----------//              // Create a pipe             pipe(fd);              // Fork             pid = fork();             if (pid &lt; 0)             {                 perror("Fork failed.\n");                 return -2;             }             else if (pid == 0)             {                 // Fork again                 pid2 = fork();                  if (pid2 &lt; 0)                 {                     perror("Fork failed.\n");                     return -2;                 }                 else if (pid2 == 0)                 {                     // Change standard output                     if (dup2(fd[1], STDOUT_FILENO) != STDOUT_FILENO) perror("dup2 error to stdout.\n");                      // Execute the given program                     execvp(arguments[0], arguments);                 }                   // Change the standard input to the pipe                 if (dup2(fd[0], STDIN_FILENO) != STDIN_FILENO) perror("dup2 error to stdin.\n");                  int returnValue = execvp(arguments2[0], arguments2);                 if (returnValue == -1) perror("Error has occurred.\n");                  // Close the pipe and exit                 close(fd[0]);                 close(fd[1]);                 exit(0);             }              // Wait for the child so it doesn't become a Zombie             wait(NULL);   //----------Clean up-----------------------------------------------------------------//             delete input;             input = NULL;             int i = 0;             while (arguments[i] != NULL)             {                 delete arguments[i];                 arguments[i] = NULL;                 i++;             }             i = 0;         }     }     else perror("Cannot open file.\n");      inputFile.close();     return 0; } </code></pre>