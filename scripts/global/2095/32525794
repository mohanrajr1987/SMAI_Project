<p>I have a class which represent a generic filter expression</p>  <pre><code>public class SimpleFilter : BaseRuleExpression {     public string field { get; set; }      public string op { get; set; }      public string data { get; set; } } </code></pre>  <p>When I need to apply a filter on a IQueryable I simply convert this filter to a LambdaExpression object and apply this filter to a DbSet instance like in the following example</p>  <pre><code>var filter = new SimpleFilter() {     field = "CustomerID",     op = "eq",     value = "1" }; ParameterExpression pe = Expression.Parameter( typeof( Customer ), "x" ); IQueryable&lt;Customer&gt; query = _ctx.Customers.AsQueryable&lt;Customer&gt;(); Expression&lt;Func&lt;Customer, bool&gt;&gt; lambda = (Expression&lt;Func&lt;Customer, bool&gt;&gt;)filter.ToExpression( query, pe ); var cList = _ctx.Customers.AsQueryable&lt;Customer&gt;().Where( lambda ) </code></pre>  <p>The <code>ToExpression</code> method is as follow:</p>  <pre><code>MemberExpression memberAccess = GetMemberExpression( field, pe ); ConstantExpression filter = Expression.Constant( Convert.ChangeType( data, memberAccess.Type ) ); Operator condition = (Operator)StringEnum.Parse( typeof( Operator ), op ); LambdaExpression lambda = BuildLambdaExpression( memberAccess, filter, pe, condition, data ); </code></pre>  <p>The problem happens on the following line because the <code>Convert.ChangeType</code> method has no direct conversion between <code>string</code> and <code>enum</code>. </p>  <pre><code>ConstantExpression filter = Expression.Constant( Convert.ChangeType( data, memberAccess.Type ) ); </code></pre>  <p>How can I solve this problem? Can I check for type enum in target and eventually convert first the <code>string</code> in <code>int</code>?</p>