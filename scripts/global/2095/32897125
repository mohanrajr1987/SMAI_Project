<p>I currently rely quite heavily on the springframework.net port ( c# ) to evaluate expressions. It works fantastically well and am very happy with it, except for 1 small oversight, I can't seem to find any examples / documentation regarding evaluating boolean conditions with nested parentheses. Here is an example from the documentation </p>  <pre><code>// AND bool falseValue = (bool) ExpressionEvaluator.GetValue(null, "true and false"); //false </code></pre>  <p>Now that is great and works very well, but this fails very badly </p>  <pre><code>// AND bool falseValue = (bool) ExpressionEvaluator.GetValue(null, "((true == true) == true) and false"); //false </code></pre>  <p>that probably makes no sense so here is a more real-world use case </p>  <pre><code>// Operator precedence int minusFortyFive = (int) ExpressionEvaluator.GetValue(null, "(1+(2-3)*(8^2)/2)/2"); //  </code></pre>  <p>As you can see, it's trivial, but it is a use case where you may have nested expressions in parentheses and would expect them to be processed first. The result of executing that code is a very messy antlr runtime exception (TokenMismatchException). </p>  <p>I have written a small recursive method to evaluate these types of expressions from the inside out, but it's messy and I'm embarrassed to post it here ( substrings all over the place ). </p>  <p>So to the question... Is this supported in the expression library and am I just missing something? if not has someone out there solved this problem in a "tre-elegant" way and is willing to share?</p>  <p>Here is my recursive method....</p>  <pre><code>static Regex CONDITION_EXPR_EXTRACTER = new Regex(@"\((?:[^()]|(?&lt;open&gt; \( )|(?&lt;-open&gt; \) ))+(?(open)(?!))\)", RegexOptions.IgnorePatternWhitespace | RegexOptions.Compiled | RegexOptions.CultureInvariant); private static string RecursiveParenthesesProcessor(string Expression)     {         MatchCollection matchCollection = CONDITION_EXPR_EXTRACTER.Matches(Expression);         foreach (Match match in matchCollection)         {             string rawMatch = match.Value.Substring(1, match.ToString().Length - 2);             if (CONDITION_EXPR_EXTRACTER.IsMatch(rawMatch))                 rawMatch = RecursiveParenthesesProcessor(rawMatch);             string result = Spring.Expressions.ExpressionEvaluator.GetValue(null, rawMatch).ToString().ToLower();              int index = Expression.IndexOf(match.Value);             Expression = Expression.Remove(index, match.Length).Insert(index, result);          }         return Expression;     } </code></pre>