<p>I've got a custom type which I use on my repositories that helps me explicitly represent query options, e.g. for sorting, paging etc.</p>  <p>Initially, the interface looked like this:</p>  <pre><code>public class IQueryAction&lt;TEntity&gt; {     IQueryable&lt;TEntity&gt; ApplyTo(IQueryable&lt;T&gt; entitity); } </code></pre>  <p>With that I can represent sorting like this:</p>  <pre><code>public class SortingAction&lt;TEntity, TSortKey&gt; : IQueryAction&lt;TEntity&gt; {     public Func&lt;IQueryable&lt;TEntity&gt;, IOrderedQueryable&lt;TEntity&gt;&gt; SortAction { get; }      public SortingAction(Expression&lt;Func&lt;TEntity, TSortKey&gt;&gt; sortExpression) {         SortAction = q =&gt; q.OrderBy(sortExpression);     }      public IQueryable&lt;TEntity&gt; ApplyTo(IQueryable&lt;TEntity&gt; query) {         return SortAction(query);     }  } </code></pre>  <p>Most of the time I work with Entity Framework, so this is not a problem. However now I need to implement the <code>IQueryAction&lt;'T&gt;</code> model for a data source which doesn't provide a query provider (<code>IQueryProvider</code>). I could now refactor my interface to use <code>IEnumerable&lt;'T&gt;</code> instead of <code>IQueryable&lt;'T&gt;</code> and expect a <code>Func</code> <em>delegate</em> for the key selector instead of a <em>lambda expression</em>. </p>  <p>Now my question is: Would this cause the sort action to be run in memory instead of on the query provider when an <code>IQueryable&lt;'T&gt;</code> is simply being casted to an <code>IEnumerable&lt;'T&gt;</code>? Since I wouldn't pass an <em>expression</em> anymore, but rather a <em>delegate</em>, how could the query provider still know what <em>key</em> I'd like to use for the query? And if that won't work anymore: What could I do to fit both, sorting in memory and on the query provider, depending on the underlying type of <code>IEnumerable&lt;'T&gt;</code>?</p>  <h2>Usage example</h2>  <pre><code>public class MyEntity {     public int    Id   { get; set; }     public string Name { get; set } }  // somewhere in code var orderByName = new SortingAction&lt;MyEntity, string&gt;(x =&gt; x.Name); myEntityRepository.GetAll(orderByName);  // ef repository impl public IEnumerable&lt;TEntity&gt; GetAll(IQueryAction&lt;TEntity&gt; queryAction) {     return queryAction.ApplyTo(dbContext.Set&lt;TEntity&gt;()); // runs on the query provider }  // misc repository impl not supporting IQueryable/IQueryProvider public IEnumerable&lt;TEntity&gt; GetAll(IQueryAction&lt;TEntity&gt; queryAction) {     var result = someProvider.Sql("SELECT *")...     return queryAction.ApplyTo(result); } </code></pre>