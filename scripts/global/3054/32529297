<p>I have a collection of about a dozen structured things of a type I've defined (say <code>Component</code>), each of which can be identified by a "name", and am struggling to sort out an idiomatic Haskell way of instantiating and retrieving them. These things are used frequently in my application, so conceptually they are a set of global constants or a table of constants, that ideally would be initialized and saved for fast retrieval. </p>  <p>My current approach, which I'm uncomfortable with, just uses a function to "compute" each <code>Component</code> from its name. </p>  <pre><code>data Component = Component {                     someData :: !String,                     otherData :: ![Int]                  } deriving Show  component :: Name -&gt; Component component n = case n of     -- about a dozen in the application     "1"       -&gt; Component "lasdkfj;alksdjfalkf" [1]     "Q"       -&gt; Component "nvjufhhqwe" [5,10,11]     "other"   -&gt; Component "ugugugu" []     "A"       -&gt; Component "alkkjsfkjaleifuhqiweufjc" []     "B"       -&gt; Component "randomletters" []     "C"       -&gt; Component "nothingimportant" [9,10]     "b"       -&gt; Component "uk" []     "c"       -&gt; Component "x" [4,2,7,9,0]     ""        -&gt; Component "ABC" []     -- if not listed above, the Component is computed     otherwise -&gt; Component (someFunctionOf n) (someOtherFunctionOf n) </code></pre>  <p>This doesn't feel right to me. For one thing, the <code>Component</code>'s name is really a part of the <code>Component</code>, but isn't included in the type. More importantly, even constant values get computed, when in fact they should just be initialized in some table.</p>  <p>With this in mind I've also tried</p>  <pre><code>type Name = String  import Data.Maybe import Data.Map  data Component = Component {                     name :: Name,                     someDate :: String,                     otherData :: [Int]                  } deriving Show  components = fromList $ (\c -&gt; (name c, c)) &lt;$&gt; [     Component "1" "lasdkfj;alksdjfalkf" [1],     Component "Q" "nvjufhhqwe" [5,10,11],     Component "other" "ugugugu" [],     Component "A" "alkkjsfkjaleifuhqiweufjc" [],     Component "B" "randomletters" [],     Component "C" "nothingimportant" [9,10],     Component "b" "uk" [],     Component "c" "x" [4,2,7,9,0],     Component "" "ABC" []     ]  component :: Name -&gt; Component component n | isNothing c = Component n (someFunctionOf n) (someOtherFunctionOf n)              | otherwise   = fromJust c           where c = Data.Map.lookup n components </code></pre>  <p>This has the advantage of clearly treating the "constant" values as constants, but feels awkward, since it introduces an intermediate value (the <code>Map</code> <code>components</code>) and duplicates the name there (in the <code>Component</code> and as the corresponding key).</p>  <p>Anyway, I feel like I'm going about this all wrong, and that there must be a better way to set up an indexed set of structured values, that include a bunch of constants as well as computed ones.</p>