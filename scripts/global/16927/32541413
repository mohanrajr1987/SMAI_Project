<p>I have a follow-up question for this question: <a href="http://stackoverflow.com/q/29629006/1399395">Groovy XmlSlurper get value of the node without children</a>.</p>  <p>It explains that in order to get the local inner text of a (HTML) node without recursively get the nested text of potential inner child nodes as well, one has to use <code>#localText()</code> instead of <code>#text()</code>.</p>  <p>For instance, a slightly enhanced example from the original question:</p>  <pre><code>&lt;html&gt;     &lt;body&gt;         &lt;div&gt;             Text I would like to get1.             &lt;a href="http://intro.com"&gt;extra stuff&lt;/a&gt;             Text I would like to get2.             &lt;a href="http://example.com"&gt;link to example&lt;/a&gt;             Text I would like to get3.         &lt;/div&gt;         &lt;span&gt;             &lt;a href="http://intro.com"&gt;extra stuff&lt;/a&gt;             Text I would like to get2.             &lt;a href="http://example.com"&gt;link to example&lt;/a&gt;             Text I would like to get3.         &lt;/span&gt;     &lt;/body&gt; &lt;/html&gt; </code></pre>  <p>with the solution applied:</p>  <pre><code>def tagsoupParser = new org.ccil.cowan.tagsoup.Parser() def slurper = new XmlSlurper(tagsoupParser) def htmlParsed = slurper.parseText(stringToParse)  println htmlParsed.body.div[0].localText()[0] </code></pre>  <p>would return:</p>  <pre><code>[Text I would like to get1., Text I would like to get2., Text I would like to get3.] </code></pre>  <p>However, when parsing the <code>&lt;span&gt;</code> part in this example</p>  <pre><code>println htmlParsed.body.span[0].localText() </code></pre>  <p>the output is</p>  <pre><code>[Text I would like to get2., Text I would like to get3.] </code></pre>  <p>The problem I am facing now is that it's apparently not possible to pinpoint the location ("between which child nodes") of the texts. I would have expected the second invocation to yield</p>  <pre><code>[, Text I would like to get2., Text I would like to get3.] </code></pre>  <p>This would have made it clear: Position 0 (before child 0) is empty, position 1 (between child 0 and 1) is "Text I would like to get2.", and position 2 (between child 1 and 2) is "Text I would like to get3." But given the API works as it does, there is apparently no way to determine whether the text returned at index 0 is actually positioned at index 0 or at any other index, and the same is true for all the other indices.</p>  <p>I have tried it with both <code>XmlSlurper</code> and <code>XmlParser</code>, yielding the same results.</p>  <p>If I'm not mistaken here, it's as a consequence also impossible to completely recreate an original HTML document using the information from the parser because this "text index" information is lost.</p>  <p><strong>My question is: Is there any way to find out those text positions?</strong> An answer requiring me to change the parser would also be acceptable.</p>  <hr>  <p><strong>UPDATE / SOLUTION:</strong></p>  <p>For further reference, here's Will P's answer, applied to the original code:</p>  <pre><code>def tagsoupParser = new org.ccil.cowan.tagsoup.Parser() def slurper = new XmlParser(tagsoupParser) def htmlParsed = slurper.parseText(stringToParse)  println htmlParsed.body.div[0].children().collect {it in String ? it : null} </code></pre>  <p>This yields:</p>  <pre><code>[Text I would like to get1., null, Text I would like to get2., null, Text I would like to get3.] </code></pre>  <p>One has to use <strong><code>XmlParser</code></strong> instead of <strong><code>XmlSlurper</code></strong> with <code>node.children()</code>.</p>