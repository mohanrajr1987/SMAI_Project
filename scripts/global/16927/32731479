<p>The <a href="http://lxml.de/html5parser.html" rel="nofollow">lxml html5parser</a> seems to ignore any <code>namespaceHTMLElements=False</code> option I pass to it. It puts all elements I give it into the HTML namespace instead of the (expected) void namespace.</p>  <p>Here’s a simple case that reproduces the problem:</p>  <pre class="lang-none prettyprint-override"><code>echo "&lt;p&gt;" | python -c "from sys import stdin; \   from lxml.html import html5parser as h5, tostring; \   print tostring(h5.parse(stdin, h5.HTMLParser(namespaceHTMLElements=False)))" </code></pre>  <p>The output from that is this:</p>  <pre class="lang-html prettyprint-override"><code>&lt;html:html xmlns:html="http://www.w3.org/1999/xhtml"&gt;&lt;html:head&gt;&lt;/html:head&gt;&lt;html:body&gt;&lt;html:p&gt; &lt;/html:p&gt;&lt;/html:body&gt;&lt;/html:html&gt; </code></pre>  <p>As can be seen, the <code>html</code> element and all other elements there are in the HTML namespace.</p>  <p>The expected output is instead this:</p>  <pre class="lang-html prettyprint-override"><code>&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt; &lt;/p&gt;&lt;/body&gt;&lt;/html&gt; </code></pre>  <p>I recognize that <code>namespaceHTMLElements</code> is an html5lib option, not a native lxml option that lxml does anything itself with directly. lxml is supposed to just call html5lib and pass that option on to html5lib in such a way that html5lib uses it as expected.</p>  <hr>  <h3>More details</h3>  <p>Some things I already know:</p>  <ul> <li>html5lib fully conforms to the requirements of the HTML spec, including <a href="https://html.spec.whatwg.org/multipage/syntax.html#the-before-html-insertion-mode" rel="nofollow">the requirement that the <code>html</code> element must be placed into the HTML namespace</a>—which html5lib does</li> <li>However, html5lib provides <code>namespaceHTMLElements=False</code> as an option to override that default “put the <code>html</code> element into the HTML namespace” behavior.</li> <li>When I use html5lib directly (not through lxml), and I pass <code>namespaceHTMLElements=False</code> to it, everything works as expected—the <code>html</code> element goes into the void namespace.</li> <li><p>Hacking some printf into the html5lib sources, I observe that:</p>  <ul> <li>lxml <em>is</em> actually calling html5lib with <code>namespaceHTMLElements=False</code> as expected</li> <li><em>but</em>, lxml seems to be calling into html5lib <strong>twice</strong>: first without <code>namespaceHTMLElements</code>, then a second time with <code>namespaceHTMLElements=False</code></li> </ul></li> </ul>  <hr>  <h3>Conclusion about where the cause is to be found</h3>  <p>Given the above, it’s clear that the problem is in the interface between lxml and html5lib. I’m not sure why lxml is calling into html5lib twice but I think it may be because for some reason it first tries to create a new instance of its own <code>XHTMLParser</code> before doing what I’m actually asking it to do, which is just to create an instance of its own <code>HTMLParser</code>.</p>  <p>So maybe the fact that it does make two calls to html5lib causes html5lib to sort of “lock in” the default <code>namespaceHTMLElements=True</code> behavior that results from the first call, and then ignore the <code>namespaceHTMLElements=False</code> directive when it sees it in the second call.</p>  <p>Maybe in making two calls the way it does, lxml is either breaking some assumption in html5lib, or is actually misusing the html5lib API in a way that it by design is not intended to be used.</p>  <p>Or maybe the cause isn’t at all the result of lxml making two separate calls to html5lib, but instead some other problem in the way it’s using the html5lib interface.</p>  <p>Anyway, I’m interested in hearing from others about whether anybody else ahs run into this problem and has a workaround—or at least have some insight into why it’s happening.</p>