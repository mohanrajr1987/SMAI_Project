<p>I am confused about the hashtable in unordered containers... or at least in sets.</p>  <p>So, I thought it would work like this:</p>  <p>I hash my object. I calculate the modulo of object and vector lengths (hash%vectorlength) and use that as the index for the pointer to my object in the hash table.. which is a vector as far as I know...</p>  <p>so for a naive hash function that returns for a int wrapper just the int member's value it would look like this:</p>  <pre><code>hash table:  vector index:           [0, 1, 2, 3, 4]                          |  |  |  |  | object with value...:    0  1  2  3  4 </code></pre>  <p>I wrote a program to test that:</p>  <pre><code>#include &lt;iostream&gt; #include &lt;unordered_set&gt;  struct Obj {  public:      Obj(int i)     {         mem = i;     }      friend bool operator==(const Obj&amp; o1, const Obj&amp; o2)     {         return (o1.mem == o2.mem);     }      friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; o, const Obj&amp; obj)     {         o &lt;&lt; obj.mem;         return o;     }      int mem;  };  namespace std {     template&lt;&gt;     struct hash&lt;Obj&gt;     {         size_t operator()(const Obj&amp; r) const         {             size_t hash = r.mem;             return hash;         }     }; }   int main() {     std::unordered_set&lt;Obj&gt; map;     for (int i = 0; i &lt; 5; ++i)     {         map.insert(Obj(i));     }      for(auto it = map.begin(); it != map.end(); ++it)     {         std::cout &lt;&lt; (*it) &lt;&lt; std::endl;     } } </code></pre>  <p>I expected the output</p>  <pre><code>0 1 2 3 4 </code></pre>  <p>but I got:</p>  <pre><code>4 3 2 1 0 </code></pre>  <p>Why is that?</p>