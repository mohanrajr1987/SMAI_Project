<p>(This is a follow-up question to another question I asked: <a href="http://stackoverflow.com/q/32368090/80003">XmlSerializer exception when deserializing derived class (&lt;Derived xmlns=''&gt; was not expected)</a> )</p>  <p>I am trying to serialize and deserialize a hierarchy of classes using XmlSerializer and control the xml by implementing <code>IXmlSerializer</code>. The serialization works fine, but when I try to deserialize I get this exception:</p>  <blockquote>   <p>System.InvalidOperationException: There is an error in XML document (2, 2). --->  System.MissingMethodException: Cannot create an abstract class.</p> </blockquote>  <p>If I don't implement <code>IXmlSerializable</code>, the serialization and deserialization works fine. </p>  <p>But if I implement <code>IXmlSerializable</code>, the serializer does not write the necessary xml namespaces and does not write the <code>xsi:type</code> attribute signaling the concrete type of the class that is being serialized.</p>  <p>In order to overcome this problem, in the <code>WriteXml</code> method I write the namespaces and the type manually, but it looks like the deserializer won't pick them up when deserializing. Thus, it will try to create an instance of the base class, which is abstract, and it will throw an exception.</p>  <p>I am inserting my code below. When testing it, you can see that if you comment out the <code>: IXmlSerializable</code> part, everything works fine. But if you leave it in, the deserialization does not work anymore.</p>  <p>How can I make the deserialization work?</p>  <pre class="lang-csharp prettyprint-override"><code>using System; using System.IO; using System.Text; using System.Xml.Serialization;  [XmlInclude(typeof(Derived))] public abstract class Base : IXmlSerializable {     public string BaseStr { get; set; }      public System.Xml.Schema.XmlSchema GetSchema()     {         return null;     }      public virtual void ReadXml(System.Xml.XmlReader reader)     {         reader.ReadStartElement();          reader.ReadStartElement("BaseStr");         BaseStr = reader.ReadElementContentAsString();         reader.ReadEndElement();          reader.ReadEndElement();     }      public virtual void WriteXml(System.Xml.XmlWriter writer)     {         writer.WriteAttributeString("xmlns", "xsd", null, "http://www.w3.org/2001/XMLSchema");         writer.WriteAttributeString("xmlns", "xsi", null, "http://www.w3.org/2001/XMLSchema-instance");         writer.WriteAttributeString("xsi", "type", null, GetType().Name);         writer.WriteElementString("BaseStr", BaseStr);     } }  public class Derived : Base {     public string DerivedStr { get; set; }      public override void WriteXml(System.Xml.XmlWriter writer)     {         base.WriteXml(writer);         writer.WriteElementString("DerivedStr", DerivedStr);     }      public override void ReadXml(System.Xml.XmlReader reader)     {         reader.ReadStartElement();          reader.ReadStartElement("BaseStr");         BaseStr = reader.ReadElementContentAsString();         reader.ReadEndElement();         reader.ReadStartElement("DerivedStr");         DerivedStr = reader.ReadElementContentAsString();         reader.ReadEndElement();          reader.ReadEndElement();     } }  class Program {     static void Main(string[] args)     {         try         {             XmlSerializer serializer = new XmlSerializer(typeof(Base));             MemoryStream ms = new MemoryStream();             serializer.Serialize(ms, new Derived() { DerivedStr = "Derived", BaseStr = "Base" });              Console.WriteLine(Encoding.ASCII.GetChars(ms.ToArray()));              ms.Position = 0;              XmlSerializer deserializer = new XmlSerializer(typeof(Base));             Base b = (Base)deserializer.Deserialize(ms);             Console.WriteLine(b.GetType().Name);         }         catch (Exception ex)         {             Console.WriteLine();             Console.WriteLine(ex.ToString());         }     } } </code></pre>  <hr>  <h2>EDIT:</h2>  <p>I did some more research into this, and I used reflector to decompile the serialization assembly that is generated on-the-fly. I compared the code for the case when I implement <code>IXmlSerializable</code> and for the case where I don't implement it.</p>  <p>I found that when I don't implement the interface, the assembly includes this kind of code:</p>  <pre class="lang-csharp prettyprint-override"><code>public object Read4_Base() {     base.Reader.MoveToContent();     if (base.Reader.NodeType == XmlNodeType.Element)     {         if ((base.Reader.LocalName != this.id1_Base) || (base.Reader.NamespaceURI != this.id2_Item))         {             throw base.CreateUnknownNodeException();         }         return this.Read3_Base(true, true);     }     base.UnknownNode(null, ":Base");     return null; }  private Base Read3_Base(bool isNullable, bool checkType) {     XmlQualifiedName type = checkType ? base.GetXsiType() : null;     bool flag = false;     if (isNullable)     {         flag = base.ReadNull();     }     if ((checkType &amp;&amp; (type != null)) &amp;&amp; ((type.Name != this.id1_Base) || (type.Namespace != this.id2_Item)))     {         if ((type.Name != this.id3_Derived) || (type.Namespace != this.id2_Item))         {             throw base.CreateUnknownTypeException(type);         }         return this.Read2_Derived(isNullable, false);     }     if (!flag)     {         throw base.CreateAbstractTypeException("Base", "");     }     return null; } </code></pre>  <p>But when I implement IXmlSerializable, the code looks like this:</p>  <pre class="lang-csharp prettyprint-override"><code>public object Read1_Base() {     base.Reader.MoveToContent();     if (base.Reader.NodeType == XmlNodeType.Element)     {         if ((base.Reader.LocalName != this.id1_Base) || (base.Reader.NamespaceURI != this.id2_Item))         {             throw base.CreateUnknownNodeException();         }         return (Base) base.ReadSerializable((IXmlSerializable) Activator.CreateInstance(typeof(Base), BindingFlags.CreateInstance | BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance, null, new object[0], null));     }     base.UnknownNode(null, ":Base");     return null; } </code></pre>  <p>So it looks like whe I don't implement IXmlSerializable, the deserializer checks the <code>xsi:type</code> attribute and calls the deserializer for the concrete type. But when I implement <code>IXmlSerializable</code>, the deserializer does not do this and it tries to deserialize whatever type it has been created to handle. If this type is an abstract type, then I get an exception because it can't instantiate an abstract type.</p>  <p>Does anyone know of a workaround I can use to get the deserializer to read the <code>xsi:type</code> attribute and deserialize the derived type?</p>