<p>I'm having trouble serializing generic objects with the correct element name. I want the Generic Type to specify the element name to be used, not the Generic Class. Here's a test if anyone is interested in playing around with it.</p>  <pre><code>[TestFixture] public class BedsOnlineHotelSearchServiceTests {     [Test]     public void Will_contain_MyClass()     {         var obj = new Request&lt;MyClass&gt;         {             Body = new MyClass()         };         var xmlSerializer = new XmlSerializer(obj.GetType());         string result;         using (var textWriter = new StringWriter())         {             xmlSerializer.Serialize(textWriter, obj);             result = textWriter.ToString();         }         Debug.WriteLine(result);         Assert.That(result, Contains.Substring("MyClass"));     }      [XmlRoot("Request")]     public class Request&lt;T&gt;     {         public T Body { get; set; }     }      public class MyClass     {         public string Hello = "Cat";     } } </code></pre>  <p>Currently this is what happens:</p>  <pre><code>&lt;Request ...&gt;   &lt;Body&gt;     &lt;Hello&gt;Cat&lt;/Hello&gt;   &lt;/Body&gt; &lt;/Request&gt; </code></pre>  <p>What would make me happy is if I found a way to serialize it as such:</p>  <pre><code>&lt;Request ...&gt;   &lt;MyClass&gt;     &lt;Hello&gt;Cat&lt;/Hello&gt;   &lt;/MyClass&gt; &lt;/Request&gt; </code></pre>  <p>This must be done without setting the XmlElement("MyClass") attribute on the Request.Body-property, because if T is instead my DonkeyMoneyMaker class I want the element name to be "DonkeyMoneyMaker" instead, and I don't want to create a new Request class for every single object to be serialized.</p>  <p>Does this make sense?</p>