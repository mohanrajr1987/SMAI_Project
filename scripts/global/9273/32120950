<p>I've been researching online, including Stack Overflow, but either I'm missing something or the examples I've seen just don't apply to my situation.</p>  <p>I am receiving this error when I attempt to dynamically set the root and list item element names during XML Serialization.</p>  <pre class="lang-none prettyprint-override"><code>XmlRoot and XmlType attributes may not be specified for the type System.Collections.Generic.List`1[   [XmlSerializationFailureExample.Controllers.MyClass, XmlSerializationFailureExample,   Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]] </code></pre>  <p>I've seen one rather old posting on <a href="https://social.msdn.microsoft.com/Forums/en-US/726317a0-aaff-468c-b099-f47227190bf3/misleading-error-message-from-xmlserializer-constructor?forum=asmxandxml" rel="nofollow">Microsoft's site</a> which states that the message ought to read: <code>Only XmlRoot and XmlType attributes may be specified...</code>. Sure enough, if I remove all overrides except XmlRoot and XmlType, the error is cleared, but then the rendered XML does not match my needs.</p>  <p>I am using the <code>XmlSerializer</code> Overrides constructor because I have to dynamically set the Root and first child element names. The same classes need to produce different XML element names in different situations. Though this sample has a meager two fields, the actual class being serialized has around 100 fields.</p>  <p><strong>So, how can I control the name of both the root element and the immediate child elements when directly serializing a <code>List&lt;MyClass&gt;</code> object?</strong></p>  <p>The objective is to get XML looking like this:</p>  <pre class="lang-xml prettyprint-override"><code>&lt;ArrayOfPerson&gt;   &lt;Person&gt;     &lt;Name&gt;John Doe&lt;/Name&gt;     &lt;Age&gt;57&lt;/Age&gt;   &lt;/Person&gt;   &lt;Person&gt;     &lt;Name&gt;Doe, Jane&lt;/Name&gt;     &lt;Age/&gt;   &lt;/Person&gt; &lt;/ArrayOfPerson&gt; </code></pre>  <p>By changing the override values, I should be able to generate XML like this from the same class:</p>  <pre class="lang-xml prettyprint-override"><code>&lt;ArrayOfEmployee&gt;   &lt;Employee&gt;     &lt;Name&gt;John Doe&lt;/Name&gt;     &lt;Age&gt;57&lt;/Age&gt;   &lt;/Employee&gt;   &lt;Employee&gt;     &lt;Name&gt;Doe, Jane&lt;/Name&gt;     &lt;Age/&gt;   &lt;/Employee&gt; &lt;/ArrayOfEmployee&gt; </code></pre>  <p>Here is some simplified code that demonstrates my problem. I used a basic MVC.Net app from Visual Studio 2013's templates for this example.</p>    <pre class="lang-cs prettyprint-override"><code>// GET api/SerializationTest public ActionResult SerializationTest() {     var list = new List&lt;MyClass&gt; {         new MyClass {Name = "John Doe", Age = 57},         new MyClass {Name = "Doe, Jane"}     };      XmlAttributes xmlPerson = new XmlAttributes {         XmlRoot = new XmlRootAttribute { ElementName = "Person" }     };      XmlAttributes xmlPersonList = new XmlAttributes {         XmlRoot = new XmlRootAttribute { ElementName = "ArrayOfPerson" },         XmlArrayItems = {             new XmlArrayItemAttribute("Person",typeof(MyClass))         },     };      XmlAttributeOverrides overrides = new XmlAttributeOverrides();     overrides.Add(typeof(MyClass), xmlPerson);     overrides.Add(typeof(List&lt;MyClass&gt;), xmlPersonList);      return new XmlResult(         list,         "TestFile.xml",         overrides     ); } </code></pre>  <p>The example class being serialized. The actual class has around 100 properties.</p>  <pre class="lang-cs prettyprint-override"><code>public class MyClass {     public string Name { get; set; }     public int? Age { get; set; } } </code></pre>  <p><strong>Update 1</strong></p>  <p>If I encapsulate my <code>List&lt;MyClass&gt;</code> in another class and annotate with attributes as below, I can get the XML I want. But how do I do this dynamically, as the specified element names must vary at runtime?</p>  <pre class="lang-cs prettyprint-override"><code>[XmlRoot(ElementName = "ArrayOfPerson")] public class MyCollection {      [XmlElement(ElementName = "Person")]     public List&lt;MyClass&gt; Items { get; set; }  } </code></pre>  <p><strong>End of Update 1</strong></p>  <p>The <code>XmlResult</code> type derives from the built-in <code>ActionResult</code> and contains the actual serialization logic. The class is intended to return a file rather than an HTML page.</p>  <pre class="lang-cs prettyprint-override"><code>public class XmlResult : ActionResult {      private string FileName { get; set; }     private object ObjectToSerialize { get; set; }     private XmlAttributeOverrides Overrides { get; set; }      public XmlResult(object objectToSerialize, string fileName, XmlAttributeOverrides overrides)     {         ObjectToSerialize = objectToSerialize;         FileName = fileName;         Overrides = overrides;     }      public override void ExecuteResult(ControllerContext context)     {         HttpContext.Current.Response.Clear();         HttpContext.Current.Response.AddHeader("content-control", "no-store, no-cache");         HttpContext.Current.Response.AddHeader("content-disposition", "attachment;filename=" + FileName);         HttpContext.Current.Response.ContentType = "text/xml";         try         {             if (ObjectToSerialize != null)             {                 var xs = new XmlSerializer(ObjectToSerialize.GetType(), Overrides);                 xs.Serialize(HttpContext.Current.Response.Output, ObjectToSerialize);             }         }         catch (Exception ex)         {             HttpContext.Current.Response.Write("&lt;error&gt;" + ex + "&lt;/error&gt;");         }         HttpContext.Current.Response.Flush();         HttpContext.Current.Response.SuppressContent = true;         HttpContext.Current.ApplicationInstance.CompleteRequest();     }  } </code></pre>