<p>I have following setup in a MEF application:</p>  <p>Assembly <strong>MyBaseAssembly</strong>:</p>  <pre><code>namespace My.Namespace {     [DataContract]     public class Container     {         [DataMember]         public Data Item { get; set; }     }      [DataContract]     public class Data     {         [DataMember]         public string Foo { get; set; }     } } </code></pre>  <p>Assembly <strong>SecondAssembly</strong>, references the <em>MyBaseAssembly</em>:</p>  <pre><code>namespace My.Another.Namespace {     [DataContract]     public class SecondData : Data     {         [DataMember]         public string Bar { get; set; }     } } </code></pre>  <p>Somewhere deep inside of my application I create a <code>Container</code> object:</p>  <pre><code>Container container = new Container(); container.Item = new SecondData { Bar = "test" }; </code></pre>  <p>I want to serialize and de-serialize the <code>container</code> object. Since the <strong>SecondAssembly</strong> is a MEF-module, I need to dynamically detect and resolve the types in the data contract, so the <code>KnownTypeAttribute</code> is not a good solution.</p>  <p>I created a custom <code>DataContractResolver</code>, but I don't know how do I get the assembly information for de-serialization.</p>  <p>On serialization, I get following XML:</p>  <pre><code>&lt;d4p1:SecondData     xmlns:d6p1="http://schemas.datacontract.org/2004/07/My.Another.Namespace"     i:type="d7p1:My.Another.Namespace.SecondData"&gt; ... &lt;/d4p1:SecondData&gt; </code></pre>  <p>This is the default <code>DataContract</code> serialization behavior: we get the type name and the type namespace, but there is no (explicit) assembly information!</p>  <p>Trying to de-serialize this XML, I cannot determine which assembly to use for resolving the type:</p>  <pre><code>class SerializationTypeResolver : DataContractResolver {     ...      public override Type ResolveName(string typeName, string typeNamespace, Type declaredType, DataContractResolver knownTypeResolver)     {         Type result = knownTypeResolver.ResolveName(typeName, typeNamespace, declaredType, null);         if (result == null)         {             // Here, I cannot rely on the declaredType parameter,             // because it contains the declared type which is Data from MyBaseAssembly.             // But I need the SecondData from the SecondAssembly!              string assemblyName = ???; // How do I get this assembly name?             string fullTypeName = typeName + ", " + assemblyName;             result = Type.GetType(fullTypeName);         }          return result;     } } </code></pre>  <p>So my question is: what is the good way to store and get assembly name while serializing and de-serializing the <code>DataContract</code>s?</p>