<p>I know this is a popular topic and I have researched extensively without finding an answer to my problem.</p>  <p>I have a base class IntroductionAction and 2 derived classes IntroductionActionComplex and IntroductionActionSimple. I have a list of IntroductionAction objects to which I have added objects of both of the derived types. My classes are as follows:</p>  <pre><code>[XmlInclude(typeof(IntroductionActionComplex))] [XmlInclude(typeof(IntroductionActionSimple))] public class IntroductionAction {     public IntroductionAction() { } }  public class IntroductionActionComplex : IntroductionAction {     [XmlIgnore]     public string name { get; set; }      [XmlElement(ElementName = "QuestionString")]     public string question { get; set; }      [XmlElement(ElementName = "AnswerString")]     public List&lt;string&gt; answerStrings { get; set; }      public IntroductionActionComplex()     {         name = string.Empty;         question = null;         answerStrings = new List&lt;string&gt;();     } }  public class IntroductionActionSimple : IntroductionAction {     [XmlIgnore]     public string name { get; set; }      [XmlText]     public string Value { get; set; }      public IntroductionActionSimple()     {         Value = string.Empty;     } } </code></pre>  <p>I then create the List as follows</p>  <pre><code>[XmlElement("IntroductionAction")] public List&lt;IntroductionAction&gt; introductionActions { get; set; } </code></pre>  <p>I am using xmlserializer and everything serializes correctly. This is the resulting xml of the list containing one of each of the derived classes which is correct.</p>  <pre><code>&lt;IntroductionAction&gt;   &lt;QuestionString&gt;     test   &lt;/QuestionString&gt;   &lt;AnswerString&gt;     test   &lt;/AnswerString&gt;   &lt;AnswerString&gt;     test   &lt;/AnswerString&gt; &lt;/IntroductionAction&gt; &lt;IntroductionAction&gt;   test &lt;/IntroductionAction&gt; </code></pre>  <p>This xml file is going onto a device which doesn't read it as xml but just searches for the tags and does whatever work it needs to do and because of that the file can't contain any xsi or xsd tags, indentation, etc that is usually associated with proper xml.</p>  <p>My deserialization code is straight forward:</p>  <pre><code>public static T Deserialize_xml_Config&lt;T&gt;(string file1, T obj) {    XmlSerializer deserializer = new XmlSerializer(obj.GetType());    using (TextReader reader = new StreamReader(file1))    {       return (T)deserializer.Deserialize(reader);    } } </code></pre>  <p>Finally to my problem. When I deserialize, it is being deserialized to the base class IntroductionAction and not to the derived classes. These Introduction Action classes are just part of a much larger object that I am serializing/deserializing. I have tried making the base class abstract since it contains no functionality but I get an error on deserialization saying </p>  <blockquote>   <p>The specified type is abstract: name='IntroductionAction'</p> </blockquote>  <p>Despite my XmlIncludes it seems unable to find the derived classes. </p>  <p>I have tried adding the types to the serializer but that didn't work.</p>  <p>Any help is much appreciated.</p>  <p>Edit: This is what I mean by adding the types to the serializer</p>  <pre><code>XmlSerializer deserializer = new XmlSerializer(obj.GetType(), new Type [] { typeof(IntroductionActionComplex), typeof(IntroductionActionSimple) }); using (TextReader reader = new StreamReader(file1)) {    return (T)deserializer.Deserialize(reader); } </code></pre>  <p>Also my attempt at using xmlAttributeOverrides:</p>  <pre><code>XmlAttributeOverrides attrOverrides = new XmlAttributeOverrides(); var attrs = new XmlAttributes(); XmlElementAttribute attr = new XmlElementAttribute(); attr.ElementName = "IntroductionAction"; attr.Type = typeof(IntroductionActionComplex); attrs.XmlElements.Add(attr); attr.ElementName = "IntroductionAction"; attr.Type = typeof(IntroductionActionSimple); attrs.XmlElements.Add(attr); attrOverrides.Add(typeof(IntroductionAction), "IntroductionAction", attrs);  XmlSerializer deserializer = new XmlSerializer(obj.GetType(), attrOverrides); using (TextReader reader = new StreamReader(file1)) {    return (T)deserializer.Deserialize(reader); } </code></pre>