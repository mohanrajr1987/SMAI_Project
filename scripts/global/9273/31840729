<p>I am trying to support Forward Compatibility for Data Contract Serializer. The case which I have problems with:</p>  <p>If you have an object which is saved as a reference to a property which is added in a later version inside of a known type, it will become an exception. Note that both of these types are known in both versions. The only thing which is new is the property inside of one of the objects.</p>  <p>I attached a simple simulation of the problem at <a href="http://www.megafileupload.com/diUl/Unknown_types_Test.rar" rel="nofollow">samples</a> and <a href="http://s000.tinyupload.com/?file_id=03194982617993128896" rel="nofollow">samples</a>:</p>  <p>It has two different projects:  V1 which is an older version which is already deployed. V2 which is a newer version of V1. V2 is saving its data and V1 needs to be able to load V2 saved data to support forward compatibility.</p>  <p>There are three custom types:  People: has two object references and Person and AnotherPerson are being saved in them.</p>  <p>In V1 and V2:</p>  <pre><code>[DataContract(Name = "People", Namespace = "Tests.FCTests")] [KnownType(typeof(Person))] [KnownType(typeof(AnotherPerson))] public class People : IExtensibleDataObject {     [DataMember]     public object Person { get; set; }      [DataMember]     public object AnotherPerson { get; set; }      public ExtensionDataObject ExtensionData { get; set; } } </code></pre>  <p>Person: has a Name.</p>  <p>In V1 and V2:</p>  <pre><code>[DataContract(Name = "Person", Namespace = "Tests.FCTests")] public class Person : IExtensibleDataObject {     [DataMember]     public string Name { get; set; }      public ExtensionDataObject ExtensionData { get; set; }  } </code></pre>  <p>AnotherPerson: has a Name and in V2 a reference to Person (FriendPerson) was added.</p>  <p>In V1:</p>  <pre><code>[DataContract(Name = "AnotherPerson", Namespace = "Tests.FCTests")] public class AnotherPerson : IExtensibleDataObject {     [DataMember]     public string Name { get; set; }      public ExtensionDataObject ExtensionData { get; set; } } </code></pre>  <p>In V2:</p>  <pre><code>[DataContract(Name = "AnotherPerson", Namespace = "Tests.FCTests")] public class AnotherPerson : IExtensibleDataObject {     [DataMember]     public string Name { get; set; }      /* This is added in this version */     [DataMember]     public Person FriendPerson { get; set; }      public ExtensionDataObject ExtensionData { get; set; } } </code></pre>  <p>Version 2 is saving the data:</p>  <pre><code>    static void Main(string[] args)     {         DataContractSerializer serializer = new DataContractSerializer(typeof(People), null, int.MaxValue, false, true, null, null);          var people = new People();         var person = new Person() { Name = "Person" };         var anotherPerson = new AnotherPerson() { Name = "AnotherPerson", FriendPerson = person };          people.Person = person;         people.AnotherPerson = anotherPerson;          using (var writer = new XmlTextWriter("../../../../SavedFiles/Version2Saved.xml", null) { Formatting = Formatting.Indented })         {             serializer.WriteObject(writer, people);             writer.Flush();         }          Console.WriteLine("Save Successfull.");         Console.ReadKey();     } </code></pre>  <p>Version 1 is loading the same data:</p>  <pre><code>    static void Main(string[] args)     {         DataContractSerializer serializer = new DataContractSerializer(typeof(People), null, int.MaxValue, false, true, null, null);          People loadedPeople;          using (var reader = new XmlTextReader("../../../../SavedFiles/Version2Saved.xml"))         {             loadedPeople = (People)serializer.ReadObject(reader);         }          Console.WriteLine("Load Successful.");          Console.ReadKey();     } </code></pre>  <p>The saved data:</p>  <pre><code>&lt;People xmlns:i="http://www.w3.org/2001/XMLSchema-instance" z:Id="1" xmlns:z="http://schemas.microsoft.com/2003/10/Serialization/" xmlns="Tests.FCTests"&gt;   &lt;AnotherPerson z:Id="2" i:type="AnotherPerson"&gt;     &lt;FriendPerson z:Id="3"&gt;       &lt;Name z:Id="4"&gt;Person&lt;/Name&gt;     &lt;/FriendPerson&gt;     &lt;Name z:Id="5"&gt;AnotherPerson&lt;/Name&gt;   &lt;/AnotherPerson&gt;   &lt;Person z:Ref="3" i:nil="true" /&gt; &lt;/People&gt; </code></pre>  <p>When V1 is trying to load the data this exception is thrown:</p>  <pre><code>{System.Runtime.Serialization.SerializationException: Element Person from namespace Tests.FCTests cannot have child contents to be deserialized as an object. Please use XmlNode[] to deserialize this pattern of XML. ---&gt; System.Xml.XmlException: 'Element' is an invalid XmlNodeType.    at System.Xml.XmlReader.ReadEndElement()    at System.Runtime.Serialization.XmlReaderDelegator.ReadEndElement()    at System.Runtime.Serialization.ObjectDataContract.ReadXmlValue(XmlReaderDelegator reader, XmlObjectSerializerReadContext context)    --- End of inner exception stack trace ---    at System.Runtime.Serialization.ObjectDataContract.ReadXmlValue(XmlReaderDelegator reader, XmlObjectSerializerReadContext context)    at System.Runtime.Serialization.XmlObjectSerializerReadContext.ReadDataContractValue(DataContract dataContract, XmlReaderDelegator reader)    at System.Runtime.Serialization.XmlObjectSerializerReadContext.InternalDeserialize(XmlReaderDelegator reader, String name, String ns, Type declaredType, DataContract&amp; dataContract)    at System.Runtime.Serialization.XmlObjectSerializerReadContextComplex.InternalDeserialize(XmlReaderDelegator xmlReader, Type declaredType, String name, String ns)    at System.Runtime.Serialization.XmlObjectSerializerReadContext.DeserializeFromExtensionData(IDataNode dataNode, Type type, String name, String ns)    at System.Runtime.Serialization.XmlObjectSerializerReadContext.GetExistingObject(String id, Type type, String name, String ns)    at System.Runtime.Serialization.XmlObjectSerializerReadContext.TryHandleNullOrRef(XmlReaderDelegator reader, Type declaredType, String name, String ns, Object&amp; retObj)    at System.Runtime.Serialization.XmlObjectSerializerReadContext.InternalDeserialize(XmlReaderDelegator reader, String name, String ns, Type declaredType, DataContract&amp; dataContract)    at System.Runtime.Serialization.XmlObjectSerializerReadContextComplex.InternalDeserialize(XmlReaderDelegator xmlReader, Int32 declaredTypeID, RuntimeTypeHandle declaredTypeHandle, String name, String ns)    at ReadPeopleFromXml(XmlReaderDelegator , XmlObjectSerializerReadContext , XmlDictionaryString[] , XmlDictionaryString[] )    at System.Runtime.Serialization.ClassDataContract.ReadXmlValue(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContext context)    at System.Runtime.Serialization.XmlObjectSerializerReadContext.ReadDataContractValue(DataContract dataContract, XmlReaderDelegator reader)    at System.Runtime.Serialization.XmlObjectSerializerReadContext.InternalDeserialize(XmlReaderDelegator reader, String name, String ns, Type declaredType, DataContract&amp; dataContract)    at System.Runtime.Serialization.XmlObjectSerializerReadContextComplex.InternalDeserialize(XmlReaderDelegator xmlReader, Type declaredType, DataContract dataContract, String name, String ns)    at System.Runtime.Serialization.DataContractSerializer.InternalReadObject(XmlReaderDelegator xmlReader, Boolean verifyObjectName, DataContractResolver dataContractResolver)    at System.Runtime.Serialization.XmlObjectSerializer.ReadObjectHandleExceptions(XmlReaderDelegator reader, Boolean verifyObjectName, DataContractResolver dataContractResolver)    at System.Runtime.Serialization.DataContractSerializer.ReadObject(XmlReader reader)    at Version1.Program.Main(String[] args) in C:\Users\Administrator\Desktop\Unknown types Test\Version1\Version1\Program.cs:line 17} </code></pre>  <p>Inner Exception:</p>  <pre><code>{System.Xml.XmlException: 'Element' is an invalid XmlNodeType.    at System.Xml.XmlReader.ReadEndElement()    at System.Runtime.Serialization.XmlReaderDelegator.ReadEndElement()    at System.Runtime.Serialization.ObjectDataContract.ReadXmlValue(XmlReaderDelegator reader, XmlObjectSerializerReadContext context)} </code></pre>  <p>I suspect that the error is because the object is referencing to a type which is being deserialized inside of Extension Object and does not have any type. The reason is, if you add a new instance of Person inside of People and not referencing the same instance inside of AnotherPerson (FriendPerson).</p>  <pre><code>var anotherPerson = new AnotherPerson() { Name = "AnotherPerson", FriendPerson = new Person() }; </code></pre>  <p>Then the saved file becomes the following and everything works just fine:</p>  <pre><code>&lt;People xmlns:i="http://www.w3.org/2001/XMLSchema-instance" z:Id="1" xmlns:z="http://schemas.microsoft.com/2003/10/Serialization/" xmlns="Tests.FCTests"&gt;   &lt;AnotherPerson z:Id="2" i:type="AnotherPerson"&gt;     &lt;FriendPerson z:Id="3"&gt;       &lt;Name i:nil="true" /&gt;     &lt;/FriendPerson&gt;     &lt;Name z:Id="4"&gt;AnotherPerson&lt;/Name&gt;   &lt;/AnotherPerson&gt;   &lt;Person z:Id="5" i:type="Person"&gt;     &lt;Name z:Id="6"&gt;Person&lt;/Name&gt;   &lt;/Person&gt; &lt;/People&gt; </code></pre>  <p>I tried to fix the problem using a Data Contract Resolver, Adding Known Types inside of serializer dynamically, and Data Contract Surrogate but, none of them worked. The reason is the exception is thrown when the serializer is de-serializing FriendPerson and the overridden methods inside of the surrogate or resolver are not being called prior to that.</p>  <p><strong>NOTE</strong> We need to preserve object references and removing it is not an option.</p>