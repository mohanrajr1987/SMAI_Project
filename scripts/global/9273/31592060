<p>I have a class that I need to serialize/deserialize, and I'm half way there - I have serialization functional, resulting in the below XML. However, since I'm implementing <code>IXmlSerializable</code> myself, I'm uncertain what an implementation of <code>ReadXml</code> should look like, given that <code>SomeGenericClass&lt;T&gt;</code> was serialized using attribute-based flagging rather than an explicit implementation if <code>IXmlSerializable</code></p>  <pre><code>&lt;?xml version="1.0" encoding="utf-16"?&gt; &lt;FooContainer FooName="DoSomething"&gt;   &lt;SomeGenericClassOfString xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" Value="Foobar" Name="firstParam" Description="First Paramater Serialized" /&gt;   &lt;SomeGenericClassOfInt32 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" Value="10000" Name="nextParam" Description="Second Serialized parameter" /&gt; &lt;/FooContainer&gt; </code></pre>  <p>Which I want to serialize back into an instance of:</p>  <pre><code>public class FooContainer : IList&lt;ISomeGenericClassBase&gt;, IXmlSerializable {      public string FooName {get;set;}       void IXmlSerializable.WriteXml(XmlWriter writer) {          var serializer = XmlSerializer.FromTypes(new Type[]{SomeGenericBaseClass})[0];          this              .Select(item=&gt;SomeGenericClassBase.ConvertToMe(item))              .ToList()              .ForEach(item=&gt;serializer.Serialize(writer, item));      }       // IList Implementation omitted - wraps a private List&lt;ISomeGenericClassBase&gt; } </code></pre>  <p>Where the list will contain instances along these lines:</p>  <pre><code>public interface ISomeGenericClassBase { }  public interface ISomeGenericBaseClass&lt;T&gt; : ISomeGenericBaseClass  { }   public class SomeGenericClassBase : ISomeGenericClassBase {     public static SomeGenericClassBase ConvertToMe(ISomeGenericClassBase target) {         return new SomeGenericClassBase() {Property1 = target.Property1; Property2 = target.Property2}     }      public static ISomeGenericBaseClass ExpantToTyped(SomeGenericClassBase target) {         // Implementation omitted - converts a base class instance to a generic instance by working out the generic type from saved data and reconstructing     } }  public class SomeGenericClass&lt;T&gt; : SomeGenericClassBase, ISomeGenericBaseClass&lt;T&gt; {     [XmlAttribute]     public string Name {get;set;}      [XmlAttribute]     public string Description{get;set;}      [XmlAttribute]     public T Value {get;set;}      [XmlElement("")]     public T[] ValidOptions {get;set;}  } </code></pre>  <p>EDIT: Expanded the implementation - realised as it was, it didn't illustrate the problem correctly</p>  <p>Core issue is that I want to be able to serialize items that only implement the interface, even if I only get back <code>SomeGenericClassBase</code> instances. Per the approach used in the <code>ExpandToTyped</code> method, I'm expecting consumers of the class to save sufficient data in <em>their</em> implementations that allow the resulting classes to be converted back into their original form as required. So yes, there's a loss of fidelity, but it's one I can live with in exchange for the flexibility of using a list of interfaces instead of a list of base classes.</p>