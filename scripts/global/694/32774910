<p>I'm looking for a clean and simple way to read a null-terminated C string from a file or file-like object in Python. In a way that doesn't consume more input from the file than it needs, or pushes it back onto whatever file/buffer it works with such that other code can read the data immediately after a null-terminated string.</p>  <p>I've seen <a href="http://bytes.com/topic/python/answers/41987-canonical-way-dealing-null-separated-lines" rel="nofollow">a bit of rather ugly code</a> to do it, but not much that I'd like to use.</p>  <p><a href="https://docs.python.org/2/library/functions.html#open" rel="nofollow">universal newlines support</a> only works for <code>open()</code>ed files, not StringIO objects etc, and doesn't look like it handles unconventional newlines. Also, if it did work it'd result in strings with <code>\n</code> appended, which is undesirable.</p>  <p><a href="https://docs.python.org/2/library/struct.html" rel="nofollow">struct</a> <a href="http://stackoverflow.com/q/26060110/398670">doesn't look like it supports reading arbitrary-length C strings at all</a>, requiring a length as part of the format.</p>  <p><a href="https://docs.python.org/2/library/ctypes.html" rel="nofollow">ctypes</a> has <code>c_buffer</code>, which can be constructed from a byte string and will return the first null terminated string as its <code>value</code>. Again, this requires determining how much must be read in advance, and it doesn't differentiate between null-terminated and unterminated strings. The same is true of <code>c_char_p</code>. So it doesn't seem to help much, since you already have to know you've read enough of the string and have to handle buffer splits.</p>  <p>The usual way to do this in C is read chunks into a buffer, copying and resizing the buffer if needed, then check if the newest chunk read contains a null byte. If it does, return everything up to the null byte and either realign the buffer or if you're being fancy, keep on reading and use it as a ring buffer. (This only works if you can hand the excess data read back to the caller, or if your platform's <code>ungetc</code> lets to push a lot back onto the file, of course.)</p>  <p>Is it necessary to spell out similar code in Python? I was surprised not to find anything canned in <code>io</code>, <code>ctypes</code> or <code>struct</code>.</p>  <p>file objects don't seem to have a way to push back onto their buffer, like <code>ungetc</code>, and neither do buffered I/O streams in the <code>io</code> module.</p>  <p>I feel like I must be missing the obvious here. I'd really rather avoid byte-by-byte reading:</p>  <pre><code>def readcstr(f):     buf = bytearray()     while True:         b = f.read(1)         if b is None or b == '\0':             return str(buf)         else:             buf.append(b) </code></pre>  <p>but right now that's what I'm doing.</p>