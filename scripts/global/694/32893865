<p>So I have this test class, I'm very clearly setting the constraints in my Deck object, but it ends up being null. Why is it doing this? I can't figure it out</p>  <pre><code>  import javax.swing.JFrame;   import java.awt.*;    class DeckTester   {      public DeckTester()      {         JFrame fr = new JFrame();         fr.setDefaultCloseOperation(fr.EXIT_ON_CLOSE);         fr.setSize(640,480);         fr.setLocation(300,200);         CardTable table = new CardTable();         table.setLayout(new FlowLayout());         Stack faceupPile = new Stack(0,-.25,true);         faceupPile.setStackRules(Stack.GRAB_FROM_TOP|Stack.FACEUP);         table.add(faceupPile);         StackRuleConstraints src = new StackRuleConstraints();         src.dropPile = faceupPile;         Deck deck = new Deck();         deck.setStackRules(deck.getStackRules(),src);         table.add(new Deck());         fr.add(table);         fr.setVisible(true);      }       public static void main(String[]args)      {         new DeckTester();      }   } </code></pre>  <p>Here are the Deck, Stack, and StackRuleConstraints classes. I have </p>  <pre><code>System.out.println("constraints are "+(ruleConstraints!=null?"not null":"null")); </code></pre>  <p>included in the mouseReleased method of variable ml and setStackRules method.</p>  <p>...</p>  <pre><code>  import java.awt.Color;    public class Deck extends Stack   {         public Deck()      {         this(false);      }       public Deck(boolean includeJokers)      {         super(0,-.25,true);         for(int rank = Card.ACE; rank &lt;= Card.KING; rank++)         {            for(int i = 0; i &lt; 4; i++)            {               int suit = (int)Math.pow(2,i);               add(new Card(rank,suit));            }         }         if(includeJokers)         {              add(new Card(Card.JOKER,Card.RED));            add(new Card(Card.JOKER,Card.BLACK));         }         setStackRules(GRAB_FROM_TOP|DRAW_PILE);         shuffle();      }   } </code></pre>  <p>...</p>  <pre><code>  import java.awt.Graphics;   import java.awt.Graphics2D;   import java.util.Collections;   import java.util.ArrayList;   import java.awt.Container;   import java.awt.Component;   import java.awt.FlowLayout;   import java.awt.Color;   import java.awt.Dimension;   import java.awt.RenderingHints;   import java.awt.Color;   import java.awt.Point;   import java.awt.event.MouseEvent;   import java.awt.event.MouseListener;   import java.awt.event.MouseAdapter;    public class Stack extends Container   {      public static final int GRAB_FROM_TOP = 1;      public static final int GRAB_BY_GROUP = 2;      public static final int ASCENDING = 4;      public static final int DESCENDING = 8;      public static final int SAME_SUITS = 16;      public static final int ALTERNATING_COLORS = 32;      public static final int DRAW_PILE = 64;      public static final int RECEPTACLE = 128;      public static final int FACEDOWN = 256;      public static final int FACEUP = 512;       private int rules = 0;      protected ArrayList&lt;Card&gt; cards = new ArrayList&lt;Card&gt;();      protected boolean accessible;      private double xOffset;      private double yOffset;      private Color outlineColor;      protected static Card selectedCard = null; //BOOKMARK we have to grab cards by the group, thus this will probably need to be a Card array      protected static Card[] groupedCards = null;      private Point clickLoc;      protected static int xOrigin;      protected static int yOrigin;      protected static int mouseX;      protected static int mouseY;      protected static Point cardOrigin;      protected static boolean dragging = false;      protected static double draggedCardXOffset;      protected static double draggedCardYOffset;      private ArrayList&lt;Card&gt; cardsToRemove = new ArrayList&lt;Card&gt;();      protected StackRuleConstraints ruleConstraints = null;       private MouseAdapter ml = new MouseAdapter()      {         public void mousePressed(MouseEvent e)         {            if((rules&amp;RECEPTACLE)&gt;0)return;            xOrigin = e.getXOnScreen();            yOrigin = e.getYOnScreen();             for(int i = 0; i &lt; cards.size(); i++)            {               if(cards.get(i).getLocationOnScreen().x&lt;xOrigin                  &amp;&amp;xOrigin&lt;cards.get(i).getLocationOnScreen().x+50                  &amp;&amp;cards.get(i).getLocationOnScreen().y&lt;yOrigin                  &amp;&amp;yOrigin&lt;cards.get(i).getLocationOnScreen().y+70)                  {                     cardsToRemove.clear();                     groupedCards = null;                     if(i!=cards.size()-1)                     {                        if((rules&amp;GRAB_FROM_TOP)&gt;0)continue;                        if((rules&amp;GRAB_BY_GROUP)&gt;0&amp;&amp;i!=cards.size()-1)                        {                           groupedCards = new Card[cards.size()-1-i];                           for(int j = i+1; j &lt; cards.size(); j++)                           {                              groupedCards[j-i-1] = cards.get(j);                              cardsToRemove.add(cards.get(j));                           }                        }                     }                     if((rules&amp;DRAW_PILE)==0&amp;&amp;!cards.get(i).isSelected())//if the card you clicked is facedown                     {                        if(i!=cards.size()-1)return; //if it's not the top card, return                        else //otherwise flip it faceup                        {                           cards.get(i).setSelected(true);                           repaint();                           return;                        }                     }                     cardOrigin = cards.get(i).getLocationOnScreen();                     selectedCard = cards.get(i);                     draggedCardXOffset = xOffset;                     draggedCardYOffset = yOffset;                  }            }         }          public void mouseDragged(MouseEvent e)         {            if(!dragging&amp;&amp;selectedCard!=null)            {               remove(selectedCard);               for(Card c: cardsToRemove)System.out.println("moving "+c.toString());               if(cardsToRemove.size()&gt;0)for(int i = 0; i &lt; cardsToRemove.size(); i++){remove(cardsToRemove.get(i));}               dragging = true;            }            mouseX = e.getXOnScreen();            mouseY = e.getYOnScreen();            getParent().repaint();         }          public void mouseReleased(MouseEvent e)         {            System.out.println("constraints are "+(ruleConstraints!=null?"not null":"null"));            if(dragging)ADDING_CARD_TO_STACK:            {               for(Component c: getParent().getComponents())               {                  if(c instanceof Stack                     &amp;&amp;e.getXOnScreen()&gt;c.getLocationOnScreen().x                     &amp;&amp;e.getXOnScreen()&lt;c.getLocationOnScreen().x+c.getWidth()                     &amp;&amp;e.getYOnScreen()&gt;c.getLocationOnScreen().y                     &amp;&amp;e.getYOnScreen()&lt;c.getLocationOnScreen().y+c.getHeight()                     &amp;&amp;selectedCard!=null                     &amp;&amp;(((Stack)c).rules&amp;DRAW_PILE)==0)                     {                        ((Stack)c).add(selectedCard);                        if(groupedCards!=null)for(Card card: groupedCards)((Stack)c).add(card);                        break ADDING_CARD_TO_STACK;                     }               }               if(dragging&amp;&amp;selectedCard!=null){add(selectedCard);if(groupedCards!=null)for(Card card: groupedCards)add(card);}            }            else {if((rules&amp;DRAW_PILE)&gt;0&amp;&amp;ruleConstraints!=null){System.out.println("criteria met");if(ruleConstraints.dropPile!=null){remove(selectedCard);ruleConstraints.dropPile.add(selectedCard);}}}            selectedCard = null;            groupedCards = null;            cardsToRemove.clear();            dragging = false;            getParent().repaint();         }      };       public Stack()      {         this(true);      }       public Stack(boolean accessible)      {         this(0,0,accessible);      }       public Stack(double xOffset, double yOffset, boolean accessible)      {         this(new Color(5,250,10),xOffset,yOffset,accessible);      }       public Stack(Color outlineColor, double xOffset, double yOffset, boolean accessible)      {         super();         this.xOffset = xOffset;         this.yOffset = yOffset;         this.accessible = accessible;         this.outlineColor = outlineColor;         setPreferredSize(new Dimension((int)(50+Math.max(2,Math.abs(getXOffset())*cards.size())),(int)(70+Math.max(2,.25*54)+(getYOffset()&lt;0?0:getYOffset()*cards.size()))));         addMouseListener(ml);         addMouseMotionListener(ml);      }       public void setStackRules(int rules)      {         this.rules = rules;      }       public void setStackRules(int rules, StackRuleConstraints constraints)      {         this.rules = rules;         ruleConstraints = constraints;         System.out.println("constraints are "+(ruleConstraints!=null?"not null":"null"));      }       public int getStackRules()      {         return rules;      }       public Color getOutlineColor()      {         return outlineColor;      }       public void setOutlineColor(Color c)      {         outlineColor = c;         repaint();      }       public void setXOffset(double xOffset)      {         this.xOffset = xOffset;      }       public void setYOffset(double yOffset)      {         this.yOffset = yOffset;      }       public double getXOffset()      {         return xOffset;      }       public double getYOffset()      {         return yOffset;      }        public void shuffle()      {         Collections.shuffle(cards);         super.removeAll();         for(int i = 0; i &lt; cards.size();i++)super.add(cards.get(i));      }       public void remove(Card c)      {         cards.remove(c);         super.remove(c);         setPreferredSize(new Dimension((int)(50+Math.max(2,Math.abs(getXOffset())*cards.size())),(int)(70+Math.max(2,.25*54)+(getYOffset()&lt;0?0:getYOffset()*cards.size()))));         setSize(getPreferredSize());         repaint();      }    //    public Card drawCard()   //    {   //       if(cards.size()&gt;0)   //       {   //          Card c = cards.get(cards.size()-1);   //          remove(c);   //          cards.remove(cards.size()-1);   //          return c;   //       }   //       else return null;   //    }       public void add(Card c)      {         cards.add(c);         super.add(c);         if((rules&amp;FACEUP)&gt;0)c.setSelected(true);         if((rules&amp;FACEDOWN)&gt;0)c.setSelected(false);         setPreferredSize(new Dimension((int)(50+Math.max(2,Math.abs(getXOffset())*cards.size())),(int)(70+Math.max(2,.25*54)+(getYOffset()&lt;0?0:getYOffset()*cards.size()))));         setSize(getPreferredSize());         repaint();      }       @Override      public void paint(Graphics gi)      {         Graphics2D g = (Graphics2D)gi;         g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);         g.setColor(outlineColor);         g.fillRoundRect(0,(int)(.25*54)-2,52,72,10,10);         g.setColor(getParent().getBackground());         g.fillRoundRect(2,(int)(.25*54),48,68,5,5);         double x = 1;         double y = .25*54-1;         for(int i = 0; i &lt; cards.size(); i++)         {            cards.get(i).setLocation((int)x,(int)y);            g.drawImage(cards.get(i).getCurrentImage(),(int)x,(int)y,null);            x+=xOffset;            y+=yOffset;         }         super.paint(g);      }   } </code></pre>  <p>...</p>  <pre><code>  public class StackRuleConstraints   {      public Stack dropPile = null;       public StackRuleConstraints()      {       }   } </code></pre>  <p>The output is "constraints are not null" "constraints are null"</p>