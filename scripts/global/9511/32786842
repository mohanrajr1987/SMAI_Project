<p>When using jersey, I am encountering an OOM exception serving large files. I thought that by using <code>StreamingOutput</code>, I would avoid keeping the entire file in memory and therefore avoid an OOM exception, but that doesn't seem to be the case. This is how we are building the <code>StreamingOutput</code>:</p>  <pre><code>StreamingOutput streamingOutput = new StreamingOutput() {                 @Override                 public void write(OutputStream outputStream) throws IOException, WebApplicationException {                     final InputStream is = tis.getInputStream();                     byte[] bbuf = new byte[1024 * 8];                     long total = 0;                     int length;                     while ((is != null) &amp;&amp; ((length = is.read(bbuf)) != -1)) {                         outputStream.write(bbuf, 0, length);                         total += length;                         log.trace("Copied {} of {}", total, tis.getFileLength());                     }                     outputStream.flush();                     is.close();                     outputStream.close();                 }             };              responseBuilder = Response.ok(streamingOutput, tis.getStreamType()); </code></pre>  <p>tis is a typedInputStream... </p>  <p>Am I just mistaken in thinking that this should prevent the entire file from being in memory? I am using tomcat 7. I have about a gig of free heap, so when I try to download a 1.5 gig file, an OOM exception is thrown. Is there a mistake in this code? Looking at the heap dump, it seems all of the memory is being used by a byte array, I'm not sure if I can use the heap dump to figure out exactly where in the code that byte array is being initialized. </p>