<h3>Background/Example:</h3>  <p>I currently have a class like the following:</p>  <pre><code>class Element {   Large l1;   OtherLarge l2;   Small s1;   VerySmall s2; }; </code></pre>  <p>where <code>Large</code> and <code>OtherLarge</code> are relatively big (~80 bytes) whereas <code>Small</code> and <code>VerySmall</code> are fairly small (~4 to 16 Byte).</p>  <p>On these elements, I operate in two ways:</p>  <ul> <li>sorting them in various ways. During this, only members <code>s1</code> and <code>s2</code> are accessed/needed.</li> <li>combining the large members in various way (e.g. matrix-matrix multiplication).</li> </ul>  <p>The second class of operations is already fairly fast and can be parallelised easily, hence I’d like to speed up the first class of operations more. Comparing with another class <code>Element2</code> where I replaced the two big data members by 8-byte integers doing nothing tells me that if I can somehow replace the direct data members <code>l1</code> and <code>l2</code> by pointers of one sort or another to dynamically-allocated elements elsewhere, I’ll already get a big win.</p>  <p>For reference, all member types have both copy and move constructors and can be both copied and moved, but moving them is much much cheaper. <code>Large</code> and <code>OtherLarge</code> also allocate a lot of memory by themselves, so allocating a bit more isn’t necessarily horrible.</p>  <h3>Concrete question</h3>  <p>Is it possible, and if so, what is the best way, to replace a direct member object of a class with a pointer to a dynamically-allocated object elsewhere; preserving the behaviour of a direct member as closely as possible w.r.t construction, destruction, member variable access etc? If I use a <code>std::unique_ptr&lt;Large&gt;</code> naively, I assume I’ll have to dereference it half the time/take care of copying specially? Ideally I’d like the new member object to behave just as if the old, big member object was still there.</p>