<p>I've got a simple program that stores sets of 3 variables using two classes, one called <code>Stock</code> which has the 3 variable definitions, along with basic inspector and mutator functions, and a second function called <code>StockManagement</code> that has a pointer to <code>Stock</code> and some other functions that do all sorts of things such as creating a dynamic array of <code>Stock</code>, dumping a files data into the array we just made and so on and so forth.</p>  <p>Everything works fine in terms of creating the stuff (such as the constructor, array, entering data, reading data) but when it comes to the destructor, there is a chance that SOMETIMES the program will seg fault at the delete command, and the times it doesn't, the data is still accessable for some reason or another.</p>  <p>Here's what I believe to be the important parts of the code</p>  <p>Header file</p>  <pre><code>class Stock { private:     char tag[5];     int cost;     long volume;  public:     // mutator and inspector functions  }  class StockManagement { private:     Stock* data;     int size;  public:     StockManagement();     ~StockManagement();     // other functions } </code></pre>  <p>Cpp file (the proper name escapes me)</p>  <pre><code>...  StockManagement::StockManagement() {     data = NULL;     size = 0; }  StockManagement::~StockManagement() {     if (data != NULL) {         std::cout &lt;&lt; data[0].getTag() &lt;&lt; std::endl; // Debug line         delete [] data;         std::cout &lt;&lt; data[0].getTag() &lt;&lt; std::endl; // Debug line          data = NULL;         size = 0;     } }  void StockManagement::allocateMemory() {     data = new Stock[size]; }  ... </code></pre>  <p>So at the point in time when calling the destructor, there is always data in there. Theres a function always called that gets the amount of lines from a file (and saves it as <code>size</code>) which is used to allocate the memory, in which data is then entered into the array.</p>  <p>Then comes time to use the destructor. The first cout line will always output, as expected. Then theres a chance that either two things happen from then on. We seg fault at the delete line, or we go over it, calling the second cout and somehow printing the same data we printed the first time.</p>  <p>So obviously the data wasn't deleted. But why? And why does this only happen sometimes and other times it just straight up seg faults?</p>