<p>Simplest 2 table definition in EF code-first with foreign key.</p>  <pre><code>public class Blog {     [Key]     public int BlogId { get; set; }     public string Name { get; set; }      public virtual List&lt;Post&gt; Posts { get; set; } }  public class Post {     [Key, Column(Order = 0)]     public int BlogId { get; set; }      [Key, Column(Order = 1)]     public int PostId { get; set; }     public string Title { get; set; }     public string Content { get; set; }      public virtual Blog Blog { get; set; } } </code></pre>  <p>Generates</p>  <pre><code>CREATE TABLE [dbo].[Blogs] (     [BlogId] [int] NOT NULL IDENTITY,     [Name] [nvarchar](max),     CONSTRAINT [PK_dbo.Blogs] PRIMARY KEY ([BlogId]) ) CREATE TABLE [dbo].[Posts] (     [BlogId] [int] NOT NULL,     [PostId] [int] NOT NULL,     [Title] [nvarchar](max),     [Content] [nvarchar](max),     CONSTRAINT [PK_dbo.Posts] PRIMARY KEY ([BlogId], [PostId]) )  CREATE INDEX [IX_BlogId] ON [dbo].[Posts]([BlogId])  ALTER TABLE [dbo].[Posts]     ADD CONSTRAINT [FK_dbo.Posts_dbo.Blogs_BlogId]     FOREIGN KEY ([BlogId]) REFERENCES [dbo].[Blogs] ([BlogId])         ON DELETE CASCADE </code></pre>  <p><code>BlogId</code> is the 1st column in composite index to maintain primary key, hence <code>IX_BlogId</code> is redundant and wonâ€™t be used ever.</p>  <p>What was the point creating it?</p>  <p>There were similar questions discussing indexing foreign key column, but not redundant indexes:  <a href="http://stackoverflow.com/questions/29707363/entity-framework-indexing-all-foreign-key-columns">Entity Framework Indexing ALL foreign key columns</a></p>  <p><a href="http://stackoverflow.com/questions/22225796/entity-framework-code-first-foreign-key-adding-index-as-well">Entity Framework Code First Foreign Key adding Index as well</a></p>  <p>IMO, there is no universal answer, i.e. "it depends". It should be an easy way to disable index creation.</p>