<p>In my Laravel app I have the following schema (and corresponding models):</p>  <pre><code>clients     id - integer (primary)     name - string  accounts     id - integer (primary)     account_id - string (unique)     client_id - integer (foreign, references id on clients)     name - string  contracts     id - integer (primary)     account_id - string (foreign, references account_id on accounts)     title - string </code></pre>  <p>I want a <code>hasManyThrough</code> relationship so I can get all the contracts for a given Client, so I define the relationship in my <code>Client</code> model:</p>  <pre><code>public function contracts() {     return $this-&gt;hasManyThrough('Contract', 'Account', 'client_id', 'account_id'); } </code></pre>  <p>This doesn't work. The reason being that the relationship between <code>Contract</code> and <code>Account</code> is joined by <code>contracts.account_id = account.account_id</code> (<strong>not</strong> <code>contracts.account_id = account.id</code>).</p>  <p>This is an unconventional relationship by is necessary for the structure of the application. However there seems to not be a way to define the joined key on the intermediate model.</p>  <p>Is there a way to get around this or do I need to construct the query myself?</p>  <p><strong>Update</strong></p>  <p>Currently, the way I'm working around this is to use a query scope. On my <code>Contract</code> model I add the following:</p>  <pre><code>public function scopeForClient($query, Client $client) {     return $query-&gt;whereIn('account_id', $client-&gt;accounts-&gt;lists('account_id')); } </code></pre>  <p>This allows me to do <code>Contract::forClient($client);</code> which is almost as elegant but probably is slightly worse performance due to eager loading the accounts as well as the lists operation.</p>  <p>Having the relationship work properly would still be preferable.</p>