<p>I am on a Red Hat 7 server and i want to make a C server to connect 1Million clients simultaneously. </p>  <p><code>ulimit -n</code> output is 1000000</p>  <pre><code>sudo vi /etc/security/limits.conf </code></pre>  <p>contains at the end </p>  <pre><code>*         hard    nofile      1000000 *         soft    nofile      1000000 root      hard    nofile      1000000 root      soft    nofile      1000000 </code></pre>  <p><br></p>  <pre><code>sudo vi /etc/sysctl.conf </code></pre>  <p>contains at some point</p>  <pre><code>fs.file-max = 90000000000000 </code></pre>  <p>when i <strong>don't run</strong> my C server the output of my<br></p>  <pre><code>cat /proc/sys/fs/file-nr </code></pre>  <p>is </p>  <pre><code>5184    0   90000000000000 </code></pre>  <p>when i <strong>run</strong> my C server the output of my<br></p>  <pre><code>cat /proc/sys/fs/file-nr </code></pre>  <p>is </p>  <pre><code>116537  0   90000000000000 </code></pre>  <p><br> I can connect around 55000 clients and because i run the server and the clients on the same machine it means 2 file descriptors foreach client, so... i have that number 116537. But why not more, when i raised every system limit i found about that has something to do with my problem? <br> <br> that's the server</p>  <pre><code>#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;netdb.h&gt; #include &lt;netinet/in.h&gt; #include &lt;string.h&gt;  int main( int argc, char *argv[] ) {    int sockfd, newsockfd, portno, clilen;    char buffer[256];    struct sockaddr_in serv_addr, cli_addr;    int  n, pid;    int son=0;        /* First call to socket() function */    sockfd = socket(AF_INET, SOCK_STREAM, 0);     if (sockfd &lt; 0)       {       perror("ERROR opening socket");       exit(1);       }     /* Initialize socket structure */    bzero((char *) &amp;serv_addr, sizeof(serv_addr));    portno = 5001;     serv_addr.sin_family = AF_INET;    serv_addr.sin_addr.s_addr = INADDR_ANY;    serv_addr.sin_port = htons(portno);     /* Now bind the host address using bind() call.*/    if (bind(sockfd, (struct sockaddr *) &amp;serv_addr, sizeof(serv_addr)) &lt; 0)       {       perror("ERROR on binding");       exit(1);       }     /* Now start listening for the clients, here  *    * process will go in sleep mode and will wait  *       * for the incoming connection  *          */     listen(sockfd, SOMAXCONN);    clilen = sizeof(cli_addr);     while (1)    {       newsockfd = accept(sockfd, (struct sockaddr *) &amp;cli_addr, &amp;clilen);       if (newsockfd &lt; 0)          {          perror("ERROR on accept");          exit(1);          }        son++;        if(son % 1000 == 0)              printf("client nr %d connected with fd %d\n", son, newsockfd);     } /* end of while */ } </code></pre>  <p>that's the client</p>  <pre><code>#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;netdb.h&gt; #include &lt;netinet/in.h&gt; #include &lt;string.h&gt;  int main(int argc, char *argv[]) {    int sockfd, portno, n;    struct sockaddr_in serv_addr;    struct hostent *server;     char buffer[256];     if (argc &lt;3) {       fprintf(stderr,"usage %s hostname port\n", argv[0]);       exit(0);    }    portno = atoi(argv[2]);    server = gethostbyname(argv[1]);     if (server == NULL) {       fprintf(stderr,"ERROR, no such host\n");       exit(0);    }     bzero((char *) &amp;serv_addr, sizeof(serv_addr));    serv_addr.sin_family = AF_INET;    bcopy((char *)server-&gt;h_addr, (char *)&amp;serv_addr.sin_addr.s_addr, server-&gt;h_length);    serv_addr.sin_port = htons(portno);      int ionut;     for(ionut=0; ionut&lt;90000; ionut++) {       /* Create a socket point */      sockfd = socket(AF_INET, SOCK_STREAM, 0);      if(ionut % 1000 == 0) {         printf("connected 1000 sockets\n");          // sleep(1);      }      if (sockfd &lt; 0)      {         perror("ERROR opening socket");         exit(1);      }      /* Now connect to the server */      if (connect(sockfd, (struct sockaddr*)&amp;serv_addr, sizeof(serv_addr)) &lt; 0)      {         perror("ERROR connecting");         exit(1);      }     }    return 0; } </code></pre>