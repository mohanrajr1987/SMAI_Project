<p>I have a C++ service, which exposes 2 interfaces:</p>  <p>a. Submit(): For submitting a DistCp job to YARNRM</p>  <p>b. Query(): For querying the status of the application. </p>  <p>This service internally calls a Java client (through JNI), which has 2 static functions:</p>  <ol> <li><p>Submit()</p></li> <li><p>Query()</p></li> </ol>  <p>Submit() does:</p>  <pre><code>DistCp distCp = new DistCp(configuration, distCpOptions); Job job = distCp.execute(); Parses the "application ID" from the tracking URL and returns it. </code></pre>  <p>Query() does: </p>  <pre><code>Takes "application ID" returned in Submit() YarnClient yarnClient = YarnClient.createYarnClient(); yarnClient.init(new YarnConfiguration()); yarnClient.start(); yarnClient.getApplicationReport(applicationID);  yarnClient.stop(); </code></pre>  <p>The problem I am facing is,</p>  <ol> <li>If the first call to the service is Submit(), then all the subsequent calls (both Submit() and Query()) SUCCEED</li> <li>But, if the first call to the service is Query(), then all the Submit() calls FAIL. </li> </ol>  <p>Query() calls succeed under all the conditions.</p>  <p>The Submit() calls fail with errors (1st call, 2nd call and 3rd call below, with different exceptions):</p>  <ol> <li>java.util.ServiceConfigurationError: org.apache.hadoop.mapreduce.protocol.ClientProtocolProvider: Provider org.apache.hadoop.mapred.LocalClientProtocolProvider not found</li> <li>java.util.ServiceConfigurationError: org.apache.hadoop.mapreduce.protocol.ClientProtocolProvider: Provider org.apache.hadoop.mapred.YarnClientProtocolProvider not found</li> <li>java.io.IOException: Cannot initialize Cluster. Please check your configuration for mapreduce.framework.name and the correspond server addresses.</li> </ol>  <p>I debugged the issue and figured out that, when Query() API is called first, then classes "LocalClientProtocolProvider" and "YarnClientProtocolProvider" are not loaded. The class loader should load these classes, when Submit() is called. But, that is not happening.</p>  <p>I also observed that, when the Query() API is called first, the Hadoop configuration gets changed and contains lot many default settings related to "mapreduce.*" configuration.</p>  <p>I tried explicit loading using Class.forName(), as soon as the Submit() method is called. But, that did not help either.</p>  <p>When Submit() is called, why does not the class loader load the required classes? Is this the problem with Hadoop configuration or Java class loader? Or is it the problem because I am mixing MapReduce and Yarn APIs?</p>  <p>"mapreduce.framework.name" configuration is set to "yarn".</p>  <p>My environment is Hadoop 2.6.0.</p>  <p>My classpath contains, all the Hadoop jars present in following paths:</p>  <p>a. hadoop/common/</p>  <p>b. hadoop/common/lib</p>  <p>c. hadoop/hdfs/</p>  <p>d. hadoop/hdfs/lib</p>  <p>e. hadoop/mapreduce/</p>  <p>f. hadoop/mapreduce/lib</p>  <p>g. hadoop/yarn/</p>  <p>h. hadoop/yarn/lib</p>  <p><strong>EDIT 1:</strong></p>  <p>I figured out that, I am mixing Yarn and MapReduce APIs and that is causing some problems. When Query() is called first, it loads all YARN related classes. For e.g.</p>  <p>org.apache.hadoop.yarn.client.api.YarnClient from file:/D:/data/hadoop-2 .6.0-SNAPSHOT/share/hadoop/yarn/hadoop-yarn-client-2.6.0-SNAPSHOT.jar</p>  <p>But, the MapReduce related classes are not loaded. For e.g. </p>  <p>org.apache.hadoop.mapred.YarnClientProtocolProvider from file:/D:/data/h adoop-2.6.0-SNAPSHOT/share/hadoop/mapreduce/hadoop-mapreduce-client-jobclient-2. 6.0-SNAPSHOT.jar </p>  <p>So, when the Submit() is called, the class loader assumes that, it has loaded all the required classes. But, classes "YarnClientProtocolProvider" and "LocalClientProtocolProvider" are not loaded yet. Hence, the Submit() call fails.</p>  <p>To force the class loader to load all the MapReduce related classes, I added following statements in the constructor for YarnClientWrapper (which is a singleton class).</p>  <pre><code>Cluster cluster = new Cluster(configuration); cluster.getFileSystem(); cluster.close(); </code></pre>  <p>This resolved the issue.  But, cleaner implementation would be to use MapReduce client in Query() instead of YarnClient. This will ensure that, we will not get into class loading issues.</p>