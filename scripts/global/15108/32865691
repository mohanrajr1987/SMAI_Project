<p>I'm using Django 1.8 and I have an Image class that looks like this:</p>  <pre><code># The `child` class class Image(models.Model):     content_type = models.ForeignKey(ContentType)     object_id = models.PositiveIntegerField()      related_object = GenericForeignKey('content_type', 'object_id')      image = models.ImageField(...)      def clean(self):         related_class = self.content_type.model_class()         # Do some validation that relies on the related_class </code></pre>  <p>And a "parent" class that has a GenericRelation to it:</p>  <pre><code># The `parent` class class Product(models.Model):     ...     images = GenericRelation('Image') </code></pre>  <p>This is my (simplified) view:</p>  <pre><code>from django.shortcuts import render, get_object_or_404 from django.views.generic import View from django.contrib.contenttypes.forms import generic_inlineformset_factory  ProductImageInlineFormset = generic_inlineformset_factory(     Image, extra=1)  class ProductImageView(View):     ...     def post(self, request, id):         product = get_object_or_404(Product.objects.by_id(id))         image_formset = ProductImageInlineFormset(             request.POST, request.FILES, instance=product)         # I SHOULDN'T NEED THE FOLLOWING TWO LINES -&gt;         # for form in image_formset:         #     form.instance.related_object = product         import ipdb; ipdb.set_trace()          if image_formset.is_valid():             image_formset.save()          return render(request, self.template,                       context={'cid': id, 'formset': image_formset}) </code></pre>  <p>When I inspect the formset in ipdb, this is what I get:</p>  <pre><code>ipdb&gt; image_formset.forms[0].instance.related_object is None True </code></pre>  <p>This is causing problems because when I get to <code>Image.clean()</code> I get an error:</p>  <pre><code>django.db.models.fields.related.RelatedObjectDoesNotExist: Image has no content_type. </code></pre>  <p>If I uncomment those two lines I mentioned I don't need, it works and I don't get the error anymore. But isn't the automatic linking of forms to their models and related models the whole point of using the <code>BaseGenericInlineFormSet</code>? If I have to manually hack the ImageForm instances and attach a <code>Product</code> instance to its <code>related_object</code>, then I might as well use a simple ModelFormSet. Am I missing something?</p>  <p><strong>UPDATE</strong></p>  <p>If I comment <code>Image.clean</code> out, the code works even without the manual attachment of related objects. This means the BaseGenericInlineFormSet does handle the linking after all, but it does so AFTER it calls <code>clean</code> on the child model, which is really not ok considering that Model.clean "<a href="https://docs.djangoproject.com/en/1.8/ref/models/instances/#django.db.models.Model.clean" rel="nofollow">should be used to provide custom model validation</a>". I'm taking a look at the Django source but haven't yet figured out exactly where it does the linking. Tips are welcome.</p>  <p><strong>UPDATE 2</strong></p>  <p>Apparently the linking is done in the InlineFormSet <code>save_new</code> method:</p>  <pre><code>def save_new(self, form, commit=True):     setattr(form.instance, self.ct_field.get_attname(),         ContentType.objects.get_for_model(self.instance).pk)     setattr(form.instance, self.ct_fk_field.get_attname(),         self.instance.pk)     return form.save(commit=commit) </code></pre>  <p><a href="https://github.com/django/django/blob/master/django/contrib/contenttypes/forms.py#L46" rel="nofollow">https://github.com/django/django/blob/master/django/contrib/contenttypes/forms.py#L46</a></p>  <p>As an experiment, I've moved that code to a custom <code>_construct_form</code> method:</p>  <pre><code> def _construct_form(self, i, **kwargs):      form = super()._construct_form(i, **kwargs)      setattr(form.instance, self.ct_field.get_attname(),          ContentType.objects.get_for_model(self.instance).pk)      setattr(form.instance, self.ct_fk_field.get_attname(),          self.instance.pk)      return form </code></pre>  <p>It solved my problem. This way I don't have to do that manual linking. I haven't run the tests or written a patch but this could be a first step if someone decides to do it in the future (perhaps myself at one point).</p>  <p>For now I'm keeping my solution with manual linking though. Don't want to work with a hacked version of Django.</p>