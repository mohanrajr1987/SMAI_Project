<p>I have to write t-sql merge statement where I have to meet multiple conditions to match. </p>  <p>Table column names: ID, emailaddress, firstname, surname, titile, mobile, dob, accountnumber, address, postcode</p>  <p>The main problem here is that, the database I am working with does not have mandatory fields, there is no primary keys to compare, and source table can have duplicates records as well. As a result, there are many combination to check for the duplicates of source table against the target table. My manager have come up with following scenario  </p>  <ol> <li><p>We could have data where two people using same email address so emailaddress, firstname and surname match is 100% match (thinking all other columns else are empty)</p></li> <li><p>data where mobile and accountnumber match is 100% match (thinking all other columns else are empty) </p></li> <li><p>title, surname, postcode, dob match is 100% match (thinking all other columns else are empty)</p></li> </ol>  <p>I have given a job where I cannot see the data because I am a new recruit and my employee does not want to me to give me data to work with. So, I am kind of working with my imagination.</p>  <p>The solution Now, I am thinking rather than checking the existing record of source against target database, I will cleanse the source data using stored procedure statements, where if it meets one duplicate condition then it will skip the next duplicate removing statements and insert the data into target table.</p>  <pre><code>with cte_duplicate1 AS     (         select emailaddress, sname, ROW_NUMBER() over(partition by emailaddress, sname order by emailaddress) as dup1         from DuplicateRecordTable1     )     delete from cte_duplicate1     where dup1&gt;1; </code></pre>  <p>(if the first cte_duplicate1 code was executed then it will skip the cte_duplicate2)</p>  <pre><code>with cte_duplicate2 AS     (         select emailaddress, fname, ROW_NUMBER() over(partition by emailaddress, fname order by emailaddress) as dup2         from DuplicateRecordTable1     ) delete from cte_duplicate2 where dup2&gt;1; </code></pre>  <p>That is the vague plan at the moment. I do not know yet, if it achievable or not.</p>