<p>I'm writing an application that calculates the ranking of teams in the pool stages of a rugby competition <em>(Rugby World Cup 2015, but it could apply to many other pool-based competitions)</em>.</p>  <p>At the completion of the pool phase, points are calculated based on wins/draws/losses/bonus points, and teams are ranked by points.  <strong>If two or more teams are level on points, then the winner of the match in which two tied teams have played each other shall be the higher ranked.</strong>  Once this initial ranking is complete, other criteria (points difference, tries difference, points scored, tries scored) are applied to complete the ranking process.</p>  <p><strong>I have written a query that does ALL of the above, EXCEPT the first ranking criteria - two teams level on points should be ordered based on the winner of the match in which the two teams played.</strong></p>  <p>Here is my database schema:</p>  <pre><code>[TEAM]        [MATCH] -TeamId       -MatchId -TeamName     -HomeTeamId -Pool         -AwayTeamId               -HomeTeamScore               -HomeTeamTries               -AwayTeamScore               -AwayTeamTries </code></pre>  <p>Here is the SQL Server query I use to calculate the ranking/standings for a given pool:</p>  <pre><code>WITH PoolResults ([MatchId], [TeamId], [Team], [P], [W], [D], [L], [PF], [PA], [PD], [TF], [TA], [TD], [PTS], [BP])  AS (SELECT          M.[MatchId],          M.[HomeTeamId] AS [TeamId],          HT.[TeamName],          1 AS [P],          CASE WHEN M.[HomeTeamScore] &gt; M.[AwayTeamScore] THEN 1 ELSE 0 END AS [W],          CASE WHEN M.[HomeTeamScore] = M.[AwayTeamScore] THEN 1 ELSE 0 END AS [D],          CASE WHEN M.[HomeTeamScore] &lt; M.[AwayTeamScore] THEN 1 ELSE 0 END AS [L],          M.[HomeTeamScore] AS [PF],          M.[AwayTeamScore] AS [PA],          (M.[HomeTeamScore] - M.[AwayTeamScore]) AS [PD],          M.[HomeTeamTries] AS [TF],          M.[AwayTeamTries] AS [TA],          (M.[HomeTeamTries] - M.[AwayTeamTries]) AS [TD],          CASE              WHEN M.[HomeTeamScore] &gt; M.[AwayTeamScore] THEN 4              WHEN M.[HomeTeamScore] = M.[AwayTeamScore] THEN 2              WHEN M.[HomeTeamScore] &lt; M.[AwayTeamScore] THEN 0          END AS [PTS],          CASE              WHEN ((M.[AwayTeamScore] - M.[HomeTeamScore]) BETWEEN 1 AND 7) AND M.[HomeTeamTries] &gt;= 4 THEN 2              WHEN ((M.[AwayTeamScore] - M.[HomeTeamScore]) BETWEEN 1 AND 7) THEN 1              WHEN M.[HomeTeamTries] &gt;= 4 THEN 1              ELSE 0          END AS [BP]      FROM          Match AS M          INNER JOIN Team AS HT              ON M.[HomeTeamId] = HT.[TeamId]      WHERE          M.[HomeTeamScore] IS NOT NULL          AND HT.[Pool] = @Pool      UNION       SELECT          M.[MatchId],          M.[AwayTeamId] AS [TeamId],          AT.[TeamName],          1 AS [P],          CASE WHEN M.[AwayTeamScore] &gt; M.[HomeTeamScore] THEN 1 ELSE 0 END AS [W],          CASE WHEN M.[AwayTeamScore] = M.[HomeTeamScore] THEN 1 ELSE 0 END AS [D],          CASE WHEN M.[AwayTeamScore] &lt; M.[HomeTeamScore] THEN 1 ELSE 0 END AS [L],          M.[AwayTeamScore] AS [PF],          M.[HomeTeamScore] AS [PA],          (M.[AwayTeamScore] - M.[HomeTeamScore]) AS [PD],          M.[AwayTeamTries] AS [TF],          M.[HomeTeamTries] AS [TA],          (M.[AwayTeamTries] - M.[HomeTeamTries]) AS [TD],          CASE              WHEN M.[AwayTeamScore] &gt; M.[HomeTeamScore] THEN 4              WHEN M.[AwayTeamScore] = M.[HomeTeamScore] THEN 2              WHEN M.[AwayTeamScore] &lt; M.[HomeTeamScore] THEN 0          END AS [PTS],          CASE              WHEN ((M.[HomeTeamScore] - M.[AwayTeamScore]) BETWEEN 1 AND 7) AND M.[AwayTeamTries] &gt;= 4 THEN 2              WHEN ((M.[HomeTeamScore] - M.[AwayTeamScore]) BETWEEN 1 AND 7) THEN 1              WHEN M.[AwayTeamTries] &gt;= 4 THEN 1              ELSE 0          END AS [BP]      FROM          Match AS M          INNER JOIN Team AS AT              ON M.[AwayTeamId] = AT.[TeamId]      WHERE          M.[AwayTeamScore] IS NOT NULL          AND AT.[Pool] = @Pool      )  SELECT ROW_NUMBER()      OVER (ORDER BY              SUM([BP] + [PTS]) DESC,              SUM([PD]) DESC,              SUM([TD]) DESC,              SUM([PF]) DESC,              SUM([TF]) DESC) AS [Position],      [TeamId],      [TeamName],      SUM([P]) AS [P],      SUM([W]) AS [W],      SUM([D]) AS [D],      SUM([L]) AS [L],      SUM([PF]) AS [PF],      SUM([PA]) AS [PA],      SUM([PD]) AS [PD],      SUM([TF]) AS [TF],      SUM([TA]) AS [TA],      SUM([BP]) AS [BP],      SUM([BP] + [PTS]) AS [PTS]  FROM      PoolResults  GROUP BY      [TeamId],      [TeamName]; </code></pre>  <p>As mentioned before, this does everything EXCEPT take into consideration ranking of two teams on the same points based on who won the game between them.  <strong>Does anyone have a suggestion on how to do this initial ranking?</strong></p>  <p><strong>===== UPDATE TO ORIGINAL POST =====</strong></p>  <p><strong>CLARIFICATION</strong> - There can be more than 2 teams on equal points, in which case each combination of 2 teams must be evaluated to determine rankings.  The following sample on SqlFiddle illustrates a scenario with 5 teams in a pool, where 3 teams have the same number of points - <a href="http://sqlfiddle.com/#!6/c0701/3" rel="nofollow">http://sqlfiddle.com/#!6/c0701/3</a></p>  <p>Query #1 shows the raw match data (which teams played and the scores)</p>  <p>Query #2 shows the unsorted pool standings:</p>  <pre><code>Australia (10) England (10) Fiji (5) Uruguay (0) Wales (10) </code></pre>  <p>Query #3 shows the pool standings sorted by points:</p>  <pre><code>Australia (10) England (10) Wales (10) Fiji (5) Uruguay (0) </code></pre>  <p>However, the real order should be:</p>  <pre><code>Wales (10) England (10) Australia (10) Fiji (5) Uruguay (0) </code></pre>  <p>with Wales ranked above England, because Wales beat England, and England ranked above Australia because England beat Australia</p>