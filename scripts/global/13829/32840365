<p>I have a piece of code I only want to execute once, but it's possible to get several requests at the same time, more specifically, a document operation.</p>  <p>The logic is the first thread to arrive does the code and the others wait for the first one to finish and then all return.</p>  <p>Since this can happen to any document, I created a dictionary that holds the locking object for each document (by id)</p>  <pre><code>private static readonly object LockFetchDocument = new object(); private static readonly Dictionary&lt;int, object&gt; DocumentLocks = new Dictionary&lt;int, object&gt;();  //Let's add the monitor for this document (this has to be thread-safe too) lock (LockFetchDocument) {     if (!DocumentLocks.ContainsKey(docModel.DocumentId))     {         DocumentLocks.Add(docModel.DocumentId, new object());     } }  //let's aquire the Monitor for this document so we don't prefetch the same document at the same time if (!Monitor.TryEnter(DocumentLocks[docModel.DocumentId])) {     //document is being exported, let's wait for it to end     lock (DocumentLocks[docModel.DocumentId])     {         //document was exported, return         return;     } }  //Monitor aquired try {     //DO WORK } finally {     //Let's release the monitor for this document     lock (DocumentLocks[docModel.DocumentId])     {         Monitor.Exit(DocumentLocks[docModel.DocumentId]);     } } </code></pre>  <p>Is this logic good? In order to make the dictionary adding, I use another locker. But I get a Resharper warning that the Monitor.TryEnter is not inside synchronization block. Is it needed?</p>