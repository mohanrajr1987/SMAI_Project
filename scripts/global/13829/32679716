<p>Sometimes I want to start a thread but I want to know whether or not it <strong>started and initialized</strong> correctly and handle an exception instead. Usually (without the thread) I can do something like this:</p>  <pre><code>try:     do_something() except:     some error handling </code></pre>  <p>With another thread of course I can't handle exceptions like this because the spawning function returns immediately and only throws when starting the thread itself fails.</p>  <p>So what I would <strong>like</strong> to do is s.th. like this:</p>  <pre><code>try:     t = thread(my_fn)     t.initialize()     t.proceed() except:     some error handling </code></pre>  <p>With the stuff inside <code>t.initialize()</code> already being run in the new thread (because for thread-safety reasons I don't want to run the initialization from a different thread than the rest)</p>  <p>One <em>possible</em> way to to do what I'm talking about could look like this:</p>  <pre><code>my_fn(signal):     try:         do_some()         initialization()         signal.send('ok')     catch Exception as e:         signal.send(e)     do_all()     other_stuff()  main():     s = signal()     thread(my_fn, s).run()     try:         s.wait()         print('thread initialized correctly!')     except e:         print('an error occured: ', e)         exit(-1)     do_stuff()     in_main_thread() </code></pre>  <p>I could live with this approach but I wonder if there's some elaboration about this (or maybe even a more elegant approach)</p>