<p>I have following case,</p>  <pre><code>public class Test {      private static final int MAX_NUMBER = 10_00_00;      public static void main(String[] args) {         List&lt;Integer&gt; list = new CopyOnWriteArrayList&lt;&gt;();          long start = System.nanoTime();         for(int i = 0; i &lt; MAX_NUMBER; i++) {             list.add(i * 2);         }          long end = System.nanoTime();         System.out.println(((end - start) / Math.pow(10, 9)));     }  } </code></pre>  <p><strong><em>OUTPUT</em></strong></p>  <pre><code>6.861539857 </code></pre>  <p>It adds element quite <em>slowly</em> compared to <code>ArrayList</code> which took approximately <code>0.004690843</code>. I came to know the reason in the documentation,</p>  <blockquote>   <p>A thread-safe variant of <code>ArrayList</code> in which all mutative operations   (add, set, and so on) are implemented by making a fresh copy of the   underlying array.</p> </blockquote>  <p>So, my understanding is, whenever I add new element in this list it will create new fresh array and add element at last index of this array. I find a lock in <code>add</code> method and apart from that that method is actually creating new array every time. </p>  <p>When I increased <code>MAX_NUMBER</code> to <code>10_00_000</code> my programs keeps on running and never end (<em>it would but I can't wait for so long</em>). </p>  <p>I think <code>Collections.synchronizedList</code> is the better choice when you want thread safety with speed. I used it and it took about <code>0.007673728</code>.</p>  <p>My questions :</p>  <ol> <li>Why internally it create new array does thread safety is related to this ?</li> <li>Why it took so much time in case of <code>MAX_NUMBER = 10_00_000</code> ? (as it took about 6 seconds with <code>MAX_NUMBER = 10_00_00</code>) Is this happening because mutative operation creates new array every time ? </li> <li>Does this mean <code>CopyOnWriteArrayList</code> has performance drawback when you have huge number of elements and better to choose something else (i.e. <code>Collections.synchronizedList</code>)?</li> <li>Is this the reason we usually don't see <code>CopyOnWriteArrayList</code> in public APIs ? Is there any drawbacks other than this ?</li> </ol>