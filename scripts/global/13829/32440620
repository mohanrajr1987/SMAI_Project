<p>I have a piece of code which I want to only be running once at a time. It's not the end of the world if it runs more than once concurrently, but it's heavy on resources and that's the problem. Let's call this the HEAVY_STUFF.</p>  <p>The problem is that all of my tasks depend on HEAVY_STUFF running at least once after they finish. There can be up to 2000 tasks, and it is going to happen with some regularity that all 2000 tasks finish at the exact same time. Normally I would just use <code>dispatch_group_notify</code> or similar, but this means that HEAVY_STUFF runs 2000 times when it only needs to run once. Also it is a requirement that the 1999 threads do not wait, because they are holding a lot of memory -- for example if the 1999 threads sit on a dispatch wait, then they consume >300MB on my iPhone 5S even with careful <code>autoreleasepool</code> wrappings. Ouch.</p>  <p>Here's how i'm solving it now. I'm not sure it is thread-safe but seems to work so far -- memory usage stays around 35MB and HEAVY_STUFF runs at least once after every task completes. Is this thread-safe? What's a better GCD solution? I don't want to use NSOperation*.</p>  <pre><code> static int counter = 0;  - (void)taskCompleted {     // can be called 2000 times from 2000 different threads, all at once      if( counter &gt; 0) {         return;     }      OSAtomicIncrement32Barrier(&amp;counter);      dispatch_group_async(self.group, self.queue, ^{          OSAtomicDecrement32Barrier(&amp;counter);         if( counter &gt; 0 ) {             return;         }          HEAVY_STUFF     }); } </code></pre>  <p>Thanks for your help.</p>