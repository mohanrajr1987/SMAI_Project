<p>I'm using synchronization in one "pool thread" and main thread. In pool thread I lock section with <code>synchronization(locker)</code> and then I perform:</p>  <pre><code>synchronization(locker){    QueuePool.shutdownNow();    while(!QueuePool.isShutDown()){}    //do something after      QueuePool.SetThreadQueue(null);      QueuePool queue = QueuePool.GetThreadQueue();      Pallets pallets = Pallets.GetPallets(context);      ////////////////////////////////////////////////////////////////////////////////////     for (String key : pallets.getPalletsToSend().keySet()) {         for (HashMap&lt;String, String&gt; object : pallets.getPalletsToSend().get(key)) {             PalletSender sender = new PalletSender(object, context);             queue.addTask(sender);         }     } } </code></pre>  <p>and on main thread this synchronization is when button click:</p>  <pre><code>synchronized (QueuePool.locker2){QueuePool.GetThreadQueue().addTask(palletSender);} </code></pre>  <p>QueuePool is a singleton having ThreadPoolExecution. In SetThreadQqueue I clear singleton instance on null.</p>  <p>the pool thread is run every 2 minute. It's possible that it will first go to the pool thread. So how long it can take when waiting on <code>while(!QueuePool(isShutDown())</code>? Maybe I can add some code to add one more condition in that loop? I am not sure I'm correct. Let me know what is the best.</p>