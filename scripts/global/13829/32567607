<p>tl;dr: </p>  <pre><code> class Controller  {  public:     volatile Netconsole* nc;     void init();        //initialize the threads     void calculate();   // handler for the "mothership app"     void senderThreadLoop();  //also calls reinitNet() if connection is broken.     void listenerThreadLoop();     inline void reinitNet(){ delete nc; nc = new Netconsole(); }  } </code></pre>  <hr>  <p>// inside      Json::Value header = nc->Recv();</p>  <p><code>error: passing 'volatile Netconsole' as 'this' argument discards qualifiers [-fpermissive]</code></p>  <p>Pointer to an instance of a utility class (Netconsole) shared between two threads must be updated inside both threads if the utility class is re-instantiated, but declaring it as volatile generates the above error. If it's updated just inside one thread, the other thread may still use old, invalid pointer. How to assure it's updated in both but using methods through the pointer doesn't trigger the above error?</p>  <p>Extended info:</p>  <p>The "smart glue logic" library I'm writing is used to pass and convert messages between a 3rd party software and a custom device. It consists of three essential threads:</p>  <ul> <li>a handler: the main thread of the 3rd party app periodically calls a "calculate" function in my library to handle new updates - data to send, data received</li> <li>a sender thread that converts and sends whatever the handler pushed into the send buffer</li> <li>a listener thread that converts and pushes any data received from the device into receive buffer.</li> </ul>  <p>Both the sender and the listener threads use the same utility class that handles network communication with the device; upon initialization the class creates a connection to the device, and the two threads perform blocking reads or await for new data to send respectively. In case of any problems, the sender thread performs all "maintenance" work, while the listener thread enters a safe state awaiting return of connectivity.</p>  <p>Now, since the two threads share one connection to the device, they both share the same instance of the communication class, as a pointer to that class.</p>  <p>The problem is in the procedure of reconnect - it involves destroying and creating the helper class instance exploiting safe shutdown and initialization already present in the destructor and constructor. As result the pointer changes. Without <code>volatile</code> it's quite likely the listener won't receive the updated pointer. With volatile, it protests - needlessly, because <code>nc</code> (the pointer) won't change at a random moment - first the listener is notified of a problem, then it enters a safe state where it doesn't perform any operations on 'nc' and notifies the sender it's ready. Only then the sender performs the repair and notifies the listener to resume normal operation.</p>  <p>So what's the right solution in this situation?</p>