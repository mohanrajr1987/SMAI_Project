<p>I'm experimenting with multithreading for the first time. I'm using <code>Queue.Queue</code> and putting data in there after I've created a set of objects that inherit from <code>threading.Thread</code>. The script downloads a series of files and works perfectly fine, I have it downloading and it has proven much faster than my old one.</p>  <p>However, my thread begins with a print command to show that it has begun downloading. Just a simple "Downloading C:\foo.bar". When the queue is first created, all these print commands are stuck together, and then the newlines all appear afterwards.</p>  <p>Here's a basic idea of the code involved:</p>  <pre><code>import Queue import threading  queue = Queue.Queue()  class ThreadDownload(threading.Thread):     """Threaded Download"""      def __init__(self, queue):         threading.Thread.__init__(self)         self.queue = queue      def run(self):         while True:             data = self.queue.get()              print ("Downloading {}".format(data))             #download_file(data)             time.sleep(10)              self.queue.task_done()  for i in range(4):     t = ThreadDownload(queue)     t.setDaemon(True)     t.start()  #for d in data: for d in range(20):     queue.put(d)  queue.join() </code></pre>  <p>Note that <code>download_file</code> is a function from a 3rd party library that people are unlikely to know or have easy access to so I've left it out in favour of people putting some other time consuming call for their testing. Likewise with <code>data</code>, the form of data is irrelevant to the question so instead I suggest people use <code>range</code> in order to test easily.</p>  <p>Here's what output might look like:</p>  <pre><code>Downloading C:\foo.barDownloading C:\foo.barDownloading C:\foo.barDownloading C:\foo.bar    Downloading C:\foo.bar Downloading C:\foo.bar Downloading C:\foo.bar </code></pre>  <p>The reason seems to be because of the fact that these threads are starting their run simultaneously. If I add <code>time.sleep(0.01)</code> I can prevent it but that's a hacky approach. And I'm also concerned that this could mean that if two downloads coincidentally started at the same split second it would happen again.</p>  <p>Is there any way to actually enforce a separation here so I don't get this problem? I have heard that you shouldn't have threads handle UI, that's usually in the context of something like redrawing a progress bar though. Also I'm not sure if there's a convenient way to note when an item from the queue has been taken by a thread, but perhaps I've missed it.</p>