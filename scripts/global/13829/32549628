<p>My program looks like this:</p>  <pre><code>public class Main {     private static ArrayList&lt;T&gt; list;      public static void main(String[] args) {         new DataListener().start();         new DataUpdater().start();     }      static class DataListener extends Thread {         @Override         public void run() {             while(true){                 //Reading the ArrayList and displaying the updated data                 Thread.sleep(5000);             }         }     }      static class DataUpdater extends Thread{         @Override         public void run() {             //Continuously receive data and update ArrayList;         }     } } </code></pre>  <p>In order to use this ArrayList in both threads, I know two options:</p>  <ol> <li><p>To make the ArrayList volatile. However I read in <a href="http://www.ibm.com/developerworks/java/library/j-jtp06197/index.html" rel="nofollow">this article</a> that making variables volatile is only allowed if it "Writes to the variable do not depend on its current value." which I think in this case it does (because for example when you do an add operation on an ArrayList, the contents of the ArrayList after this operation depend on the current contents of the ArrayList, or doesn't it?). Also the DataUpdater has to remove some elements from the list every now and then, and I also read that editing a volatile variable from different threads is not possible.</p></li> <li><p>To make this ArrayList a synchronized variable. However, my DataUpdater will continuously update the ArrayList, so won't this block the DataListener from reading the ArrayList?</p></li> </ol>  <p>Did I misunderstand any concepts here or is there another option to make this possible?</p>