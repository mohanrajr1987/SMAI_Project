<p>I've have the following situation:</p>  <ul> <li>There is only one thead which only adds items to a list</li> <li>Multiple threads which can read the items.</li> </ul>  <p>I know when we directly expose the list, I will ran into concurrent modification while enumerating.</p>  <p>But when I call <code>.ToList()</code> it makes a instance of the List and copies all items with the Array.Copy function of the .NET Framework.</p>  <p>What do you mean, is it safe when using this approach when dirty reads are ok?</p>  <pre><code>using System; using System.Collections.Generic; using System.Linq; using System.Threading;  namespace ConsoleApplication1 {     class Program     {         static void Main(string[] args)         {             var container = new Container();             Thread writer = new Thread(() =&gt;             {                 for (int i = 0; i &lt; 1000; i++)                 {                     container.Add(new Item("Item " + i));                 }             });              writer.Start();              Thread[] readerThreads = new Thread[10];             for (int i = 0; i &lt; readerThreads.Length; i++)             {                 readerThreads[i] = new Thread(() =&gt;                 {                     foreach (Item item in container.Items)                     {                         Console.WriteLine(item.Name);                     }                 });                 readerThreads[i].Start();             }              writer.Join();              for (int i = 0; i &lt; readerThreads.Length; i++)             {                 readerThreads[i].Join();             }              Console.ReadLine();         }     }      public class Container     {         private readonly IList&lt;Item&gt; _items;          public Container()         {             _items = new List&lt;Item&gt;();         }          public IReadOnlyList&lt;Item&gt; Items         {             get { return _items.ToList().AsReadOnly(); }         }          public void Add(Item item)         {             _items.Add(item);         }     }      public class Item     {         private readonly string _name;          public Item(string name)         {             _name = name;         }          public string Name         {             get { return _name; }         }     } } </code></pre>