<p>I tried to generate an image where there is a small portion of code that initializes the board (Raspberry Pi 2B), copies the rest of the stuff in upper memory and starts running the rest of the code there.</p>  <p>The idea is that the whole image is first loaded at 0x8000 from where the "functonality" is copied to the upper memory and started, and the stuff in 0x8000 is then abandoned.</p>  <p>It doesn't work. I get errors from ld:</p>  <pre><code>... /bin/ld: address 0x124ac of loader.elf section `.text2' is not within region `EXEC' ... /bin/ld: address 0x1ff18 of loader.elf section `.bss' is not within region `EXEC' ... /bin/ld: address 0x124ac of loader.elf section `.text2' is not within region `EXEC' ... /bin/ld: address 0x1ff18 of loader.elf section `.bss' is not within region `EXEC' ... /bin/ld: address 0x124ac of loader.elf section `.text2' is not within region `EXEC' ... /bin/ld: address 0x1ff18 of loader.elf section `.bss' is not within region `EXEC' ... /bin/ld: region `EXEC' overflowed by -520487144 bytes collect2: error: ld returned 1 exit status make: *** [loader.elf] Error 1 make: Target `all' not remade because of errors. </code></pre>  <p>My linker script:</p>  <pre><code>ENTRY(_start)  MEMORY {     LOAD (rwx) : ORIGIN = 0x00008000, LENGTH = 512k /* initial */     EXEC (rwx) : ORIGIN = 0x1f000000, LENGTH = 512k /* runtime */ }  SECTIONS {        /* Starts at LOADER_ADDR. */     . = 0x8000;     __text_start = .;     .text :     {         *(.init)         *start1.o(.text)         *start1.o(.data)         *start1.o(.bss)         *(.text.startup)     } &gt;LOAD      .text2 ALIGN(0x1000):     {          __code_begin = .;         *loader.o(.text)         *rpi2.o(.text)         *serial.o(.text)         *util.o(EXCLUDE_FILE(*instr_util.o).text)         *gdb.o(.text)         *(.text)     } &gt;EXEC AT&gt;LOAD     __text_end = .;       __data_start = .;     .data :     {         *(.data)     } &gt;EXEC AT&gt;LOAD     __data_end = .;       __bss_start = .;     .bss ALIGN(0x8):     {         bss = .;         *(.bss)         stacks = .;         . = . + 512;    /* fiq stack size */         __fiq_stack = .;         . = . + 1024;   /* usr &amp; sys stack size (common) */         __usrsys_stack = .;         . = . + 16384;  /* svc stack size (start-up) */         __svc_stack = .;         . = . + 4096;   /* irq stack size (serial) */         __irq_stack = .;         . = . + 512;    /* mon stack size */         __mon_stack = .;         . = . + 512;    /* hyp stack size */         __hyp_stack = .;         . = . + 512;    /* und stack size */         __und_stack = .;         . = . + 16384;  /* abrt stack size (gdb-stub) */         __abrt_stack = .;     } &gt;EXEC AT&gt;LOAD     __bss_end = .;      __new_org = 0x1f000000;       /* gcc-generated crap */     .note :     {         *(.note.*)     } &gt;LOAD      .debug :     {         *(.debug*)     } &gt;LOAD      __end = .; } </code></pre>  <p>It works fine, when I only use >LOAD everywhere (all in the lower memory). The program is not that big:</p>  <pre><code>       0x0001ff18                __bss_end = .        0x00032098                __end = . </code></pre>  <p>Forgot to mention: this is a bare metal program.</p>  <p>[EDIT] Funny, this works (but I'd rather 'catenate'...)</p>  <pre><code>.text2 0x1e000000: {      __code_begin = .;     *loader.o(.text)     *rpi2.o(.text)     *serial.o(.text)     *util.o(EXCLUDE_FILE(*instr_util.o).text)     *gdb.o(.text)     *(.text) } AT&gt;LOAD </code></pre>  <p>[/EDIT]</p>