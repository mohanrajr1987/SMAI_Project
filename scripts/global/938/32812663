<p>I am a bit confused by the <code>static</code> in-class initialization of a <code>const</code> member. For example, in the code below:</p>  <pre><code>#include &lt;iostream&gt;  struct Foo {     const static int n = 42; };  // const int Foo::n; // No ODR  void f(const int&amp; param) {     std::cout &lt;&lt; param &lt;&lt; std::endl; }  int g(const int&amp; param) {     return param; }  template&lt;int N&gt; void h() {     std::cout &lt;&lt; N &lt;&lt; std::endl; }  int main() {     // f(Foo::n); // linker error, both g++/clang++     std::cout &lt;&lt; g(Foo::n) &lt;&lt; std::endl; // OK in g++ only with -O(1,2 or 3) flag, why?!     h&lt;Foo::n&gt;(); // this should be fine } </code></pre>  <p><kbd><a href="http://coliru.stacked-crooked.com/a/1af2cb53dc649007" rel="nofollow">Live example</a></kbd></p>  <p>I do not define <code>Foo::n</code> (the line is commented). So, I expect the call <code>f(Foo::n)</code> to fail at link time, and indeed it does. However, the following line <code>std::cout &lt;&lt; g(Foo::n) &lt;&lt; std::endl;</code> compiles and links fine only by gcc (clang still emits a linker error) whenever I use an optimization flag such as <code>-O1/2/3</code>. </p>  <ol> <li>Why does gcc (tried with gcc5.2.0 and gcc 4.9.3) compile <strong>and link</strong> the code when the optimization is turned on? </li> <li>And am I correct to say that <strong>the only usage of in-class static const members is in constant expressions</strong>, such as template parameters like in the <code>h&lt;Foo::n&gt;</code> call, in which case the code should link?</li> </ol>