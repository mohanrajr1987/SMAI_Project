<p>I've got a number of low-level functions, typedef and define that I tend to re-use among multiple source codes.</p>  <p>Up to now, I made the simpler choice to copy/paste and adapt the relevant parts to their host context. I would like to change this design, grouping relevant prototypes by logical themes, providing each theme into its own <code>.h</code>.</p>  <p>The <code>.h</code> design is selected over a <code>.c</code> because most functions defined are very short and expected to be inlined, for performance reason. While Visual for example is doing a fine job at inlining functions from different <code>.c</code>, gcc and clang on the other hand don't do it by default. Recent versions made it possible, by using <code>-flto</code> switch, but that's still recent, and certainly not default. By contrast, the <code>#include "theme.h"</code> does not suffer such limitation.</p>  <p>However, there is still a last drawback : functions defined into the <code>theme.h</code> will be exported as symbols within the <code>.c</code> including it. If 2 or more <code>.c</code> in the same program include the same <code>theme.h</code>, it results in a symbol conflict at link stage.</p>  <p>The solution to this problem is supposed to be simple : make these functions <code>static</code>. That's what I'm used to do, that's also what the stb (single-file public domain libraries) does. However, the fact that now <code>theme.h</code> is generic means it contains all useful functions of a given theme, and some of them might be unused by the calling <code>.c</code>. In which case, the compiler generates a warning : <code>function XXXX defined but not used</code>.</p>  <p>A warning is not an error, indeed, but in a clean production chain, no warning is tolerated. So a solution must be found.</p>  <p>The stb library collection does not seem concerned by this issue, so I could not find any hint there.</p>  <p>A first solution could be to disable the warning. And it works, but require compiler-specific flags, extensions or pragma. For example, in <code>gcc</code>, it can be done using <code>-Wno-unused-function</code>.  However, it's more complex than that : I don't want to remove the warning for the whole project, since it can be useful in other parts of the code. I just want to disable it for the functions defined into <code>theme.h</code> (typedefs and defines are already fine). It's possible too, using <code>__attribute__((unused))</code> in front of each function. But that's gcc specific. For Visual, I'll need something else. For clang, I don't know yet. And there is always a risk that another compiler will need something else.</p>  <p>I tend to shy away from such complexity, because there are too many compilers out there, and they constantly evolve. So such a solution would require maintenance.</p>  <p>Another possibility would be to declare these functions <code>static inline</code>. In which case, the <code>function XXXX defined but not used</code> warning is no longer issued. <code>static inline</code> has the pretty big advantage of being <code>C99</code> standard.</p>  <p>Sounds good, but there are still a number of compilers in use today which are not <code>C99</code> standard (MS Visual is probably the biggest one). These compilers are not necessarily current : there are still a lot of systems out there which are not exactly up to date. And I would prefer a solution which can work for them too.</p>  <p>That being said, being at least <code>C99</code> compliant seems like a relatively mild requirement by 2015, so it should prove okay for a growing majority share of compilers in use. The most important exception is Visual here, with <code>C99</code> only supported since VC2013, hence a relatively recent version. Therefore, it's quite likely that older versions such as VC2012 or VC2010 remain in use today and within the next few years.</p>  <p>Such older Visual versions could probably use Visual-specific keyword <code>static __inline</code>. That's one work around, but only for Visual. For all other potential non-C99 compiler out there, I'm out of luck.</p>  <p>I'm currently considering to use <code>static inline</code> by default for C99 compliant compilers, with <code>static __inline</code> as backup for Visual, and just <code>static</code> for all others.</p>  <p>I was wondering if there was a better solution to this problem.</p>  <p><em>[Edit]</em> : as stated by Jonathan Leffler, the correct spelling is <code>static inline</code>. That's what I meant but I was too lazy and only wrote <code>inline</code>. Fixed that in the text.</p>  <p>Current solution is (by priority order) :</p>  <ul> <li>C99 : <code>static inline</code></li> <li>Visual : <code>static __inline</code></li> <li>gcc : <code>static __attribute__((unused))</code></li> <li>any other : <code>static</code> (with the risk to trigger warnings for unused functions)</li> </ul>