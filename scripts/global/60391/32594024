<p>In code below SurfaceHolder object events invoked if preview initialized on <code>onCreate()</code> event .</p>  <p><strong>this code works when Activity launched</strong></p>  <pre><code>public class HeartRateMonitor extends ActionBarActivity {  private static final String TAG = "HeartRateMonitor"; //  private static final AtomicBoolean processing = new AtomicBoolean(false); private static SurfaceView preview = null; private static SurfaceHolder previewHolder = null; private static Camera camera ; private static View image = null; private static TextView text = null; private static WakeLock wakeLock = null; private static int averageIndex = 0; private static final int averageArraySize = 4; private static final AtomicBoolean processing = new AtomicBoolean(false); private static final int[] averageArray = new int[averageArraySize]; public static enum TYPE {     GREEN, RED }; private static TYPE currentType = TYPE.GREEN; public static TYPE getCurrent() {     return currentType; } private static int beatsIndex = 0; private static final int beatsArraySize = 4; private static final int[] beatsArray = new int[beatsArraySize]; private static double beats = 0; private static long startTime = 0; static Context context; static int beatCount = 0 ; static CircleButton cb ; static int txt ;   /**  * {@inheritDoc}  */ @Override public void onCreate(Bundle savedInstanceState) {     super.onCreate(savedInstanceState);     setContentView(R.layout.main);     PlaceholderFragment  p = new PlaceholderFragment() ;     if (savedInstanceState == null) {         getSupportFragmentManager().beginTransaction()                 .add(R.id.contain, p)                 .commit();     }      preview = (SurfaceView) findViewById(R.id.preview);     previewHolder = preview.getHolder();     previewHolder.addCallback(surfaceCallback);     previewHolder.setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS);       image = findViewById(R.id.image);     text = (TextView) findViewById(R.id.text);      PowerManager pm = (PowerManager) getSystemService(Context.POWER_SERVICE);     wakeLock = pm.newWakeLock(PowerManager.FULL_WAKE_LOCK, "DoNotDimScreen");     HeartRateMonitor.context = getApplicationContext(); }    class PlaceholderFragment extends Fragment implements View.OnClickListener {     View rootView ;     public PlaceholderFragment() {     }      @Override     public void onCreate(Bundle savedInstanceState) {         super.onCreate(savedInstanceState);     }     @TargetApi(Build.VERSION_CODES.JELLY_BEAN)     @Override     public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {         rootView = inflater.inflate(R.layout.start, container, false);         cb = (CircleButton) rootView.findViewById(R.id.startButton);         cb.setImageResource(R.drawable.start);         cb.isClickable();         cb.findViewById(R.id.startButton).setOnClickListener(this);         return rootView;     }      @Override     public void onClick(View v) {        // Toast.makeText(getActivity(), "Button clicked", Toast.LENGTH_SHORT).show();         cb.setImageResource(R.drawable.stop);      } }     public static Context returnContext() {     return HeartRateMonitor.context; }  @Override protected void onResume() {     super.onResume();     wakeLock.acquire();     camera = Camera.open();     startTime = System.currentTimeMillis(); }  @Override public void onPause() {     super.onPause();     wakeLock.release();     camera = null; }  private static PreviewCallback previewCallback = new PreviewCallback() {     /**      * {@inheritDoc}      */     @Override     public void onPreviewFrame(byte[] data, Camera cam) {         Log.e("MOHAB","onPReviewFrame");         if (data == null) throw new NullPointerException();         Camera.Size size = cam.getParameters().getPreviewSize();         if (size == null) throw new NullPointerException();          if (!processing.compareAndSet(false, true)) return;          int width = size.width;         int height = size.height;          int imgAvg = ImageProcessing.decodeYUV420SPtoRedAvg(data.clone(), height, width);         // Log.i(TAG, "imgAvg="+imgAvg);         if (imgAvg == 0 || imgAvg == 255) {             processing.set(false);             return;         }         int averageArrayAvg = 0;         int averageArrayCnt = 0;         for (int i = 0; i &lt; averageArray.length; i++) {             if (averageArray[i] &gt; 0) {                 averageArrayAvg += averageArray[i];                 averageArrayCnt++;             }         }         int rollingAverage = (averageArrayCnt &gt; 0) ? (averageArrayAvg / averageArrayCnt) : 0;         TYPE newType = currentType;         if (imgAvg &lt; rollingAverage) {             newType = TYPE.RED;             if (newType != currentType) {                 beats++;                 // Log.d(TAG, "BEAT!! beats="+beats);             }         } else if (imgAvg &gt; rollingAverage) {             newType = TYPE.GREEN;         }         if (averageIndex == averageArraySize) averageIndex = 0;         averageArray[averageIndex] = imgAvg;         averageIndex++;         // Transitioned from one state to another to the same         if (newType != currentType) {             currentType = newType;             image.postInvalidate();         }         long endTime = System.currentTimeMillis();         double totalTimeInSecs = (endTime - startTime) / 1000d;         if (beats&gt;3) {             beatCount++ ;             double bps = (beats / totalTimeInSecs);             int dpm = (int) (bps * 60d);             if (dpm &lt; 30 || dpm &gt; 180) {                 startTime = System.currentTimeMillis();                 beats = 0;                 processing.set(false);                 return;             }             if (beatsIndex == beatsArraySize) beatsIndex = 0;             beatsArray[beatsIndex] = dpm;             beatsIndex++;             int beatsArrayAvg = 0;             int beatsArrayCnt = 0;             for (int i = 0; i &lt; beatsArray.length; i++) {                 if (beatsArray[i] &gt; 0) {                     beatsArrayAvg += beatsArray[i];                     beatsArrayCnt++;                 }             }             int beatsAvg = (beatsArrayAvg / beatsArrayCnt);             beats = 0;           if (beatCount &gt;3 ){                 int diff = Integer.parseInt((String) text.getText()) &gt; beatsAvg ? Integer.parseInt((String) text.getText()) - beatsAvg : beatsAvg - Integer.parseInt((String) text.getText());                 if (diff &lt; 2) {                     Toast.makeText(HeartRateMonitor.returnContext(), "beats " + beatsAvg, Toast.LENGTH_LONG).show();                     text.setText(String.valueOf(beatsAvg));                     txt =beatsAvg ;                     camera.setPreviewCallback(null);                     camera.stopPreview();                     camera.release();                     beatCount = 0;                 }             }             text.setText(String.valueOf(beatsAvg));             startTime = System.currentTimeMillis();         }         processing.set(false);     } };  private static SurfaceHolder.Callback surfaceCallback = new SurfaceHolder.Callback() {      /**      * {@inheritDoc}      */     @Override     public void surfaceCreated(SurfaceHolder holder) {         Log.e("MOHAB", "surfaceCreated");          try {             camera.setPreviewDisplay(previewHolder);             camera.setPreviewCallback(previewCallback);         } catch (Throwable t) {             Log.e("PreviewDemo-surfaceCallback", "Exception in setPreviewDisplay()", t);         }     }      /**      * {@inheritDoc}      */     @Override     public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) {         Camera.Parameters parameters = camera.getParameters();         parameters.setFlashMode(Camera.Parameters.FLASH_MODE_TORCH);         Camera.Size size = getSmallestPreviewSize(width, height, parameters);         if (size != null) {             parameters.setPreviewSize(size.width, size.height);             Log.d(TAG, "Using width=" + size.width + " height=" + size.height);         }         camera.setParameters(parameters);         camera.startPreview();     }      /**      * {@inheritDoc}      */     @Override     public void surfaceDestroyed(SurfaceHolder holder) {         // Ignore     } };   private static Camera.Size getSmallestPreviewSize(int width, int height, Camera.Parameters parameters) {     Camera.Size result = null;      for (Camera.Size size : parameters.getSupportedPreviewSizes()) {         if (size.width &lt;= width &amp;&amp; size.height &lt;= height) {             if (result == null) {                 result = size;             } else {                 int resultArea = result.width * result.height;                 int newArea = size.width * size.height;                 if (newArea &lt; resultArea) result = size;             }         }     }     return result; } </code></pre>  <p>}</p>  <p>i want start preview if <code>Button</code> clicked so i create initialize it on onClick() event. i used <code>Log</code> to log to track events but surfaceCreated() method does not invoked ,why ? what is the right way ?</p>  <p><strong>Code</strong></p>  <pre><code>    public class HeartRateMonitor extends ActionBarActivity {      private static final String TAG = "HeartRateMonitor";     //  private static final AtomicBoolean processing = new AtomicBoolean(false);     private static SurfaceView preview = null;     private static SurfaceHolder previewHolder = null;     private static Camera camera ;     private static View image = null;     private static TextView text = null;     private static WakeLock wakeLock = null;     private static int averageIndex = 0;     private static final int averageArraySize = 4;     private static final AtomicBoolean processing = new AtomicBoolean(false);     private static final int[] averageArray = new int[averageArraySize];     public static enum TYPE {         GREEN, RED };     private static TYPE currentType = TYPE.GREEN;     public static TYPE getCurrent() {         return currentType;     }     private static int beatsIndex = 0;     private static final int beatsArraySize = 4;     private static final int[] beatsArray = new int[beatsArraySize];     private static double beats = 0;     private static long startTime = 0;     static Context context;     static int beatCount = 0 ;     static CircleButton cb ;     static int txt ;       /**      * {@inheritDoc}      */     @Override     public void onCreate(Bundle savedInstanceState) {         super.onCreate(savedInstanceState);         setContentView(R.layout.main);         PlaceholderFragment  p = new PlaceholderFragment() ;         if (savedInstanceState == null) {             getSupportFragmentManager().beginTransaction()                     .add(R.id.contain, p)                     .commit();         }          preview = (SurfaceView) findViewById(R.id.preview);         previewHolder = preview.getHolder();            image = findViewById(R.id.image);         text = (TextView) findViewById(R.id.text);          PowerManager pm = (PowerManager) getSystemService(Context.POWER_SERVICE);         wakeLock = pm.newWakeLock(PowerManager.FULL_WAKE_LOCK, "DoNotDimScreen");         HeartRateMonitor.context = getApplicationContext();     }        class PlaceholderFragment extends Fragment implements View.OnClickListener {         View rootView ;         public PlaceholderFragment() {         }          @Override         public void onCreate(Bundle savedInstanceState) {             super.onCreate(savedInstanceState);         }         @TargetApi(Build.VERSION_CODES.JELLY_BEAN)         @Override         public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {             rootView = inflater.inflate(R.layout.start, container, false);             cb = (CircleButton) rootView.findViewById(R.id.startButton);             cb.setImageResource(R.drawable.start);             cb.isClickable();             cb.findViewById(R.id.startButton).setOnClickListener(this);             return rootView;         }          @Override         public void onClick(View v) {            // Toast.makeText(getActivity(), "Button clicked", Toast.LENGTH_SHORT).show();             cb.setImageResource(R.drawable.stop);             start();          }     }     public void start(){         // here i want start preview .         previewHolder.addCallback(surfaceCallback);         previewHolder.setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS);          wakeLock.acquire();         camera = Camera.open();         startTime = System.currentTimeMillis();     }         public static Context returnContext()     {         return HeartRateMonitor.context;     }        @Override     public void onPause() {         super.onPause();         wakeLock.release();         camera = null;     }      private static PreviewCallback previewCallback = new PreviewCallback() {         /**          * {@inheritDoc}          */         @Override         public void onPreviewFrame(byte[] data, Camera cam) {             Log.e("MOHAB","onPReviewFrame");             if (data == null) throw new NullPointerException();             Camera.Size size = cam.getParameters().getPreviewSize();             if (size == null) throw new NullPointerException();              if (!processing.compareAndSet(false, true)) return;              int width = size.width;             int height = size.height;              int imgAvg = ImageProcessing.decodeYUV420SPtoRedAvg(data.clone(), height, width);             // Log.i(TAG, "imgAvg="+imgAvg);             if (imgAvg == 0 || imgAvg == 255) {                 processing.set(false);                 return;             }             int averageArrayAvg = 0;             int averageArrayCnt = 0;             for (int i = 0; i &lt; averageArray.length; i++) {                 if (averageArray[i] &gt; 0) {                     averageArrayAvg += averageArray[i];                     averageArrayCnt++;                 }             }             int rollingAverage = (averageArrayCnt &gt; 0) ? (averageArrayAvg / averageArrayCnt) : 0;             TYPE newType = currentType;             if (imgAvg &lt; rollingAverage) {                 newType = TYPE.RED;                 if (newType != currentType) {                     beats++;                     // Log.d(TAG, "BEAT!! beats="+beats);                 }             } else if (imgAvg &gt; rollingAverage) {                 newType = TYPE.GREEN;             }             if (averageIndex == averageArraySize) averageIndex = 0;             averageArray[averageIndex] = imgAvg;             averageIndex++;             // Transitioned from one state to another to the same             if (newType != currentType) {                 currentType = newType;                 image.postInvalidate();             }             long endTime = System.currentTimeMillis();             double totalTimeInSecs = (endTime - startTime) / 1000d;             if (beats&gt;3) {                 beatCount++ ;                 double bps = (beats / totalTimeInSecs);                 int dpm = (int) (bps * 60d);                 if (dpm &lt; 30 || dpm &gt; 180) {                     startTime = System.currentTimeMillis();                     beats = 0;                     processing.set(false);                     return;                 }                 if (beatsIndex == beatsArraySize) beatsIndex = 0;                 beatsArray[beatsIndex] = dpm;                 beatsIndex++;                 int beatsArrayAvg = 0;                 int beatsArrayCnt = 0;                 for (int i = 0; i &lt; beatsArray.length; i++) {                     if (beatsArray[i] &gt; 0) {                         beatsArrayAvg += beatsArray[i];                         beatsArrayCnt++;                     }                 }                 int beatsAvg = (beatsArrayAvg / beatsArrayCnt);                 beats = 0;               if (beatCount &gt;3 ){                     int diff = Integer.parseInt((String) text.getText()) &gt; beatsAvg ? Integer.parseInt((String) text.getText()) - beatsAvg : beatsAvg - Integer.parseInt((String) text.getText());                     if (diff &lt; 2) {                         Toast.makeText(HeartRateMonitor.returnContext(), "beats " + beatsAvg, Toast.LENGTH_LONG).show();                         text.setText(String.valueOf(beatsAvg));                         txt =beatsAvg ;                         camera.setPreviewCallback(null);                         camera.stopPreview();                         camera.release();                         beatCount = 0;                     }                 }                 text.setText(String.valueOf(beatsAvg));                 startTime = System.currentTimeMillis();             }             processing.set(false);         }     };      private static SurfaceHolder.Callback surfaceCallback = new SurfaceHolder.Callback() {          /**          * {@inheritDoc}          */         @Override         public void surfaceCreated(SurfaceHolder holder) {             Log.e("MOHAB", "surfaceCreated");              try {                 camera.setPreviewDisplay(previewHolder);                 camera.setPreviewCallback(previewCallback);             } catch (Throwable t) {                 Log.e("PreviewDemo-surfaceCallback", "Exception in setPreviewDisplay()", t);             }         }          /**          * {@inheritDoc}          */         @Override         public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) {             Camera.Parameters parameters = camera.getParameters();             parameters.setFlashMode(Camera.Parameters.FLASH_MODE_TORCH);             Camera.Size size = getSmallestPreviewSize(width, height, parameters);             if (size != null) {                 parameters.setPreviewSize(size.width, size.height);                 Log.d(TAG, "Using width=" + size.width + " height=" + size.height);             }             camera.setParameters(parameters);             camera.startPreview();         }          /**          * {@inheritDoc}          */         @Override         public void surfaceDestroyed(SurfaceHolder holder) {             // Ignore         }     };       private static Camera.Size getSmallestPreviewSize(int width, int height, Camera.Parameters parameters) {         Camera.Size result = null;          for (Camera.Size size : parameters.getSupportedPreviewSizes()) {             if (size.width &lt;= width &amp;&amp; size.height &lt;= height) {                 if (result == null) {                     result = size;                 } else {                     int resultArea = result.width * result.height;                     int newArea = size.width * size.height;                     if (newArea &lt; resultArea) result = size;                 }             }         }         return result;     } } </code></pre>  <p><strong>snippet from code above , where i start SurfaceHoder</strong></p>  <pre><code>  public void start(){     // here i want start preview .     previewHolder.addCallback(surfaceCallback);     previewHolder.setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS);      wakeLock.acquire();     camera = Camera.open();     startTime = System.currentTimeMillis(); } </code></pre>