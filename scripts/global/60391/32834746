<p>I'm trying to implement <strong>android.hardware.camera2</strong>, but i'm a little bit confused with it.</p>  <p>The c√¢mera is rotating with the fone!</p>  <p>BEFORE Taking the picture, If I rotated the phone the camera is rotating instead of keeping the same position.</p>  <p>Example image.</p>  <p><a href="http://imgur.com/fE1EqXv" rel="nofollow">http://imgur.com/fE1EqXv</a></p>  <p>I don't know why it happens.</p>  <p>I dont't have two layouts for the holder.</p>  <p>Camera XML</p>  <pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"     xmlns:fab="http://schemas.android.com/apk/res-auto"     xmlns:tools="http://schemas.android.com/tools"     android:layout_width="match_parent"     android:layout_height="match_parent"     tools:context=".Camera" &gt;      &lt;TextureView         android:id="@+id/texture"         android:layout_width="match_parent"         android:layout_height="match_parent"         android:layout_alignParentTop="true" /&gt;      &lt;com.getbase.floatingactionbutton.FloatingActionButton         android:id="@+id/btn_takepicture"         android:layout_width="wrap_content"         android:layout_height="wrap_content"         fab:fab_icon="@drawable/ic_fab_foto"         fab:fab_colorNormal="#FFFF56B9"         fab:fab_colorPressed="#FFD5379B"         android:layout_alignParentBottom="true"         android:layout_centerHorizontal="true"         android:layout_marginBottom="16dp" /&gt;      &lt;com.getbase.floatingactionbutton.FloatingActionButton         android:id="@+id/btn_switchcam"         android:layout_width="wrap_content"         android:layout_height="wrap_content"         fab:fab_icon="@drawable/ic_fab_switch"         fab:fab_colorNormal="#267300"         fab:fab_colorPressed="#1e5b00"         fab:fab_size="mini"         android:layout_alignParentTop="true"         android:layout_alignParentRight="true"         android:layout_marginTop="16dp"         android:layout_marginRight="16dp" /&gt;  &lt;/RelativeLayout&gt; </code></pre>  <p>Camera Activity</p>  <pre><code>public class AppCamera extends AppCompatActivity {     private Size mPreviewSize;      private TextureView mTextureView;     private CameraDevice mCameraDevice;     private CaptureRequest.Builder mPreviewBuilder;     private CameraCaptureSession mPreviewSession;     private static int cam = 0;      private FloatingActionButton mBtnShot;     private FloatingActionButton mBtnSwitch;      private static final SparseIntArray ORIENTATIONS = new SparseIntArray();      static {         ORIENTATIONS.append(Surface.ROTATION_0, 90);         ORIENTATIONS.append(Surface.ROTATION_90, 0);         ORIENTATIONS.append(Surface.ROTATION_180, 270);         ORIENTATIONS.append(Surface.ROTATION_270, 180);     }      @Override     protected void onCreate(Bundle savedInstanceState) {         super.onCreate(savedInstanceState);         getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN);         setContentView(R.layout.camera);          mTextureView = (TextureView)findViewById(R.id.texture);         mTextureView.setSurfaceTextureListener(mSurfaceTextureListener);          mBtnShot = (FloatingActionButton)findViewById(R.id.btn_takepicture);         mBtnSwitch = (FloatingActionButton)findViewById(R.id.btn_switchcam);          mBtnShot.setOnClickListener(new OnClickListener(){              @Override             public void onClick(View v) {                 takePicture();             }          });          mBtnSwitch.setOnClickListener(new OnClickListener(){              @Override             public void onClick(View v) {                 if (cam == 0) {                     cam = 1;                 } else {                     cam = 0;                 }                 if (null != mCameraDevice) {                     mCameraDevice.close();                     mCameraDevice = null;                 }                 openCamera();             }          });      }      protected void takePicture() {         if(null == mCameraDevice) {             return;         }          CameraManager manager = (CameraManager) getSystemService(Context.CAMERA_SERVICE);         try {             CameraCharacteristics characteristics = manager.getCameraCharacteristics(mCameraDevice.getId());              Size[] jpegSizes = null;             if (characteristics != null) {                 jpegSizes = characteristics                         .get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP)                         .getOutputSizes(ImageFormat.JPEG);             }             int width = 640;             int height = 480;             if (jpegSizes != null &amp;&amp; 0 &lt; jpegSizes.length) {                 width = jpegSizes[0].getWidth();                 height = jpegSizes[0].getHeight();             }              ImageReader reader = ImageReader.newInstance(width, height, ImageFormat.JPEG, 1);             List&lt;Surface&gt; outputSurfaces = new ArrayList&lt;Surface&gt;(2);             outputSurfaces.add(reader.getSurface());             outputSurfaces.add(new Surface(mTextureView.getSurfaceTexture()));              final CaptureRequest.Builder captureBuilder = mCameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_STILL_CAPTURE);             captureBuilder.addTarget(reader.getSurface());             captureBuilder.set(CaptureRequest.CONTROL_MODE, CameraMetadata.CONTROL_AE_MODE_ON_AUTO_FLASH);              // Orientation             int rotation = getWindowManager().getDefaultDisplay().getRotation();             captureBuilder.set(CaptureRequest.JPEG_ORIENTATION, ORIENTATIONS.get(rotation));              final File file = new File(Environment.getExternalStorageDirectory()+"/DCIM", "teste.jpg");              ImageReader.OnImageAvailableListener readerListener = new ImageReader.OnImageAvailableListener() {                  @Override                 public void onImageAvailable(ImageReader reader) {                      Image image = null;                     try {                         image = reader.acquireLatestImage();                         ByteBuffer buffer = image.getPlanes()[0].getBuffer();                         byte[] bytes = new byte[buffer.capacity()];                         buffer.get(bytes);                         save(bytes);                     } catch (FileNotFoundException e) {                         e.printStackTrace();                     } catch (IOException e) {                         e.printStackTrace();                     } finally {                         if (image != null) {                             image.close();                         }                     }                 }                  private void save(byte[] bytes) throws IOException {                     OutputStream output = null;                     try {                         output = new FileOutputStream(file);                         output.write(bytes);                     } finally {                         if (null != output) {                             output.close();                         }                     }                 }              };              HandlerThread thread = new HandlerThread("CameraPicture");             thread.start();             final Handler backgroudHandler = new Handler(thread.getLooper());             reader.setOnImageAvailableListener(readerListener, backgroudHandler);              final CameraCaptureSession.CaptureCallback captureListener = new CameraCaptureSession.CaptureCallback() {                  @Override                 public void onCaptureCompleted(CameraCaptureSession session,                                                CaptureRequest request, TotalCaptureResult result) {                      super.onCaptureCompleted(session, request, result);                     Toast.makeText(AppCamera.this, "Saved:"+file, Toast.LENGTH_SHORT).show();                     startPreview();                 }              };              mCameraDevice.createCaptureSession(outputSurfaces, new CameraCaptureSession.StateCallback() {                  @Override                 public void onConfigured(CameraCaptureSession session) {                      try {                         session.capture(captureBuilder.build(), captureListener, backgroudHandler);                     } catch (CameraAccessException e) {                          e.printStackTrace();                     }                 }                  @Override                 public void onConfigureFailed(CameraCaptureSession session) {                  }             }, backgroudHandler);          } catch (CameraAccessException e) {             e.printStackTrace();         }      }      @Override     protected void onResume() {         super.onResume();     }      private void openCamera() {          CameraManager manager = (CameraManager) getSystemService(Context.CAMERA_SERVICE);         try {             String cameraId = manager.getCameraIdList()[cam];             CameraCharacteristics characteristics = manager.getCameraCharacteristics(cameraId);             StreamConfigurationMap map = characteristics.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);             mPreviewSize = map.getOutputSizes(SurfaceTexture.class)[0];              manager.openCamera(cameraId, mStateCallback, null);         } catch (CameraAccessException e) {             e.printStackTrace();         }     }      private TextureView.SurfaceTextureListener mSurfaceTextureListener = new TextureView.SurfaceTextureListener(){          @Override         public void onSurfaceTextureAvailable(SurfaceTexture surface, int width, int height) {             openCamera();         }          @Override         public void onSurfaceTextureSizeChanged(SurfaceTexture surface,                                                 int width, int height) {         }          @Override         public boolean onSurfaceTextureDestroyed(SurfaceTexture surface) {             return false;         }          @Override         public void onSurfaceTextureUpdated(SurfaceTexture surface) {             //Log.e(TAG, "onSurfaceTextureUpdated");         }      };      private CameraDevice.StateCallback mStateCallback = new CameraDevice.StateCallback() {          @Override         public void onOpened(CameraDevice camera) {              mCameraDevice = camera;             startPreview();         }          @Override         public void onDisconnected(CameraDevice camera) {          }          @Override         public void onError(CameraDevice camera, int error) {          }      };      @Override     protected void onPause() {          super.onPause();         if (null != mCameraDevice) {             mCameraDevice.close();             mCameraDevice = null;         }     }      protected void startPreview() {          if(null == mCameraDevice || !mTextureView.isAvailable() || null == mPreviewSize) {             return;         }          SurfaceTexture texture = mTextureView.getSurfaceTexture();         if(null == texture) {             return;         }          texture.setDefaultBufferSize(mPreviewSize.getWidth(), mPreviewSize.getHeight());         Surface surface = new Surface(texture);          try {             mPreviewBuilder = mCameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);         } catch (CameraAccessException e) {              e.printStackTrace();         }         mPreviewBuilder.addTarget(surface);          try {             mCameraDevice.createCaptureSession(Arrays.asList(surface), new CameraCaptureSession.StateCallback() {                  @Override                 public void onConfigured(CameraCaptureSession session) {                      mPreviewSession = session;                     updatePreview();                 }                  @Override                 public void onConfigureFailed(CameraCaptureSession session) {                      Toast.makeText(AppCamera.this, "onConfigureFailed", Toast.LENGTH_LONG).show();                 }             }, null);         } catch (CameraAccessException e) {              e.printStackTrace();         }     }      protected void updatePreview() {          if(null == mCameraDevice) {         }          mPreviewBuilder.set(CaptureRequest.CONTROL_MODE, CameraMetadata.CONTROL_MODE_AUTO);         HandlerThread thread = new HandlerThread("CameraPreview");         thread.start();         Handler backgroundHandler = new Handler(thread.getLooper());          try {             mPreviewSession.setRepeatingRequest(mPreviewBuilder.build(), null, backgroundHandler);         } catch (CameraAccessException e) {              e.printStackTrace();         }     } } </code></pre>