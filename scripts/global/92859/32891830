<p>With help from <a href="http://stackoverflow.com/questions/32352886/how-to-set-physics-properties-for-a-circle-so-it-follows-given-path">here</a> I have made a circle body traverse a given path. I have some bodies at some of the path points and have logged contact in <code>didBeginContact</code>. When the body gets in contact with a specific body the circle body is changed to a rectangle. This rectangular body is suppose to traverse the same path as the original circle body but it doesn't reach the path points as the contact is not logged. I tried changing <code>radiusPoint</code> to the width or height of the rectangle also but that didn't work. Also the rectangle body is bigger than the circle body. How can I get the rectangle to traverse the points with the contact recognised?  Please see code below.</p>  <p>Code related to path traversal:</p>  <pre><code>    let repeats: Bool = true //Whether to repeat the path.     var pathIndex = 0 //The index of the current point to travel.     var pointRadius: CGFloat = SKTexture(imageNamed: "circle").size().width //How close the node must be to reach the destination point.     let travelSpeed: CGFloat = 250 //Speed the node will travel at.     let rate: CGFloat = 0.9 //Motion smoothing. 0.5      circlePath = [     CGPoint(x:screenSize.width , y: screenSize.height/3),     CGPoint(x: screenSize.width/2, y: platform.sprite.frame.height),     CGPoint(x: 0.0, y: screenSize.height/3),     CGPoint(x: CGFloat(pos1) + screenSize.width/20, y: upperSpearPosHeight)]      final func didReachPoint() {     //reached point!     pathIndex++      if pathIndex &gt;= ballPath.count &amp;&amp; repeats {     pathIndex = 0     }     }      func updatePath() {      if pathIndex &gt;= 0 &amp;&amp; pathIndex &lt; circlePath.count {     let destination = circlePath[pathIndex]     //currentPosition = destination     let displacement = CGVector(dx: destination.x-circle!.sprite.position.x, dy: destination.y-circle!.sprite.position.y)     let radius = sqrt(displacement.dx*displacement.dx+displacement.dy*displacement.dy)     let normal = CGVector(dx: displacement.dx/radius, dy: displacement.dy/radius)     let impulse = CGVector(dx: normal.dx*travelSpeed, dy: normal.dy*travelSpeed)     let relativeVelocity = CGVector(dx:impulse.dx-circle!.sprite.physicsBody!.velocity.dx, dy:impulse.dy-circle!.sprite.physicsBody!.velocity.dy);     circle!.sprite.physicsBody!.velocity=CGVectorMake(circle!.sprite.physicsBody!.velocity.dx+relativeVelocity.dx*rate, circle!.sprite.physicsBody!.velocity.dy+relativeVelocity.dy*rate);      if radius &lt; pointRadius {         didReachPoint()         }         }     } </code></pre>  <p>Contact code:</p>  <pre><code>        func didBeginContact(contact: SKPhysicsContact) {     var firstBody : SKPhysicsBody     var secondBody : SKPhysicsBody      if contact.bodyA.categoryBitMask &lt; contact.bodyB.categoryBitMask  {     firstBody = contact.bodyA     secondBody = contact.bodyB     }     else    {     firstBody = contact.bodyB     secondBody = contact.bodyA     }              if firstBody.categoryBitMask == circleCategory &amp;&amp; secondBody.categoryBitMask == bonusCategory  {     let img = SKTexture(imageNamed: "rectangular")    (firstBody.node! as? SKSpriteNode)?.size = img.size()           firstBody.node!.physicsBody = SKPhysicsBody(texture: img, size: img.size())    firstBody.node!.physicsBody?.allowsRotation = false     changeCircleAction = SKAction.setTexture(img)       firstBody.node!.runAction(changeCircleAction)  }      if firstBody.categoryBitMask == circleCategory &amp;&amp; secondBody.categoryBitMask == platformCategory  {      print("touched platform")     }      if firstBody.categoryBitMask == circleCategory &amp;&amp; secondBody.categoryBitMask == smallStarCategory  {      removeStar(secondBody.node!)     } </code></pre>