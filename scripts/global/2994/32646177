<p>I normally have no Problem with binding a DataSource to a GridControl. I usually so something like this: </p>  <pre><code>myGrid.DataSource = myList // BindingList&lt;ComplexObject&gt; colMyStrings.FieldName = "PropertyNameOfComplexObject"; </code></pre>  <p>and it works fine. I can add and delete rows from the grid and they will get added to / deleted from the DataSource "myList". So I basically always see whats in my List.</p>  <p>But now I dont have a List, where the Generic Type has Properties, but I have a List filled with strings.</p>  <pre><code>BindingList&lt;string&gt; </code></pre>  <p>When I Try to bind the List to my grid, it wont get that the strings themselves are what i want bound to the rows of my column and since string doesnt have any properties, there is nothing I can fill the columns .FielName with.</p>  <p>I know I could use a wrapper class to solve this problem, but I dont find this solution to be very nice.</p>  <p>Is there a way to tell the column, that the data it should use is the Objects, in this case the strings, themselves? </p>  <p>Tanks for the help.</p>  <p><strong>UPDATE1</strong>:</p>  <p>This is something I tried. I thought if I could make my own GridControl and override the setter for the DataSource Property, I could make an internal Wrapper so that anyone who uses it wont need do so. This kind of works. I can add my DataSource BindingList now, but for some reason I cant edit the values. I dont know why. Here is the Code:</p>  <pre><code>public partial class NativeTypeGrid : DevExpress.XtraGrid.GridControl {     public NativeTypeGrid()     {         InitializeComponent();     }      public override object DataSource     {         get         {             return base.DataSource;         }         set         {             if (value is IBindingList)             {                 Type GenericType;                 IBindingList myList = (IBindingList) value;                 BindingList&lt;Wrapper&gt; wrappedList = new BindingList&lt;Wrapper&gt;();                 GenericType = myList.GetType().GetGenericArguments()[0];                 if(GenericType.IsPrimitive || GenericType == typeof(string))                 {                     for(int i = 0; i &lt; myList.Count; i++)                     {                         object obj = myList[i];                         wrappedList.Add(new Wrapper(ref obj));                     }                      base.DataSource = wrappedList;                 }                 else                 {                     base.DataSource = value;                 }             }             else             {                 base.DataSource = value;             }         }     }      internal class Wrapper     {         private object _NativeTypeProperty;          public Wrapper()         {             _NativeTypeProperty = "SomeValueForInitialization";         }          public Wrapper(ref object nativeType)         {             _NativeTypeProperty = nativeType;         }          public object NativeTypeProperty         {             get { return _NativeTypeProperty; }             set { _NativeTypeProperty = value; }         }     } } </code></pre>  <p><strong>UPDATE2:</strong> I already figured out why it wont get any by the user added objects. Of course it doenst work since adding an Object to the DataSource uses the basic/empty constructor, wich in turn means that my DataSource doesnt have that connection to the original List, wich is the one I want the new objects to be in. I will work on this and update again.</p>  <p><strong>UPDATE3:</strong> Couldnt think of any better solution, so I went with the initial approach and built a wrapper class for my strings. Looks a little bit like this:</p>  <pre><code>class StringWrapper{     public String MyString{ get; set;} }  myGrid.DataSource = new BindingList&lt;StringWrapper&gt;(); </code></pre>  <p>Im still glad for any suggestions or ideas for another approach.</p>