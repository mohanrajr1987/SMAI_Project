<p>I am trying to implement a buffer overflow attack and I need to know the address of my buffer that I am trying to overflow.</p>  <p>The address that is displayed using GDB is different than if I just did this in the code:</p>  <p>Exact code:</p>  <pre><code>#include&lt;stdio.h&gt;  int main() {    char buffer[20];    printf("%p\n", buffer); // 0xbffff320     return 0; } </code></pre>  <p>However, in gdb if I do:</p>  <pre><code>p &amp;buffer </code></pre>  <p>I get: <code>0xbffff330</code></p>  <p>Why is there a difference and will it mess up my buffer overflow attack?</p>  <p>I have ALSR and stack guard disabled. </p>  <p>Thanks.</p>  <p>EDIT 1: Even when I step through gdb and it encounters the print line, I get 0xbffff320 as the address</p>  <p>EDIT 2:</p>  <p>Environment: Ubuntu Linux 9 image running in virtual box on windows 7.</p>  <p>The gdb version: 6.8-debian</p>  <p>Compiled using GCC such as: <code>gcc -g -fno-stack-protector filename.c</code>  execute immediately: <code>./a.out</code> address printed: 0xbffff320</p>  <p>Then open in debugger like this: <code>gdb ./a.out</code> then enter <code>b main</code> then <code>run</code> then <code>p &amp;buffer</code> </p>  <p>Then address is 0xbffff330</p>  <p>Edit 3:</p>  <p>This is the gdb log to reproduce behavior:</p>  <p>$ gdb ./a.out</p>  <p>b main</p>  <p>run</p>  <p>p &amp;buffer /* address here is different than what is shown if I run executable */</p>  <p>step through program to printf statement /* address here is same as p &amp;buffer but different than what is printed when program is ran */</p>