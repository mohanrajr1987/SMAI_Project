<p>I have a big problem at the moment. I get a segmentation fault in my code, and I stepped through it with the debugger. From an object I am reading the member <code>const char* name</code>, to print it with <code>printf</code>. And here is where my segfault comes. I would guess that the pointer to the object is invalid, but from gdb I can inspect all values of that object, and the content of <code>name</code> is exactly what it should be. I have absolutely no idea, why I am getting a segmentation fault.</p>  <p><strong>So what reasons can there be, that my program isn't allowed to read some data, while gdb is allowed to do so?</strong></p>  <p>edit: for those people those people who still didn't get it, I am not asking for anyone to fix my problems, I just want to know how and in which scenarios a debugger is allowed to read some data, and my program is not. I added a screenshot as a proof that I am not making things up here, but I don't need you to understand my code.</p>  <p>Just some corner information. My program is a Plugin for a Qt Application. It uses the Qt plugin api to load plugins via <code>lib&lt;PluginName&gt;.so</code>.</p>  <p>g++ (Debian 4.9.2-10) 4.9.2 GNU gdb (Debian 7.7.1+dfsg-5) 7.7.1</p>  <p>edit: I added a screenshot to better see the problem. The initialization is done it the constructor.</p>  <p><img src="https://picload.org/image/pdiddia/cbug.png" alt="proof">.</p>  <pre><code>class PickingHandler { public:     const char* name;     PickingHandler(const char* name) : name(name) {}     [...]     virtual void Drag(PickResult) = 0; };  class ConnectHandler : public PickingHandler { public:     ConnectHandler() : PickingHandler("connect handler") {}     [...]     void Drag(PickResult) override; }; </code></pre>