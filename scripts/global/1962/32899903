<p>I've got a problem with code corruption, and I need a way to check that the local stack is not messed up. I've noticed something is overwriting the <code>this</code> variable (well, that is what gdb seems to show. It displays the <code>this</code> pointer as 0x1959 or some other small 16 bit value that seems wrong),  so I stuck in a bunch of <code>assert(VALID_RAM_MEMORY(this))</code> over the code with this definition</p>  <pre><code>#define VALID_RAM_POINTER(x) (( (uint64_t)x &amp; 0xFFFFFFFF00000000) == 0x7fff00000000ULL) </code></pre>  <p>(All pointers in my code that addresses that look like that, ie start with 7FFF...).  However, the compiler seems to have optimized this check out. For example, if I have</p>  <pre><code>void* a = suspicious_call(); assert(VALID_RAM_POINTER(this)); assert(VALID_RAM_POINTER(a));      //&lt;&lt;-- this one assert(VALID_RAM_POINTER(this)); </code></pre>  <p>I find that the debugger (gdb) catches the assert marked "this one", and examining the value of <code>a</code> and <code>this</code>, I find that <em>both</em> <code>a</code> and <code>this</code> are bogus values like 0xabcd, instead of 0x7FFFE1484580. It seems that the compiler thinks that <code>this</code> is <code>const</code>, and so checking it multiple times is unnecessary.  I want to cast <code>this</code> as <code>volatile</code> but that's not possible (I tried). And you can't take the address of <code>this</code> (it is not an lvalue).</p>  <pre><code> 1): warning #191: type qualifier is meaningless on cast type               assert(VALID_MEM_POINTER((volatile decltype(this))this)); </code></pre>  <p>What can I do?  Using icc and gdb.</p>