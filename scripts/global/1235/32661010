<p>As per this stackoverflow question: </p>  <p><a href="http://stackoverflow.com/questions/7562335/what-is-the-correct-way-to-programmatically-quit-an-mfc-application">What is the correct way to programmatically quit an MFC application?</a></p>  <p>I am using <code>AfxGetMainWnd()-&gt;PostMessage(WM_CLOSE,0,0);</code> to exit an MFC program. (SDI, CFrameWnd containing a CSplitterWnd with two CFormViews)</p>  <p>As expected, this calls <code>DestroyWindow()</code>.</p>  <p>The problem I am facing is that after the derived CFormView destruction, as per MSDN:</p>  <blockquote>   <p>After calling DestroyWindow on a non-auto-cleanup object, the C++ object will still be around, but m_hWnd will be NULL. [<a href="https://msdn.microsoft.com/en-us/library/5zba4hah.aspx" rel="nofollow">MSDN</a>]</p> </blockquote>  <p>Now the <code>CView</code> destructor is called and at the point it does the </p>  <pre><code>CDocument::RemoveView()... CDocument::UpdateFrameCounts() </code></pre>  <p>it fails on the following assert: <code>ASSERT(::IsWindow(pView-&gt;m_hWnd));</code></p>  <p>I checked and the <code>m_hWnd</code> is already set to NULL in the derived CView destructor called just before.</p>  <p>What am I doing wrong ?</p>  <p>EDIT: </p>  <p>Here is a chart illustrating why I want to send a WM_CLOSE message and not a WM_QUIT.</p>  <p><a href="http://i.stack.imgur.com/i7SlP.png" rel="nofollow"><img src="http://i.stack.imgur.com/i7SlP.png" alt="enter image description here"></a></p>  <p>I think the answer lays in this <a href="https://msdn.microsoft.com/en-us/library/5zba4hah.aspx" rel="nofollow">MSDN Technical Note</a>, but I can't figure it out.</p>  <p>EDIT 2:</p>  <p>The order that things get called:</p>  <p>1- <code>AfxGetMainWnd()-&gt;PostMessage(WM_CLOSE,0,0);</code></p>  <p>2- <code>Derived CFrameWnd::OnClose()</code></p>  <p>3- <code>CFrameWnd::OnClose()</code></p>  <p>which calls <code>CWinApp::CloseAllDocuments(BOOL bEndSession);</code></p>  <p>which calls <code>CDocManager::CloseAllDocuments(BOOL bEndSession)</code></p>  <p>which calls <code>CDocTemplate::CloseAllDocuments(BOOL)</code></p>  <p>which calls <code>CDocument::OnCloseDocument()</code></p>  <p>Now, in this function</p>  <pre><code>while (!m_viewList.IsEmpty()) {     // get frame attached to the view     CView* pView = (CView*)m_viewList.GetHead();     ASSERT_VALID(pView);     CFrameWnd* pFrame = pView-&gt;EnsureParentFrame();      // and close it     PreCloseFrame(pFrame);     pFrame-&gt;DestroyWindow();     // will destroy the view as well } </code></pre>  <p>So we see that <code>CWnd::DestroyWindow()</code> is called, so:</p>  <p>4- <code>Derived CFormView destructor</code></p>  <p>5- <code>CScrollView::~CScrollView()</code></p>  <p>6- <code>CView::~CView()</code></p>  <p>which calls <code>CDocument::RemoveView(CView* pView)</code></p>  <p>which calls <code>CDocument::OnChangedViewList()</code></p>  <p>which calls <code>CDocument::UpdateFrameCounts()</code></p>  <p>Which crashes here: <code>ASSERT(::IsWindow(pView-&gt;m_hWnd));</code></p>  <p>because <code>pView-&gt;m_hWnd</code> is <code>NULL</code>...</p>  <p>EDIT 3:</p>  <p>I figured out what the problem was:</p>  <p>The destructor of the first view was deleting an uninitialized pointer, which is UB. This was making the destructor hang and never complete.</p>  <p>Usually, the destructor of the second view is only called upon completion of the first one. But in this case it was still being executed although the first one never completed.</p>  <p>Since the first view base class destructors were never called, this function was never called for the first view:</p>  <pre><code>void CDocument::RemoveView(CView* pView) {     ASSERT_VALID(pView);     ASSERT(pView-&gt;m_pDocument == this); // must be attached to us      m_viewList.RemoveAt(m_viewList.Find(pView));     pView-&gt;m_pDocument = NULL;      OnChangedViewList();    // must be the last thing done to the document } </code></pre>  <p><strong>Where we can see that the view is removed from the <code>m_viewList</code></strong>.</p>  <p>This means that when the second view destructor completes, in:</p>  <pre><code>void CDocument::UpdateFrameCounts()      // assumes 1 doc per frame {     // walk all frames of views (mark and sweep approach)     POSITION pos = GetFirstViewPosition();     while (pos != NULL)     { ... </code></pre>  <p><strong>The pos is supposed to be <code>NULL</code>, but it is not. Which lead to the crash.</strong></p>