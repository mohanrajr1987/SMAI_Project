<p>I am building a test application(testApp) for a legacy MFC based application (MFC-app). I am trying to simulate mouse clicks on the MFC-app using message-passing between them. I was able to do this successfully for bring up dialog boxes from the MFC-app menu. However when I am trying to simulate a mouse click on the View of the MFC -app it doesn't seem to work. </p>  <p>The main question I have is whether there are any known limitations in trying to use SendMessage,PostMessage functions to communicate to a derived class of CView ? Also note that I am reusing the ON_COMMAND() handlers for handling my messages since the goal is to exercise the same handler which gets called through Menu option clicks via my TestApp. More details about what I tried and the errors I am getting: </p>  <h2>Attempt 1.</h2>  <h2>TestApp:</h2>  <p>::SendMessage to MFC-app's CMainFrame asking it to bring up the CView with the desired input. ----> This works </p>  <h2>MFCApp:</h2>  <p>CMainFrame: Retrieves a  ptr to the derived class of CView (CDesignView) and its HWND handle using the approach described here: <a href="https://support.microsoft.com/en-us/kb/108587" rel="nofollow">https://support.microsoft.com/en-us/kb/108587</a> Code used is pasted below: </p>  <pre><code>  CMDIChildWnd * pChild = MDIGetActive();    if ( !pChild )       return -1;    CView *pView = pChild-&gt;GetActiveView();    if (!pView) {      MessageBox(_T("Could not get a handle to the design"), _T("Test2 Error"),  MB_OK);     return -1; }    // Fail if view is of wrong kind   if ( !pView-&gt;IsKindOf( RUNTIME_CLASS(CDesignView) ) ) {       MessageBox(_T("View obtained is not of type DesignView"), _T("Test2 Error"),  MB_OK);      return -1;   } CDesignView* designView = (CDesignView*)pView ;  HWND view_hWnd = designView-&gt;m_hWnd ;  if (!view_hWnd) {      MessageBox(_T("designView handle could not be obtained"), _T("Test2 Error"),  MB_OK);      return -1; } </code></pre>  <p>-------------------> At this point the code has non-NULL values for view_hWnd and designView. However when I use these for SendMessage it fails: </p>  <p>designView->PostMessageW(ID_DESIGN_xxx,NULL, NULL) ;  </p>  <p>--> This does NOT work i.e no change in app as if the mesg was never sent. The ID_DESIGN_xxx handler is never called. The handler is declared as below in the CDesignView Message Map: </p>  <p>ON_COMMAND(ID_DESIGN_xxx       , OnXXX)</p>  <p>(Note: I am re-using the handler which the MFCApp had already used for the menu option corresponding to this function on the CDesignView since the goal is to test it out)</p>  <p>-------------------->When I replaced it with a direct call to the handler as below it works: </p>  <p>designView->OnStarOrder() ; </p>  <p>However that is not the behavior I want since it involves exposing too many View handlers as public and also defeats the purpose of a test-app closely simulating the actual use model. </p>  <p>------------------->To further debug I also tried calling the native WM_xxx messages  like below.</p>  <p>designView->PostMessageW(WM_CLOSE,NULL, NULL) ; </p>  <p>This gave an exception failure in this check : IsKindOf( RUNTIME_CLASS(CView) assertion fail.</p>  <h2> Attempt 2</h2>  <p>I also tried to make the TestApp send the messages to the MFCApp CDesignView instead of its own MainFrame doing it as described above. So I passed the CDerivedView handle view_hWnd from above code to TestApp using a ON_COPY message. Then TestApp does a ::SendMessage(view_hWnd,WM_CLOSE,NULL, NULL). The same error was got.  This approach was tried to rule out the possibility of the CDesignView not being an active window at the time of the SendMessage. In this case, I manually click on the CView of MFCApp before letting the  TestApp send the message. </p>  <p>None of these seem to work. Any suggestions you can provide to proceed will be of great help. Thanks in advance!</p>