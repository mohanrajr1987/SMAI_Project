<p>I am trying to simulate a mouse click on the <code>CView</code> window in a legacy code which I must say I don't fully understand. The idea is to search for a particular item in the <code>CView</code>, get its co-ordinates and then simulate a right mouse click on it using <code>SendInput</code>.  I want to understand if the basic steps I am following are correct before I proceed digging further into the legacy code which has a bunch of transformations happening across co-ordinate systems :( Here are the steps I follow: </p>  <ol> <li><p>Get the position co-ordinates of the item displayed in <code>CView</code>. at this point the co-ordinates is in the internal co-ordinate system (lets call it <code>CDPoint</code>). </p>  <p><code>CDPoint gPosn = viewObj-&gt;m_point_a ;</code> </p></li> <li><p>Covert the co-ordinates to the client co-ordinate system i.e CDPoint to CPoint using the existing transformations in the code. </p>  <p><code>CPoint newPosn = GetTransform().Scale(gPosn);</code></p></li> </ol>  <p>//Note: The basis of arriving that this is the correct transformation to use is the below code with the exact reverse transform happening in the mouse click handler code to convert <code>CPoint</code> to <code>CDPoint</code>:</p>  <pre><code> `CDesignView::OnLButtonDown(UINT nFlags, CPoint p) {       CDPoint np = GetTransform().DeScale(p);  }` </code></pre>  <p>Is this thinking right that CPoint received in the OnLButtonDown() handler will always be in the client co-ordinates and hence the reverse transform should convert CDPoint (internal co-ordinates) to client coordinates (CPoint) ? </p>  <ol start="3"> <li><p>Convert client co-ordinates to screen co-ordinates: </p>  <p><code>ClientToScreen(&amp;newPosn);</code></p></li> <li><p>Pass these values to <code>SendInput</code> function after converting to pixel co-ordinates: </p>  <p><code>INPUT buffer[1]; MouseSetup(buffer); MouseMoveAbsolute(buffer, newPos.x, newPos.y); MouseClick(buffer);</code></p></li> <li><p>The Mousexxx() functions are defined as below similar to the sample code in this post: <a href="http://stackoverflow.com/questions/7492529/how-to-simulate-a-mouse-movement">How to simulate a mouse movement</a></p></li> </ol>  <p>.</p>  <pre><code>#define SCREEN_WIDTH (::GetSystemMetrics( SM_CXSCREEN )-1)  #define SCREEN_HEIGHT (::GetSystemMetrics( SM_CYSCREEN )-1)   static void inline makeAbsXY(double &amp;x, double &amp;y) {      x = (x * 0xFFFF) / SCREEN_WIDTH ;      y = (y * 0xFFFF) / SCREEN_HEIGHT ;  }  static void inline MouseSetup(INPUT *buffer) {     buffer-&gt;type = INPUT_MOUSE;     buffer-&gt;mi.dx = (0 * (0xFFFF / SCREEN_WIDTH));     buffer-&gt;mi.dy = (0 * (0xFFFF / SCREEN_HEIGHT));     buffer-&gt;mi.mouseData = 0;     buffer-&gt;mi.dwFlags = MOUSEEVENTF_ABSOLUTE;     buffer-&gt;mi.time = 0;     buffer-&gt;mi.dwExtraInfo = 0; }  static void inline MouseMoveAbsolute(INPUT *buffer, double x, double y) {     makeAbsXY(x,y) ;      buffer-&gt;mi.dx = x ;     buffer-&gt;mi.dy = y ;     buffer-&gt;mi.dwFlags = (MOUSEEVENTF_ABSOLUTE | MOUSEEVENTF_MOVE);     SendInput(1, buffer, sizeof(INPUT)); }  static void inline MouseClick(INPUT *buffer) {     buffer-&gt;mi.dwFlags = (MOUSEEVENTF_ABSOLUTE | MOUSEEVENTF_RIGHTDOWN);     SendInput(1, buffer, sizeof(INPUT));     Sleep(10);     buffer-&gt;mi.dwFlags = (MOUSEEVENTF_ABSOLUTE | MOUSEEVENTF_RIGHTUP);     SendInput(1, buffer, sizeof(INPUT)); } </code></pre>  <p>Could anyone pls provide pointers on what might be going wrong in these steps since the simulated mosue click always seem to be shifted left by some factor which keeps increasing as x becoems larger. I have verified that is gPosn is pointing to (0,0) it always simulates a mouse click on the top right corner of the client screen. </p>  <p>Thanks for your time.</p>