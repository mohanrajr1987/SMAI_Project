<p>In my MVVM application there are several points where I have a scenario like this:</p>  <pre><code>public class Model {     public ISubModel[] SubModels {get;}      // some subModels are created in the model domain,     // so I can't pass the desired view model upon addition     public void AddSubModel(ISubModel subModel); } </code></pre>  <p>The model contains a list of submodels, which can be of several concrete types (they only share a common interface).</p>  <p>The ViewModels also exposes these submodels like this:</p>  <pre><code>public class ViewModel1 {     public IViewSubModel1[] SubModels {get;} }  public class ViewModel2 {     public IViewSubModel2[] SubModels {get;} } </code></pre>  <p>The model is used in different places and thus needs different view models/views for each SubModel.</p>  <p>To sum it up:</p>  <ul> <li>There are several implementations of <code>ISubModel</code></li> <li>I need a way to get from <code>ISubModel</code> to <code>IViewSubModel1</code> and <code>IViewSubModel2</code> (maybe more)</li> <li>The concrete implementation that shall be used must not be fixed but should be changeable.</li> </ul>  <p>The solutions I've found so far are either:</p>  <ul> <li>susceptible for runtime errors (if the mapping cannot be found)</li> <li>not flexible (if the concrete mapping is hard-coded)</li> </ul>  <p>An example:</p>  <p>I have list of articles for a shop. The list of articles (i.e. the <code>Model</code> class) has loaded the articles (i.e. the <code>ISubModel</code>s) from file. Thus there is no View model for each article yet. Different kind of articles have different models (since they have different attributes), so they only share an interface (<code>ISubModel</code>) with common functionality (like "is on stock", "price" etc.). I want to present the list in several contexts (e.g. a shop-admin and an user) so I need several ViewModels for each model since the options what can be done with an article depends on the context.</p>