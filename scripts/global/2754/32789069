<p>While trying different ways to send a <code>Vec&lt;u8&gt;</code> to a function that expects an <code>&amp;[u8]</code>, I made a "mistake" which actually works. I wrote some sample code to show this:</p>  <pre><code>fn sum(v: &amp;[u8]) -&gt; u8 {     let mut s = 0u8;     for x in v.iter() {         s = s + x;     }     return s; }  fn main() {     let myarr = [1u8, 2u8, 3u8];     let myvec = vec![1u8, 2u8, 3u8];      println!("{}", sum(&amp;myarr));     println!("{}", sum(&amp;myvec)); } </code></pre>  <p>I have a few questions in relation to this:</p>  <ul> <li>Why and how does this work? </li> <li>Is there an automatic casting between these two types? </li> <li>Does it incur any penalty or it is just taking the memory location of the underlying array of the vector? </li> <li>Does this mean that for this type of usage (read only operations on an array of numbers) is better to use an array and not a vector as the API? </li> </ul>