<p>When I am starting my server, I am getting an error that I cannot cast Long to Date. It is thrown at a specific line. </p>  <p>Error log :</p>  <pre><code>java.lang.ClassCastException: java.lang.Long cannot be cast to java.util.Date     at org.hibernate.type.descriptor.java.JdbcTimestampTypeDescriptor.unwrap(JdbcTimestampTypeDescriptor.java:41)     at org.hibernate.type.descriptor.sql.TimestampTypeDescriptor$1.doBind(TimestampTypeDescriptor.java:64)     at org.hibernate.type.descriptor.sql.BasicBinder.bind(BasicBinder.java:90)     at org.hibernate.type.AbstractStandardBasicType.nullSafeSet(AbstractStandardBasicType.java:286)     at org.hibernate.type.AbstractStandardBasicType.nullSafeSet(AbstractStandardBasicType.java:281)     at org.hibernate.param.NamedParameterSpecification.bind(NamedParameterSpecification.java:67)     at org.hibernate.loader.hql.QueryLoader.bindParameterValues(QueryLoader.java:616)     at org.hibernate.loader.Loader.prepareQueryStatement(Loader.java:1901)     at org.hibernate.loader.Loader.executeQueryStatement(Loader.java:1862)     at org.hibernate.loader.Loader.executeQueryStatement(Loader.java:1839)     at org.hibernate.loader.Loader.doQuery(Loader.java:910)     at org.hibernate.loader.Loader.doQueryAndInitializeNonLazyCollections(Loader.java:355)     at org.hibernate.loader.Loader.doList(Loader.java:2554)     at org.hibernate.loader.Loader.doList(Loader.java:2540)     at org.hibernate.loader.Loader.listIgnoreQueryCache(Loader.java:2370)     at org.hibernate.loader.Loader.list(Loader.java:2365)     at org.hibernate.loader.hql.QueryLoader.list(QueryLoader.java:497)     at org.hibernate.hql.internal.ast.QueryTranslatorImpl.list(QueryTranslatorImpl.java:387)     at org.hibernate.engine.query.spi.HQLQueryPlan.performList(HQLQueryPlan.java:236)     at org.hibernate.internal.SessionImpl.list(SessionImpl.java:1300)     at org.hibernate.internal.QueryImpl.list(QueryImpl.java:103)     at com.journaldev.spring.dao.SupportRequestDAOImpl.getUnResolvedIssuesWithTimerExpired(SupportRequestDAOImpl.java:211)     at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)     at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)     at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)     at java.lang.reflect.Method.invoke(Method.java:497)     at org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:317)     at org.springframework.aop.framework.ReflectiveMethodInvocation.invokeJoinpoint(ReflectiveMethodInvocation.java:190)     at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:157)     at org.springframework.transaction.interceptor.TransactionInterceptor$1.proceedWithInvocation(TransactionInterceptor.java:99)     at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:281)     at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:96)     at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179) </code></pre>  <p>SupportRequestDAOImpl :</p>  <pre><code> @Override     public List&lt;SupportRequest&gt; getUnResolvedIssuesWithTimerExpired() {         Session session = this.sessionFactory.getCurrentSession();         long now = System.currentTimeMillis();         Query query = session.createQuery("from SupportRequest as sr where sr.resolved=false and sr.timeToResolve&gt;:now and sr.requestStatus=false");         query.setParameter("now", now); // error line         return query.list();     } </code></pre>  <p>SupportRequest model :</p>  <pre><code>@Entity @Table(name = "supportrequest") public class SupportRequest implements Serializable {      private static final long serialVersionUID = 1L;      @Id     @Column(name = "supportrequestid")     @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "supportrequest_gen")     @SequenceGenerator(name = "supportrequest_gen", sequenceName = "supportrequest_seq")     private int supportRequestId;      @Column(name = "subject")     private String subject;      @Column(name = "text")     private String text;      @Column(name = "type")     private String type;      @Column(name = "priority")     private String priority;      @Column(name = "status",columnDefinition = "boolean default false")     private boolean requestStatus;      @Column(name = "timetoresolve")     private Timestamp timeToResolve;      @Column(name = "creationtime")     private Timestamp creationTime;      @Column(name = "resolvedtime")     private Timestamp resolvedTime;      @Column(name = "assigned_team_member_id")     private int assignedTeamMemberId;      @Column(name = "resolved",columnDefinition = "boolean default false")     private boolean resolved;      @Column(name = "resolvedintime",columnDefinition = "boolean default false")     private boolean resolvedInTime;      // Only for testing     @Transient     private int assignedteamid;      @Transient     private Long assignedgroupid; </code></pre>  <p>SupportRequest Database table :</p>  <pre><code>CREATE TABLE supportrequest (   supportrequestid integer NOT NULL,   subject character varying,   text character varying,   type character varying,   priority character varying,   timetoresolve timestamp without time zone,   creationtime timestamp without time zone,   resolvedtime timestamp without time zone,   assigned_team_member_id integer DEFAULT 0,   resolved boolean DEFAULT false,   resolvedintime boolean DEFAULT false,   groupid numeric NOT NULL,   status boolean,   CONSTRAINT supportrequestid PRIMARY KEY (supportrequestid),   CONSTRAINT groupaccount_supportrequest_fk FOREIGN KEY (groupid)       REFERENCES groupaccount (groupid) MATCH SIMPLE       ON UPDATE NO ACTION ON DELETE NO ACTION ) WITH (   OIDS=FALSE ); ALTER TABLE supportrequest   OWNER TO postgres; </code></pre>  <p>What am I doing wrong?</p>  <p>I also tried :</p>  <pre><code>long now = new Timestamp(System.currentTimeMillis()).getTime(); </code></pre>