<p>I am looking at the article from MSDN <a href="https://msdn.microsoft.com/en-US/library/ms173147(v=vs.80).aspx" rel="nofollow">Guidelines for Overloading Equals() and Operator ==</a></p>  <p>and I saw the following code</p>  <pre><code>public override bool Equals(object obj) {     // If parameter is null return false.     if (obj == null)     {         return false;     }      // If parameter cannot be cast to Point return false.     TwoDPoint p = obj as TwoDPoint;     if ((System.Object)p == null)     {         return false;     }      // Return true if the fields match:     return (x == p.x) &amp;&amp; (y == p.y); } </code></pre>  <p>the strange thing is the cast to object in the second if</p>  <pre><code>// If parameter cannot be cast to Point return false. TwoDPoint p = obj as TwoDPoint; if ((object)p == null) {     return false; } </code></pre>  <p>Why p is casted again to object? Isn't it enough to write this</p>  <pre><code>// If parameter cannot be cast to Point return false. TwoDPoint p = obj as TwoDPoint; if (p == null) {     return false; } </code></pre>  <p>If p cannot be casted to TwoDPoint, then it's value will be null. I am puzzled, probably I don't understand something trivial ...</p>  <p><strong>EDIT</strong></p>  <p>One more such cast is presented in the other Equals method</p>  <pre><code>public bool Equals(TwoDPoint p) {     // If parameter is null return false:     if ((object)p == null)     {         return false;     } } </code></pre>  <p>Here again it's enough to check only <code>if(p == null)</code></p>