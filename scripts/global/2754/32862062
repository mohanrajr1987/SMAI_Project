<p>I'm trying to learn about templates and template specialisation. I'm writing a template class for arrays, using template specialisation to avoid code bloat. Thus I have a fully specialised template MyArray and then I inherit from this one like <code>class MyArray&lt;T*&gt; : private MyArray&lt;void*&gt;</code>. I'm having trouble overloading the subscript operators  (one for non-const refs, one for const refs). Here's a piece of code (far from complete, but contains my problem).</p>  <pre><code>#include &lt;iostream&gt; using std::cout; using std::cin; using std::endl;  /*** template class MyArray   **/ template &lt;class T&gt; class MyArray {};  /*** Full template specialization for MyArray holding pointers ***/ template &lt;&gt;  class MyArray&lt;void*&gt; {     public:         explicit MyArray(unsigned s = 100) : sz(s) {             data = new void*[s];          }         virtual ~MyArray() { delete[] data; }          /** subscript operator overload for non-const refs **/         void*&amp; operator[](unsigned i) {             return data[i];         }          /** subscript operator overload for const refs **/         const void*&amp; operator[](unsigned i) const {             return data[i];    // line 26         }          unsigned size() const { return sz; }      private:          void** data;         unsigned sz; };  /** Partial specialization: create the template class by inheriting from the one above **/ template &lt;class T&gt; class MyArray&lt;T*&gt; : private MyArray&lt;void*&gt; {     public:         explicit MyArray(unsigned s = 100) : MyArray&lt;void*&gt;::MyArray(s) {             data = new T*[s];           }         virtual ~MyArray() { delete[] data; }          /** subscript operator overload for non-const refs **/         T*&amp; operator[](unsigned i) {             return reinterpret_cast&lt;T*&amp;&gt;(      // line 47                 MyArray&lt;void*&gt;::operator[](i)             );         }         /** subscript operator overload for const refs **/         const T*&amp; operator[](unsigned i) const {             return reinterpret_cast&lt;const T*&amp;&gt;(                 MyArray&lt;void*&gt;::operator[](i)             );         }           unsigned size() const { return MyArray&lt;void*&gt;::size(); }      private:         T** data;  };  /** input function for filling MyArray's  **/ template &lt;class T&gt; void InputMyArray(MyArray&lt;T*&gt;&amp; my_array) {     unsigned size = 0;     T tmp;     while (cin &gt;&gt; tmp) {         T* i = new T;         *i = tmp;         my_array[size++] = i;     } }  /** output function for printing elements of MyArray's **/ template &lt;class T&gt; void OutputArray(const MyArray&lt;T*&gt;&amp; my_array) {      for (unsigned i = 0; i &lt; my_array.size(); i++) {         cout &lt;&lt; *my_array[i] &lt;&lt; " ";     }     cout &lt;&lt; endl; }  int main() {     /** Initialize array, fill it, print contents **/     MyArray&lt;int*&gt; p;     InputMyArray(p);     cout &lt;&lt; "MyArray of pointer to ints holds int values: " &lt;&lt; endl;     OutputArray(p);      return 0; } </code></pre>  <p>The compiler (clang) is complaining (error) about line 26 </p>  <blockquote>   <p>non-const lvalue reference to type 'const void *' cannot bind to a value of unrelated type 'void *'</p> </blockquote>  <p>I suppose I don't want the compiler to interpret this as a non-const reference - what I want is for it to be const. How can I properly overload this operator in this context? The corresponding piece of code works fine for a  template class without specialisation, like <code>MyArray&lt;T&gt;</code>. </p>  <p>The compiler further complains (warnings) about the <code>reinterpret_cast</code>s which apparently contain undefined behaviour</p>  <blockquote>   <p>reinterpret_cast from 'void *' to 'int *&amp;' has undefined behavior </p> </blockquote>  <p>(line 47). The <code>reinterpret_casts</code> are essentially copy-pasted from my instructions, so I would think they are to be used like this. I don't know why the reference to <code>void*</code> isn't picked up. What am I doing wrong here?</p>