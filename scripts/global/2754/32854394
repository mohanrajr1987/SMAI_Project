<p>I'm fiddling a bit with <code>Any</code> and casting just to get a deeper understanding of Rust. From C# I'm used to the fact that casting can lead to runtime exceptions because casting in C# basically means <em>Dear compiler, trust me, I know what I'm doing please cast this into an <code>int32</code> because I know it will work.</em></p>  <p>However, if you're doing an invalid cast the program will blow up with an Exception at runtime. So I was wondering if casting in (safe) Rust can equally lead to a runtime exception.</p>  <p>So, I came up with this code to try it out.</p>  <pre><code>use std::any::Any;  fn main() {     let some_int = 4;     let some_str = "foo";     {       let mut v = Vec::&lt;&amp;Any&gt;::new();       v.push(&amp;some_int);       v.push(&amp;some_str);        // this gives a None       let x = v[0].downcast_ref::&lt;String&gt;();       println!("foo {:?}", x);        //this gives Some(4)       let y = v[0].downcast_ref::&lt;i32&gt;();       println!("foo {:?}", y);        //the compiler doesn't let me do this cast (which would lead to a runtime error)       //let z = v[1] as i32;      } } </code></pre>  <p>My observation so far is that the compiler seems to prevent me from this kind of runtime exceptions because I have to cast through <code>downcast_ref</code> which returns an <code>Option</code> which makes it safe again. Sure, I can <code>unwrap</code> on a <code>None</code> to blow it up but that's not my point ;)</p>  <p>The compiler prevents me from writing <code>let z = v[1] as i32;</code> which could lead to a runtime error. So, is it correct to assume that casting in safe Rust will never result in a runtime error?</p>  <p>I know that preventing runtime errors is exactly what Rust is all about so it makes perfect sense, I just want to validate my observation :)</p>