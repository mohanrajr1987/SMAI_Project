<p>I am building an interface, where it would be a little bit inconvenient to use separate variables to access individual interfaces, it would be great if somehow I could create a union of the two.</p>  <p>In a file:</p>  <pre><code>struct A{     virtual int auu() { return 41; } }; struct B{     virtual int boo() { return 43; } }; </code></pre>  <p>In another file:</p>  <pre><code>#include &lt;path to A, B&gt; struct C : public A, public B{     int auu() { return 20; }     int boo() { return 22; } }; </code></pre>  <p>And another file:</p>  <pre><code>#include &lt;declaration of A and B, but not C&gt;  void doSth(A* a) {     B * b = dynamic_cast&lt;B*&gt;(a);     /* I can only call auu with a */     a-&gt;auu();     /* I can only call boo with b */     b-&gt;boo;      /* Something like this would be ideal: */     &lt;??? type&gt; * C_interface = dynamic_interface_cast&lt;B*&gt;(a)     C_interface-&gt;auu();     C_interface-&gt;boo(); } </code></pre>  <p>So is there to call both auu and boo through only one pointer variable and without the knowledge of C's implementation (not casting it to )? Also I'd like to avoid creating inheritance hierarchy that is NOT in connection with class C.</p>  <p>Probably the answer is no, however I'm curious if an idea like this has come up from the side of the language developers because to my primitive mind it's not a so far fetched idea.</p>  <p>EDIT: In real, A and B are abstract. A is a Simulation object that has methods like size() and length(). B is an IO interface, implementing getters and setters, but it doesn't know about sizes so I have to use both interfaces in many calculations. C is a specialized Simulation that implements the former 2. </p>  <p>EDIT: I rewrote the question, maybe it actually makes sense now.</p>