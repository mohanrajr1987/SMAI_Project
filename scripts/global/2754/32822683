<p>I wrote some code. It works... but is it safe?</p>  <pre><code>use std::mem; use std::ptr; use std::marker::PhantomData;  struct Atomic&lt;T: Copy&gt;(AtomicUsize, PhantomData&lt;T&gt;);  impl&lt;T: Copy&gt; Atomic&lt;T&gt; {     unsafe fn encode(src: T) -&gt; usize {         assert!(mem::size_of::&lt;T&gt;() &lt;= mem::size_of::&lt;usize&gt;());          let mut dst = 0;         ptr::write(&amp;mut dst as *mut usize as *mut T, src);         dst     }      unsafe fn decode(src: usize) -&gt; T {         assert!(mem::size_of::&lt;T&gt;() &lt;= mem::size_of::&lt;usize&gt;());         ptr::read(&amp;src as *const usize as *const T)     }      fn new(val: T) -&gt; Atomic&lt;T&gt; {         unsafe {             Atomic(AtomicUsize::new(Self::encode(val)), PhantomData)         }     }      fn load(&amp;self, order: Ordering) -&gt; T {         unsafe { Self::decode(self.0.load(order)) }     }      fn store(&amp;self, val: T, order: Ordering) {         unsafe { self.0.store(Self::encode(val), order) }     } }  impl&lt;T: Copy + Default&gt; Default for Atomic&lt;T&gt; {     fn default() -&gt; Atomic&lt;T&gt; {         Self::new(T::default())     } } </code></pre>  <p>As you can see, I write an arbitrary <code>Copy</code> value of small enough size into a <code>usize</code>, and ship it around in an <code>Atomic</code>. I then read it out as a new value.</p>  <p>In essence I use the <code>usize</code> as a memory block of size <code>size_of::&lt;usize&gt;()</code>.</p>  <p>If this is safe, the next step is to consider fancier operations.</p>  <pre><code>unsafe trait PackedInt {} unsafe impl PackedInt for u8  {} unsafe impl PackedInt for i8  {} unsafe impl PackedInt for u32 {} unsafe impl PackedInt for i32 {} unsafe impl PackedInt for u64 {} unsafe impl PackedInt for i64 {}  impl&lt;T: Copy + PackedInt&gt; Atomic&lt;T&gt; {     fn compare_and_swap(&amp;self, current: T, new: T, order: Ordering) -&gt; T {         unsafe {             Self::decode(self.0.compare_and_swap(                 Self::encode(current),                 Self::encode(new),                 order             ))         }     }      fn fetch_add(&amp;self, val: T, order: Ordering) -&gt; T {         unsafe {             Self::decode(self.0.fetch_add(Self::encode(val), order))         }     }      fn fetch_sub(&amp;self, val: T, order: Ordering) -&gt; T {         unsafe {             Self::decode(self.0.fetch_sub(Self::encode(val), order))         }     } } </code></pre>  <p>These are of course not always particularly sensible on overflow (since two "equal" values could compare unequal due to bits outside of the <code>T</code>), but they still seem well-defined... I think.</p>  <p>So, is this safe, and why?</p>