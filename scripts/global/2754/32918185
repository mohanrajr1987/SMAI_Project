<p>Trying to CAST a video to the chromecast. Button shows, can select it, when I choose the chromecast, i get connected successful. Get a message that the player is ready too. Then when I push the video, nothing happens, press again, error.</p>  <p>What am i missing? (I do see the tv go black for a second like its about to prepare for displaying but after a few seconds returns to the hold screen)</p>  <pre><code>import android.content.DialogInterface; import android.os.Bundle; import android.support.v4.view.MenuItemCompat; import android.support.v7.app.ActionBarActivity; import android.support.v7.app.AlertDialog; import android.support.v7.app.AppCompatActivity; import android.support.v7.app.MediaRouteActionProvider; import android.support.v7.media.MediaControlIntent; import android.support.v7.media.MediaRouteSelector; import android.support.v7.media.MediaRouter; import android.util.Log; import android.view.Menu; import android.view.MenuItem; import android.view.View; import android.widget.Button;  import com.google.android.gms.cast.ApplicationMetadata; import com.google.android.gms.cast.Cast; import com.google.android.gms.cast.CastDevice; import com.google.android.gms.cast.MediaInfo; import com.google.android.gms.cast.MediaMetadata; import com.google.android.gms.cast.MediaStatus; import com.google.android.gms.cast.RemoteMediaPlayer; import com.google.android.gms.common.ConnectionResult; import com.google.android.gms.common.api.GoogleApiClient; import com.google.android.gms.common.api.ResultCallback; import com.google.android.gms.common.api.Status;  import java.io.IOException;  public class MainActivity extends AppCompatActivity {     private MediaRouteSelector selector=null;     private MediaRouter router=null;     private MediaRouter.RouteInfo routeSelected;     private CastDevice mSelectedDevice;     private GoogleApiClient mApiClient;     private boolean mWaitingForReconnect;     private boolean mApplicationStarted;      private Cast.Listener  mCastClientListener;      private String TAG = "APP";     private String APPID = "APP_ID"; // YES I GOT MY REAL ID HERE      private MyMediaRouterCallback mMediaRouterCallback;     private HelloWorldChannel mHelloWorldChannel;      private RemoteMediaPlayer mRemoteMediaPlayer;      private Button btnPlay;      @Override     protected void onCreate(Bundle savedInstanceState) {         super.onCreate(savedInstanceState);         setContentView(R.layout.activity_main);          btnPlay = (Button) findViewById(R.id.btn_play);          btnPlay.setOnClickListener(new View.OnClickListener() {             public void onClick(View v) {                 // TODO Auto-generated method stub                  if (mApiClient.isConnected())                 {                     showMessage("Still connected and trying to load");                      // OK!!!!                     MediaMetadata mediaMetadata = new MediaMetadata(MediaMetadata.MEDIA_TYPE_MOVIE);                     mediaMetadata.putString(MediaMetadata.KEY_TITLE, "TEST");                     MediaInfo mediaInfo = new MediaInfo.Builder(                             "http://clips.vorwaerts-gmbh.de/VfE_html5.mp4")                             .setContentType("video/mp4")                             .setStreamType(MediaInfo.STREAM_TYPE_BUFFERED)                             .setMetadata(mediaMetadata)                             .build();                       try {                         showMessage("LOAD!");                         mRemoteMediaPlayer.load(mApiClient, mediaInfo, true)                                 .setResultCallback(new ResultCallback&lt;RemoteMediaPlayer.MediaChannelResult&gt;() {                                     @Override                                     public void onResult(RemoteMediaPlayer.MediaChannelResult result) {                                         if (result.getStatus().isSuccess()) {                                             Log.d(TAG, "Media loaded successfully");                                             showMessage("Media loaded successfully");                                         } else {                                             showMessage("Media loaded failed " + result.getStatus().toString());                                         }                                     }                                 });                     } catch (IllegalStateException e) {                         showMessage("Problem occurred with media during loading");                         Log.e(TAG, "Problem occurred with media during loading", e);                     } catch (Exception e) {                         showMessage("Problem opening media during loading");                         Log.e(TAG, "Problem opening media during loading", e);                     }                     showMessage("END TRY");                   } else {                     showMessage("API NOT CONNECTED");                 }                 }         });          router=MediaRouter.getInstance(this);         selector= new MediaRouteSelector.Builder().addControlCategory(MediaControlIntent.CATEGORY_LIVE_AUDIO)                         .addControlCategory(MediaControlIntent.CATEGORY_LIVE_VIDEO)                         .addControlCategory(MediaControlIntent.CATEGORY_REMOTE_PLAYBACK)                         .build();            mMediaRouterCallback = new MyMediaRouterCallback();          mCastClientListener = new Cast.Listener() {             @Override             public void onApplicationStatusChanged() {                 if (mApiClient != null) {                     Log.d(TAG, "onApplicationStatusChanged: " + Cast.CastApi.getApplicationStatus(mApiClient));                 }             }              @Override             public void onVolumeChanged() {                 if (mApiClient != null) {                     Log.d(TAG, "onVolumeChanged: " + Cast.CastApi.getVolume(mApiClient));                 }             }              @Override             public void onApplicationDisconnected(int errorCode)             {                 //teardown();             }         };            mRemoteMediaPlayer = new RemoteMediaPlayer();         mRemoteMediaPlayer.setOnStatusUpdatedListener(                 new RemoteMediaPlayer.OnStatusUpdatedListener() {                     @Override                     public void onStatusUpdated() {                         MediaStatus mediaStatus = mRemoteMediaPlayer.getMediaStatus();                         boolean isPlaying = mediaStatus.getPlayerState() == MediaStatus.PLAYER_STATE_PLAYING;                        }                 });          mRemoteMediaPlayer.setOnMetadataUpdatedListener(                 new RemoteMediaPlayer.OnMetadataUpdatedListener() {                     @Override                     public void onMetadataUpdated() {                         MediaInfo mediaInfo = mRemoteMediaPlayer.getMediaInfo();                         MediaMetadata metadata = mediaInfo.getMetadata();                     }                 });      }      private void teardown() {         Log.d(TAG, "teardown");         if (mApiClient != null) {             if (mApplicationStarted) {                 if (mApiClient.isConnected() || mApiClient.isConnecting()) {                     mApiClient.disconnect();                 }                 mApplicationStarted = false;             }             mApiClient = null;         }         mSelectedDevice = null;         mWaitingForReconnect = false;     }       @Override     public void onStart() {         super.onStart();         router.addCallback(selector, mMediaRouterCallback, MediaRouter.CALLBACK_FLAG_REQUEST_DISCOVERY);     }      @Override     public void onStop() {         router.removeCallback(mMediaRouterCallback);         super.onStop();     }        public void startReceiver()     {         if (mSelectedDevice == null)         {              Log.e(TAG, "mSelectedDevice = null!");          } else {              Log.e(TAG, "mSelectedDevice NOT  NULL !");             Cast.CastOptions.Builder apiOptionsBuilder = Cast.CastOptions.builder(mSelectedDevice, mCastClientListener).setVerboseLoggingEnabled(true);              mApiClient = new GoogleApiClient.Builder(this)                     .addApi(Cast.API, apiOptionsBuilder.build())                     .addConnectionCallbacks(new ConnectionCallbacks())                     .addOnConnectionFailedListener(new ConnectionFailedListener())                     .build();             mApiClient.connect();         }     }       private void sendMessage(String message) {         if (mApiClient != null &amp;&amp; mHelloWorldChannel != null) {             try {                 Cast.CastApi.sendMessage(mApiClient, mHelloWorldChannel.getNamespace(), message)                         .setResultCallback(                                 new ResultCallback&lt;Status&gt;() {                                     @Override                                     public void onResult(Status result) {                                         if (!result.isSuccess()) {                                             Log.e(TAG, "Sending message failed");                                         }                                     }                                 });             } catch (Exception e) {                 Log.e(TAG, "Exception while sending message", e);             }         }     }       @Override     public boolean onCreateOptionsMenu(Menu menu) {         getMenuInflater().inflate(R.menu.menu_main, menu);          MenuItem item=menu.findItem(R.id.route_provider);         MediaRouteActionProvider provider= (MediaRouteActionProvider)MenuItemCompat.getActionProvider(item);         provider.setRouteSelector(selector);          return(true);     }      private class MyMediaRouterCallback extends MediaRouter.Callback     {          @Override         public void onRouteSelected(MediaRouter router, MediaRouter.RouteInfo info) {             mSelectedDevice = CastDevice.getFromBundle(info.getExtras());             startReceiver();         }          @Override         public void onRouteUnselected(MediaRouter router, MediaRouter.RouteInfo info) {            // teardown();             mSelectedDevice = null;         }     }         private class ConnectionCallbacks implements GoogleApiClient.ConnectionCallbacks {         @Override         public void onConnected(Bundle connectionHint)         {             Log.e(TAG, "ConnectionCallbacks onConnected");             if (mWaitingForReconnect) {                 mWaitingForReconnect = false;                 //reconnectChannels();                  Log.e(TAG, "ConnectionCallbacks mWaitingForReconnect was true");              } else {                 Log.e(TAG, "ConnectionCallbacks launchApplication connect");                  try {                     Cast.CastApi.launchApplication(mApiClient, APPID, false)                             .setResultCallback(                                     new ResultCallback&lt;Cast.ApplicationConnectionResult&gt;() {                                         @Override                                         public void onResult(Cast.ApplicationConnectionResult result) {                                             Status status = result.getStatus();                                              Log.e(TAG, "ConnectionCallbacks onResult" + status.toString());                                              if (status.isSuccess()) {                                                  Log.e(TAG, "ConnectionCallbacks onResult YES!");                                                  showMessage("ConnectionCallbacks SUCCESS!");                                                  ApplicationMetadata applicationMetadata =                                                         result.getApplicationMetadata();                                                 String sessionId = result.getSessionId();                                                 String applicationStatus = result.getApplicationStatus();                                                 boolean wasLaunched = result.getWasLaunched();                                                  mApplicationStarted = true;                                                    try {                                                     Cast.CastApi.setMessageReceivedCallbacks(mApiClient, mRemoteMediaPlayer.getNamespace(), mRemoteMediaPlayer);                                                 } catch (IOException e) {                                                     Log.e(TAG, "Exception while creating media channel", e);                                                 }                                                 mRemoteMediaPlayer                                                         .requestStatus(mApiClient)                                                         .setResultCallback(                                                                 new ResultCallback&lt;RemoteMediaPlayer.MediaChannelResult&gt;() {                                                                     @Override                                                                     public void onResult(RemoteMediaPlayer.MediaChannelResult result) {                                                                         if (!result.getStatus().isSuccess())                                                                         {                                                                              showMessage("mRemoteMediaPlayer FAILED!");                                                                           } else {                                                                              showMessage("mRemoteMediaPlayer Successfull - ready to play?");                                                                          }                                                                     }                                                                 });                                                } else {                                                 showMessage("ConnectionCallbacks FAILED!");                                                 Log.e(TAG, "ConnectionCallbacks onResult NO!");                                             }                                         }                                     });                  } catch (Exception e) {                     Log.e(TAG, "Failed to launch application", e);                 }             }         }          @Override         public void onConnectionSuspended(int cause)         {             Log.e(TAG, "ConnectionCallbacks onConnectionSuspended");             mWaitingForReconnect = true;         }     }      private class ConnectionFailedListener implements GoogleApiClient.OnConnectionFailedListener     {         @Override         public void onConnectionFailed(ConnectionResult result) {             Log.e(TAG, "ConnectionFailedListener onConnectionFailed");             teardown();         }     }       class HelloWorldChannel implements Cast.MessageReceivedCallback {         public String getNamespace() {             return "urn:x-cast:com.google.cast.media";         }          @Override         public void onMessageReceived(CastDevice castDevice, String namespace,                                       String message) {             Log.d(TAG, "onMessageReceived: " + message);         }     }        private void showMessage(String message)     {         new AlertDialog.Builder(this)                 .setTitle("Warning")                 .setMessage(message)                 .setPositiveButton(android.R.string.yes, new DialogInterface.OnClickListener() {                     public void onClick(DialogInterface dialog, int which) {                         // continue with delete                     }                 })                 .setIcon(android.R.drawable.ic_dialog_alert)                 .show();     } } </code></pre>