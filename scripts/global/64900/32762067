<p>Here is the controller code that I have which has one service that invokes multiple $http requests, and controller would call these where-ever it is required, which is also shown below in the code:</p>  <pre><code>    var inventoryService = function ($http) {         var baseURL = Config.baseURL;         this.getResults = function (query) {             return $http({                 method: 'GET',                 url: baseURL + '/search',                 params: { query: query },                 headers: {'Content-Type': 'application/json'}             });         };         this.getAllGroups = function () {             return $http({                 method: 'GET',                 url: baseURL + '/search/groups',                 headers: {'Content-Type': 'application/json'}             });         };         this.getAllTypesForGroup = function (group) {             return $http({                 method: 'GET',                 url: baseURL + '/search/groups/' + group + "/types",                 headers: {'Content-Type': 'application/json'}             });         };         this.getAllNamesForType = function (group, type) {             return $http({                 method: 'GET',                 url: baseURL + '/search/groups/' + group + "/types/" + type + "/names",                 headers: {'Content-Type': 'application/json'}             });         };     };  var searchCtrl = function ($scope, $log, InventoryService) {     $log.log('controller initialized!');      // Get all category filters     $scope.filters = loadJSONFile(Category);     $scope.selectedMainFilters = [];     $scope.deleteMainFilter = function (index) {         $scope.selectedMainFilters.splice(index, 1);     };     $scope.addFilter = function (filter) {         // Get specific category filter list         $scope[filter.name] = loadJSONFile(eval(filter.name));         $scope['selected' + filter.name] = [];         $scope.deleteFilter = function (filter, index) {             $scope['selected' + filter.name].splice(index, 1);         };         $scope.getFilter = function (filter) {             return $scope['selected' + filter.name];         };         $scope.checkAll = function (filter) {             $scope['selected' + filter.name] = angular.copy($scope[filter.name]);         };     };       $scope.aggregateInventory = [];     $scope.deleteInventory = function (index) {         $scope.aggregateInventory.splice(index, 1);         delete $scope['groups' + index];         delete $scope['groups1' + index];         delete $scope['groups2' + index];         delete $scope['groups3' + index];     };     $scope.addInventory = function () {         InventoryService.getAllGroups().then(             function (result) {                 $log.info('groups returned...' + JSON.stringify(result.data));                 $scope.groups = result.data;             },             function (error) {                 $log.error('Server returned: ' + error.status);             }         );          $scope.inventory = {};         $scope.selectGroup = function (selectedGroup, index) {              if (selectedGroup.name !== $scope.inventory.group) {                 InventoryService.getAllTypesForGroup(selectedGroup.name).then(                     function (result) {                         $log.info('types for a group returned...' + JSON.stringify(result.data));                         $scope['groups1' + index] = result.data;                     },                     function (error) {                         $log.error('Server returned: ' + error.status);                     }                 );             }              $scope.selectGroup1 = function (selectedGroup1, index) {                 if (selectedGroup1.name !== $scope.inventory.group1) {                     InventoryService.getAllNamesForType(selectedGroup.name, selectedGroup1.name).then(                         function (result) {                             $log.info('names for a type returned...' + JSON.stringify(result.data));                             $scope['groups2' + index] = result.data;                         },                         function (error) {                             $log.error('Server returned: ' + error.status);                         }                     );                 }                  $scope.selectGroup2 = function (selectedGroup2, index) {                     $scope['groups3' + index] = [                         {name: 'Contains', key: 'Contains'},                         {name: 'NotEqualTo', key: 'NotEqualTo'},                         {name: 'EqualTo', key: 'EqualTo'}                     ];                 };             };         };          if ($scope.aggregateInventory.length &gt; 0) {             var index = $scope.aggregateInventory.length;             $scope['conditions' + index] = [                 {name: 'AND', key: 'AND'},                 {name: 'OR', key: 'OR'}             ];         }         $scope.getGroups = function (groups, index) {             return $scope[groups + index];         };         $scope.aggregateInventory.push($scope.inventory);     };      $scope.search = function (isValid) {         $log.log('search function called...');          if (isValid) {             $scope.invData = [];             var query = buildInventorySearchRequestObject($scope.aggregateInventory);             $log.info('query:' + query);             InventoryService.getResults(query).then(                 function (result) {                     $log.info('search results returned...' + JSON.stringify(result.data));                     $scope.invData = result.data;                 },                 function (error) {                     $log.error('Server returned: ' + error.status);                 }             );             document.querySelector('.md-close').click();         }     }; }; </code></pre>  <p>Test cases written in Jamine:</p>  <pre><code>/**  * This test case will test inventory search webservice  * **/ describe('invApp.search module', function () {      var _inventorySearchCtrl;     var _inventoryService;     var _httpBackend;     var _scope;     var _elm1;     var _elm2;      // initialize the module     beforeEach(module('invApp.search'));     // inject all the required angularjs dependencies to execute the test cases     beforeEach(inject(['$controller', '$rootScope', '$compile', '$httpBackend', 'InventoryService', function ($controller, $rootScope, $compile, $httpBackend, InventoryService) {         _inventoryService = InventoryService;          _httpBackend = $httpBackend;          _scope = $rootScope.$new();          _inventorySearchCtrl = $controller('SearchCtrl', {             $scope: _scope         });          _elm1 = angular.element('&lt;filter-checkbox model="selectedMainFilter.name" value="filter"&gt;&lt;/filter-checkbox&gt;');         $compile(_elm1)(_scope);         _scope.$digest();          _elm2 = angular.element('&lt;bootstrap-dropdown id="dropdownGroup{{$index}}" ng-model="inventory.group" items="groups" callback="selectGroup(item, $index)" placeholder="Select"&gt;&lt;/bootstrap-dropdown&gt;');         $compile(_elm2)(_scope);         _scope.$digest();          _scope.deleteMainFilter(1);         _scope.addFilter(loadJSONFile(Category)[0]);         _scope.deleteFilter(loadJSONFile(Category)[0], 1);         _scope.getFilter(loadJSONFile(Category)[0]);         _scope.checkAll(loadJSONFile(Category)[0]);          var container = document.createElement('div');         container.innerHTML = '&lt;a href="#" class="md-close action"&gt;&amp;times;&lt;/a&gt;';         document.body.appendChild(container);          _scope.search(false);         _scope.aggregateInventory = [{             group: 'Hardware',             group1: 'FinancialDevice',             group2: 'DeviceClass',             group3: 'Contains'         }];         _scope.search(true);         _scope.aggregateInventory = [];     }]));      it('should have a inventory controller defined', function () {         expect(_inventorySearchCtrl).toBeDefined();     });      it('should delete the selected inventory from aggregateInventory scope', function () {         _scope.deleteInventory(1);         expect(_scope.aggregateInventory.length).toEqual(0);     });      it('should add the selected inventory to the aggregateInventory scope', function () {         _scope.aggregateInventory = [{             group: 'Hardware',             group1: 'FinancialDevice',             group2: 'DeviceClass',             group3: 'Contains'         }];          _scope.addInventory();          _scope.getGroups('Hardware', 1);         _scope.selectGroup({name: 'Hardware', key: 'Hardware'}, 1);         _scope.selectGroup1({name: 'FinancialDevice', key: 'FinancialDevice'}, 1);         _scope.selectGroup2({name: 'DeviceClass', key: 'DeviceClass'}, 1);         expect(_scope.aggregateInventory.length).toEqual(2);     });      it('should not load the json file if same attribute &lt;Hardware&gt; is selected again', function () {         _scope.addInventory();         _scope.inventory = {             group: 'Hardware',             group1: 'FinancialDevice',             group2: 'DeviceClass',             group3: 'Contains'         };         _scope.selectGroup({name: 'Hardware', key: 'Hardware'}, 1);         expect(_scope.aggregateInventory.length).toEqual(1);     });      it('should test bootstrap-dropdown directive  without callback function being invoked', function() {         expect(_elm2).toBeDefined();         var isolatedScope = _elm2.isolateScope();         isolatedScope.callback = false;         isolatedScope.selectVal({name: 'Hardware', key: 'Hardware'});     });      it('should test bootstrap-dropdown directive with callback function being invoked', function() {         expect(_elm2).toBeDefined();         var isolatedScope = _elm2.isolateScope();         isolatedScope.selectVal({name: 'Hardware', key: 'Hardware'});     });      it('should test submit button click with valid promise', function () {         _httpBackend.when('GET', /.*\/search.*/).respond(200, {             result: "result"         });         _inventoryService.getResults('*:*').then(             function (result) {                 _scope.inventoryData = result.data;             });         _httpBackend.flush();         expect(_scope.inventoryData).toEqual({             result: "result"         });     });      it('should test submit button click with invalid promise', function () {         var returnedError;         _httpBackend.when('GET', /.*\/search.*/).respond(400, {             error: "Bad Query"         });         _inventoryService.getResults('*:*').then(             function (result) {                 _scope.inventoryData = result.data;             },             function (error) {                 returnedError = error;             });         _httpBackend.flush();         expect(returnedError.data.error).toBe("Bad Query");     }); }); </code></pre>  <p>I am not able to cover the below code:</p>  <pre><code>InventoryService.getAllGroups().then(             function (result) {                 $log.info('groups returned...' + JSON.stringify(result.data));                 $scope.groups = result.data;             },             function (error) {                 $log.error('Server returned: ' + error.status);             }         ); </code></pre>  <p>Could you please suggest how to cover all the service $http method calls like above to be covered using Jasmine?</p>  <p><a href="http://i.stack.imgur.com/6aFG2.png" rel="nofollow"><img src="http://i.stack.imgur.com/6aFG2.png" alt="enter image description here"></a></p>