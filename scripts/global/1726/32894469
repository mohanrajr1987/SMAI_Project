<p>I am trying my best to render a texture to the screen. I've also tried to render a sprite but none has succeeded. From my understanding the camera needs a viewport and its best to use world units when rendering your world. I get the idea about units and it makes sense. But if you say your world is 100X100 then your sprite background must also be 100X100. I still don't get it how is supposed to cover the entire device screen(android phone). I guess providing assets at different resolutions or implementing a stretchviewport might be ideal. Also, I am trying to implement the private moveCamera method. My goal is  to have the camera move in random ways displaying parts of my texture. When i ran the code for the first time, I saw that the camera moved but then the screen turned red and then black. I think I might have to clamp the camera to force it to stay within the bounds of the asset. Please help me set this functionality up. </p>  <p>Well here is my code:(Cant render a thing)</p>  <pre><code>public class myGdxGame extends ApplicationAdapter{   @Override  public void Create(){  scenery= new Texture...;  sprity= new Sprite(new Texture(..));  sprity.setPosition(0f,0f);  sprity.setSize(100f,100f);   w= Gdx.graphics.getWidth();  h= Gdx.graphics.getHeight();   moveX=0f;//float value  moveY=0f;//float value  time= System.currentTimeMillis();   camera= new OrthoGraphicCamera(30,30*(h/w));  camera.position.set(camera.viewportWidth/2f,camera.viewportHeight/2f,0);  camera.update();   }   @Override  public void resize(int width, int height) {  camera.viewportWidth = 30f;          camera.viewportHeight = 30f * (height/width);  camera.update();  }  @Override public void render () {  moveCamera(); camera.update(); batch.setProjectionMatrix(camera.combined);  Gdx.gl.glClearColor(1, 0, 0, 1); Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);  batch.begin(); batch.draw(scenery, 0, 0); batch.end();  }  public void moveCamera(){  if(System.currentTimeMillis()-time&gt;2000){  double random=Math.round(Math.random()*100); double random2=Math.round(Math.random()*100); double d=random/10; double e=random2/10; int f=(int)d; int g=(int)e; moveX=moveX+f; moveY=moveY+g;  time=System.currentTimeMillis(); camera.translate(moveX,moveY,0); camera.update();  } }  } </code></pre>