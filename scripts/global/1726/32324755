<p>I am trying to make a skimp with cube mapping. And I have the cube "painted" already, but there is no texture. I don't know if the problem is, when I am loading my texture, like it is not loading any information.  Or because it has no Texture Coords... But in tutorials and explanations I found about Cube Mapping, they don't need any Texture Coords.</p>  <p><a href="http://i.stack.imgur.com/NAi45.png" rel="nofollow"><img src="http://i.stack.imgur.com/NAi45.png" alt="enter image description here"></a></p>  <p>As you see, it is painting the cube, but everything is black.</p>  <pre><code>#define SIZE 1.0  GLfloat VERTICES[] = {     -SIZE,  SIZE, -SIZE,     -SIZE, -SIZE, -SIZE,     SIZE, -SIZE, -SIZE,     SIZE, -SIZE, -SIZE,     SIZE,  SIZE, -SIZE,     -SIZE,  SIZE, -SIZE,      -SIZE, -SIZE,  SIZE,     -SIZE, -SIZE, -SIZE,     -SIZE,  SIZE, -SIZE,     -SIZE,  SIZE, -SIZE,     -SIZE,  SIZE,  SIZE,     -SIZE, -SIZE,  SIZE,      SIZE, -SIZE, -SIZE,     SIZE, -SIZE,  SIZE,     SIZE,  SIZE,  SIZE,     SIZE,  SIZE,  SIZE,     SIZE,  SIZE, -SIZE,     SIZE, -SIZE, -SIZE,      -SIZE, -SIZE,  SIZE,     -SIZE,  SIZE,  SIZE,     SIZE,  SIZE,  SIZE,     SIZE,  SIZE,  SIZE,     SIZE, -SIZE,  SIZE,     -SIZE, -SIZE,  SIZE,      -SIZE,  SIZE, -SIZE,     SIZE,  SIZE, -SIZE,     SIZE,  SIZE,  SIZE,     SIZE,  SIZE,  SIZE,     -SIZE,  SIZE,  SIZE,     -SIZE,  SIZE, -SIZE,      -SIZE, -SIZE, -SIZE,     -SIZE, -SIZE,  SIZE,     SIZE, -SIZE, -SIZE,     SIZE, -SIZE, -SIZE,     -SIZE, -SIZE,  SIZE,     SIZE, -SIZE,  SIZE };  @interface CubeMap (){     GLuint textureId;     NSString *face[6];     ObjLoader *objLoader;      GLuint skyboxVAO, skyboxVBO;      Shader *shader;     GLuint program;      //Unifroms     GLuint u_modelViewProjectionMatrix;     GLuint u_texture; }  @property GLfloat* VertexData; @property uint ByteSize;   @end  @implementation CubeMap  -   (void)initCubeMape{      shader = [[Shader alloc] init];     program = [shader standartProgramaVertPath:@"cubemap" VertType:@"vert" FragPath:@"cubemap" FragType:@"frag"];      //Texture Locations     face[0] = @"back";     face[1] = @"back";     face[2] = @"back";     face[3] = @"back";     face[4] = @"back";     face[5] = @"back";      //Uniforms     glUseProgram(program);     u_modelViewProjectionMatrix = glGetUniformLocation(program, "modelViewProjectionMatrix");     u_texture = glGetUniformLocation(program, "cubeMap");      glEnable(GL_TEXTURE_CUBE_MAP);     glGenTextures(1, &amp;textureId);     glBindTexture(GL_TEXTURE_CUBE_MAP, textureId);      for(int i = 0; i &lt; 6; i++) {          NSString *path = [[NSBundle mainBundle] pathForResource:@"back" ofType:@"jpg"];         NSData *texData = [[NSData alloc] initWithContentsOfFile:path];         UIImage *image = [[UIImage alloc] initWithData:texData];         if (image == nil){             NSLog(@"Image could not been load");         }           size_t width = CGImageGetWidth(image.CGImage);         size_t height = CGImageGetHeight(image.CGImage);         //    NSLog(@"texture image w,h: %zu, %zu", width, height);         CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();         void *imageData = malloc( height * width * 4 );         CGContextRef context0 = CGBitmapContextCreate( imageData, width, height, 8, 4 * width, colorSpace, kCGImageAlphaPremultipliedLast | kCGBitmapByteOrder32Big );         CGColorSpaceRelease( colorSpace );         CGContextClearRect( context0, CGRectMake( 0, 0, width, height ) );         CGContextTranslateCTM( context0, 0, height - height );         CGContextDrawImage( context0, CGRectMake( 0, 0, width, height ), image.CGImage );          glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, (int)width, (int)height, 0, GL_RGBA, GL_UNSIGNED_BYTE, imageData);            CGContextRelease(context0);         free(imageData);     }     glTexParameteri(GL_TEXTURE_CUBE_MAP,GL_TEXTURE_MIN_FILTER,GL_LINEAR);     glTexParameteri(GL_TEXTURE_CUBE_MAP,GL_TEXTURE_MAG_FILTER,GL_LINEAR);     glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);     glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);     glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);      glBindTexture(GL_TEXTURE_CUBE_MAP, 0);        /*********************************      ***********Buffering*************/      // Setup skybox VAO     glGenVertexArrays(1, &amp;skyboxVAO);     glGenBuffers(1, &amp;skyboxVBO);     glBindVertexArray(skyboxVAO);     glBindBuffer(GL_ARRAY_BUFFER, skyboxVBO);     glBufferData(GL_ARRAY_BUFFER, sizeof(VERTICES), &amp;VERTICES, GL_STATIC_DRAW);     glEnableVertexAttribArray(0);     glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(GLfloat), (GLvoid*)0);     glBindVertexArray(0);   }  -   (void)update{  }  -   (void)render{     glDepthMask(GL_FALSE);     glDepthFunc(GL_LEQUAL);     glBindVertexArray(skyboxVAO);     glUseProgram(program);      //bind Texture     glEnable(GL_TEXTURE_CUBE_MAP);     glActiveTexture(GL_TEXTURE0);     glBindTexture(GL_TEXTURE_CUBE_MAP, textureId);     glUniform1i(u_texture, 0);      glUniformMatrix4fv(u_modelViewProjectionMatrix, 1, 0, _modelViewProj.m);       glDrawArrays(GL_TRIANGLES, 0, 36);     glBindVertexArray(0);     glDepthFunc(GL_LESS);     glDepthMask(GL_TRUE);  }  @end </code></pre>  <p>Just for testing, all faces are loading the same image.</p>  <p>Vertex shader:</p>  <pre><code>attribute vec3 position;  varying highp vec3 vTexCoord;  uniform mat4 modelViewProjectionMatrix;  void main() {     vTexCoord = position.xyz;     gl_Position = modelViewProjectionMatrix * vec4(position, 1.0); } </code></pre>  <p>Fragment shader:</p>  <pre><code>uniform samplerCube cubeMap;  varying highp vec3 vTexCoord;  void main() {     lowp vec4 texCol = textureCube(cubeMap, vTexCoord);      lowp vec4 color = vec4(vTexCoord, 1.0);      gl_FragColor = texCol; } </code></pre>  <p>This is how it looks like, if I am changing gl_FragColor to color!</p>  <p><a href="http://i.stack.imgur.com/h1vD3.png" rel="nofollow"><img src="http://i.stack.imgur.com/h1vD3.png" alt="enter image description here"></a></p>