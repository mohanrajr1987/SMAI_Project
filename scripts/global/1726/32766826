<p>I am working on an OpenGL engine and my textures are being rendered weirdly. The textures are mostly full and working, but they have little weird interruptions. Here's what it looks like.</p>  <p><a href="http://i.stack.imgur.com/O0BAi.png" rel="nofollow"><img src="http://i.stack.imgur.com/O0BAi.png" alt="Image"></a></p>  <p>The bottom right corner is what the textures are supposed to look like, there are also randomly colored squares of blue peppered in there. These solid squares (not textured) do not have these interruptions.</p>  <p>I can provide code, but I'm not sure what to show because I've checked everywhere and I don't know where the problem is from.</p>  <p>I am working on a Java and a C++ version. Here is the renderer in Java (If you want to see something else just ask):</p>  <pre><code>public class BatchRenderer2D extends Renderer2D {      private static final int MAX_SPRITES = 60000;     private static final int VERTEX_SIZE = Float.BYTES * 3 + + Float.BYTES * 2 + Float.BYTES * 1 + Float.BYTES * 1;     private static final int SPRITE_SIZE = VERTEX_SIZE * 4;     private static final int BUFFER_SIZE = SPRITE_SIZE * MAX_SPRITES;     private static final int INDICES_SIZE = MAX_SPRITES * 6;      private static final int SHADER_VERTEX_INDEX = 0;     private static final int SHADER_UV_INDEX = 1;     private static final int SHADER_TID_INDEX = 2;     private static final int SHADER_COLOR_INDEX = 3;      private int VAO;     private int VBO;     private IndexBuffer IBO;     private int indexCount;     private FloatBuffer buffer;      private List&lt;Integer&gt; textureSlots = new ArrayList&lt;Integer&gt;();      public BatchRenderer2D() {         init();     }      public void destroy() {         IBO.delete();         glDeleteBuffers(VBO);          glDeleteVertexArrays(VAO);         glDeleteBuffers(VBO);     }      public void init() {         VAO = glGenVertexArrays();         VBO = glGenBuffers();          glBindVertexArray(VAO);         glBindBuffer(GL_ARRAY_BUFFER, VBO);         glBufferData(GL_ARRAY_BUFFER, BUFFER_SIZE, GL_DYNAMIC_DRAW);          glEnableVertexAttribArray(SHADER_VERTEX_INDEX);         glEnableVertexAttribArray(SHADER_UV_INDEX);         glEnableVertexAttribArray(SHADER_TID_INDEX);         glEnableVertexAttribArray(SHADER_COLOR_INDEX);          glVertexAttribPointer(SHADER_VERTEX_INDEX, 3, GL_FLOAT, false, VERTEX_SIZE, 0);         glVertexAttribPointer(SHADER_UV_INDEX, 2, GL_FLOAT, false, VERTEX_SIZE, 3 * 4);         glVertexAttribPointer(SHADER_TID_INDEX, 1, GL_FLOAT, false, VERTEX_SIZE, 3 * 4 + 2 * 4);         glVertexAttribPointer(SHADER_COLOR_INDEX, 4, GL_UNSIGNED_BYTE, true, VERTEX_SIZE, 3 * 4 + 2 * 4 + 1 * 4);          glBindBuffer(GL_ARRAY_BUFFER, 0);          int[] indices = new int[INDICES_SIZE];          int offset = 0;         for (int i = 0; i &lt; INDICES_SIZE; i += 6) {             indices[  i  ] = offset + 0;             indices[i + 1] = offset + 1;             indices[i + 2] = offset + 2;              indices[i + 3] = offset + 2;             indices[i + 4] = offset + 3;             indices[i + 5] = offset + 0;              offset += 4;         }          IBO = new IndexBuffer(indices, INDICES_SIZE);          glBindVertexArray(0);     }      @Override     public void begin() {         glBindBuffer(GL_ARRAY_BUFFER, VBO);         buffer = glMapBuffer(GL_ARRAY_BUFFER, GL_WRITE_ONLY).asFloatBuffer();     }      @Override     public void submit(Renderable2D renderable) {         Vector3f position = renderable.getPosition();         Vector2f size = renderable.getSize();         Vector4f color = renderable.getColor();         List&lt;Vector2f&gt; uv = renderable.getUV();         float tid = renderable.getTID();          float c = 0;          float ts = 0.0f;         if (tid &gt; 0) {             boolean found = false;             for(int i = 0; i &lt; textureSlots.size(); i++) {                  if(textureSlots.get(i) == tid) {                     ts = (float)(i + 1);                     found = true;                     break;                 }             }              if(!found) {                 if(textureSlots.size() &gt;= 32) {                     end();                     flush();                     begin();                 }                 textureSlots.add((int)tid);                 ts = (float)textureSlots.size();             }         } else {             int r = (int) (color.x * 255);             int g = (int) (color.y * 255);             int b = (int) (color.z * 255);             int a = (int) (color.w * 255);             c = Float.intBitsToFloat((r &lt;&lt; 0) | (g &lt;&lt; 8) | (b &lt;&lt; 16) | (a &lt;&lt; 24));         }          transformationBack.multiply(position).store(buffer);         uv.get(0).store(buffer);         buffer.put(ts);         buffer.put(c);          transformationBack.multiply(new Vector3f(position.x, position.y + size.y, position.z)).store(buffer);         uv.get(1).store(buffer);         buffer.put(ts);         buffer.put(c);          transformationBack.multiply(new Vector3f(position.x + size.x, position.y + size.y, position.z)).store(buffer);         uv.get(2).store(buffer);         buffer.put(ts);         buffer.put(c);          transformationBack.multiply(new Vector3f(position.x + size.x, position.y, position.z)).store(buffer);         uv.get(3).store(buffer);         buffer.put(ts);         buffer.put(c);          indexCount += 6;     }      @Override     public void end() {         glUnmapBuffer(GL_ARRAY_BUFFER);         glBindBuffer(GL_ARRAY_BUFFER, 0);     }      @Override     public void flush() {         for(int i = 0; i &lt; textureSlots.size(); i++) {             glActiveTexture(GL_TEXTURE0 + i);             glBindTexture(GL_TEXTURE_2D, textureSlots.get(i));         }          glBindVertexArray(VAO);         IBO.bind();          glDrawElements(GL_TRIANGLES, indexCount, GL_UNSIGNED_INT, NULL);          IBO.unbind();         glBindVertexArray(0);          indexCount = 0;     }  } </code></pre>