<p>I found a script about 2D water and modified it a little. Now I need that my water looks like this texture:</p>  <p><a href="http://i.stack.imgur.com/ubOKg.png" rel="nofollow"><img src="http://i.stack.imgur.com/ubOKg.png" alt="Water Texture"></a></p>  <p>(<em>This image is a linear gradient from opaque white to transparent white, top to bottom</em>)</p>  <p>I want the color at the top of the water to look white and the other part of the water to look transparent.</p>  <p>I tested <code>Legacy Shaders/Transparent/Cutout/Soft Edge Unlit</code> but it didn't work.</p>  <p>My script :</p>  <pre><code>using UnityEngine; using System.Collections;  public struct WaterLinePart {     public float height;     public float velocity;     public GameObject gameObject;     public Mesh mesh;     public Vector2 boundsMin;     public Vector2 boundsMax; }  public class WaterSwim : MonoBehaviour {     public GameObject waterMesh;     public float velocityDamping = 0.999999f; // Proportional velocity damping, must be less than or equal to 1.     public float timeScale = 25f;     public int Width = 50;     public float Height = 10f;     public Material lineMaterial;     public Color waterColor = Color.blue;     public Color lineColor = Color.black;     public float splashForceMin = 3;     public float splashForceMax = 7;     public float splashTimeMin = 1;     public float splashTimeMax = 3;     public float lineWidth = 0.1f;      private LineRenderer line;      private WaterLinePart[] parts;      private int size;     private float time;     private float randomForce;     private float randomTime;      void Start()     {         Initialize();     }      private void Initialize()     {         size = Width;          //waterMaterial.color = waterColor;         lineMaterial.color = lineColor;          parts = new WaterLinePart[size];          // we'll use spheres to represent each vertex for demonstration purposes         for (int i = 0; i &lt; size; i++)         {             // Create a game object             GameObject go = Instantiate(waterMesh, Vector3.zero, Quaternion.identity) as GameObject;             go.transform.parent = transform;             go.transform.localPosition = new Vector3(i - (size / 2), 0, 0);              parts[i].gameObject = go;         }          //Create the line         line = gameObject.AddComponent&lt;LineRenderer&gt;();         line.material = lineMaterial;         line.material.renderQueue = -1;         line.SetVertexCount(size);         line.SetWidth(lineWidth, lineWidth);          // Create the meshes         for (int i = 0; i &lt; size; i++)         {             GameObject go = parts[i].gameObject;              // Except for the last point             if (i &lt; size - 1)             {                 Mesh mesh = new Mesh();                 mesh.MarkDynamic();                 parts[i].mesh = mesh;                  // Define vertices for the mesh (the points of the model)                 UpdateMeshVertices(i);                 UpdateLineRenderer(i);                  // Define triangles and normals                 InitializeTrianglesAndNormalsForMesh(i);                  go.GetComponent&lt;MeshFilter&gt;().mesh = mesh;             }         }     }      private void UpdateLineRenderer(int i)     {         line.SetPosition(i, new Vector3(parts[i].gameObject.transform.localPosition.x, parts[i].gameObject.transform.localPosition.y, parts[i].gameObject.transform.localPosition.z) + transform.position);     }      private void UpdateMeshVertices(int i)     {         Mesh mesh = parts[i].mesh;         if (mesh == null)             return;          Transform current = parts[i].gameObject.transform;          Transform next = current;         if (i &lt; parts.Length - 1)         {             next = parts[i + 1].gameObject.transform;         }          Vector3 left = new Vector3();         Vector3 right = next.localPosition - current.localPosition;          // Get all parts of the mesh (it's just 2 planes, one on top and one on the front face)         Vector3 topLeftFront = new Vector3(left.x, left.y, 0);         Vector3 topRightFront = new Vector3(right.x, right.y, 0);         Vector3 topLeftBack = new Vector3(left.x, left.y, 1);         Vector3 topRightBack = new Vector3(right.x, right.y, 1);         Vector3 bottomLeftFront = new Vector3(left.x, left.y + (0 - Height), 0);         Vector3 bottomRightFront = new Vector3(right.x, right.y + (0 - Height), 0);          mesh.vertices = new Vector3[] { topLeftFront, topRightFront, topLeftBack, topRightBack, bottomLeftFront, bottomRightFront };          parts[i].boundsMin = topLeftFront + current.position;         parts[i].boundsMax = bottomRightFront + current.position;     }      private void InitializeTrianglesAndNormalsForMesh(int i)     {         Mesh mesh = parts[i].mesh;         if (mesh == null)             return;          // Normals         var uvs = new Vector2[mesh.vertices.Length];         for (int i2 = 0; i2 &lt; uvs.Length; i2++)         {             uvs[i2] = new Vector2(mesh.vertices[i2].x, mesh.vertices[i2].z);         }         mesh.uv = uvs;          // Triangles         mesh.triangles = new int[] { 5, 4, 0, 0, 1, 5, 0, 2, 3, 3, 1, 0 };          // For shader         mesh.RecalculateNormals();     }      void Update()     {         time -= Time.deltaTime;          if (time &lt; 0)         {             randomForce = Random.Range(splashForceMin, splashForceMax);             Splash(3, randomForce);             //Splash(25, randomForce);             randomTime = Random.Range(splashTimeMin, splashTimeMax + 1);             time = randomTime;         }          // Water tension is simulated by a simple linear convolution over the height field.         for (int i = 1; i &lt; size - 1; i++)         {             int j = i - 1;             int k = i + 1;             parts[i].height = (parts[i].gameObject.transform.localPosition.y + parts[j].gameObject.transform.localPosition.y + parts[k].gameObject.transform.localPosition.y) / 3.0f;         }          // Velocity and height are updated...          for (int i = 0; i &lt; size; i++)         {             // update velocity and height             parts[i].velocity = (parts[i].velocity + (parts[i].height - parts[i].gameObject.transform.localPosition.y)) * velocityDamping;              float timeFactor = Time.deltaTime * timeScale;             if (timeFactor &gt; 1f) timeFactor = 1f;              parts[i].height += parts[i].velocity * timeFactor;              // Update the dot position             Vector3 newPosition = new Vector3(parts[i].gameObject.transform.localPosition.x, parts[i].height, parts[i].gameObject.transform.localPosition.z);             parts[i].gameObject.transform.localPosition = newPosition;         }          // Update meshes         for (int i = 0; i &lt; size; i++)         {             UpdateMeshVertices(i);             UpdateLineRenderer(i);         }     }      #region Interaction      /// &lt;summary&gt;     /// Make waves from a point     /// &lt;/summary&gt;     /// &lt;param name="location"&gt;&lt;/param&gt;     /// &lt;param name="force"&gt;&lt;/param&gt;     public void Splash(Vector3 location, float force)     {         // Find the touched part         for (int i = 0; i &lt; (size - 1); i++)         {             if (location.x &gt;= parts[i].boundsMin.x               &amp;&amp; location.x &lt; parts[i].boundsMax.x)             {                 if (location.y &lt;= parts[i].boundsMin.y                &amp;&amp; location.y &gt; parts[i].boundsMax.y)                 {                     Splash(i, force);                 }             }         }      }      private void Splash(int i, float heightModifier)     {         parts[i].gameObject.transform.localPosition = new Vector3(parts[i].gameObject.transform.localPosition.x, parts[i].gameObject.transform.localPosition.y + heightModifier, parts[i].gameObject.transform.localPosition.z);     }      #endregion } </code></pre>  <p><strong>Answer :</strong></p>  <p>Finally, I found the solution. The problem was in the part of the code that referred to create mesh.</p>  <p>Correct code :</p>  <pre><code>using UnityEngine; using System.Collections;  public struct WaterLinePart {     public float height;     public float velocity;     public GameObject gameObject;     public Mesh mesh;     public Vector2 boundsMin;     public Vector2 boundsMax; }  public class WaterSwim : MonoBehaviour {     public GameObject waterMesh;     public float velocityDamping = 0.999999f; // Proportional velocity damping, must be less than or equal to 1.     public float timeScale = 25f;     public int Width = 50;     public float Height = 10f;     public Material lineMaterial;     public Color waterColor = Color.blue;     public Color lineColor = Color.black;     public float splashForceMin = 3;     public float splashForceMax = 7;     public float splashTimeMin = 1;     public float splashTimeMax = 3;     public float lineWidth = 0.1f;      private LineRenderer line;      private WaterLinePart[] parts;      private int size;     private float time;     private float randomForce;     private float randomTime;      void Start()     {         Initialize();     }      private void Initialize()     {         size = Width;          //waterMaterial.color = waterColor;         lineMaterial.color = lineColor;          parts = new WaterLinePart[size];          // we'll use spheres to represent each vertex for demonstration purposes         for (int i = 0; i &lt; size; i++)         {             // Create a game object             GameObject go = Instantiate(waterMesh, Vector3.zero, Quaternion.identity) as GameObject;             go.transform.parent = transform;             go.transform.localPosition = new Vector3(i - (size / 2), 0, 0);              parts[i].gameObject = go;         }          //Create the line         line = gameObject.AddComponent&lt;LineRenderer&gt;();         line.material = lineMaterial;         line.material.renderQueue = -1;         line.SetVertexCount(size);         line.SetWidth(lineWidth, lineWidth);          // Create the meshes         for (int i = 0; i &lt; size; i++)         {             GameObject go = parts[i].gameObject;              // Except for the last point             if (i &lt; size - 1)             {                 Mesh mesh = new Mesh();                 mesh.MarkDynamic();                 parts[i].mesh = mesh;                  // Define vertices for the mesh (the points of the model)                 UpdateMeshVertices(i);                 UpdateLineRenderer(i);                  // Define triangles and normals                 InitializeTrianglesAndNormalsForMesh(i);                  go.GetComponent&lt;MeshFilter&gt;().mesh = mesh;             }         }     }      private void UpdateLineRenderer(int i)     {         line.SetPosition(i, new Vector3(parts[i].gameObject.transform.localPosition.x, parts[i].gameObject.transform.localPosition.y, parts[i].gameObject.transform.localPosition.z) + transform.position);     }      private void UpdateMeshVertices(int i)     {         Mesh mesh = parts[i].mesh;         if (mesh == null)             return;          Transform current = parts[i].gameObject.transform;          Transform next = current;         if (i &lt; parts.Length - 1)         {             next = parts[i + 1].gameObject.transform;         }          Vector3 left = new Vector3();         Vector3 right = next.localPosition - current.localPosition;          // Get all parts of the mesh (it's just 2 planes, one on top and one on the front face)         Vector3 topLeftFront = new Vector3(left.x, left.y, 0);         Vector3 topRightFront = new Vector3(right.x, right.y, 0);         //Vector3 topLeftBack = new Vector3(left.x, left.y, 1);         //Vector3 topRightBack = new Vector3(right.x, right.y, 1);         Vector3 bottomLeftFront = new Vector3(left.x, left.y + (0 - Height), 0);         Vector3 bottomRightFront = new Vector3(right.x, right.y + (0 - Height), 0);          mesh.vertices = new Vector3[] { topLeftFront, topRightFront, bottomLeftFront, bottomRightFront };          parts[i].boundsMin = topLeftFront + current.position;         parts[i].boundsMax = bottomRightFront + current.position;     }      private void InitializeTrianglesAndNormalsForMesh(int i)     {         Mesh mesh = parts[i].mesh;          Vector2[] UVs = new Vector2[4];         UVs[0] = new Vector2(0, 1);         UVs[1] = new Vector2(1, 1);         UVs[2] = new Vector2(0, 0);         UVs[3] = new Vector2(1, 0);          mesh.uv = UVs;          // Triangles         mesh.triangles = new int[] { 0, 1, 3, 3, 2, 0 };          // For shader         mesh.RecalculateNormals();     }      void Update()     {         time -= Time.deltaTime;          if (time &lt; 0)         {             randomForce = Random.Range(splashForceMin, splashForceMax);             Splash(3, randomForce);             //Splash(25, randomForce);             randomTime = Random.Range(splashTimeMin, splashTimeMax + 1);             time = randomTime;         }          // Water tension is simulated by a simple linear convolution over the height field.         for (int i = 1; i &lt; size - 1; i++)         {             int j = i - 1;             int k = i + 1;             parts[i].height = (parts[i].gameObject.transform.localPosition.y + parts[j].gameObject.transform.localPosition.y + parts[k].gameObject.transform.localPosition.y) / 3.0f;         }          // Velocity and height are updated...          for (int i = 0; i &lt; size; i++)         {             // update velocity and height             parts[i].velocity = (parts[i].velocity + (parts[i].height - parts[i].gameObject.transform.localPosition.y)) * velocityDamping;              float timeFactor = Time.deltaTime * timeScale;             if (timeFactor &gt; 1f) timeFactor = 1f;              parts[i].height += parts[i].velocity * timeFactor;              // Update the dot position             Vector3 newPosition = new Vector3(parts[i].gameObject.transform.localPosition.x, parts[i].height, parts[i].gameObject.transform.localPosition.z);             parts[i].gameObject.transform.localPosition = newPosition;         }          // Update meshes         for (int i = 0; i &lt; size; i++)         {             UpdateMeshVertices(i);             UpdateLineRenderer(i);         }     }      #region Interaction      /// &lt;summary&gt;     /// Make waves from a point     /// &lt;/summary&gt;     /// &lt;param name="location"&gt;&lt;/param&gt;     /// &lt;param name="force"&gt;&lt;/param&gt;     public void Splash(Vector3 location, float force)     {         // Find the touched part         for (int i = 0; i &lt; (size - 1); i++)         {             if (location.x &gt;= parts[i].boundsMin.x               &amp;&amp; location.x &lt; parts[i].boundsMax.x)             {                 if (location.y &lt;= parts[i].boundsMin.y                &amp;&amp; location.y &gt; parts[i].boundsMax.y)                 {                     Splash(i, force);                 }             }         }      }      private void Splash(int i, float heightModifier)     {         parts[i].gameObject.transform.localPosition = new Vector3(parts[i].gameObject.transform.localPosition.x, parts[i].gameObject.transform.localPosition.y + heightModifier, parts[i].gameObject.transform.localPosition.z);     }      #endregion } </code></pre>