<p>I'm trying fade a premultiplied texture so it gradually becomes transparent. The problem I am having is as the alpha value goes from 1 to 0, the texture fades to black instead of being transparent.</p>  <pre><code>glEnable(GL_BLEND); glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);  // premultiply color color.r = r * alpha; color.g = g * alpha; color.b = b * alpha; color.a = alpha; </code></pre>  <p><br/> see image (you need a reputation of at least 10 to upload an image)</p>  <p><a href="https://sites.google.com/site/soundsculptorpro/_/rsrc/1442889599502/games/blend.png" rel="nofollow">https://sites.google.com/site/soundsculptorpro/_/rsrc/1442889599502/games/blend.png</a> <br/> <br/> <br/> Additive blending fades out correctly but it's too bright.</p>  <pre><code>glEnable(GL_BLEND); glBlendFunc(GL_SRC_ALPHA, GL_ONE); // premultiply color... </code></pre>  <p><br/> Any ideas why additive blending would fade correctly, but alpha blending would fade to black?</p>  <p><br/> <br/> <strong>UPDATE</strong> <br/> <br/> fragment shader (cocos2d 2.1)...</p>  <pre><code>"                                           \n\ #ifdef GL_ES                                \n\ precision lowp float;                       \n\ #endif                                      \n\                                             \n\ varying vec4 v_fragmentColor;               \n\ varying vec2 v_texCoord;                    \n\ uniform sampler2D CC_Texture0;              \n\                                             \n\ void main()                                 \n\ {                                           \n\     gl_FragColor = v_fragmentColor * texture2D(CC_Texture0, v_texCoord); \n\ }                                           \n\ "; </code></pre>  <p><br/> vertex shader (cocos2d 2.1)â€¦</p>  <pre><code>"                                                   \n\ attribute vec4 a_position;                          \n\ attribute vec2 a_texCoord;                          \n\ attribute vec4 a_color;                             \n\                                                     \n\ #ifdef GL_ES                                        \n\ varying lowp vec4 v_fragmentColor;                  \n\ varying mediump vec2 v_texCoord;                    \n\ #else                                               \n\ varying vec4 v_fragmentColor;                       \n\ varying vec2 v_texCoord;                            \n\ #endif                                              \n\                                                     \n\ void main()                                         \n\ {                                                   \n\     gl_Position = CC_MVPMatrix * a_position;        \n\     v_fragmentColor = a_color;                      \n\     v_texCoord = a_texCoord;                        \n\ }                                                   \n\ "; </code></pre>  <p><br/></p>  <pre><code>_ccV3F_C4F_T2F vertices[4];  glVertexAttribPointer(kCCVertexAttrib_Position, 3, GL_FLOAT, GL_FALSE, sizeof(_ccV3F_C4F_T2F), &amp;vertices[0].vertices); glVertexAttribPointer(kCCVertexAttrib_Color, 4, GL_FLOAT, GL_FALSE, sizeof(_ccV3F_C4F_T2F), &amp;vertices[0].colors); glVertexAttribPointer(kCCVertexAttrib_TexCoords, 2, GL_FLOAT, GL_FALSE, sizeof(_ccV3F_C4F_T2F), &amp;vertices[0].texCoords);  glDrawArrays(GL_TRIANGLE_STRIP, 0, 4); </code></pre>