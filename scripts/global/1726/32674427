<p>I am new to webgl, and I'm try to display a texture but only got a nothing, I don't know , where was wrong.</p>  <p>if I comment this line <code>gl.enableVertexAttribArray(a_TextureCoordinates);</code> I'll got a color block, the color is based on the image.</p>  <p>The code is :</p>  <p><div class="snippet" data-lang="js" data-hide="false"> <div class="snippet-code"> <pre class="snippet-code-js lang-js prettyprint-override"><code>// 1. 获得canvas对象 var canvas = document.getElementById('webgl');  // 2. 获得webGL上下文 var gl = getWebGLContext(canvas);  // 顶点着色器 var VSHADER_SOURCE =     'attribute vec4 a_Position;\n' +     'attribute vec2 a_TextureCoordinates;\n' +     'uniform mat4 uMVMatrix;\n' +     'uniform mat4 uPMatrix;\n' +     'varying vec4 v_Color;\n' +     'varying vec2 v_TextureCoordinates;\n' +     'void main() {\n' +     '   gl_Position = a_Position;\n' +     '   v_TextureCoordinates = a_TextureCoordinates;\n' +     '}\n';  // 片元着色器 var FSHADER_SOURCE =     'precision mediump float;\n' +     'varying vec2 v_TextureCoordinates;\n' +     'uniform sampler2D uSampler;\n' +     'void main() {\n' +     '   gl_FragColor= texture2D(uSampler, v_TextureCoordinates);\n' +     '}\n';   // 顶点和颜色对象 var verticesColors = new Float32Array([     1.0, 1.0, 0.0, // rightTop White     -1.0, 1.0, 0.0, // leftTop Magenta     -1.0, -1.0, 0.0, // leftBottom Red     1.0, -1.0, 0.0 // rightBottom Yellow ]);  // 顶点序列标识 var indices = new Uint8Array([     0, 1, 2, 0, 2, 3, // front ]);  // texture 序列 var textureCoordinates = new Float32Array([     0.0, 0.0, //v0     0.0, 0.0, //v1     0.5, 1.0, //v2 ]);  // 3. 初始化着色器 initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE);  // 4. 打开深度测试 gl.enable(gl.DEPTH_TEST);   // 5. 顶点/颜色缓冲区操作 var vertexColorBuffer = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, vertexColorBuffer); gl.bufferData(gl.ARRAY_BUFFER, verticesColors, gl.STATIC_DRAW);   img = new Image(); img.onload = function() {     // 绑定纹理     var samplerUniform = gl.getUniformLocation(gl.program, "uSampler");     gl.activeTexture(gl.TEXTURE0);     //     var texture = gl.createTexture();     gl.bindTexture(gl.TEXTURE_2D, texture);     gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);     gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);     gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);     gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);      // 纹理索引缓冲区     var textureBuffer = gl.createBuffer();     gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer);          gl.bufferData(gl.ARRAY_BUFFER, textureCoordinates, gl.STATIC_DRAW);     var a_TextureCoordinates = gl.getAttribLocation(gl.program, 'a_TextureCoordinates');     gl.vertexAttribPointer(a_TextureCoordinates, 2, gl.FLOAT, false, 0, 0);     gl.enableVertexAttribArray(a_TextureCoordinates);          gl.uniform1i(samplerUniform, 0);      // 5. 顶点/颜色缓冲区操作     var vertexColorBuffer = gl.createBuffer();     gl.bindBuffer(gl.ARRAY_BUFFER, vertexColorBuffer);     gl.bufferData(gl.ARRAY_BUFFER, verticesColors, gl.STATIC_DRAW);      var FSIZE = verticesColors.BYTES_PER_ELEMENT;     var a_Position = gl.getAttribLocation(gl.program, 'a_Position');     gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, FSIZE * 3, 0);     gl.enableVertexAttribArray(a_Position);      // 顶点索引缓冲区     var indexBuffer = gl.createBuffer();     gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);     gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);      // 6.设置视图     gl.viewport(0, 0, canvas.width, canvas.height);     var pMatrixUniform = gl.getUniformLocation(gl.program, "uPMatrix");     var mvMatrixUniform = gl.getUniformLocation(gl.program, "uMVMatrix");     var mvMatrix = mat4.create();     var pMatrix = mat4.create();     mat4.perspective(pMatrix, 45, canvas.width / canvas.height, 1, 1000.0);     mat4.lookAt(mvMatrix, [40, 40, 40], [0, 0, 0], [0, 1, 0]);     gl.uniformMatrix4fv(pMatrixUniform, false, pMatrix);     gl.uniformMatrix4fv(mvMatrixUniform, false, mvMatrix);      // 7. 清除画布     gl.clearColor(0.0, 0.0, 0.0, 1.0);     gl.clear(gl.COLOR_BUFFER_BIT);     // 8. 绘制     gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_BYTE, 0);   } img.crossOrigin = 'anonymous'; img.src = "http://127.0.0.1:8090/webgl/webgl-lessons/lesson05/nehe.gif"; // img.src = "http://127.0.0.1:8090/webgl/webgl-lessons/lesson06/crate.gif";     /********* functions **********/  //get the context function getWebGLContext(canvas, err) {     // bind err      if (canvas.addEventListener) {         canvas.addEventListener("webglcontextcreationerror", function(event) {             err(event.statusMessage);         }, false);     }     //create context     var names = ["webgl", "experimental-webgl", "webkit-3d", "moz-webgl"];     var context = null;     for (var ii = 0; ii &lt; names.length; ++ii) {         try {             context = canvas.getContext(names[ii], err);         } catch (e) {}         if (context) {             break;         }     }     return context; };  //init shader function initShaders(gl, vshader, fshader) {     var program = createProgram(gl, vshader, fshader);     if (!program) {         console.log('Failed to create program');         return false;     }     gl.useProgram(program);     gl.program = program;     return true; }  //create program function createProgram(gl, vshader, fshader) {     // Create shader object     var vertexShader = loadShader(gl, gl.VERTEX_SHADER, vshader);     var fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fshader);     if (!vertexShader || !fragmentShader) {         return null;     }     // Create a program object     var program = gl.createProgram();     if (!program) {         return null;     }     // Attach the shader objects     gl.attachShader(program, vertexShader);     gl.attachShader(program, fragmentShader);     // Link the program object     gl.linkProgram(program);     // Check the result of linking     var linked = gl.getProgramParameter(program, gl.LINK_STATUS);     if (!linked) {         var error = gl.getProgramInfoLog(program);         console.log('Failed to link program: ' + error);         gl.deleteProgram(program);         gl.deleteShader(fragmentShader);         gl.deleteShader(vertexShader);         return null;     }     return program; }  //loadShader function loadShader(gl, type, source) {     // Create shader object     var shader = gl.createShader(type);     if (shader == null) {         console.log('unable to create shader');         return null;     }     // Set the shader program     gl.shaderSource(shader, source);     // Compile the shader     gl.compileShader(shader);     // Check the result of compilation     var compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);     if (!compiled) {         var error = gl.getShaderInfoLog(shader);         console.log('Failed to compile shader: ' + error);         gl.deleteShader(shader);         return null;     }     return shader; }</code></pre> <pre class="snippet-code-html lang-html prettyprint-override"><code>&lt;canvas id="webgl" width="300" height="300" &gt;&lt;/canvas&gt;</code></pre> </div> </div> </p>