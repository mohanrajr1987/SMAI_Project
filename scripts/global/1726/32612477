<p>I'm trying to do collision-detection between my webcamera and some arbitrary gameobjects in a scene. The basic collision is something like this:</p>  <ul> <li>Game marks areas of an array the size of my cameras resolution with colorcodes corresponding to different objects.</li> <li>Script reads webcamera feed and translates it to an average movement shadow with some post processing shader passes. Static 1.0 on all pixels where there is movement.</li> <li>Array translated to datatexture.</li> <li>Collision shader pass multiplies object texture with movement texture, i.e any pixel where there is movement and and object results in a pixel the color of the object, all others are 0's.</li> </ul>  <p>It's worked well for a static game scene, but the data texture does not seem to update properly.</p>  <p>Here's (i think)all the relevant code:     </p>  <p>Creating array from game objects</p>  <pre><code> createCollisionMap: function(objects){      var map = this.emptymap.slice();      for(var obj = 0; obj&lt;objects.length;obj++){          var bounds = this.getBounds(objects[obj]);         for(var i = 0;i&lt;bounds.width/10;i++){             for(var j = 0;j&lt;bounds.height/10;j++){                 for( var k =0;k&lt;4;k++){                     if(!map[((bounds.x/10+i)+((j+bounds.y/10)*bounds.width/10))+k]){                          map[((bounds.x/10+i)+((j+bounds.y/10)*bounds.width/10))+k] = (obj+200);                         k=4;                     }                 }             }         }     }     return map; } </code></pre>  <p>Call from the games' update loop</p>  <pre><code>checkMotion: function(map,objects, callback, callbackContext) {      this.dataTexture = new THREE.DataTexture( map, options.cameraWidth, options.cameraHeight, THREE.RGBAFormat );     this.dataTexture.needsUpdate = true;     mapmaterial.needsUpdate = true;     callback(pixelData,objects,callbackContext, options.cameraWidth, options.cameraHeight);  }, </code></pre>  <p>Creating shader pass</p>  <pre><code> var collision_uniforms = {         camerashadow:   { type: "t", value: subtractionResult.read() },         screenwidth:    { type: "f", value: options.cameraWidth },         screenheight:   { type: "f", value: options.cameraHeight},         objects:        { type: "t", value: this.dataTexture}     };     rttcollision = new ThreeRTT.Stage(this.renderer, {         width: options.cameraWidth,         height: options.cameraHeight,         history: 1 // number of frames of history to keep     });     mapmaterial = new ThreeRTT.FragmentMaterial(rttcollision, 'collision-shader',{},collision_uniforms);     rttcollision.fragment(mapmaterial);     rrtToRender.push(rttcollision); </code></pre>  <p>Rendering loop</p>  <pre><code> rrtToRender.forEach(function(target) {                 target.render();             });              if (this.videoTime &gt; options.videoIgnoreTime / 1000){                  this.renderer.render(this.scene, this.camera);                 gl.readPixels(0, 0, options.cameraWidth, options.cameraHeight, gl.RGBA, gl.UNSIGNED_BYTE, pixelData); </code></pre>  <p>collision shader</p>  <pre><code>&lt;!-- Collision Shader --&gt; &lt;script type='application/x-glsl' id='collision-shader'&gt; precision highp float;     uniform sampler2D camerashadow;     uniform float screenheight;     uniform float screenwidht;     uniform sampler2D objects;     varying vec2 vUV;     void main() {         vec2 pos = vUV * vec2(screenwidht,screenheight);         vec4 texres = texture2D(camerashadow,vUV);         vec4 res = texture2D(objects,vUV);         gl_FragColor = res*texres;     } &lt;/script&gt; </code></pre>  <p>The problem seems to be that the object texture is all 0's no matter the array put in, but i can't seem to find what i've missed.</p>  <p>Any help would be appreciated.</p>