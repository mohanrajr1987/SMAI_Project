<p>I'm trying to implement the eigenfaces algorithm in C++. I already made the database creation part and now I'm setting up the recognition part.</p>  <p>The only problem is that even if all the variables are correctly read from the file <code>"prova.txt"</code>, once they are passed to the function something odd happens: the whole <code>imd</code> array contains values that differ from the expected ones (I've the same algorithm running in Matlab for reference).</p>  <p>I'm a python programmer so I know that probably it's something silly for a C++ user, but I can't find errors in my code (probably not very well optimized and full of redundancies btw). I'm posting a link to the <code>"prova.txt"</code> after the code.</p>  <p><code>U</code> and <code>omega</code> are matrices, that I linearized in order to be able to pass them as input arguments of the function.</p>  <pre><code>#include &lt;iostream&gt; #include &lt;cmath&gt; #include &lt;fstream.h&gt; #include &lt;cstdlib&gt;  using namespace std;  int confrontodb(double*, double, double, double*, double*, double*);  int confrontodb(double* test, double H, double M, double* m, double* U,                 double* omega) {   int Urows = M;   int Ulines = H;   double om[Urows];   double imd[Ulines];   double d[Urows][Urows];   double dist[Urows];   double accum;   double minimo;   int ind = 0;    // subtract average "med" from test sample "test"   for (int i = 0; i &lt; Ulines; i++) {     imd[i] = test[i] - m[i];   }   // Project "imd" on the U eigenspace (om = U'*imd)   for (int i = 0; i &lt; Urows; i++) {     for (int j = 0; j &lt; Ulines; j++) {       om[i] += U[Urows * j + i] * imd[j];     };   };    // Generate a matrix in which each column is a copy of om   for (int i = 0; i &lt; Urows; i++) {     for (int j = 0; j &lt; Urows; j++) {       d[i][j] = om[i];     };   };    // subtract omega from d   for (int i = 0; i &lt; Urows; i++) {     for (int j = 0; j &lt; Urows; j++) {       d[i][j] = d[i][j] - omega[i * Urows + j];     };   };    // norm each column of d   for (int i = 0; i &lt; Urows; i++) {     accum = 0;     for (int j = 0; j &lt; Urows; j++) {       accum += d[i][j] * d[i][j];     };     dist[i] = sqrt(accum);   };    // look for minimum and maximum distance   minimo = dist[0];   double massimo = dist[0];   for (int i = 0; i &lt; Urows; i++) {     if (dist[i] &lt; minimo) {       ind = i;       minimo = dist[i];     } else if (dist[i] &gt; massimo) {       massimo = dist[i];     };   };    cout &lt;&lt; "minimo " &lt;&lt; minimo &lt;&lt; endl;   cout &lt;&lt; "massimo " &lt;&lt; massimo &lt;&lt; endl;   return ind; }  int main(int argc, char* argv[]) {   ifstream f;   f.open("prova.txt");   double* omega;   omega = (double*)calloc(198 * 198, sizeof(double));   for (int i = 0; i &lt; 198 * 198; i++) {     f &gt;&gt; omega[i];   };   for (int i = 0; i &lt; 198; i++) {     for (int j = 0; j &lt; 198; j++) {       cout &lt;&lt; "   " &lt;&lt; omega[i * 198 + j];     }     cout &lt;&lt; endl;   }    double* U;   U = (double*)calloc(4001 * 198, sizeof(double));   // float U[4001*198];    for (int i = 0; i &lt; 4001 * 198; i++) {     f &gt;&gt; U[i];   };    double* med;   med = (double*)calloc(4001, sizeof(double));   for (int i = 0; i &lt; 4001; i++) {     f &gt;&gt; med[i];   };    double* test;   test = (double*)calloc(4001, sizeof(double));   for (int i = 0; i &lt; 4001; i++) {     f &gt;&gt; test[i];   };    f.close();   cout &lt;&lt; "etichetta riconosciuta "        &lt;&lt; confrontodb(test, 4001, 198, med, U, omega) &lt;&lt; endl;   free(med);   free(test);   free(U);   free(omega);   return 0; } </code></pre>  <p><a href="http://s000.tinyupload.com/?file_id=98697908462504898225" rel="nofollow">Link to <code>"prova.txt"</code> (it's 13 megabytes)</a></p>  <p>Expected results: </p>  <pre><code>imdmatlab =    -2.5252525e-01   -1.3080808e+00   -1.8080808e+00   -2.7676768e+00   -4.1161616e+00   -3.1969697e+00   -2.5707071e+00   -2.6616162e+00   -3.1616162e+00   -2.3181818e+00   -2.1767677e+00   [...] </code></pre>  <p>With the actual code, the first <code>imd</code> element is correct, the second has a 1/1000 error and then everything goes randomly, so these elements should be enough to check).</p>