<p>I have a download button in my webpage where when i click it, it downloads a zip file. now i want to have a function like, when i click the download button the zip file should automatically extract and save in a user defined folder.</p>  <p>i have an idea that if we can create a exe file and add it to the download button then it should automatically extract the zip file and save in folder</p>  <pre><code>%&gt;                     &lt;td align="center"&gt;                     &lt;img onclick="pullReport('&lt;%=reportPath.toString()%&gt;');" title="Click to download this Report" src="./images/down-bt.gif"/&gt;                     &lt;/td&gt;                 &lt;/tr&gt;             &lt;%} %&gt; </code></pre>  <p>this is the method that creates zip file</p>  <pre><code>public ActionForward pullReport(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response)throws SQLException{      Connection connection=null;      boolean cont=false;      failureList.clear();      logger.info("dispatch = pullReport");      String filePaths=null;       String filePath = null;      String fileName = null;      String srcFileName = null;      String directory = null;      try{           Properties props = Application.getProperties();            String basePath = props.getProperty("std.report_location");           logger.info(" basepath " + basePath);           connection=ConnectionManager.getConnection();           StandardReportsForm standardReportsForm=(StandardReportsForm)form;           filePaths=standardReportsForm.getFilePath();          logger.info("filepaths " + filePaths);           ServletOutputStream fos = null;             InputStream is = null;           String [] filePathArr = filePaths.split(",");            FileIO fio = null;           FileIO srcFio = null;           if (filePathArr.length &gt; 1) {             filePath = filePathArr[0].substring(0,filePathArr[0].lastIndexOf("."))+".zip";             logger.info(filePath + " creating zip file ......");              directory = basePath+filePath.substring(0,filePath.lastIndexOf('/'));             logger.info( " Direcory Name :" +directory);              fileName = filePath.substring(filePath.lastIndexOf('/')+1);             logger.info( " File Name :" +fileName);              fio = new FileIO(directory,fileName);             fio.mkDir();             byte[] buffer = new byte[1024];              OutputStream fosForZip = fio.createOutputStream();              ZipOutputStream zos = new ZipOutputStream(fosForZip);             InputStream fis = null;             for (int i=0; i &lt; filePathArr.length; i++) {                 srcFileName = filePathArr[i].substring(filePathArr[i].lastIndexOf('/')+1);                 srcFio = new FileIO(directory,srcFileName);                  if (srcFio.isFileExist()) {                     cont=true;                      logger.info(" adding into zip file " +srcFileName);                     fis = srcFio.createInputStream();                     BufferedInputStream bis = new BufferedInputStream(fis);                      zos.putNextEntry(new ZipEntry(srcFileName));                      int length;                      while ((length = bis.read(buffer)) != -1) {                         zos.write(buffer, 0, length);                     }                      zos.closeEntry();                     // close the InputStream                     bis.close();                     srcFio.closeInputStream(fis);                 } else {                     logger.info(srcFileName + " file does not exist on shared drive");                     cont =false;                     break;                 }              }             FileIO.closeOutputStream(zos);             if (!cont){                 standardReportsForm.setMissingFileName(srcFileName);                 request.getSession().getAttribute("fetchReports");                 standardReportsForm.setFetchedReports((List&lt;ReportDetails&gt;)request.getSession().getAttribute("fetchReports"));                 return mapping.findForward("fetchReport");             }            } else {             filePath = filePathArr[0];             fileName = filePath.substring(filePath.lastIndexOf('/')+1);           }            if (basePath.startsWith("smb")) {             SmbFile smbFile = new SmbFile(basePath+filePath,SMBHelper.getInstance().createAuthFromSmbLocation(basePath));             if(smbFile.exists())             {                     is = new SmbFileInputStream(smbFile);                     cont=true;             }           } else {             File file=new File(basePath+filePath);             if(file.exists())             {                     is = new FileInputStream(file);                     cont=true;             }           }           if(cont)           {               fos=response.getOutputStream();                setContentType(response, fileName);                  //fos.write (baos.toByteArray());               ByteArrayOutputStream bos = new ByteArrayOutputStream();               byte[] buf = new byte[1024];               for (int readNum; (readNum = is.read(buf)) != -1;) {                   bos.write(buf, 0, readNum);               }                  byte[] bytes = bos.toByteArray();                 fos.write(bytes);                 fos.flush();                 fos.close();            } else {                 standardReportsForm.setMissingFileName(fileName);                 request.getSession().getAttribute("fetchReports");                 standardReportsForm.setFetchedReports((List&lt;ReportDetails&gt;)request.getSession().getAttribute("fetchReports"));                 return mapping.findForward("fetchReport");           }          }catch(SQLException sx) {             logger.error(" error log SQLException " ,sx);             failureList.add(new UROCException(UROCMessages.getMessage("ERR_CONN_EXEC"), sx));         } catch(NamingException ne) {             logger.info("RMI error is "+ne);             failureList.add(new UROCException(UROCMessages.getMessage("ERR_NAMING_EXEC"), ne));         } catch(Exception e) {             logger.error(" error log Exception " ,e);             failureList.add(new UROCException(UROCMessages.getMessage("ERR_GEN_EXEC", new String[] {"General Exception"}), e));         } finally {             SQLHelper.closeConnection(connection, failureList, logger);         }          return null;  } </code></pre>