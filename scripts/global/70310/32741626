<p>I have created A Circular Canvas Using Kinetic JS 4.4.1 Here is the JS Fiddle for same <a href="http://jsfiddle.net/8qjgjkLp/1/" rel="nofollow">http://jsfiddle.net/8qjgjkLp/1/</a></p>  <p>HTML CODE :</p>  <pre><code>&lt;!DOCTYPE HTML&gt; &lt;html&gt;   &lt;head&gt;     &lt;style&gt;       body {         margin: 0px;         padding: 0px;       }     &lt;/style&gt;   &lt;/head&gt;   &lt;body&gt;     &lt;div class="mainDiv"&gt;     &lt;div id="Outcontainer"&gt;&lt;/div&gt;     &lt;div id="container"&gt;&lt;/div&gt;     &lt;/div&gt;     &lt;script src="js/kinetic-v4.4.1.js"&gt;&lt;/script&gt;     &lt;script defer="defer" src="js/main.js"&gt;&lt;/script&gt;   &lt;/body&gt; &lt;/html&gt; </code></pre>  <p>Javascript Code :</p>  <pre><code>var angularVelocity = 6; var angularVelocities = []; var lastRotations = 0; var controlled = false; var numWedges = 12; var angularFriction = 0.2; var target, activeWedge, stage, layer, wheel, pointer;  //addition by vivek var wheelText   = ["Meet","News","Cities","Events","Food","Travel"]; var DarkColor   = ["#615F5E","#142A48","#62605F","#586979","#651B2E","#142A48"]; var LightColor  = ["#9A9796","#2C4366","#9A9796","#9DB2C6","#A63855","#2C4366"];  var OutwheelText    = ["London","Paris","Lyon"]; var OutDarkColor    = ["#62605F","#142A48","#651B2E"]; var OutLightColor   = ["#9A9796","#2C4366","#A63855"];  function getAverageAngularVelocity() {     var total = 0;     var len = angularVelocities.length;      if(len === 0) {         return 0;     }      for(var n = 0; n &lt; len; n++) {         total += angularVelocities[n];     }      return total / len; }  function purifyColor(color) {     var randIndex = Math.round(Math.random() * 3);     color[randIndex] = 0;     return color; } function getRandomColor() {     var r = 100 + Math.round(Math.random() * 55);     var g = 100 + Math.round(Math.random() * 55);     var b = 100 + Math.round(Math.random() * 55);     var color = [r, g, b];     color = purifyColor(color);     color = purifyColor(color);      return color; } function bind() {     wheel.on('mousedown', function(evt) {         angularVelocity = 0;         controlled = true;         target = evt.targetNode;     });     // add listeners to container     document.body.addEventListener('mouseup', function() {         controlled = false;         angularVelocity = getAverageAngularVelocity() * 5;          if(angularVelocity &gt; 20) {         angularVelocity = 20;         }         else if(angularVelocity &lt; -20) {         angularVelocity = -20;         }          angularVelocities = [];     }, false);      document.body.addEventListener('mousemove', function(evt) {         var mousePos = stage.getMousePosition();         if(controlled &amp;&amp; mousePos &amp;&amp; target) {         var x = mousePos.x - wheel.getX();         var y = mousePos.y - wheel.getY();         var atan = Math.atan(y / x);         var rotation = x &gt;= 0 ? atan : atan + Math.PI;         var targetGroup = target.getParent();          wheel.setRotation(rotation - targetGroup.startRotation - (target.getAngle() / 2));         }     }, false); } function getRandomReward(n) {       if(n &gt; 5){       n = n%6;       }       return wheelText[n]; //         var mainDigit = Math.round(Math.random() * 9); //         return mainDigit + '\n0\n0';     } function addWedge(n) {     var s = getRandomColor();     var reward = getRandomReward(n);     var r = s[0];     var g = s[1];     var b = s[2];     var angle = 2 * Math.PI / numWedges;     if(numWedges == 12){         var m = n;         if(m &gt; 5){             m = m%6;         }           var endColor = LightColor[m];         //         r += 100;         //         g += 100;         //         b += 100;          var startColor = DarkColor[m];     }else{         var endColor = OutLightColor[n];         var startColor = OutDarkColor[n];     }     var wedge = new Kinetic.Group({         rotation: 2 * n * Math.PI / numWedges,     });     var radiusVal = 200;     if(numWedges == 3){         radiusVal = 300;     }     var wedgeBackground = new Kinetic.Wedge({         radius: radiusVal,         angle: angle,         fillRadialGradientStartPoint: 0,         fillRadialGradientStartRadius: 0,         fillRadialGradientEndPoint: 0,         fillRadialGradientEndRadius: 400,         fillRadialGradientColorStops: [0, startColor, 1, endColor],         fill: '#64e9f8',         fillPriority: 'radial-gradient',         stroke: '#ccc',         strokeWidth: 2     });      wedge.add(wedgeBackground);      var text = new Kinetic.Text({         text: reward,         //           fontFamily: 'Calibri',         fontSize: 25,         fill: 'white',         align: 'center',         stroke: 'white',         strokeWidth: 1      });      // cache text as an image to improve performance     text.toImage({         width: text.getWidth(),         height: text.getHeight(),         callback: function(img) {             var cachedText = new Kinetic.Image({                 image: img,                 listening: false,                 rotation: 0.25,//(Math.PI + angle) / 2,                 x: 100,                 y: 15,             });              wedge.add(cachedText);             layer.draw();         }     });      wedge.startRotation = wedge.getRotation();     wedge.on("click",function(){         alert(n);     });     wheel.add(wedge); } function animate(frame) {     // handle wheel spin     var angularVelocityChange = angularVelocity * frame.timeDiff * (1 - angularFriction) / 1000;     angularVelocity -= angularVelocityChange;      if(controlled) {         if(angularVelocities.length &gt; 10) {         angularVelocities.shift();         }          angularVelocities.push((wheel.getRotation() - lastRotation) * 1000 / frame.timeDiff);     }     else {     //           wheel.rotate(frame.timeDiff * angularVelocity / 1000);     }     lastRotation = wheel.getRotation();      // activate / deactivate wedges based on point intersection     var intersection = stage.getIntersection({         x: stage.getWidth() / 2,         y: 100     });      if(intersection) {         var shape = intersection.shape;          if(shape &amp;&amp; (!activeWedge || (shape._id !== activeWedge._id))) {             pointer.setY(20);             pointer.transitionTo({                 y: 30,                 easing: 'elastic-ease-out',                 duration: 0.3             });              if(activeWedge) {                 activeWedge.setFillPriority('radial-gradient');             }             shape.setFillPriority('fill');             activeWedge = shape;         }     } } function init(whichContainer,conwidth,conHeight,numWedgesCount) {     numWedges = numWedgesCount;      stage = new Kinetic.Stage({         container: whichContainer,         width: conwidth,         height: conHeight     });     layer = new Kinetic.Layer();     wheel = new Kinetic.Group({         x: 0,         y: stage.getWidth() / 2     });      for(var n = 0; n &lt; numWedges; n++) {         addWedge(n);     }     //         pointer = new Kinetic.Wedge({     //           fillRadialGradientStartPoint: 0,     //           fillRadialGradientStartRadius: 0,     //           fillRadialGradientEndPoint: 0,     //           fillRadialGradientEndRadius: 30,     //           fillRadialGradientColorStops: [0, 'white', 1, 'red'],     //           stroke: 'white',     //           strokeWidth: 2,     //           lineJoin: 'round',     //           angleDeg: 30,     //           radius: 30,     //           x: stage.getWidth() / 2,     //           y: 30,     //           rotationDeg: -105,     //           shadowColor: 'black',     //           shadowOffset: 3,     //           shadowBlur: 2,     //           shadowOpacity: 0.5     //         });      // add components to the stage      layer.add(wheel);     //         layer.add(pointer);     stage.add(layer);      // bind events     bind();      var anim = new Kinetic.Animation(animate, layer);      // wait one second and then spin the wheel     setTimeout(function() {         anim.start();     }, 1000); } //init("container ID ","Width","Height","Wedge Count"); // init("Outcontainer",600,600,3); // call init init("container",400,400,12); // call 197 </code></pre>  <p>I want to make something similar to this : Image Attached<a href="http://i.stack.imgur.com/rRKmN.png" rel="nofollow"><img src="http://i.stack.imgur.com/rRKmN.png" alt="enter image description here"></a></p>  <p>The inner circle and outer circle will rotate. As only Semi Circle of both will be visible in Page The one that comes on Blue Background while the one that come on gray Background will be hidden on Screen.</p>  <p>When a Wedge of inner cricle is clicked I would show the outer circle and inner circle size will minimize.</p>  <ol> <li>How to Create 2 cricle with kinetic JS and allow both to rotate. </li> <li>Adding click event on wedge and toggle the outer circle.</li> <li>How to Add Image to wedge ? Currently I'm showing text and Bgcolor on wedge. But would Like to add a image on each wedge. </li> </ol>  <p>Is There any tutorial available for kinetic JS ? </p>