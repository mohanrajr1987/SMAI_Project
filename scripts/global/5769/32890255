<p>I am developing a login system for my Android application using spring boot and Spring Security OAuth. My starting point is the following demo repository: <a href="https://github.com/royclarkson/spring-rest-service-oauth" rel="nofollow">https://github.com/royclarkson/spring-rest-service-oauth</a>. In the demo you can find the following setup:</p>  <p>oAuth2 Client:</p>  <pre><code>clients .inMemory()     .withClient("clientapp")         .authorizedGrantTypes("password", "refresh_token")         .authorities("USER")         .scopes("read", "write")         .resourceIds(RESOURCE_ID)         .secret("123456"); </code></pre>  <p>Method to fetch the access token in its tests:</p>  <pre><code>private String getAccessToken(String username, String password) throws Exception { String authorization = "Basic " + new String(Base64Utils.encode("clientapp:123456".getBytes()));  String content = mvc         .perform(                 post("/oauth/token")                         .header("Authorization", authorization)                         .contentType(MediaType.APPLICATION_FORM_URLENCODED)                         .param("username", username)                         .param("password", password)                         .param("grant_type", "password")                         .param("scope", "read write")                         .param("client_id", "clientapp")                         .param("client_secret", "123456"))         .andExpect(status().isOk())         .andReturn().getResponse().getContentAsString();  return content.substring(17, 53); </code></pre>  <p>}</p>  <p>Every test in the project provides works perfectly but I want do things differently and I am having trouble doing so. As you can see the demo client defines a 'client_secret' (witch is also used in the tests) but a 'client_secret' is really worthless in an Android environment, I can not guarantee its 'privateness'. </p>  <p><a href="https://apigility.org/documentation/auth/authentication-oauth2" rel="nofollow">https://apigility.org/documentation/auth/authentication-oauth2</a></p>  <blockquote>   <p>If we are using a public client (by default, this is true when no secret is associated with the client) you can omit the client_secret value; </p> </blockquote>  <p><a href="http://tools.ietf.org/html/draft-ietf-oauth-v2-31#section-2.1" rel="nofollow">http://tools.ietf.org/html/draft-ietf-oauth-v2-31#section-2.1</a></p>  <blockquote>   <p>Public:         Clients incapable of maintaining the confidentiality of their         credentials (e.g. clients executing on the device used by the         resource owner such as an installed native application or a web         browser-based application), and incapable of secure client         authentication via any other means.</p> </blockquote>  <p>So what I have done is removing the secret in the client configuration:</p>  <pre><code>clients     .inMemory()     .withClient("books_password_client")     .authorizedGrantTypes("password", "refresh_token")     .authorities("USER")     .scopes("read", "write")     .resourceIds(RESOURCE_ID); </code></pre>  <p>Also adapted the getAccessToken(...) method: </p>  <pre><code>private String getAccessToken(String username, String password) throws Exception { String authorization = "Basic " + new String(Base64Utils.encode("books_password_client:123456".getBytes()));  String content = mvc         .perform(                 post("/oauth/token")                         .contentType(MediaType.APPLICATION_FORM_URLENCODED)                         .param("username", username)                         .param("password", password)                         .param("grant_type", "password")                         .param("client_id", "books_password_client"))         .andExpect(status().isOk())         .andReturn().getResponse().getContentAsString();  return content.substring(17, 53);} </code></pre>  <p>But when I use this new setup my tests fail, I can't get an access token, I keep getting an HTTP Error 401 Unauthorized. Any help would be welcome, thanks in advance!</p>