<p>I just started using Automapper and blocked with one particular behavior regards to nested child entities.</p>  <p>While updating the child objects of a parent object, Automapper is replacing the child object in destination object with a new instance created using data from Target data instead of copying property by property.  To better explain the problem, I have copied the test code below:</p>  <pre><code>class Program {     static void Main(string[] args)     {          Mapper.CreateMap&lt;PersonDTO, Person&gt;();         Mapper.CreateMap&lt;UserLoginDTO, UserLogin&gt;();          Person pmodel = new Person()         {             Id = 10,             FullName = "XYZ",             LoginInfo = new UserLogin() { Id = 10, UserName = "xyz" }         };          PersonDTO pdto = new PersonDTO()         {             Id = 10,             FullName = "XYZ",             LoginInfo = new UserLoginDTO() { Id = 10, UserName = "abc" }         };          pmodel.Initiated();         pmodel.LoginInfo.Initiated();         Console.WriteLine("model =&gt; LoginInfo =&gt; IsInitiated : {0}", pmodel.LoginInfo.IsInitiated);         Mapper.Map&lt;PersonDTO, Person&gt;(pdto, pmodel);         Console.WriteLine("model =&gt; LoginInfo =&gt; IsInitiated : {0}", pmodel.LoginInfo.IsInitiated);      } }  public class PersonDTO {     public int Id     {         get;         set;     }      public String FullName     {         get;         set;     }       public UserLoginDTO LoginInfo { get; set; } }  public class UserLoginDTO {      public int Id     {         get;         set;     }      public String UserName     {         get;         set;     } }  public class Person : BaseEntity {     private int _id;     private string _name;     private UserLogin _loginInfo;      public int Id {          get { return _id;  }         set { _id= value; }     }      public String FullName     {         get { return _name; }         set { _name = value; }     }      public UserLogin LoginInfo { get { return _loginInfo; } set { _loginInfo = value; } }  }  public class UserLogin : BaseEntity {     private int _id;     private string _userName;      public int Id     {         get { return _id; }         set { _id = value; }     }      public String UserName     {         get { return _userName; }         set { _userName= value; }     } }   public abstract class BaseEntity {     private bool _isInitiated = false;      public bool IsInitiated { get { return _isInitiated; } }      public void Initiated()     {         this._isInitiated = true;      } } </code></pre>  <p>Output of the above code is:</p>  <p>Before mapping : model => LoginInfo => IsInitiated : True After mapping : model => LoginInfo => IsInitiated : False</p>  <p>My requirement is to retain the IsInitiated property after mapping.  Am I missing something here.</p>