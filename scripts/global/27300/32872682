<p>Out team is currently programming a JavaEE webapplication for use on a Tomcat appserver.</p>  <p>We want to handle persistence using Hibernate (5.0.1). To access the database entities, we use <code>EntityManagers</code> (not from JPA, they were implemented by us, see below) which provide methods to list, create and delete rows in the associated tables. The model classes use Hibernate Annotations for the mapping.</p>  <p>We also have a static class <code>PersistenceController</code> which initializes Hibernate's <code>SessionFactory</code> and provides a static method to get a newly opened session.</p>  <p>Of course we want to be able to use unit tests to test the functionality of our classes, so the <code>PersistenceController</code> is a little thorn in our eyes.</p>  <p>Someone else recommended me to move everything from the <code>PersistenceController</code> into the <code>EntityManager</code> base class. He wasn't sure if this would have any side consequences though.</p>  <p>So I thought "let's ask the hive mind". What would be the best practice in this case?</p>  <p>(If more code is needed, I'm happy to provide it)</p>  <p><strong>PersistenceController</strong></p>  <pre><code>import org.hibernate.Session; import org.hibernate.SessionFactory; import org.hibernate.boot.MetadataSources; import org.hibernate.boot.registry.StandardServiceRegistry; import org.hibernate.boot.registry.StandardServiceRegistryBuilder;  public class PersistenceController {      private static final SessionFactory sessionFactory;      static {         final StandardServiceRegistry registry = new StandardServiceRegistryBuilder()                 .configure() // configures settings from hibernate.cfg.xml                 .build();         try {             sessionFactory = new MetadataSources(registry).buildMetadata()                     .buildSessionFactory();         } catch (Exception e) {             // The registry would be destroyed by the SessionFactory, but we had             // trouble building the SessionFactory             // so destroy it manually.             StandardServiceRegistryBuilder.destroy(registry);             throw e;         }     }      public static Session openSession() {         return sessionFactory.openSession();     } } </code></pre>  <p><strong>EntityManager</strong></p>  <pre><code>import java.util.List;  public abstract class EntityManager&lt;T extends PersistenceEntity&gt; {      public abstract List&lt;T&gt; listAll();      public abstract void save(T entity);      public abstract void delete(T entity);  } </code></pre>  <p><strong>ProductManager</strong></p>  <pre><code>import java.util.ArrayList; import java.util.List;  import org.hibernate.Session; import org.hibernate.Transaction;  import etepat.model.product.Product;  public class ProductManager extends EntityManager&lt;Product&gt; {      public ProductManager() {         super();     }      @Override     public List&lt;Product&gt; listAll() {         try (Session session = PersistenceController.openSession()) {             Transaction transaction = null;             try {                 transaction = session.beginTransaction();                 @SuppressWarnings("unchecked")                 List&lt;Product&gt; returned = session.createCriteria(Product.class)                         .list();                 transaction.commit();                 return returned;             } catch (Exception e) {                 if (transaction != null) {                     transaction.rollback();                 }                 e.printStackTrace();             }         }         return new ArrayList&lt;Product&gt;();     }      @Override     public void save(Product entity) {         // TODO Auto-generated method stub      }      @Override     public void delete(Product entity) {         // TODO Auto-generated method stub      }  } </code></pre>