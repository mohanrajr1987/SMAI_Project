<p>I'm using a singleton to use <code>JODConverter</code>. The problem is, when a new request is received, a new singleton is created while the old one is destroyed, but the order does not match : the <code>@PostContruct</code> method of the new singleton is called before the <code>@PreDestroy</code> method of the old one.</p>  <p>This cause a failure, since the server is already running for <code>JodConverter</code>.</p>  <p>Here is the code :</p>  <pre><code>@ConcurrencyManagement(ConcurrencyManagementType.CONTAINER) @Startup @Singleton public class FileConverter {      private static final String PROPERTIES_FILE = "path/conf.properties";     private static final String OO_HOME_KEY = "viewers.ooHome";     private static final String OO_PORT_KEY = "viewers.ooPort";     private static final Logger LOGGER = Logger.getLogger(FileConverter.class.getName());      private OfficeManager officeManager;      @PostConstruct     private void init() {         InputStream inputStream = null;         try {             Properties properties = new Properties();             inputStream = FileConverter.class.getResourceAsStream(PROPERTIES_FILE);             properties.load(inputStream);             String ooHome = properties.getProperty(OO_HOME_KEY);             int ooPort = Integer.parseInt(properties.getProperty(OO_PORT_KEY));             officeManager = new DefaultOfficeManagerConfiguration()                     .setOfficeHome(new File(ooHome))                     .setPortNumber(ooPort)                     .buildOfficeManager();             officeManager.start();         } catch (IOException e) {             LOGGER.log(Level.SEVERE, null, e);             throw new RuntimeException(e);         } finally {             try{                 if(inputStream!=null){                     inputStream.close();                 }             }catch (IOException e){                 LOGGER.log(Level.FINEST, null, e);             }         }     }      @PreDestroy     private void close(){         officeManager.stop();     } </code></pre>  <p>Edit:</p>  <p>I've changed from javax.ejb.Singleton to javax.inject.Singleton and managed the concurrency on my own. Thanks a lot @peeskillet</p>