<p>I draw 4D plot.</p>  <p>My plot has some parts ( surfaces ).</p>  <p>I generate each part ( each surface ) in a different array.</p>  <p>The last part ( the last surface ) of graph has two sections.</p>  <p>1 in upside and second in back.</p>  <p>But in graph in <strong><code>pylab</code></strong> this isn't correct.</p>  <p>The last surface always are on top in the graph. ( If you rotated <code>mat</code>, so the surface had show in top )</p>  <p><a href="http://bayanbox.ir/view/8829931126503661463/figure-1.png" rel="nofollow">chaos plot</a> <a href="http://i.stack.imgur.com/NEQ2X.jpg" rel="nofollow"><img src="http://i.stack.imgur.com/NEQ2X.jpg" alt="enter image description here"></a></p>  <p><code>EDIT</code>: the code:</p>  <pre><code>#!/usr/bin/python3 from scipy.integrate import odeint from numpy import var import numpy as np from mpl_toolkits.mplot3d import Axes3D from matplotlib.ticker import LinearLocator, FormatStrFormatter import matplotlib.pyplot as plt import matplotlib.cm as cm import time as tim import matplotlib as mpl epsel=np.array(1.*10**(-5),float) ru=np.array(.264,float) #free parameter ddd=100 ddd2=(ddd+1)**2 bi =  np.zeros((4,ddd2,4),float) bbb=1. def boundary1(ru,ddd=100):#x=y     namnam=0     for zz in np.linspace(-bbb,bbb+1.,ddd):         for tt in np.linspace(-bbb,bbb,ddd):             bi[0,namnam,:]=[tt+epsel,tt+epsel,zz+epsel,0]             namnam=namnam+1     return(namnam) def boundary2(ru,ddd=100):#x=0############################################     namnam=0     for zz in np.linspace(-bbb,bbb+1,ddd):         for yy in np.linspace(-bbb,bbb,ddd):             bi[1,namnam,:]=[0.+epsel,yy+epsel,zz+epsel,1]             namnam=namnam+1     return(namnam) def boundary3(ru,ddd=100):#z=0     namnam=0     for xx in np.linspace(-bbb,bbb,ddd):         for yy in np.linspace(-bbb,bbb,ddd):             bi[2,namnam,:]=[xx+epsel,yy+epsel,0.+epsel,2]             namnam=namnam+1     return(namnam) def boundary4(ru,ddd=100):     namnam=0     for zz in np.linspace(-bbb,bbb+1.,ddd):         for tt in np.linspace(ru**(.5),bbb,ddd/4):             bi[3,namnam,:]=[tt+epsel,1./tt+epsel,zz+epsel,3]             namnam=namnam+1         for tt in np.linspace(ru**(.5),bbb,ddd/4):             bi[3,namnam,:]=[1./tt+epsel,tt+epsel,zz+epsel,3]             namnam=namnam+1         for tt in np.linspace(ru**(.5),bbb,ddd/4):             bi[3,namnam,:]=[-tt+epsel,-1./tt+epsel,zz+epsel,3]             namnam=namnam+1         for tt in np.linspace(ru**(.5),bbb,ddd/4):             bi[3,namnam,:]=[-1./tt+epsel,-tt+epsel,zz+epsel,3]             namnam=namnam+1     return(0) def bound(ru,ddd=100):     bbb=2.*ru     boundary4(ru,ddd=100)     boundary3(ru,ddd=100)     boundary2(ru,ddd=100)     boundary1(ru,ddd=100)     return(0)  bound(ru,ddd=100) fig = plt.figure() ax = fig.add_subplot(111, projection='3d') for i in range(4):     ax.scatter(bi[i,:,0],bi[i,:,1],bi[i,:,2],c=bi[i,:,3], cmap=plt.hot()) plt.show() </code></pre>