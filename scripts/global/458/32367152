<p>tl;dr Valid names don't get written to the database because the test fails, and invalid names do get written to the database because the test passes.</p>  <p><strong>Edit:</strong> <em>For clarification about the project and my question in general: As described in the book, this User model is set up as the beginning stages to allow a website user to eventually log in to a website. The database columns would be "name" and "email", and each row would be one user (assuming the user name and email were valid). I've edited my original post below for further clarification, and all edits are in italics.</em></p>  <p><em>Additionally, please only respond if you can explain the code <strong>as is</strong> in my post--don't suggest adding additional code to make it work. The textbook I'm working from asserts that this code should work as is, yet it seems to evaluate to the opposite that it should. Lastly, if you know other links that explain this in more detail, that is helpful; however, I have already read <a href="http://apidock.com/rails/ActiveSupport/Testing/Assertions/assert_not" rel="nofollow">apidock</a>, <a href="http://api.rubyonrails.org/classes/ActiveSupport/Testing/Assertions.html" rel="nofollow">RoR API</a>, and most of the SO links that show up in a Google search, and none have been helpful in explicating this problem.</em> </p>  <p>I'm working through Michael Hartl's Ruby on Rails Tutorial. I'm in chapter 6 working through validation tests and I'm stuck on the validation for the presence of a name. It seems to be doing exactly the opposite of what the tutorial says it should do (i.e., validating a non-valid name entry), even though I've followed the tutorial exactly. I've also searched the web and SO for more details on how <code>assert_not</code> works, but can't find any helpful details. Here's the process I've went through.</p>  <ol> <li><p>Add a test that we know will fail: </p>  <pre><code>require 'test_helper'  class UserTest &lt; ActiveSupport::TestCase    def setup     @user = User.new(name: "Example User", email: "user@example.com")   end    # resolves to true and passes   test "should be valid" do    assert @user.valid?   end    test "name should be present" do     @user.name = "     "     assert_not @user.valid?   end  end </code></pre></li> </ol>  <p>So far so good. I understand this code perfectly well, and although the second test's wording is awkward, I interpret <code>assert_not @user.valid?</code> to work like this: <code>@user.valid?</code> evaluates to true, since no validations have been set up, so the test thinks a name with all blank spaces is valid. This is preceded by an <code>assert_not</code> which converts a true value to false, and makes the test fail. </p>  <ol start="2"> <li><p>We add a validation test: </p>  <pre><code>class User &lt; ActiveRecord::Base   validates :name, presence: true end </code></pre></li> </ol>  <p>This sets a validation rule for the User model that ensures the <code>:name</code> object has content and is not nil, an empty string, or blank space. Still good so far. </p>  <ol start="3"> <li><p>Here's where things get tricky. At this point, the expression <code>@user.valid?</code> in our test should (and does) evaluate to false, since the validation rule won't allow a <code>:name</code> with only spaces in it. I've added comments alongside this code to help my mind see what values are assigned and evaluated in this process: </p>  <pre><code>test "name should be present" do     @user.name = "   "     # =&gt; name: "   " email: "example@example.com"     assert_not @user.valid?      # =&gt; assert_not false =&gt; true end </code></pre></li> </ol>  <p><code>@user.valid?</code> evaluates to false, which makes the entire <code>assert_not</code> expression evaluate to true, and thus the test passes. <em>In pseudocode, this line could translate thusly: <code>assert_not (is the user valid? no)</code> ==> <code>assert_not(false)</code> ==> <code>true</code>. Similarly, "We do not assert that the user is false", which evaluates to true.</em></p>  <p>This is where my problem is: The test passes on an invalid value for <code>:name</code>, thus allowing a name consisting of blank spaces to be written to the database, when that's exactly the opposite of what we are trying to achieve, namely, <em>preventing</em> blank names from being written to db. </p>  <ol start="4"> <li><p>Conversely, I worked out this logic with a valid name: </p>  <pre><code>test "name should be present" do # =&gt; name: "Example User" email: "example@example.com"     assert_not @user.valid?      # assert_not true =&gt; false end </code></pre></li> </ol>  <p>In this case, since <code>@user.valid?</code> evaluates to true (since "Example User" is a valid name), <code>assert_not @user.valid?</code> evaluates to false, the test fails, and our valid name does not get written to the database. <em>In pseudocode, this line could translate thusly: <code>assert_not (is the user valid? yes)</code> ==> <code>assert_not(true)</code> ==> <code>false</code>. Similarly, "We do not assert that the user is true", which evaluates to false. Because the test evaluates to false (even with a true/valid user name), this valid name is not written to the database.</em></p>  <p>If someone could explain how this makes any sense, I'd greatly appreciate it, and detailed answers walking me through it would be even better. </p>