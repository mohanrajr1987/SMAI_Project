<p>I am learning unit tests (in a TDD-like approach). I am creating a class that encapsulates an collection, it has 3 methods:</p>  <ul> <li>store</li> <li>retrieveAllDocuments</li> <li>hasItem</li> </ul>  <p>I created one test: testRetrieveWhenEmpty, whici goes like this:</p>  <pre><code>@Test public void testRetrieveAllDocumentsWhenEmpty() {     List&lt;String&gt; storedDocs = state.retrieveAllDocs();      assertNotNull(storedDocs);     assertEquals(0, storedDocs.size()); } </code></pre>  <p>And then I made it pass.</p>  <p>Now I would like to create a testRetrieveAllDocumentsWhenNotEmpty, which would be like this:</p>  <pre><code>@Test public void testRetrieveAllDocumentsWhenNotEmpty() {     state.store("test") //This is the only api point that I can use to insert things     List&lt;String&gt; storedDocs = state.retrieveAllDocs();      assertNotNull(storedDocs);     assertEquals(1, storedDocs.size());     assertEquals("test", storedDocs..get(0)); } </code></pre>  <p>But now I have to implement the store method, so I created the following test method:</p>  <pre><code>@Test public void testStoreDocument() {     state.store("test")     List&lt;String&gt; storedDocs = state.retrieveAllDocs(); //This is the only api point I can use to see the content      assertNotNull(storedDocs);     assertEquals(1, storedDocs.size());     assertEquals("test", storedDocs.get(0)); } </code></pre>  <p>I see two problems:</p>  <ol> <li>These methods are identical.</li> <li>I test two methods in each test, if the store fails, I get a message that the retrieve has a problem.</li> </ol>  <p>Using reflection would bind my test to my implementation, and I am trying to avoid it. Changing the interface for better testing is hard to argument to my team mates.</p>  <p><strong>What approach do you take in these cases? (Is this case a problem at all?)</strong></p>