<p>What is the best practice when creating many implementations of an interface to ensure compliance with the interface's contract?</p>  <pre><code>public interface IFoo {     /// &lt;exception cref="System.ArgumentNullException"&gt;     /// If &lt;paramref name="baz"&gt; is &lt;c&gt;null&lt;/c&gt;.     /// &lt;/exception&gt;     void Bar(Baz baz); } </code></pre>  <p>I was thinking about something along the lines of:</p>  <pre><code>public abstract class IFooTestsBase {     protected IFoo Foo;      [Test]     [ExpectedException(typeof(ArgumentNullException))]     public void Bar_ThrowsException_WhenBazArgumentIsNull() {         Foo.Bar(null);     } }  [TestFixture] public class SpecialFooTests : IFooTestsBase {     [TestFixtureSetUp]     public void Init() {         // Provide instance of `SpecialFoo` for inherited tests.         Foo = new SpecialFoo();     }      // TDD as normal from here... } </code></pre>  <p>Is this a valid TDD approach?</p>  <ol> <li><p>The test will initially not compile because the <code>SpecialFoo</code> class will not have been defined.</p></li> <li><p>Create minimal <code>SpecialFoo</code> implementation that compiles but fails all tests.</p></li> <li><p>The tests will then compile but not pass since the minimal <code>SpecialFoo</code> class will not meet the expectations of the interface.</p></li> </ol>  <p>Or should I be re-implementing each test one-by-one for each new implementation of <code>IFoo</code>?</p>