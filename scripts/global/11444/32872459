<p>I have the client upload an image directly to S3 with javascript and have designed the url to be exactly what it would be if carrierwave was uploading it (by using a unique_id that I pass to the create method). Once the image is uploaded, I want to send an AJAX request to create the record, and then process the image using carrierwave, but I don't need carrierwave to handle the upload, just process the versions.</p>  <p>I have this typical carrierwave setup using the fog gem for s3 storage:</p>  <pre><code>class Picture &lt; ActiveRecord::Base   mount_uploader :image, ImageUploader   # . . . end </code></pre>  <p>and this:</p>  <pre><code>class ImageUploader &lt; CarrierWave::Uploader::Base   include CarrierWave::RMagick    storage :fog    def store_dir     "uploads/picture/#{model.unique_id}"   end    version :large do     resize_to_limit(600, 600)   end    # . . .  end </code></pre>  <p>But I can't figure out how to create a new <code>Picture</code> without carrierwave wanting to handle the upload.</p>  <p>I have tried setting Picture.image to the filename but it becomes nil:</p>  <pre><code>&gt;&gt; Picture.create(image: params[:filename], unique_id: params[:unique_id]) =&gt; #&lt;Picture id: 96, image: nil, ... &gt; </code></pre>  <p>I have also tried getting the image by using carrierwave's "Uploading files from a remote location" feature:</p>  <pre><code>class PicturesController &lt; ApplicationController                                                                                     def create     @picture = Picture.create(       remote_image_url: params[:url],       unique_id: params[:unique_id]     )     # . . .     end   # . . . end </code></pre>  <p>That works eventually, but it is a lot of extra downloading and uploading and feels wrong.</p>  <p>How do I create the <code>Picture</code> without carrierwave getting involved, and then have carrierwave process the image versions?</p>