<p>I'm using CMake's AUTOMOC via:</p>  <pre><code>set(CMAKE_AUTOMOC ON) </code></pre>  <p>I was factoring out a class from a working file that did:</p>  <pre><code>#include &lt;QtWidgets&gt; #include "workingstuff.h" </code></pre>  <p>The factored-out class didn't have any GUI code, and really only used QObject and QString in its forward definition.  So I thought I'd pare down the includes for the broken-out file to just:</p>  <pre><code>#include &lt;QObject&gt; #include &lt;QString&gt; #include "workingstuff.h" </code></pre>  <p>Despite workingstuff being just fine elsewhere, it began having very random-seeming errors.  Not when building <code>newfile.cpp</code> or <code>newfile.h</code>, only when workingstuff was being built as an include from <code>moc_newfile.cpp</code>  The errors weren't at the top of the file on the first definition, but way in the middle...like:</p>  <pre><code>#ifndef FALSE #define FALSE 0    // "expected unqualified-id before numeric constant" #define TRUE (!0) #endif </code></pre>  <p><em>(That's a puzzle because it's hard to imagine what it can be complaining about while processing a line after a preprocessor directive where it's just decided that thing doesn't exist... and sets it to zero.  :-/)</em></p>  <p>Since this message is hindsight, I've already pointed to what the breaking difference was found to be: it would work by including <code>&lt;QtWidgets&gt;</code> (either as a replacement for <code>&lt;QString&gt;</code> and <code>&lt;QObject&gt;</code>, or in addition).  I tried some other includes to see if they would have the same magical effect: <code>&lt;QThread&gt;</code> and <code>&lt;QTimer&gt;</code> did not, while <code>&lt;QMessageBox&gt;</code> did.</p>  <p>"workingstuff.h" is basically just a plain C library that happens to be buildable as C++...no Qt dependency whatsoever.  Is there a requirement I don't know about automoc that you need to include some GUI-related file, or it will have strange errors while building the moc?</p>