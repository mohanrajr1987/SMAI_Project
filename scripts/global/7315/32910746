<p>I want to use the same class as a JAXB class and a domain object for a DAO.  This way I can easily move data back and forth from incoming/outgoing XML web service calls to direct CRUD transactions on a database.  Is there a design pattern out there that I could use?  I am leaning towards AbstractFactory because I have some database util functions that prep the SQL parameters without having to know the table/column names.</p>  <pre><code>@XmlRootElement( name = "labdata") @XmlAccessorType(XmlAccessType.FIELD) @XmlType(name = "labdata", propOrder = {"labId",                                         "labDesc",                                         "lastUpdateDatetime",                                         "userId"}) public class LabData extends DbObject {      @XmlTransient     private HashMap&lt;String, Object&gt; mappedFields;      @XmlElement(name="lab_id", required = true)     private Integer labId;      @XmlElement(name="lab_desc", required = true)     private String labDesc;      @XmlElement(name="last_altered_dt", required = true)     private Timestamp lastUpdateDatetime;      @XmlElement(name="user_id", required = true)     private String userId;      @XmlTransient     private final String labIdField = "TST_LAB_CD";      @XmlTransient     private final String labDescField = "LAB_DSC_TE";      @XmlTransient     private final String lastUpdateDatetimeField = "INS_GMT_TS";      @XmlTransient     private final String userIdField = "USR_ID";      @XmlTransient     private final String tableName = "TSTLAB";      /**      * Default constructor.      */     public LabData() {         super();         mappedFields = new HashMap&lt;String, Object&gt;();     }      /**      * Constructor which takes all fields as parameters       * and will update the protected hash map after setting all the fields.      * @param labId {@link Integer}      * @param labDesc {@link String}      * @param lastUpdateDatetime {@link Timestamp}      * @param userId {@link String}      */     public LabData(Integer labId, String labDesc, Timestamp lastUpdateDatetime, String userId) {         super();         this.labId = labId;         this.labDesc = labDesc;         this.lastUpdateDatetime = lastUpdateDatetime;         this.userId = userId;         updateHashMap();     }      public Object[] getFieldValues() {         return new Object[] {this.labId, this.labDesc, this.lastUpdateDatetime, this.userId};     }      public Object[] getUpdateFieldValues() {         return new Object[] {this.labDesc, this.lastUpdateDatetime, this.userId};     }      public void updateHashMap() {         mappedFields.clear();         mappedFields.put(this.labIdField, this.labId);         mappedFields.put(this.labDescField, this.labDesc);         mappedFields.put(this.lastUpdateDatetimeField, this.lastUpdateDatetime);         mappedFields.put(this.userIdField, this.userId);     }      getters and setters... } </code></pre>  <p>Database Util:</p>  <pre><code>public List&lt;Object[]&gt; createInsertBatchArgs(DbObject[] dbPojos){     List&lt;Object[]&gt; args = new ArrayList&lt;Object[]&gt;();     for(DbObject dbPojo: dbPojos) {         args.add(dbPojo.getFieldValues());     }     return args; }  public List&lt;Object[]&gt; createUpdateBatchArgs(DbObject[] dbPojos, String... updateFields){     List&lt;Object[]&gt; args = new ArrayList&lt;Object[]&gt;();     for(DbObject dbPojo: dbPojos) {         Object[] fields = dbPojo.getUpdateFieldValues();         Object[] values = Arrays.copyOf(fields, fields.length+updateFields.length);         for(int i = 0; i &lt; updateFields.length; i++) {             values[values.length-updateFields.length+i] =                        dbPojo.getFieldValue(updateFields[i]);         }         args.add(values);     }     return args; }  public List&lt;Object[]&gt; createDeleteBatchArgs(DbObject[] dbPojos, String... deleteFieldName){     List&lt;Object[]&gt; args = new ArrayList&lt;Object[]&gt;();     Object[] values = new Object[deleteFieldName.length];     for(DbObject dbPojo: dbPojos) {         for(int i = 0; i &lt; deleteFieldName.length; i++) {             values[i] = dbPojo.getFieldValue(deleteFieldName[i]);         }         args.add(values);     }     return args; } </code></pre>  <p>If I remove the DbObject inheritance then the usage of the DAO methods by casting causes  java.lang.VerifyError: Bad type on operand stack.  Unfortunately I don't have the ability to implement a new framework that would easily do this.</p>