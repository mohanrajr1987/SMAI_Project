<p>I tried the approach in <a href="http://stackoverflow.com/questions/5319024/using-jaxb-to-cross-reference-xmlids-from-two-xml-files">this post</a></p>  <p>However I am getting a </p>  <p>></p>  <pre><code> 1 counts of IllegalAnnotationExceptions XmlIDREF property is referencing a type "java.lang.String" that doesn't have an XmlID property.     this problem is related to the following location:         at private externalReferences.Department    externalReferences.Employee.department         at externalReferences.Employee         at private java.util.List externalReferences.Company.employees         at externalReferences.Company </code></pre>  <p>The two xml Files are the following:</p>  <p>employee.xml</p>  <pre><code>&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt; &lt;company&gt;     &lt;employeeList&gt;         &lt;employee name="Jane Doe" id="1"&gt;             &lt;department&gt;1&lt;/department&gt;         &lt;/employee&gt;         &lt;employee name="John Smith" id="2"&gt;             &lt;department&gt;2&lt;/department&gt;         &lt;/employee&gt;         &lt;employee name="Anne Jones" id="3"&gt;             &lt;department&gt;3&lt;/department&gt;         &lt;/employee&gt;     &lt;/employeeList&gt; &lt;/company&gt; </code></pre>  <p>department.xml</p>  <pre><code>    &lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt; &lt;departmentList&gt;     &lt;departmentList&gt;         &lt;department name="Dev" id="1"/&gt;         &lt;department name="Sales" id="2"/&gt;         &lt;department name="Research" id="3"/&gt;     &lt;/departmentList&gt; &lt;/departmentList&gt; </code></pre>  <p>The employee.xml references the department and I want to point to the right department objects when unmarshalling employee.xml.</p>  <p>Classes are as follows:</p>  <p>Company.java</p>  <pre><code> @XmlRootElement  @XmlAccessorType(XmlAccessType.FIELD)  public class Company {      @XmlElementWrapper(name = "employeeList")     @XmlElement(name="employee")     private List&lt;Employee&gt; employees;      @XmlElementWrapper(name = "departmentList")     @XmlElement(name="department")     private List&lt;Department&gt; departments;      public Company() {         employees = new ArrayList&lt;Employee&gt;();         departments = new ArrayList&lt;Department&gt;();     }     ... } </code></pre>  <p>Employee.java</p>  <pre><code> @XmlRootElement  @XmlAccessorType(XmlAccessType.FIELD)  public class Employee {          @XmlAttribute         @XmlID         private String id;          public String getId() {             return id;         }           @XmlIDREF          private Employee manager;           @XmlJavaTypeAdapter(EmpAdapter.class)         @XmlIDREF         private Department department;      } </code></pre>  <p>Department.java</p>  <pre><code>@XmlRootElement @XmlAccessorType(XmlAccessType.FIELD) public class Department {  @XmlAttribute @XmlID private String id; ... } </code></pre>  <p>DepartmentList.java</p>  <pre><code>    @XmlRootElement     @XmlAccessorType(XmlAccessType.FIELD)     public class DepartmentList {      @XmlElementWrapper(name = "departmentList")     @XmlElement(name="department")     private List&lt;Department&gt; departments; </code></pre>  <p>Then I run the following in Main</p>  <pre><code> JAXBContext jc = JAXBContext.newInstance(DepartmentList.class);                                                                                  Unmarshaller unmarshaller = jc.createUnmarshaller();       DepartmentList depList = (DepartmentList) unmarshaller.unmarshal(new FileReader(DepRef));       EmpAdapter adapter = new EmpAdapter();       for(Department dep : depList.getDepartments()) {           adapter.getDepList().put(dep.getId(), dep);       }       JAXBContext jc2 = JAXBContext.newInstance(Company.class);       Unmarshaller unmarshaller2 = jc2.createUnmarshaller();       unmarshaller2.setAdapter(adapter);       Company company2 = (Company) unmarshaller2.unmarshal(new FileReader(empRef)); </code></pre>  <p>I feel that having one XMLIDREF refer to employee id and the other XMLIDREF refer to department id is part of the problem. But that is required since the manager field references other employee objects.</p>  <p>Can someone please help me with this. Thank you </p>