<p>I have multiple entity objects which I would like to secure by using custom Access Lists (ACL) stored in a SQL Server database. All my "securables" implement an <code>ISecurable</code> interface:</p>  <pre><code>public interface ISecurable {     int ACLId { get; }     ACL ACL { get; } } </code></pre>  <p><code>AccessList</code> (ACL) entity looks like this:</p>  <pre><code>public class ACL {     public int Id { get; set; }     public virtual ICollection&lt;ACE&gt; ACEntries { get; set; } } </code></pre>  <p>... and each ACL has multiple <code>ACE</code> entries: </p>  <pre><code>public class ACE {     public int Id { get; set; }      public int ACLId { get; set; }     public virtual ACL ACL { get; set; }      public int PrincipalId { get; set; }     public virtual Principal Principal { get; set; }      public int AllowedActions { get; set; }  // flags } </code></pre>  <p><code>Actions</code> can be granted both to <code>Users</code> and to <code>Workgroups</code>.</p>  <p><code>Principal</code> is an abstract class, and both <code>User</code> and <code>Workgroup</code> inherits from it:</p>  <pre><code>public abstract class Principal {     public int Id { get; set; }     public string DisplayName { get; set; }      public virtual ICollection&lt;ACE&gt; ACEntries { get; set; } }  public class User : Principal {     public string Email { get; set; }      public virtual ICollection&lt;Workgroup&gt; Workgroups { get; set; } }  public class Workgroup : Principal {     public virtual ICollection&lt;User&gt; Users { get; set; } } </code></pre>  <p><code>User</code> and <code>Workgroup</code> are obviously in many-to-many relation.</p>  <p>My <code>DbContext</code> is looks like this:</p>  <pre><code>public class MyDbContext : DbContext {        public DbSet&lt;User&gt; Users { get; set; }     public DbSet&lt;Workgroup&gt; Workgroups { get; set; }     public DbSet&lt;ACL&gt; ACLs { get; set; }     public DbSet&lt;ACE&gt; ACEntries { get; set; }     public DbSet&lt;SecurableClass&gt; SecurableClassItems { get; set; } } </code></pre>  <p><strong>Finally, my question</strong> : I would like to write extension method to filter out all my <code>ISecurable</code> classes by ACL, based on user and required action. And I would like to have single query to the DB:</p>  <pre><code>    public static IQueryable&lt;ISecurable&gt; FilterByACL(this IQueryable&lt;ISecurable&gt; securables, User user, int requiredAction)     {         var userId = user.Id;          return securables.Where(s =&gt;             s.ACL.ACEntries.Any(e =&gt;                 (e.PrincipalId == userId || user.Workgroups.Select(w =&gt; w.Id).Contains(userId)) &amp;&amp;                 (e.AllowedActions &amp; requiredAction) == requiredAction));      } </code></pre>  <p>This does not work, due to error:</p>  <blockquote>   <p>Unable to create a constant value of type 'Test.Entities.Workgroup'. Only primitive types or enumeration types are supported in this context</p> </blockquote>  <p>even though I select only IDs from Workgroup:</p>  <pre><code>user.Workgroups.Select(w =&gt; w.Id) </code></pre>  <p>Is there any way to handle this scenario ? Sorry for long question, but existing simplified code will probably best explain my intention.</p>  <h2>UPDATE</h2>  <p>After @vittore suggestion, my extension method might be something like this:</p>  <pre><code>public static IQueryable&lt;ISecurable&gt; FilterByACL2(this IQueryable&lt;ISecurable&gt; securables, User user, int requiredAction, MyDbContext db) {     var userId = user.Id;      var workgroups = db.Entry(user).Collection(u =&gt; u.Workgroups).Query();      return securables.Where(s =&gt;         s.ACL.ACEntries.Any(e =&gt;             (e.PrincipalId == userId || workgroups.Select(w =&gt; w.Id).Contains(e.PrincipalId)) &amp;&amp;             (e.AllowedActions &amp; requiredAction) == requiredAction));  } </code></pre>  <p>.. but I'll have to reference 'MyDbContext' as additional parameter ?</p>  <p>On the other side, if I write SQL function (TVF) which will return all allowable ACLIDs based on 'UserId' and 'RequiredAction':</p>  <pre><code>CREATE function [dbo].[AllowableACLs] (     @UserId int,     @RequiredAction int ) returns table as return      select         ace.ACLId     from         dbo.ACEntries ace     where         (@UserId = ace.PrincipalId or @UserId in (select wu.User_Id from dbo.WorkgroupUsers wu where ace.PrincipalId = wu.Workgroup_Id))         and         ((ace.AllowedActions &amp; @RequiredAction) = @RequiredAction) </code></pre>  <p>.. theoretically I could just make 'inner join' or 'exist (select 1 from dbo.AllowableACLs(@UserId, @RequiredAction)' from my ISecurable Entity.</p>  <p>Is there any way to get this working from code-first ?</p>