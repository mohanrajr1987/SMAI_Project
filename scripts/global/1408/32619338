<p>Say I have this where I want to get every person in group 42, but I want to get an IQueryable of each unique first name in the database (PS - I know I can call AsQueryable() after the Select but that's not what I'm interested in doing - I want the database to perform the distinct, not the program):</p>  <pre><code>MyEfContextContainer db = new MyEfContextContainer(); IQueryable&lt;string&gt; uniqueFirstNames =      db.People     .Where(x=&gt; x.GroupId == 42)     .DistinctBy(c=&gt; c.FirstName)     .Select(c=&gt; c.FirstName); </code></pre>  <p>From what I can tell of how EF/LINQ to Entities handles the DistinctBy extension method, a store query is executed when DistinctBy is invoked and a list of ALL items in the database that match the Where is retrieved, then C# returns an IEnumberable from the DistinctBy method that matches the expression sent to DistinctBy.</p>  <p>If there are millions of names in the list this is very inefficient.</p>  <p>I am interested in being able to do this efficiently, hopefully by having the store query only return a result set of all of the unique FirstNames in the table. I might, for example, want to return that IQueryable as part of a repository where it is not okay for performance reasons to have millions of items grabbed and processed by DistinctBy to just return unique values. This would increase request processing time to an unacceptable level.</p>  <p>Is there any way to do this? Am I missing something? This is only a simple example, obviously in a real application objects more complex than string would be the subject of a query to the repository.</p>