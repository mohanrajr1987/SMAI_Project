<p>I would like to group a list of entities by a common identifier of their base entity, select the first entity of each group and return a new list of entities. There are 3 different entities involved: GenericObject, ObjectVersion and ObjectDependency.</p>  <pre><code>public class GenericObject {     public int Id { get; set; } }  public class ObjectVersion {     public int Id { get; set; }     public GenericObject GenericObject { get; set; } }  public class ObjectDependency {     public string Name { get; set; }     public ObjectVersion ObjectVersion1 { get; set; }     public ObjectVersion ObjectVersion2 { get; set; } } </code></pre>  <p>The sample setup looks like this:</p>  <pre><code>GenericObject go1 = new GenericObject { Id = 1 }; GenericObject go2 = new GenericObject { Id = 2 }; GenericObject go3 = new GenericObject { Id = 3 };  ObjectVersion ov1 = new ObjectVersion { Id = 1, GenericObject = go1 }; ObjectVersion ov2 = new ObjectVersion { Id = 2, GenericObject = go2 }; ObjectVersion ov3 = new ObjectVersion { Id = 3, GenericObject = go3 }; ObjectVersion ov4 = new ObjectVersion { Id = 4, GenericObject = go1 };  List&lt;ObjectDependency&gt; dependencies = new List&lt;ObjectDependency&gt; {      new ObjectDependency { Name = "d1", ObjectVersion1 = ov1, ObjectVersion2 = ov2 },      new ObjectDependency { Name = "d2", ObjectVersion1 = ov2, ObjectVersion2 = ov3 },      new ObjectDependency { Name = "d3", ObjectVersion1 = ov4, ObjectVersion2 = ov2 } }; </code></pre>  <p>In order to get all ObjectDependencies containing ov2, I would filter like this:</p>  <pre><code>var ov2Dependencies = dependencies.Where(d =&gt; d.ObjectVersion1.Id == ov2.Id                                                || d.ObjectVersion2.Id == ov2.Id)                                   .OrderBy(d =&gt; d.Name); foreach (ObjectDependency dependency in ov2Dependencies) {     Console.WriteLine(dependency.Name); } // Output: // d1 // d2 // d3 </code></pre>  <p>In order to get all ObjectVersions dependent on ov2:</p>  <pre><code>var ov2AllDependentObjectVersions =               dependencies.Where(d =&gt; d.ObjectVersion1.Id == ov2.Id                                       || d.ObjectVersion2.Id == ov2.Id)                          .Select(d =&gt; d.ObjectVersion1)                          .Union(dependencies.Where(d =&gt; d.ObjectVersion1.Id == ov2.Id                                                         || d.ObjectVersion2.Id == ov2.Id)                          .Select(d =&gt; d.ObjectVersion2))                          .Where(o =&gt; o.Id != ov2.Id)                          .OrderBy(o =&gt; o.Id); foreach (ObjectVersion ov in ov2AllDependentObjectVersions) {     Console.WriteLine(ov.Id); } // Output: // 1 // 3 // 4 </code></pre>  <p>In order to get the latest ObjectVersions dependent on ov2 with different GenericObject:</p>  <pre><code>var ov2LatestDependentObjectVersions =           dependencies.Where(d =&gt; d.ObjectVersion1.Id == ov2.Id                                   || d.ObjectVersion2.Id == ov2.Id)                      .Select(d =&gt; d.ObjectVersion1)                      .Union(dependencies.Where(d =&gt; d.ObjectVersion1.Id == ov2.Id                                                      || d.ObjectVersion2.Id == ov2.Id)                      .Select(d =&gt; d.ObjectVersion2))                      .Where(o =&gt; o.Id != ov2.Id)                      .GroupBy(o =&gt; o.GenericObject.Id)                      .Select(g =&gt; g.OrderByDescending(o =&gt; o.Id).FirstOrDefault())                      .OrderBy(o =&gt; o.Id); foreach (ObjectVersion ov in ov2LatestDependentObjectVersions) {     Console.WriteLine(ov.Id); } // Output: // 3 // 4 </code></pre>  <p>How would the filtering look like, in order to achieve the following output? Basically, I would like to get the latest ObjectDependencies containing ov2 with different GenericObject. The filtering should be directly translatable into T-SQL by using IQueryable.</p>  <pre><code>var ov2LatestDependencies = dependencies.Where(d =&gt; d.ObjectVersion1.Id == ov2.Id                                                       || d.ObjectVersion2.Id == ov2.Id)                                           // ???                                          .OrderBy(d =&gt; d.Name); foreach (ObjectDependency dependency in ov2LatestDependencies) {     Console.WriteLine(dependency.Name); } // Output: // d2 // d3 </code></pre>  <p>I have created a fiddle here: <a href="https://dotnetfiddle.net/OZQlWO" rel="nofollow">https://dotnetfiddle.net/OZQlWO</a></p>  <p>Any help would be much appreciated!</p>  <p><strong>Edit:</strong></p>  <p>I ended up using the following solution supporting LINQ to entities based on the answer of Jason Boyd: <a href="https://dotnetfiddle.net/YSj8ki" rel="nofollow">https://dotnetfiddle.net/YSj8ki</a></p>  <pre><code>var ov2LatestDependencies = dependencies.Where(d =&gt; d.ObjectVersion1.Id == ov2.Id                                                       || d.ObjectVersion2.Id == ov2.Id)     .Where(x =&gt; x.ObjectVersion1.Id == ov2.Id)     .Select(x =&gt; new     {         ObjectDependency = x,         ObjectVersion = x.ObjectVersion2     })     .Union(         dependencies.Where(d =&gt; d.ObjectVersion1.Id == ov2.Id                                                       || d.ObjectVersion2.Id == ov2.Id)         .Where(x =&gt; x.ObjectVersion2.Id == ov2.Id)         .Select(x =&gt; new         {             ObjectDependency = x,             ObjectVersion = x.ObjectVersion1         })     )     .GroupBy(x =&gt; x.ObjectVersion.GenericObject.Id)     .Select(x =&gt; x.OrderByDescending(y =&gt; y.ObjectVersion.Id).FirstOrDefault())     .Select(x =&gt; x.ObjectDependency)     .OrderBy(d =&gt; d.Name); foreach (ObjectDependency dependency in ov2LatestDependencies) {     Console.WriteLine(dependency.Name); } // Output: // d2 // d3 </code></pre>