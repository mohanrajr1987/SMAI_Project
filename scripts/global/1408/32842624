<p>I have encountered an issue with a ExtJS grid where I enabled remote filtering, sorting and grouping. </p>  <pre><code>System.NotSupportedException: Unable to cast the type 'System.Nullable`1[[System.Int32, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]' to type 'System.Object'. LINQ to Entities only supports casting EDM primitive or enumeration types. bij System.Data.Entity.Core.Objects.ELinq.ExpressionConverter.ValidateAndAdjustCastTypes(TypeUsage toType, TypeUsage fromType, Type toClrType, Type fromClrType) bij System.Data.Entity.Core.Objects.ELinq.ExpressionConverter.GetCastTargetType(TypeUsage fromType, Type toClrType, Type fromClrType, Boolean preserveCastForDateTime) bij System.Data.Entity.Core.Objects.ELinq.ExpressionConverter.CreateCastExpression(DbExpression source, Type toClrType, Type fromClrType) bij System.Data.Entity.Core.Objects.ELinq.ExpressionConverter.ConvertTranslator.TranslateUnary(ExpressionConverter parent, UnaryExpression unary, DbExpression operand) bij System.Data.Entity.Core.Objects.ELinq.ExpressionConverter.UnaryTranslator.TypedTranslate(ExpressionConverter parent, UnaryExpression linq) bij System.Data.Entity.Core.Objects.ELinq.ExpressionConverter.TypedTranslator`1.Translate(ExpressionConverter parent, Expression linq) bij  System.Data.Entity.Core.Objects.ELinq.ExpressionConverter.TranslateExpression(Expression linq) bij System.Data.Entity.Core.Objects.ELinq.ExpressionConverter.TranslateLambda(LambdaExpression lambda, DbExpression input) bij System.Data.Entity.Core.Objects.ELinq.ExpressionConverter.TranslateLambda(LambdaExpression lambda, DbExpression input, DbExpressionBinding&amp; binding) bij System.Data.Entity.Core.Objects.ELinq.ExpressionConverter.MethodCallTranslator.OneLambdaTranslator.Translate(ExpressionConverter parent, MethodCallExpression call, DbExpression&amp; source, DbExpressionBinding&amp; sourceBinding, DbExpression&amp; lambda) bij System.Data.Entity.Core.Objects.ELinq.ExpressionConverter.MethodCallTranslator.OneLambdaTranslator.Translate(ExpressionConverter parent, MethodCallExpression call) bij System.Data.Entity.Core.Objects.ELinq.ExpressionConverter.MethodCallTranslator.SequenceMethodTranslator.Translate(ExpressionConverter parent, MethodCallExpression call, SequenceMethod sequenceMethod) bij System.Data.Entity.Core.Objects.ELinq.ExpressionConverter.MethodCallTranslator.TypedTranslate(ExpressionConverter parent, MethodCallExpression linq) bij System.Data.Entity.Core.Objects.ELinq.ExpressionConverter.TypedTranslator`1.Translate(ExpressionConverter parent, Expression linq) bij System.Data.Entity.Core.Objects.ELinq.ExpressionConverter.TranslateExpression(Expression linq) bij System.Data.Entity.Core.Objects.ELinq.ExpressionConverter.MethodCallTranslator.UnarySequenceMethodTranslator.Translate(ExpressionConverter parent, MethodCallExpression call) bij System.Data.Entity.Core.Objects.ELinq.ExpressionConverter.MethodCallTranslator.SequenceMethodTranslator.Translate(ExpressionConverter parent, MethodCallExpression call, SequenceMethod sequenceMethod) bij System.Data.Entity.Core.Objects.ELinq.ExpressionConverter.MethodCallTranslator.TypedTranslate(ExpressionConverter parent, MethodCallExpression linq) bij System.Data.Entity.Core.Objects.ELinq.ExpressionConverter.TypedTranslator`1.Translate(ExpressionConverter parent, Expression linq) bij System.Data.Entity.Core.Objects.ELinq.ExpressionConverter.TranslateExpression(Expression linq) bij System.Data.Entity.Core.Objects.ELinq.ExpressionConverter.MethodCallTranslator.UnarySequenceMethodTranslator.Translate(ExpressionConverter parent, MethodCallExpression call) bij System.Data.Entity.Core.Objects.ELinq.ExpressionConverter.MethodCallTranslator.SequenceMethodTranslator.Translate(ExpressionConverter parent, MethodCallExpression call, SequenceMethod sequenceMethod) bij System.Data.Entity.Core.Objects.ELinq.ExpressionConverter.MethodCallTranslator.TypedTranslate(ExpressionConverter parent, MethodCallExpression linq) bij System.Data.Entity.Core.Objects.ELinq.ExpressionConverter.TypedTranslator`1.Translate(ExpressionConverter parent, Expression linq) bij System.Data.Entity.Core.Objects.ELinq.ExpressionConverter.TranslateExpression(Expression linq) bij System.Data.Entity.Core.Objects.ELinq.ExpressionConverter.MethodCallTranslator.OneLambdaTranslator.Translate(ExpressionConverter parent, MethodCallExpression call, DbExpression&amp; source, DbExpressionBinding&amp; sourceBinding, DbExpression&amp; lambda) bij System.Data.Entity.Core.Objects.ELinq.ExpressionConverter.MethodCallTranslator.SelectTranslator.Translate(ExpressionConverter parent, MethodCallExpression call) bij Systm.Data.Entity.Core.Objects.ELinq.ExpressionConverter.MethodCallTranslator.SequenceMethodTranslator.Translate(ExpressionConverter parent, MethodCallExpression call, SequenceMethod sequenceMethod) bij System.Data.Entity.Core.Objects.ELinq.ExpressionConverter.MethodCallTranslator.TypedTranslate(ExpressionConverter parent, MethodCallExpression linq) bij System.Data.Entity.Core.Objects.ELinq.ExpressionConverter.TypedTranslator`1.Translate(ExpressionConverter parent, Expression linq) bij System.Data.Entity.Core.Objects.ELinq.ExpressionConverter.TranslateExpression(Expression linq) bij System.Data.Entity.Core.Objects.ELinq.ExpressionConverter.Convert() bij System.Data.Entity.Core.Objects.ELinq.ELinqQueryState.GetExecutionPlan(Nullable`1 forMergeOption) bij System.Data.Entity.Core.Objects.ObjectQuery`1.&lt;&gt;c__DisplayClassc.&lt;GetResultsAsync&gt;b__a() bij System.Data.Entity.Core.Objects.ObjectContext.&lt;ExecuteInTransactionAsync&gt;d__3d`1.MoveNext() </code></pre>  <p>The code sample below converts the input model (string properties indicating direction and property name) and generates a LINQ script on the fly, which will be used in the repository pattern, and consequently also Entity Framework. This script works well for non-nullable types, but it gives the error above when nullable properties are being sorted.</p>  <pre><code>Expression&lt;Func&lt;Task, object&gt;&gt; orderByClause = default(Expression&lt;Func&lt;Task, object&gt;&gt;); if (sortObjects != null) {        foreach (Order sortObject in sortObjects)        {         // Get type and property of type         ParameterExpression parameter = Expression.Parameter(typeof(Task), "x");                                PropertyInfo property = typeof(Task).GetProperty(sortObject.Property);           // Create left hand side of the lambda: x =&gt; x.PROPERTY         MemberExpression propertyAccess = Expression.Property(parameter, property);         LambdaExpression orderByExp = Expression.Lambda(propertyAccess, parameter);          // Create expression from lambda         MemberExpression orderByExpression = Expression.Property(parameter, sortObject.Property);         Expression conversion = Expression.Convert(orderByExpression, typeof(object));          Expression&lt;Func&lt;Task,object&gt;&gt; lambda = Expression.Lambda&lt;Func&lt;Task, object&gt;&gt;(conversion, parameter);         if (orderByClause == default(Expression&lt;Func&lt;Task, object&gt;&gt;))        {          orderByClause = lambda;        }        else        {           InvocationExpression invokedExpr = Expression.Invoke(lambda, orderByClause.Parameters.Cast&lt;Expression&gt;());            orderByClause = Expression.Lambda&lt;Func&lt;Task, object&gt;&gt;(Expression.AndAlso(orderByClause.Body, invokedExpr), orderByClause.Parameters);        }       }  }    return orderByClause; </code></pre>  <p>The issue here probably is the casting between the object and the nullable type. I'd need to be able to box the nullable type in the expression.</p>  <p>I was thinking of two options here:</p>  <p>1) Use some kind of generic method to define the property type instead of using the object type</p>  <p>2) Box the nullable property so it can be casted to an object.</p>  <p>I think option 2 is the easiest but I'm kind of stuck here.</p>  <p><strong>Update:</strong></p>  <p>I still haven't found a solution for this but I have a workaround until I have solved this issue. Now the sorting key isn't an object anymore, instead it's a generic type. This scenario will always work because there isn't any boxing occurring anymore:</p>  <pre><code> protected virtual Expression&lt;Func&lt;T, TKey&gt;&gt; GetSorting&lt;TKey&gt;(string ordering)     {         IEnumerable&lt;Order&gt; sortObjects = string.IsNullOrEmpty(ordering) ? null : JsonConvert.DeserializeObject&lt;IEnumerable&lt;Order&gt;&gt;(ordering);          Expression&lt;Func&lt;T, TKey&gt;&gt; orderByClause = default(Expression&lt;Func&lt;T, TKey&gt;&gt;);         if (sortObjects != null)         {             foreach (Order sortObject in sortObjects)             {                 // Get type and property of type                 ParameterExpression parameter = Expression.Parameter(typeof(T), "x");                 PropertyInfo property = typeof(T).GetProperty(sortObject.Property);                  // Create left hand side of the lambda: x =&gt; x.PROPERTY                 MemberExpression propertyAccess = !sortObject.ComplexType ? Expression.Property(parameter, property) : Expression.PropertyOrField(Expression.Property(parameter, property), sortObject.ComplexTypeProperty);                 MemberExpression orderByExpression = !sortObject.ComplexType ? Expression.Property(parameter, sortObject.Property) : Expression.PropertyOrField(Expression.Property(parameter, property), sortObject.ComplexTypeProperty);                  // Create expression from lambda                 Expression&lt;Func&lt;T, TKey&gt;&gt; lambda = Expression.Lambda&lt;Func&lt;T, TKey&gt;&gt;(orderByExpression, parameter);                 if (orderByClause == default(Expression&lt;Func&lt;T, TKey&gt;&gt;))                 {                     orderByClause = lambda;                 }                 else                 {                     InvocationExpression invokedExpr = Expression.Invoke(lambda, orderByClause.Parameters.Cast&lt;Expression&gt;());                     orderByClause = Expression.Lambda&lt;Func&lt;T, TKey&gt;&gt;(Expression.AndAlso(orderByClause.Body, invokedExpr), orderByClause.Parameters);                 }             }         }          return orderByClause;     } </code></pre>  <p>Here's how I call this method. From the user's input, I determine which property is being sorted. Using reflection, I retrieve the its type, which I then pass as the type for the sorting method.</p>  <pre><code>switch (propertyType)   {           case "Int32":             Expression&lt;Func&lt;Resource, int?&gt;&gt; orderIntExpression = this.GetSorting&lt;int?&gt;(ordering);             return await this.GetResources&lt;int?&gt;(page, pageSize, orderIntExpression, base.IsAscending(ordering), selector, mergedQuery);            default:               Expression&lt;Func&lt;Resource, object&gt;&gt; orderDefaultExpression = this.GetSorting&lt;object&gt;(ordering);               return await this.GetResources&lt;object&gt;(page, pageSize, orderDefaultExpression, base.IsAscending(ordering), selector, mergedQuery);   } </code></pre>  <p>This works but it's not very scalable in my opinion. I don't see any easy or pretty fixes here to dynamically pass the type to the sorting method. Any suggestions on this matter?</p>