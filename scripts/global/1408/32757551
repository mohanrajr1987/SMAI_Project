<p>I am using EF and have a database table which has a number of date time fields which are populated as various operations are performed on the record. I am currently building a reporting system which involves filtering by these dates, but because the filters (is this date within a range, etc...) have the same behavior on each field, I would like to reuse my filtering logic so I only write a single date filter and use it on each field.</p>  <p>My initial filtering code looks something like:</p>  <pre><code>DateTime? dateOneIsBefore = null; DateTime? dateOneIsAfter = null;  DateTime? dateTwoIsBefore = null; DateTime? dateTwoIsAfter = null;  using (var context = new ReusableDataEntities()) {     IEnumerable&lt;TestItemTable&gt; result = context.TestItemTables         .Where(record =&gt; ((!dateOneIsAfter.HasValue                 || record.DateFieldOne &gt; dateOneIsAfter.Value)             &amp;&amp; (!dateOneIsBefore.HasValue                 || record.DateFieldOne &lt; dateOneIsBefore.Value)))         .Where(record =&gt; ((!dateTwoIsAfter.HasValue                 || record.DateFieldTwo &gt; dateTwoIsAfter.Value)             &amp;&amp; (!dateTwoIsBefore.HasValue                 || record.DateFieldTwo &lt; dateTwoIsBefore.Value)))         .ToList();      return result; } </code></pre>  <p>This works fine, but I would prefer to reduce the duplicated code in the 'Where' methods as the filter algorithm is the same for each date field.</p>  <p>What I would prefer is something that looks like the following (I will create a class or struct for the filter values later) where I can encapsulate the match algorithm using maybe an extension method:</p>  <pre><code>DateTime? dateOneIsBefore = null; DateTime? dateOneIsAfter = null;  DateTime? dateTwoIsBefore = null; DateTime? dateTwoIsAfter = null;  using (var context = new ReusableDataEntities()) {     IEnumerable&lt;TestItemTable&gt; result = context.TestItemTables         .WhereFilter(record =&gt; record.DateFieldOne, dateOneIsBefore, dateOneIsAfter)         .WhereFilter(record =&gt; record.DateFieldTwo, dateTwoIsBefore, dateTwoIsAfter)         .ToList();      return result; } </code></pre>  <p>Where the extension method could look something like:</p>  <pre><code>internal static IQueryable&lt;TestItemTable&gt; WhereFilter(this IQueryable&lt;TestItemTable&gt; source, Func&lt;TestItemTable, DateTime&gt; fieldData, DateTime? dateIsBefore, DateTime? dateIsAfter) {     source = source.Where(record =&gt; ((!dateIsAfter.HasValue             || fieldData.Invoke(record) &gt; dateIsAfter.Value)         &amp;&amp; (!dateIsBefore.HasValue             || fieldData.Invoke(record) &lt; dateIsBefore.Value)));      return source; } </code></pre>  <p>Using the above code, if my filtering code is as follows:</p>  <pre><code>IEnumerable&lt;TestItemTable&gt; result = context.TestItemTables     .WhereFilter(record =&gt; record.DateFieldOne, dateOneIsBefore, dateOneIsAfter)     .WhereFilter(record =&gt; record.DateFieldTwo, dateTwoIsBefore, dateTwoIsAfter)     .ToList(); </code></pre>  <p>I get the following exception:</p>  <pre><code>A first chance exception of type 'System.NotSupportedException' occurred in EntityFramework.SqlServer.dll  Additional information: LINQ to Entities does not recognize the method 'System.DateTime Invoke(RAC.Scratch.ReusableDataFilter.FrontEnd.TestItemTable)' method, and this method cannot be translated into a store expression. </code></pre>  <p>The problem I have is the use of Invoke to get the particular field being queried as this technique does not resolve nicely to SQL, because if I modify my filtering code to the following it will run without errors:</p>  <pre><code>IEnumerable&lt;TestItemTable&gt; result = context.TestItemTables     .ToList()     .AsQueryable()     .WhereFilter(record =&gt; record.DateFieldOne, dateOneIsBefore, dateOneIsAfter)     .WhereFilter(record =&gt; record.DateFieldTwo, dateTwoIsBefore, dateTwoIsAfter)     .ToList(); </code></pre>  <p>The issue with this is that the code (using ToList on the entire table before filtering with the extension method) pulls in the entire database and queries it as objects instead of querying the underlying database so it is not scaleable.</p>  <p>I have also investigated using the PredicateBuilder from Linqkit, but it could not find a way to write the code without using the Invoke method.</p>  <p>I know there are techniques where one can express parts of the query as strings which include field names, but I would prefer to use a more type safe way of writing this code.</p>  <p>Also, in an ideal world I could redesign the database to have multiple 'date' records related to a single 'item' record, but I am not at liberty to change the database schema in this way.</p>  <p>Is there another way I need to write the extension so it doesn't use Invoke, or should I be tackling reuse of my filtering code in a different way?</p>