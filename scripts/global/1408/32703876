<p>I have a method that selects data.  It can support multiple use cases if the caller can provide a predicate to modify the <code>.Where()</code>.  I attempted something like</p>  <pre><code>private class ABJoin {     public A A { get; set; }     public B B { get; set; } }  bool NoFilter(ABJoin join, int index) {     return true; // Don't filter at all for this }  private IEnumerable&lt;TResult&gt; GetData (Func&lt;ABJoin, int, bool&gt; filter) {     var query = ctx.TypeA         .Join(ctx.TypeB, a =&gt; a.BId, b =&gt; b.Id,                (a, b) =&gt; new ABJoin() { A = a, B = b })     // etc. } </code></pre>  <p>Works great, so far.</p>  <p>However, some use cases do not need to provide any filter (the real version has other parameters to distinguish behavior per use case).  I thought it would be handy to provide a default value for the filter parameter</p>  <pre><code>private IEnumerable&lt;TResult&gt; GetData (Func&lt;ABJoin, int, bool&gt; filter = NoFilter) </code></pre>  <p>However, that does not compile.  The error states that <code>NoFilter</code> must be a compile-time constant.</p>  <p>Is there a way to provide a default value for <code>filter</code> in <code>GetData()</code>?</p>