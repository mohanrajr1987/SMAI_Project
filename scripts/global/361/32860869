<p>I have some utility functions that I've declared as <code>static</code>, as they are not to be instantiated, only used for utilities. I would like to create a generator method that can generate objects, but in the same <code>static</code> utility context.</p>  <pre><code>public class PeerConnection {      public class _Heartbeat{         protected String beat = "HB_000";         protected String ack  = "HB_001";         protected String msg  = null;          protected Date beatTime = null;         protected Date ackTime  = null;         protected short missedBeats = 0;         protected short MAX_MISS = 3;     }      public _Heartbeat heartbeat = null;     //map of heartbeat objects per Peer connection     public static List&lt;_Heartbeat&gt; Heartbeats = new ArrayList&lt;_Heartbeat&gt;();      public static void GenerateHeartbeat(){         Heartbeats.add(new _Heartbeat());     } </code></pre>  <p>My reasoning, is I want to call this from a <code>SendHeartbeat</code> method:</p>  <pre><code>   private static int SendHeartbeat(PeerConnection peer){         int acks = 0;         PeerConnection.GenerateHeartbeat();         PeerConnection._Heartbeat hb = peer.Heartbeats.get(peer.Heartbeats.size() - 1);         hb.msg = hb.beat;          while (acks &lt;= 0 &amp;&amp; hb.missedBeats &lt; hb.MAX_MISS){          [...]         }    } </code></pre>  <p>I get the concept of why static works this way, but I'm thinking there has to be a work around for this scenario.</p>