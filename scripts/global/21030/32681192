<p>I am trying to make an android app, that detects known objects. I am using <a href="http://boofcv.org/index.php?title=Main_Page" rel="nofollow">boofCV</a> to achieve it. I have stored the image of the object in app's resources, on run time, i detect the features using Fast Hessian and describe it using SURF. Then through the camera's feed when i get the frame, i detect the features in the frame using Fast Hessian and describe it using SURF. Once i have the features of both the source object and the current frame, i associate them and get the matches. Now i am able to draw the matches. But what i want to do is using the matches i want get the bounds of the detected object. To do this i started following <a href="http://boofcv.org/index.php?title=Example_Image_Stitching" rel="nofollow">this</a> example. Although this is an image stitching example, but the concept can be applied to detect the bounds of a known object. </p>  <p>I have successfully implemented this example. The problem is that lines do get drawn, but the lines are just straight lines, only a single straight gets drawn in some of the frames, a rectangle is not drawn.</p>  <p>Here is my code:</p>  <pre><code>public class HomographyProcessing2&lt;Desc extends TupleDesc&gt; extends VideoRenderProcessing&lt;ImageFloat32&gt; {   DetectDescribePoint&lt;ImageFloat32,Desc&gt; detDesc; AssociateDescription&lt;Desc&gt; associate;  FastQueue&lt;Desc&gt; listSrc; FastQueue&lt;Desc&gt; listDst; FastQueue&lt;Point2D_F64&gt; locationSrc = new FastQueue&lt;Point2D_F64&gt;(Point2D_F64.class,true); FastQueue&lt;Point2D_F64&gt; locationDst = new FastQueue&lt;Point2D_F64&gt;(Point2D_F64.class,true);  // output image which is displayed by the GUI private Bitmap outputGUI; // storage used during image convert private byte[] storage; // output image which is modified by processing thread private Bitmap output;  List&lt;Point2D_F64&gt; pointsSrc = new ArrayList&lt;Point2D_F64&gt;(); List&lt;Point2D_F64&gt; pointsDst = new ArrayList&lt;Point2D_F64&gt;();  private ImageFloat32 object; private ImageFloat32 frame;   Paint paint = new Paint(); ModelManager&lt;Homography2D_F64&gt; manager = new ModelManagerHomography2D_F64(); GenerateHomographyLinear modelFitter = new GenerateHomographyLinear(true); DistanceHomographySq distance = new DistanceHomographySq(); ModelMatcher&lt;Homography2D_F64,AssociatedPair&gt; modelMatcher = new Ransac&lt;Homography2D_F64,AssociatedPair&gt;(123,manager,modelFitter,distance,60,9);  Homography2D_F64 homography2D_f64 = null;  public HomographyProcessing2(Context context, int width, int height) {     super(ImageType.single(ImageFloat32.class));      Log.e("LEARN", String.valueOf(modelFitter.getMinimumPoints()));     detDesc = CreateDetectorDescriptor.create(CreateDetectorDescriptor.DETECT_FH, CreateDetectorDescriptor.DESC_SURF, ImageFloat32.class);     listSrc = UtilFeature.createQueue(detDesc, 100);     listDst = UtilFeature.createQueue(detDesc,100);     ScoreAssociation score = FactoryAssociation.scoreEuclidean(detDesc.getDescriptionType(),true);     associate = FactoryAssociation.greedy(score,Double.MAX_VALUE,true);      Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), R.drawable.camera_image);     object = new ImageFloat32(bitmap.getWidth(),bitmap.getHeight());     byte[] storage = null;     ConvertBitmap.declareStorage(bitmap, storage);     ConvertBitmap.bitmapToGray(bitmap,object,storage);      detDesc.detect(object);     describeImage(listSrc, locationSrc);     associate.setSource(listSrc);      output = Bitmap.createBitmap(width,height,Bitmap.Config.ARGB_8888 );     outputGUI = Bitmap.createBitmap(width,height,Bitmap.Config.ARGB_8888 );     paint.setColor(Color.BLUE);     paint.setTextSize(20);  }       /**  * Using abstracted code, find a transform which minimizes the difference between corresponding features  * in both images.  This code is completely model independent and is the core algorithms.  */ public static&lt;T extends ImageSingleBand, FD extends TupleDesc&gt; Homography2D_F64 computeTransform( T imageA , T imageB ,                   DetectDescribePoint&lt;T,FD&gt; detDesc ,                   AssociateDescription&lt;FD&gt; associate ,                   ModelMatcher&lt;Homography2D_F64,AssociatedPair&gt; modelMatcher ) {     // get the length of the description     List&lt;Point2D_F64&gt; pointsA = new ArrayList&lt;Point2D_F64&gt;();     FastQueue&lt;FD&gt; descA = UtilFeature.createQueue(detDesc, 100);     List&lt;Point2D_F64&gt; pointsB = new ArrayList&lt;Point2D_F64&gt;();     FastQueue&lt;FD&gt; descB = UtilFeature.createQueue(detDesc,100);        // extract feature locations and descriptions from each image     describeImage(imageA, detDesc, pointsA, descA);     describeImage(imageB, detDesc, pointsB, descB);      // Associate features between the two images     associate.setSource(descA);     associate.setDestination(descB);     associate.associate();      // create a list of AssociatedPairs that tell the model matcher how a feature moved     FastQueue&lt;AssociatedIndex&gt; matches = associate.getMatches();     List&lt;AssociatedPair&gt; pairs = new ArrayList&lt;AssociatedPair&gt;();      for( int i = 0; i &lt; matches.size(); i++ ) {         AssociatedIndex match = matches.get(i);          Point2D_F64 a = pointsA.get(match.src);         Point2D_F64 b = pointsB.get(match.dst);          pairs.add( new AssociatedPair(a,b,false));     }      // find the best fit model to describe the change between these images     if( !modelMatcher.process(pairs) )         throw new RuntimeException("Model Matcher failed!");      // return the found image transform     return modelMatcher.getModelParameters().copy(); }  /**  * Detects features inside the two images and computes descriptions at those points.  */ private static &lt;T extends ImageSingleBand, FD extends TupleDesc&gt; void describeImage(T image,                    DetectDescribePoint&lt;T,FD&gt; detDesc,                    List&lt;Point2D_F64&gt; points,                    FastQueue&lt;FD&gt; listDescs) {     detDesc.detect(image);      listDescs.reset();     for( int i = 0; i &lt; detDesc.getNumberOfFeatures(); i++ ) {         points.add( detDesc.getLocation(i).copy() );         listDescs.grow().setTo(detDesc.getDescription(i));     } }   private static Point2D_I32 renderPoint( int x0 , int y0 , Homography2D_F64 fromBtoWork ) {     Point2D_F64 result = new Point2D_F64();     HomographyPointOps_F64.transform(fromBtoWork, new Point2D_F64(x0, y0), result);     return new Point2D_I32((int)result.x,(int)result.y); }  @Override protected void process(ImageFloat32 imageFloat32) {     detDesc.detect(imageFloat32);     describeImage(listDst,locationDst);     associate.setDestination(listDst);     associate.associate();     synchronized (new Object()) {         //ConvertBitmap.declareStorage(gray ,storage);         ConvertBitmap.grayToBitmap(imageFloat32, output, storage);         outputGUI = output;     }     synchronized (new Object())     {         pointsSrc.clear();         pointsDst.clear();          FastQueue&lt;AssociatedIndex&gt; matches = associate.getMatches();         List&lt;AssociatedPair&gt; pairs = new ArrayList&lt;AssociatedPair&gt;();          for( int i = 0; i &lt; matches.size(); i++ ) {             AssociatedIndex match = matches.get(i);              Point2D_F64 a = locationSrc.get(match.src);             Point2D_F64 b = locationDst.get(match.dst);              pairs.add( new AssociatedPair(a,b,false));             pointsDst.add(locationDst.get(match.dst));         }            if(pairs.size() &gt;= 4) {             // find the best fit model to describe the change between these images             if (!modelMatcher.process(pairs))                 throw new RuntimeException("Model Matcher failed!");              // return the found image transform             homography2D_f64 = modelMatcher.getModelParameters().copy();         }         }   }  @Override protected void render(Canvas canvas, double v) {     synchronized (new Object())     {         canvas.drawBitmap(outputGUI, 0, 0, null);         frame = ConvertBitmap.bitmapToGray(outputGUI,frame,storage);         if(homography2D_f64 != null)         {             // Convert into a BoofCV color format             MultiSpectral&lt;ImageFloat32&gt; colorA = new MultiSpectral&lt;ImageFloat32&gt;(ImageFloat32.class,3);             MultiSpectral&lt;ImageFloat32&gt; colorB = new MultiSpectral&lt;ImageFloat32&gt;(ImageFloat32.class,3);             colorB.setBands(new ImageFloat32[]{frame,frame,frame});             colorA.setBands(new ImageFloat32[]{object,object,object});             MultiSpectral&lt;ImageFloat32&gt; work = new MultiSpectral&lt;ImageFloat32&gt;(ImageFloat32.class,outputWidth,outputHeight,3);              Homography2D_F64 fromAToWork = new Homography2D_F64(0.5,0,colorA.width/4,0,scale,colorA.height/4,0,0,1);             Homography2D_F64 fromWorkToA = fromAToWork.invert(null);              // Used to render the results onto an image             PixelTransformHomography_F32 model = new PixelTransformHomography_F32();             ImageDistort&lt;MultiSpectral&lt;ImageFloat32&gt;,MultiSpectral&lt;ImageFloat32&gt;&gt; distort =                     DistortSupport.createDistortMS(ImageFloat32.class, model, new ImplBilinearPixel_F32(), false, null);               // Render first image             model.set(fromWorkToA);             distort.apply(colorA,work);              // Render second image             Homography2D_F64 fromWorkToB = fromWorkToA.concat(homography2D_f64,null);             model.set(fromWorkToB);             distort.apply(colorB,work);              Homography2D_F64 fromBtoWork = fromWorkToB.invert(null);             Point2D_I32 corners[] = new Point2D_I32[4];             corners[0] = renderPoint (0,0,fromBtoWork);             corners[1] = renderPoint(object.width,0,fromBtoWork);             corners[2] = renderPoint(object.width,object.height,fromBtoWork);             corners[3] = renderPoint(0,object.height,fromBtoWork);              paint.setColor(Color.GREEN);             paint.setStrokeWidth(5);             canvas.drawLine(corners[0].x,corners[0].y,corners[1].x,corners[1].y,paint);             canvas.drawLine(corners[1].x,corners[1].y,corners[2].x,corners[2].y,paint);             canvas.drawLine(corners[2].x,corners[2].y,corners[3].x,corners[3].y,paint);             canvas.drawLine(corners[3].x,corners[3].y,corners[0].x,corners[0].y,paint);         }         else {              for (int i = 0; i &lt; pointsDst.size(); i++) {                 Point2D_F64 point2D_f64 = pointsDst.get(i);                 canvas.drawCircle(Float.parseFloat(String.valueOf(point2D_f64.getX())), Float.parseFloat(String.valueOf(point2D_f64.getY())), 2, paint);             }         }     } }   private void describeImage(FastQueue&lt;Desc&gt; listDesc, FastQueue&lt;Point2D_F64&gt; listLoc) {     listDesc.reset();     listLoc.reset();     int N = detDesc.getNumberOfFeatures();     for( int i = 0; i &lt; N; i++ ) {         listLoc.grow().set(detDesc.getLocation(i));         listDesc.grow().setTo(detDesc.getDescription(i));     } } </code></pre>  <p>}</p>  <p>I don't clearly understand how homography works, and i think this may be the problem. </p>  <p>Please help me fix this, or provide any better approach to detect the bounds of the object on the basis of it's features.</p>  <p>Thanks!</p>