<p>I've been tasked to maintain and expand a codebase that heavily rest on Celery. This code needs to distribute several complex tasks, taking quite a long time each. Tasks were not designed as function, but directly as classes inheriting from Celery.</p>  <p>However, when you extend the task class from celery, your workers will create one and only one instance of the class, meaning that you severely pollute "self". The previous developers found a clever solution involving metaclasses to avoid this behaviour and create a new instance each time a task need to be run. This is efficient, but the result gives a code that is rather hard to read and debug, and that strays far away from classical celery usages. I'm also afraid it will prevent us from upgrading our versions of celery if new versions of celery make extensive changes.</p>  <p>I have the opportunity to refactor this code, but I'm not sure if I should. The only solution I can think of is to transform the current Task classes into "helper classes", and put the tasks themselves in simple functions that instantiate those helper classes and do the hard work. Are there any patterns to do this, or celery functionalities that I missed for this situation ?</p>  <p>(N.B.: this is pure celery, there is no Django in the mix)</p>