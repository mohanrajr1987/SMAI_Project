<p>So I have 2 classes for the moment(there might be more in the future) that are similar they both represent data from a Track</p>  <pre><code>private Track track; private TrackSearchResult trackSearchResult; </code></pre>  <p>These classes are auto-generated from Json Schema. They have no relation , but they contain similar methods. </p>  <p>So I have created a wrapper class to encapsulate both of them so I just have 1 class that I use for everything (Like playing a track).</p>  <pre><code>public class ExoPlayerTrack implements IPlayerTrack {   private Track track; private TrackSearchResult trackSearchResult;   public ExoPlayerTrack(Track track) {     this.track = track; }  public ExoPlayerTrack(TrackSearchResult trackSearchResult) {     this.trackSearchResult = trackSearchResult; }    @Override public String getTrackName() {     if (track != null) {         return track.getName();     } else if (trackSearchResult != null) {         return trackSearchResult.getTrackName();     } else {         return null;     } } </code></pre>  <p>I have defined an interface IPlayerTrack that has the common methods between the 2 similar Track Classes.</p>  <pre><code>public interface IPlayerTrack {     public String getTrackName();     public String getReleaseName();     public String getArtistName();     public String getTrackId();     public String getReleaseId();     public String getArtistId();     public String getImageUrl();     public long getDuration();     } </code></pre>  <p>So I need to implement every method of the interface by checking first for null to see which from the two Track classes was used to initialise the Wrapper Class which is very nasty.<br> Is there any way this can be avoided without touching the auto-generated model classes??? Maybe using Java 8 or Guava or a design pattern?</p>  <pre><code>@Override     public String getReleaseName() {         if (track != null) {   //AVOID             return track.getReleaseName();         } else if (trackSearchResult != null) {             return trackSearchResult.getReleaseName();         } else {             return null;         }     }   @Override public String getTrackName() {     if (track != null) {         return track.getName();     } else if (trackSearchResult != null) {         return trackSearchResult.getTrackName();     } else {         return null;     } } </code></pre>  <p>Note that also the method names are slightly different in some cases (getName/getTrackName).</p>