<p>I am having a very strange issue with R. Some actions produce NA records in a dataframe that aren't "real" NAs -- they don't have a row in the original dataset, the row ID says something strange like NA.123 instead of a real row number, and they match a test of ==1.</p>  <p>It's hard to describe what is happening, so I'll let heavily-commented code do most of the talking. The data file referenced here is a small (187 K) publicly-available file from the NHANES 2005 datasets, available at <a href="http://wwwn.cdc.gov/Nchs/Nhanes/2005-2006/COT_D.XPT" rel="nofollow">http://wwwn.cdc.gov/Nchs/Nhanes/2005-2006/COT_D.XPT</a> if anyone wants it so they can try to replicate the problem.</p>  <p>I am creating a yes/no variable to assess whether a cotinine blood test was positive or negative, using a cutoff of 10 to define a positive test. In the code below I do this two different ways, creating "cotpos1" and "cotpos2" to illustrate some of what I have found when troubleshooting this issue.</p>  <p>For the purpose of this post, a "good NA" is something that should be NA because the original blood test results were missing, and a "bad NA" is one of the mystery rows that wasn't part of the original data, every value is NA (including the SEQN, which isn't missing for any row in the original data), the row number shows up as something like NA.123, and the NAs in each column match ==1.</p>  <p>This dataset uses a field called SEQN to identify every record. At the start, no records are without a SEQN, so when the "bad NAs" appear later and their SEQNs are NA too (as well as everything else in the row) this suggests to me that rows are being added.</p>  <p>There are other ways I can do this that don't produce "bad NAs", like using ifelse() or using a package that does recodes, so my question isn't about how to make this work - it's "Why do the methods used in the code below produce the strange NA.123 rows?"</p>  <pre><code>library(foreign) # To open SAS xpt files  # Read in the data files testdata &lt;- read.xport('COT_D.xpt')  ################# cotpos1, everything set to 0 or 1 #################  testdata$cotpos1[testdata$LBXCOT &gt;= 10] &lt;- 1 # Positive cotinine test testdata$cotpos1[testdata$LBXCOT &lt; 10] &lt;- 0 # Negative cotinine test  testdata$cotpos1[testdata$cotpos1==1] # We have NAs that match ==1 testdata[testdata$cotpos1==1,c("SEQN","cotpos1")] # The bad NAs have no SEQN and their row numbers look like NA.988 testdata[is.na(testdata$cotpos1),c("SEQN","cotpos1")] # The good NAs (ones that are NA because LBXCOT was NA, and match is.na()) have SEQN and row numbers  ################# cotpos2, with initialization to 0 #################  testdata$cotpos2 &lt;- 0 # Assume everyone is negative until found otherwise testdata$cotpos2[testdata$LBXCOT &gt;= 10] &lt;- 1 # Positive cotinine test  # 3 tests to show we have no "bad NAs" at this point testdata$cotpos2[testdata$cotpos2==1] # No NAs that match ==1 testdata[testdata$cotpos2==1,c("SEQN","cotpos2")] # No lines with no SEQN values or strange row IDs like NA.988 testdata[is.na(testdata$cotpos2),c("SEQN","cotpos2")] # No good NAs either because we initialized everyone to 0  # Now let's try finding the "good NA"s and setting them to NA (since they were initialized to 0, which is not accurate if the blood test results were actually missing) testdata$cotpos2[is.na(testdata$LBXCOT)] &lt;- NA  # Re-run the three tests, and they now show the bad NAs are back as well testdata$cotpos2[testdata$cotpos2==1] # Now there are NAs that match ==1 testdata[testdata$cotpos2==1,c("SEQN","cotpos2")] # Now there are lines with NA SEQN values and strange row IDs like NA.988 testdata[is.na(testdata$cotpos2),c("SEQN","cotpos2")] # These are the "good NAs" only, the bad ones don't show up here </code></pre>  <p>There are other ways I can do this that don't produce "bad NAs", like using ifelse() or using a package that does recodes, so my question isn't about how to make this work - it's "Why do the methods used in the code above produce the strange NA.988 rows?"</p>  <p>Further information in response to BondedDust: Thank you for your reply. Can you please clarify which quirk of [] you are referring to?</p>  <p>I am aware of the quirk where if you feed it an NA, you get an all NA row, eg:</p>  <pre><code>b = testdata$cotpos1==1 b testdata[b,c("SEQN","cotpos1")] </code></pre>  <p>then anywhere b is NA I should expect the last line to return an NA. Is that the one you are referring to? Unfortunately, with my code, the problem is that the weird NA rows are showing up in places where b wasnâ€™t NA, so that quirk would not explain it.</p>  <p>Here are the last lines of b:</p>  <pre><code>[8725]  TRUE    NA FALSE FALSE    NA  TRUE FALSE FALSE FALSE FALSE FALSE    NA [8737] FALSE    NA FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE  TRUE [8749]  TRUE FALSE  TRUE FALSE FALSE </code></pre>  <p>Here are the last lines of testdata[b,c("SEQN","cotpos1")]:</p>  <pre><code>8711   41422       1 NA.986    NA      NA NA.987    NA      NA 8722   41437       1 8725   41440       1 NA.988    NA      NA NA.989    NA      NA 8730   41447       1 NA.990    NA      NA NA.991    NA      NA 8742   41461       1 8748   41468       1 8749   41469       1 8751   41472       1 </code></pre>  <p>The strange NAs are showing up in places where b was not NA</p>  <p>Final edit: BondedDust's reply was correct. When I was saying b and the strange NAs don't match up (above), I was failing to account for the fact that [] doesn't print rows corresponding to FALSE. Once you take the falses out, they match up perfectly.</p>