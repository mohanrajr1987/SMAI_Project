<p>The argument of a function is often a subset of a data.frame. Without going into the details of how the function works, it may be required a precise orientation of the vector so that x(1,3) would work, but x(3,1) would not.</p>  <p>Then the way the data.frame is subsetted matters. Given a simple data.frame:</p>  <pre><code>df1 &lt;-data.frame(X1=c(1,2,3), X2=c(10,20,30)) </code></pre>  <p>it can be subsetted to return either another data.frame:</p>  <pre><code>df1["X1"] df1[1] df1[,1,drop=F])  </code></pre>  <p>or a numeric vector:</p>  <pre><code>df1$X1 df1[,1] </code></pre>  <p>The problem is that the user can use any of the subsetting methods and I am wondering if I can write the function so that it is blind to the choice of the user (or if the only solution is to write a separate function that tests for the type of the variable, determines the dimensions and then rotates as appropriate)</p>  <p>~~~ EDIT ~~~</p>  <p>I don't particularly care if it is a vector or a list/data.frame, it is more a matter of orientation. In the simplest case I need to check that the variables have the same number of elements but length() fails if two different methods are used for subsetting:</p>  <pre><code>&gt; df1 &lt;-data.frame(X1=c(1,2,3), X2=c(10,20,30)) &gt; df2 &lt;-data.frame(Y1=c(4,5,6), Y2=c(40,50,60)) &gt; length(df1$X1) == length(df2["Y1"]) [1] FALSE </code></pre>  <p>and dim()/nrow()/ncol() do not work on numeric vectors.</p>