<p><strong>Current Functionality</strong> </p>  <p>I have a collection view where each cell is composed of an image and a label. It is a collection view within a view controller. Currently the view compiles and loads up fine from two arrays (one for image names, one for label names). When the user taps a cell, it brings them to a new view controller.</p>  <p><strong>Desired Functionality</strong></p>  <p>However, I would like to add the functionality that when the user returns to the collection view the cell they tapped is now 1st (top left position). This new order should be saved to core data and become the new default order. </p>  <p><strong>Progress to Date</strong></p>  <p>I've started the process of trying to implement this function, but getting the original arrays into CoreData is proving challenging. I can't get the original arrays into CoreData and the collectionView building from the CoreData fetch. The collection view builds but none of my images / labels are there, only some CoreData code loaded into my labels...</p>  <p>Here's what I've got in my viewDidLoad:</p>  <pre><code>    //Fetch &amp; sort the list from Core Data     let appDelegate = UIApplication.sharedApplication().delegate as! AppDelegate     let managedContext = appDelegate.managedObjectContext!     let fetchRequest = NSFetchRequest(entityName: "MenuItem_llcv")     let sortDescriptor = NSSortDescriptor(key: "displayOrder", ascending: true )     fetchRequest.sortDescriptors = [ sortDescriptor ]     var error: NSError?     let fetchedResults = managedContext.executeFetchRequest(fetchRequest, error: &amp;error) as? [NSManagedObject]      //Check fetch results     //If fetch was successful, the results are assigned to the context object     if let results = fetchedResults {         ll_ColViewOrder_Context = results         println("Fetch succesful, although possibly empty.")     } else {         println("Could not fetch \(error), \(error!.userInfo)")     }      //First-time user check     //If CoreData has the arrays, do nothing. If it doesn't, load them in.     if ll_ColViewOrder_Context.count &gt; 8 {         println("Fetch result: Previously stored list found in Core Data.")     } else {         //Set arrays to populate cells         cvListNames = ["Label 1", "Label 2", "Label 3", "Label 4", "Label 5"]          cvListImgs = ["image1","image2","image3","image4","image5"]          let entityVar =  NSEntityDescription.entityForName("MenuItem_llcv", inManagedObjectContext: managedContext)         let listItem = NSManagedObject(entity: entityVar!, insertIntoManagedObjectContext:managedContext)          var numberToStore = 1          for ea_Name in cvListNames {             listItem.setValue(ea_Name, forKey: "name")         }         for ea_ImgName in cvListImgs {             listItem.setValue(ea_ImgName, forKey: "imgName")         }         for ea_OrderNum in cvListImgs {             listItem.setValue(numberToStore, forKey: "displayOrder")             ++numberToStore         }         managedContext.save(nil)         println("Context now contains \(ll_ColViewOrder_Context)")     } </code></pre>  <p>Here's what my table is building from:</p>  <pre><code>func collectionView(collectionView: UICollectionView, cellForItemAtIndexPath indexPath: NSIndexPath) -&gt; UICollectionViewCell {      let cell = collectionView.dequeueReusableCellWithReuseIdentifier(reuseIdentifier, forIndexPath: indexPath) as! LifeList_CollectionViewCell      //Assign images     let image = UIImage(named: "\(ll_ColViewOrder_Context[indexPath.row])")     cell.cvCell_Image.image = image      //Assign list names     let title = "\(ll_ColViewOrder_Context[indexPath.row])"     cell.cvCell_Name.text = title </code></pre>