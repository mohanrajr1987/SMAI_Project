<p>Question...</p>  <p>I am trying to interpret this UML Diagram using Qt:  My concerns are how to define the QList class and how to implement the aggregation and composition relationships. I understand that inheritance is implemented by .... class derived : public base directive.</p>  <p><a href="http://i.stack.imgur.com/EbLrZ.jpg" rel="nofollow"><img src="http://i.stack.imgur.com/EbLrZ.jpg" alt="enter image description here"></a>  I have posted by attempt below. May anyone assist. Thanks</p>  <pre><code>#ifndef PRODUCT_H #define PRODUCT_H  #include &lt;Transaction.h&gt; #include &lt;QString&gt; #include &lt;QList&gt; #include &lt;QDate&gt; #include &lt;QDebug&gt;  //define product class class Product { public:   Product(QString name, int num, double seprice, double suprice, QString sc );   virtual void sell(int n);   void restock(int n);   QString getSupplierCode();   void setProductCode(QString c );   QString getProductCode();   QList&lt;Transaction*&gt;getTransactions();   QString toString();   void removeAll();   bool isExpired();  private:   QString m_Name;   int m_NumOfItems;   QString m_ProductCode;   double m_SellingPrice;   double m_SupplierPrice;   QString m_SupplierCode;   QList&lt;Transaction*&gt;m_Transactions;  }; //end of product class #endif //PRODUCT_H  #ifndef FOODPRODUCT_H #define FOODPRODUCT_H  //begining of FoodProduct class class FoodProduct : public Product { public:   FoodProduct(QString name, int num, double seprice, double suprice, QString sc, QDate sbd);   void sell(int n);   QString toString();   bool isExpired();  private:   QDate m_SellByDate;  }; //end of FoodProduct Class  #endif // FOODPRODUCT_H  #ifndef PRODUCTLIST_H #define PRODUCTLIST_H  //begining of ProductList Class class ProductList : public QList&lt;Product*&gt; { public:   QString add(QString name, int num, double seprice, double suprice, QString sc, QDate sbd );   void sell(QString pc, int n );   void restock(QString pc, int n );   QString toString();   void removeStock();   QString getTransactions(QString pc) const;  private:   int m_NextCode; }; //end of ProductList Class #endif //PRODUCTLIST_H  #include &lt;Product.h&gt; #ifndef TRANSACTION_H #define TRANSACTION_H  //begining of Transaction Class class Transaction { public:   Transaction(QString type, QDate date, int num, double price );   QString toString();  private:   QString m_Type;   QDate m_Date;   int m_NoOfItems;   double m_PricePerItem;  }; //end of Transaction class #endif // TRANSACTION_H  implementations  #include &lt;Product.h&gt;  Product::Product(QString name, int num, double seprice, double suprice, QString sc) {     m_Name = name;     m_NumOfItems = num;     m_SellingPrice = seprice;     m_SupplierPrice = suprice;     m_SupplierCode = sc; }  void Product::sell(int n) {   if(m_NumOfItems == 0)   {     qDebug() &lt;&lt; "Out of stock";   }   else     {         m_NumOfItems -= n;         m_Transaction.append(Transaction("Sale", QDate::currentDate(),n, m_SellingPrice));     } }  void Product::restock(int n) {     m_NumOfItems += n;     m_Transaction.append(Transaction("Purchase", QDate::currentDate(),n, m_SupplierPrice)); }  QString Product::getSupplierCode() {     return m_SupplierCode; }  void Product::setProductCode(QString c) {     m_ProductCode = c; }  QString Product::getProductCode() {     return m_ProductCode; }   QString Product::toString() {     return QString("Product Name: %1\nProduct Code: %2\nSupplier Price: %3\nSelling Price: %4\nSupplier Code: %5")                    .arg(m_Name).arg(m_ProductCode).arg(m_SupplierPrice).arg(m_SellingPrice).arg(m_SupplierCode); }  void Product::removeAll() {     m_NumOfItems = 0; }  -------------------------  #include &lt;Transaction.h&gt;   Transaction::Transaction(QString type, QDate date, int num, double price) {     m_Type = type;     m_Date = date;     m_NoOfItems = num;     m_PricePerItem = price; }  QString Transaction::toString() {    QString date1;    date1 = m_Date.toString();    return QString("Transaction Type: %1\nDate: %2\nNumber of Items: %3\nPrice: R%4\n")         .arg(m_Type).arg(date1).arg(m_NoOfItems).arg(m_PricePerItem*m_NoOfItems); }  --------------------------  FoodProduct::FoodProduct(QString name,int num, double seprice, double suprice, QString sc, Qdate sbd) {     FoodProduct = Product();     m_SellByDate = sbd; }  void FoodProduct::sell(int n) {     if (isExpired())         qDebug &lt;&lt; "Product has expired!";     else Product::sell(n); }  bool FoodProduct::isExpired() {     return(m_SellByDate &lt; QDate::currentDate()); }  QString FoodProduct::toString() {     Product::toString(); }   --------------------  #include ProductList.h  QString ProductList::add(QString name, int num, double seprice, double suprice, QString sc, QDate sbd) :int m_NextCode(1001); {      ProductList = Product();      m_SellByDate = sbd;      m_NextCode++;  }  ProductList::~ProductList() {  }  void ProductList:sell(Qstring pc, int n) {      foreach(Product* pc, ProductList)     {         ProductList::m_NumberOfItems -= n;      }      }  void ProductList:restock(Qstring pc, int n) {      foreach(Product* pc, ProductList)     {         ProductList::m_NumberOfItems += n;      }      }  void ProductList::removeStock() {      foreach(Product* pc, ProductList)     {         if (ProductList::isExpired())          ProductList::m_NumberOfItems = 0;      }   }  QString ProductList::toString() {      return QString("Product Name: %1\nProduct Code: %2\nNumber of Items: %3")         .arg(ProductList::m_Name).arg(ProductList::m_ProductCode).arg(ProductList::m_NumberofItems);  }  QString ProductList::getTransactions(QString pc) {  } </code></pre>