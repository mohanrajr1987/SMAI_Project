<p>I am not very familiar with exactly all of the implications of bytes or even close to charsets, simply because i have not used them often. However i am working on a project in which i need to convert every Java primitive type (and Strings) to AND from bytes. I want them all with the charset UTF-8, but i'm not sure if i am converting them properly. </p>  <p>Anyways, although i am pretty sure that all number to/from byte conversions are correct, but then again, i need to be 100% sure. If someone has really good experience with bytes with numbers and charsets, could you look over the class below, and point out any issues? </p>  <pre><code>import java.nio.ByteBuffer; import java.nio.charset.StandardCharsets;  public class ByteUtil {         //TO BYTES FROM PRIMITIVES &amp; STRINGS         public static byte[] getBytes(short i)         {                 return ByteBuffer.allocate(2).putInt(i).array();         }          public static byte[] getBytes(int i)         {                 return ByteBuffer.allocate(4).putInt(i).array();         }          public static byte[] getBytes(long i)         {                 return ByteBuffer.allocate(8).putLong(i).array();         }          public static byte getBytes(boolean i)         {                 return (byte) (i ? 1 : 0);         }          public static byte[] getBytes(char i)         {                 return getBytes(String.valueOf(i).trim());         }          public static byte[] getBytes(String i)         {                 return i.getBytes(StandardCharsets.UTF_8);         }          public static byte[] getBytes(float i)         {                 return getBytes(Float.floatToIntBits(i));         }          public static byte[] getBytes(double i)         {                 return getBytes(Double.doubleToLongBits(i));         }          //TO PRIMITIVES &amp; STRINGS FROM BYTES         public static short getShort(byte[] b)         {                 ByteBuffer wrapped = ByteBuffer.wrap(b);                 return wrapped.getShort();         }          public static int getInt(byte[] b)         {                 ByteBuffer wrapped = ByteBuffer.wrap(b);                 return wrapped.getInt();         }          public static long getLong(byte[] b)         {                 ByteBuffer wrapped = ByteBuffer.wrap(b);                 return wrapped.getLong();         }          public static boolean getBoolean(byte b)         {                 return(b == 1 ? true : false);         }          public static char getChar(byte[] b)         {                 return getString(b).trim().toCharArray()[0];         }          public static String getString(byte[] b)         {                 return new String(b, StandardCharsets.UTF_8);         }          public static float getFloat(byte[] b)         {                 return Float.intBitsToFloat(getInt(b));         }          public static double getDouble(byte[] b)         {                 return Double.longBitsToDouble(getLong(b));         } } </code></pre>  <p>Additionally, all the data put in and returned is read by my source internally, for example the boolean conversion may or may not be the correct way to do something like such, but in the boolean case, it wont matter since i know what i am checking for.</p>