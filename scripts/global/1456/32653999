<p>I'm implementing a system that uses <code>libcrafter</code> and <code>crypto++</code> to transmit specific frames on the network. But the problem I'm stuck with isn't at this level at all.</p>  <p>It's about conversion between types used in these libraries.</p>  <hr>  <h2>1) At the emission (solved)</h2>  <p>I'm trying to convert the <code>Crafter::byte array</code> to a  <code>std::string</code>, in order to put this message into a network frame (as an <em>initialization vector</em> for an AES encryption/decryption).</p>  <p>Moreover, the <code>iv</code> must be zeroed, and I can't initialize it properly (despite the answers <a href="http://stackoverflow.com/questions/2240405/byte-array-assignment">here</a> or <a href="http://forums.devshed.com/programming-42/initialize-byte-array-592458.html" rel="nofollow">there</a>).</p>  <p><strong>EDIT</strong> : to initialize it to 00, I had to do it <strong>in hexadecimal</strong> : 0x30. And to convert it to a <code>std::string</code> I had to provide the length ie ivLen2 (thanks for the answers).</p>  <p>Here's what I do :</p>  <pre><code>const int ivLen2 = 2; std::string encrypted_message("whatever");  Crafter::byte iv[ivLen2]={0x30, 0x30}; // crypto salt of 2 bytes at 0.  std::string ivStr( reinterpret_cast&lt; char const* &gt;(iv), ivLen2 ) ;  string mess2send = ivStr + encrypted_message; </code></pre>  <p>And if I display them, with this : </p>  <pre><code>cout&lt;&lt;"iv[0] : "&lt;&lt;iv[0]&lt;&lt;endl;            // display 0 cout&lt;&lt;"mess2send : "&lt;&lt;mess2send&lt;&lt;endl;    // display 00whatever </code></pre>  <p><em>Why don't I simply create a zeroed string and send it ?</em> In order to have generic functions, and a re-usable code.</p>  <hr>  <h2>2) At the reception (pending)</h2>  <p>Without surprises I have to do the opposite. I get a <code>iv</code> and the <code>message</code> concatenated within a <code>vector&lt;byte&gt;* payload</code>, and I have to extract the iv as a <code>byte array</code>, and the <code>message</code> within a string.</p>  <p>The <code>message</code> isn't actually the problem, given that <code>std::string</code> is close to <code>vector</code>.</p>  <p>Here's what I tempt to retrieve the <code>iv</code> : </p>  <pre><code>Crafter::byte iv[ ivLen2 ]; for (int i = 0; i &lt; ivLen2; i++) {     iv[i] = (byte)payload-&gt;at(i); } std::string iv_rcv( reinterpret_cast&lt; char const* &gt;(iv) ) ; </code></pre>  <p>And to display them, I do (in the same loop) : </p>  <pre><code>cout&lt;&lt;iv[i]; </code></pre>  <p>But it gives me a non-ASCII character.</p>  <p>I've also tried this (following <a href="http://stackoverflow.com/a/505047/3494633">this</a> and <a href="http://stackoverflow.com/a/347959/3494633">this</a> answers) :</p>  <pre><code>Crafter::byte* iv;  std::string iv_rcv( payload-&gt;begin(), payload-&gt;begin()+ivLen2 ) ; iv = (byte*)iv_rcv.c_str(); </code></pre>  <p>But it doesn't give me the <em>supposed</em> initialized values...</p>  <p>Does anybody have a clue ? Is my code wrong ?</p>