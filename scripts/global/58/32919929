<p>We have built an in memory database, which eats about 100-150G RAM in a single <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html" rel="nofollow">Vec</a>, which is populated like this:</p>  <pre><code>let mut result = Vec::with_capacity(a_very_large_number); while let Ok(n) = reader.read(&amp;mut buffer) {     result.push(...); } </code></pre>  <p><code>perf top</code> shows that the time is mostly spent in this "change_protection" function:</p>  <pre><code>Samples: 48K of event 'cpu-clock', Event count (approx.): 694742858  62.45%  [kernel]              [k] change_protection  18.18%  iron                  [.] database::Database::init::h63748   7.45%  [kernel]              [k] vm_normal_page   4.88%  libc-2.17.so          [.] __memcpy_ssse3_back   0.92%  [kernel]              [k] copy_user_enhanced_fast_string   0.52%  iron                  [.] memcpy@plt </code></pre>  <p>The CPU usage of this function grows as more and more data is loaded into RAM: </p>  <pre><code>  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND 12383 iron      20   0  137g  91g 1372 D 76.1 37.9  27:37.00 iron </code></pre>  <p>The code is running on an r3.8xlarge AWS EC2 instance, and transparent hugepage is already disabled.</p>  <pre><code>[~]$ cat /sys/kernel/mm/transparent_hugepage/defrag always madvise [never] [~]$ cat /sys/kernel/mm/transparent_hugepage/enabled always madvise [never] </code></pre>  <p>the real question is why is there so much overhead in that function? </p>