<p>I have <strong>a single application that loads dynamicaly the three following solutions</strong>:</p>  <pre><code> - SolutionA which references                  X.dll version 3                  Z.dll version 1 which references                                        X.dll version 1   - SolutionB which references                  X.dll version 2   - SolutionC which references                  X.dll version 1 </code></pre>  <p>.</p>  <p>X.dll contains some XAML (<em>depending on the DLL version I change the text, the background and the foreground</em>) :</p>  <pre><code>&lt;UserControl x:Class="X.MainWindow"              Background="DodgerBlue"&gt;     &lt;UserControl.Content&gt;         &lt;Label Foreground="Black" Content="version 1" /&gt;     &lt;/UserControl.Content&gt; &lt;/UserControl&gt; </code></pre>  <p>.</p>  <p>Z.dll also contains some XAML that uses X.dll :</p>  <pre><code>&lt;UserControl x:Class="Z.ZMainWindow"&gt;     &lt;StackPanel&gt;         &lt;X:MainWindow /&gt;     &lt;/StackPanel&gt; &lt;/UserControl&gt; </code></pre>  <p>.</p>  <p>SolutionA displays X version 3 and Z version 1 (which displays X version 1)</p>  <p>SolutionB displays X version 2</p>  <p>SolutionC displays X version 1</p>  <p>.</p>  <p>What I want is to <strong><em>always use the Higher version of the Assembly</em></strong>, which mean that SolutionA, SolutionB and SolutionC must <strong>always use X.dll</strong> in <strong><em>version 3</em></strong>.</p>  <p>Here is the code I use for AssemblyResolve:</p>  <pre><code>private static Assembly OnAssemblyResolveWithDllPaths(object sender, ResolveEventArgs args) {     try     {         AssemblyName parsedName = new AssemblyName(args.Name);         Version currentVersion = parsedName.Version;         string currentName = parsedName.Name;         string currentCulture = parsedName.CultureName;         byte[] currentPublicKeyToken = parsedName.GetPublicKeyToken();         string assemblyPath = string.Empty;          if (loadedAssemblies.FirstOrDefault(a =&gt; a == args.Name) != null)         {             // Assembly has already been loaded             return null;         }          List&lt;string&gt; possibleAssembliesPaths = m_dllPaths.Where(d =&gt; d.Contains(parsedName.Name)).ToList();          if (possibleAssembliesPaths != null &amp;&amp; possibleAssembliesPaths.Count &gt; 0)         {             if (possibleAssembliesPaths.Count == 1)             {                 assemblyPath = possibleAssembliesPaths[0];             }             else             {                 foreach (string possibleAssembly in possibleAssembliesPaths)                 {                     if (File.Exists(possibleAssembly))                     {                         AssemblyName possibleAssemblyName = AssemblyName.GetAssemblyName(possibleAssembly);                         Version possibleVersion = possibleAssemblyName.Version;                         string possibleName = possibleAssemblyName.Name;                         string possibleCulture = possibleAssemblyName.CultureName;                         byte[] possiblePublicKeyToken = possibleAssemblyName.GetPublicKeyToken();                          if (currentName == possibleName                              &amp;&amp; currentCulture == possibleCulture                              &amp;&amp; currentPublicKeyToken.SequenceEqual(possiblePublicKeyToken)                              &amp;&amp; currentVersion &lt; possibleVersion)                         {                             assemblyPath = possibleAssembly;                             currentVersion = possibleAssemblyName.Version;                             currentName = possibleAssemblyName.Name;                             currentCulture = possibleAssemblyName.CultureName;                             currentPublicKeyToken = possibleAssemblyName.GetPublicKeyToken();                         }                     }                 }             }              if (!string.IsNullOrEmpty(assemblyPath))             {                 loadedAssemblies.Add(args.Name);                 return Assembly.LoadFrom(assemblyPath);             }         }     }     catch     {         return null;     }      return null; } </code></pre>  <p>.</p>  <p>Everything works perfectly until in name my controls</p>  <p>i.e. (in Z.dll) : <code>&lt;Label Foreground="Black" Content="version 1" /&gt;</code> becomes <code>&lt;Label Foreground="Black" Content="version 1" x:Name="LabelV1" /&gt;</code></p>  <p>and (in X.dll) : <code>&lt;X:MainWindow x:Name="XMainWindow" /&gt;</code> becomes <code>&lt;X:MainWindow x:Name="XMainWindow" /&gt;</code></p>  <p>At this points, SolutionA has an exception and is not displayed when SolutionA is loaded before SolutionC (SolutionB is never a problem and as soon as SolutionC is loaded before SolutionA, everything works perfectly).</p>  <p>What I see, when I am attached to <code>AppDomain.CurrentDomain.AssemblyLoad += CurrentDomain_AssemblyLoad</code> is that the XAMLs automaticaly loads the Assembly they need :</p>  <pre><code>SolutionC's XAML loads X in version 1 SolutionA's XAML loads X in version 3 SolutionA's XAML loads Z in version 1 </code></pre>  <p>Then I see the following exception in the xaml.cs:</p>  <pre><code>An exception of type 'System.Exception' occurred in PresentationFramework.dll but was not handled in user code Additional information: The component 'X.MainWindow' does not have a resource identified by the URI '/X;component/mainwindow.xaml'. </code></pre>  <p>and the following one in the xaml:</p>  <pre><code>Exception thrown: 'System.Windows.Markup.XamlParseException' in PresentationFramework.dll Additional information: 'The invocation of the constructor on type 'X.MainWindow' that matches the specified binding constraints threw an exception.' Line number '10' and line position '10'. </code></pre>  <p>.</p>  <p><strong>Do you have leads to avoid the issue ?</strong></p>