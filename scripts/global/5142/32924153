<p>I couldn't reproduce this scenario on a brand new application, thus I'm tagging this <a href="/questions/tagged/bukkit" class="post-tag" title="show questions tagged &#39;bukkit&#39;" rel="tag">bukkit</a>.</p>  <p>I'm building a simple command framework against Spigot latest version (updated yesterday). You can register a global or player-only command. Obviously, commands can't be both global and player-only, thus I want to throw an exception in that case, i.e. if the client (me!) tries to register a command that has already been registered.</p>  <p>The following pieces of code are in the same package.</p>  <pre><code>@Override public void onEnable() {     CommandSystem commandSystem = new CommandSystem(this);     commandSystem.registerCommand("config", new Config());     commandSystem.registerCommand("config", new Config()); } </code></pre>    <pre><code>public class CommandSystem implements CommandExecutor {     private JavaPlugin plugin;     public CommandSystem(JavaPlugin plugin) {         this.plugin = plugin;     }     private Map&lt;Command, PlayerCommand&gt; playerCommands = new HashMap&lt;&gt;();     public void registerCommand(String name, PlayerCommand executor) {         Command command = registerCommand(name);         // 3 (see below)         System.out.println("This prints. But it shouldn't.");         playerCommands.put(command, executor);     }     private Map&lt;Command, GlobalCommand&gt; globalCommands = new HashMap&lt;&gt;();     public void registerCommand(String name, GlobalCommand executor) {         Command command = registerCommand(name);         System.out.println("This could print. But it shouldn't.");         globalCommands.put(command, executor);     }     private Command registerCommand(String name) {         PluginCommand command = plugin.getCommand(name);         if (command.getExecutor() == this) { // I'm using == because it must be exactly this instance             // 1 (see below)             throw new CommandAlreadyRegisteredException("The '" + name + "' command has been already registered");         }         // 2 (see below)         System.out.println("How can this print too? Shouldn't an exception block code execution?");         command.setExecutor(this);         return command;     }     @Override     public boolean onCommand(CommandSender sender, Command command, String alias, String[] args) {         if (playerCommands.containsKey(command)) {             if (sender instanceof Player) {                 PlayerCommand executor = playerCommands.get(command);                 executor.run((Player)sender, args);             } else {                 sender.sendMessage("You must be a player.");             }         } else {             GlobalCommand executor = globalCommands.get(command);             executor.run(sender, args);         }         return true;     } } </code></pre>    <pre><code>public class CommandAlreadyRegisteredException extends RuntimeException {     private static final long serialVersionUID = 1L;     protected CommandAlreadyRegisteredException(String message) {         super(message);     } } </code></pre>    <pre><code>public interface GlobalCommand {     void run(CommandSender sender, String[] args); } </code></pre>    <pre><code>public interface PlayerCommand {     void run(Player sender, String[] args); } </code></pre>    <pre><code>public class Config implements PlayerCommand {     @Override     public void run(Player sender, String[] args) {         // This shouldn't matter, because it's still empty     } } </code></pre>  <p><strong>EDIT #1</strong></p>  <p>While answering <a href="http://stackoverflow.com/questions/32924153/custom-unchecked-exception-doesnt-block-code-execution#comment53675448_32924337">zulkarnain's comment</a>, I noticed a strange behavior. I've added some indexes in the code above. I think they should be executed in order. Why were they executed like this? 2, 3, 1</p>