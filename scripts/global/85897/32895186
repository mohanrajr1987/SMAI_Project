<p>I have an object:</p>  <pre><code>public class Eoi {      // Generated by database     public Guid Id { get; set; }      // Not 'virtual', want to force eager loading     public IList&lt;Document&gt; Docs { get; set; } } </code></pre>  <p>This object has a 1:1 relationship with a Person:</p>  <pre><code>public class Person {      // Generated by database     public Guid Id { get; set; }      // Not virtual, want to force eager loading     public Eoi MyEoi { get; set; } } </code></pre>  <p>Document is defined as :</p>  <pre><code>public class Document {      // Generated by database     public Guid Id { get; set; }      public string FileName { get; set; } // ... and other simple string properties, stripped for brevity } </code></pre>  <p>Whenever I load a <code>Person</code> and update their <code>Person.MyEoi</code>, and call <code>Context.SaveChangesAsync()</code> in EF6, the <code>Id</code>s of the <code>Documents</code> get replaced, and the Entity Framework Profiler shows that the old Documents get deleted, new ones get generated and saved that are <strong>IDENTICAL</strong>, WITH THE EXCEPTION OF THE <code>Id</code>. Does anybody know why Entity Framework 6 does this or how to stop it ?</p>  <p>UPDATE: The code that does this (paraphrased for brevity, all relevant parts included):</p>  <pre><code>Expression&lt;Func&lt;Person, bool&gt;&gt; expression = p =&gt; p.Id == someId; Expression&lt;Func&lt;TData, object&gt;&gt;[] fields = { p =&gt; p.MyEoi, p =&gt; p.MyEoi.Documents };  IQueryable&lt;TData&gt; queryable = this.EntitySet.Where(expression);  IQueryable&lt;TData&gt; aggregate = fields.Aggregate(queryable, (total, current) =&gt; total.Include(current));  Person person = aggregate.ToList().AsEnumerable().Single();  // ASP.NET MVC Controller bit: this.TryUpdateModel(person.MyEoi, null, null, "Id,Documents".Split(','));  person.ModifiedAt = DateTimeOffset.Now; person.Modifier = modifier;  // SOME OTHER SNIPPETS THAT MODIFY THE person.MyEoi field  await this.Context.SaveChangesAsync(); </code></pre>