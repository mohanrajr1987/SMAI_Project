<p>I'm trying to integrate my API, using EF6, with MySQL. I've installed the package MySql.Data.Entity (version 6.9.7).</p>  <p>Initially, I used Sql Server, so my mapping for date fields used the type DateTimeOffSet. But, when using MySql, I had troubles with that type, so I changed it to DateTime. The migration runs successfully, creates the database in MySql, but in the end of the log shows an error:</p>  <pre><code>PM&gt; Update-Database -StartUpProjectName WMoney.WebApi -Verbose Using StartUp project 'WMoney.WebApi'. Using NuGet project 'WMoney.Persistence.EntityFramework'. Specify the '-Verbose' flag to view the SQL statements being applied to the target database. Target database is: 'wmoney' (DataSource: localhost, Provider: MySql.Data.MySqlClient, Origin: Configuration). No pending explicit migrations. System.ArgumentException: The underlying provider does not support the type 'datetimeoffset'.    at MySql.Data.MySqlClient.MySqlProviderManifest.GetEdmType(TypeUsage storeType)    at System.Data.Entity.Migrations.Infrastructure.EdmModelDiffer.BuildColumnModel(EdmProperty property, ModelMetadata modelMetadata, IDictionary`2 annotations)    at System.Data.Entity.Migrations.Infrastructure.EdmModelDiffer.BuildAlterColumnOperation(String table, EdmProperty targetProperty, ModelMetadata targetModelMetadata, EdmProperty sourceProperty, ModelMetadata sourceModelMetadata)    at System.Data.Entity.Migrations.Infrastructure.EdmModelDiffer.&lt;FindAlteredColumns&gt;b__24a(&lt;&gt;f__AnonymousType2c`2 &lt;&gt;h__TransparentIdentifier242)    at System.Linq.Enumerable.WhereSelectEnumerableIterator`2.MoveNext()    at System.Collections.Generic.List`1..ctor(IEnumerable`1 collection)    at System.Linq.Enumerable.ToList[TSource](IEnumerable`1 source)    at System.Data.Entity.Migrations.Infrastructure.EdmModelDiffer.Diff(ModelMetadata source, ModelMetadata target, Lazy`1 modificationCommandTreeGenerator, MigrationSqlGenerator migrationSqlGenerator, String sourceModelVersion, String targetModelVersion)    at System.Data.Entity.Migrations.Infrastructure.EdmModelDiffer.Diff(XDocument sourceModel, XDocument targetModel, Lazy`1 modificationCommandTreeGenerator, MigrationSqlGenerator migrationSqlGenerator, String sourceModelVersion, String targetModelVersion)    at System.Data.Entity.Migrations.DbMigrator.IsModelOutOfDate(XDocument model, DbMigration lastMigration)    at System.Data.Entity.Migrations.DbMigrator.Upgrade(IEnumerable`1 pendingMigrations, String targetMigrationId, String lastMigrationId)    at System.Data.Entity.Migrations.Infrastructure.MigratorLoggingDecorator.Upgrade(IEnumerable`1 pendingMigrations, String targetMigrationId, String lastMigrationId)    at System.Data.Entity.Migrations.DbMigrator.UpdateInternal(String targetMigration)    at System.Data.Entity.Migrations.DbMigrator.&lt;&gt;c__DisplayClassc.&lt;Update&gt;b__b()    at System.Data.Entity.Migrations.DbMigrator.EnsureDatabaseExists(Action mustSucceedToKeepDatabase)    at System.Data.Entity.Migrations.Infrastructure.MigratorBase.EnsureDatabaseExists(Action mustSucceedToKeepDatabase)    at System.Data.Entity.Migrations.DbMigrator.Update(String targetMigration)    at System.Data.Entity.Migrations.Infrastructure.MigratorBase.Update(String targetMigration)    at System.Data.Entity.Migrations.Design.ToolingFacade.UpdateRunner.Run()    at System.AppDomain.DoCallBack(CrossAppDomainDelegate callBackDelegate)    at System.AppDomain.DoCallBack(CrossAppDomainDelegate callBackDelegate)    at System.Data.Entity.Migrations.Design.ToolingFacade.Run(BaseRunner runner)    at System.Data.Entity.Migrations.Design.ToolingFacade.Update(String targetMigration, Boolean force)    at System.Data.Entity.Migrations.UpdateDatabaseCommand.&lt;&gt;c__DisplayClass2.&lt;.ctor&gt;b__0()    at System.Data.Entity.Migrations.MigrationsDomainCommand.Execute(Action command) The underlying provider does not support the type 'datetimeoffset'. </code></pre>  <p>Besides the error, the database is created, and I can run my Api. But, when trying to make a query on DB the same error occurs: "The underlying provider does not support the type 'datetimeoffset'."</p>  <p>I already changed all references to DateTimeOffSet from my code, but the error still happenning.</p>  <p>Does anyone have any idea what can I do to solve this problem?</p>  <p>Thanks</p>  <p>UPDATE: As requested by DevilSuichiro, I'm adding more informations:</p>  <pre><code>MY CONTEXT CLASS:  namespace WMoney.Persistence.EntityFramework {     [DbConfigurationType(typeof(MySql.Data.Entity.MySqlEFConfiguration))]     public class WMoneyContext : DbContext, IWMoneyContext     {         public WMoneyContext()             : base("WMoneyConnectionString")             {              }          public IUserRepository UserRepository         {              get { return new UserRepository(this); }         }          public DbSet&lt;Account&gt; Accounts { get; set; }         public DbSet&lt;Category&gt; Categories { get; set; }         public DbSet&lt;Transaction&gt; Transactions { get; set; }         public DbSet&lt;TransactionType&gt; TransactionTypes { get; set; }         public DbSet&lt;User&gt; Users { get; set; }          protected override void OnModelCreating(DbModelBuilder modelBuilder)         {             //base.OnModelCreating(modelBuilder);              modelBuilder.Entity&lt;Account&gt;()                 .HasKey(a =&gt; a.AccountId)                 .Map(a =&gt; a.ToTable("TbAccount", "dbo"));              modelBuilder.Entity&lt;Account&gt;()                 .HasRequired(a =&gt; a.User)                 .WithMany(a =&gt; a.Accounts)                 .HasForeignKey(a =&gt; a.UserId)                 .WillCascadeOnDelete(false);              modelBuilder.Entity&lt;Category&gt;()                 .HasKey(a =&gt; a.CategoryId)                 .Map(a =&gt; a.ToTable("TbCategory", "dbo"));              modelBuilder.Entity&lt;Category&gt;()                 .HasRequired(a =&gt; a.User)                 .WithMany(a =&gt; a.Categories)                 .HasForeignKey(a =&gt; a.UserId)                 .WillCascadeOnDelete(false);              modelBuilder.Entity&lt;Transaction&gt;()                 .HasKey(a =&gt; a.TransactionId)                 .Map(a =&gt; a.ToTable("TbTransaction", "dbo"));              modelBuilder.Entity&lt;Transaction&gt;()                 .HasRequired(a =&gt; a.Account)                 .WithMany(a =&gt; a.Transactions)                 .HasForeignKey(a =&gt; a.AccountId)                 .WillCascadeOnDelete(false);              modelBuilder.Entity&lt;Transaction&gt;()                 .HasRequired(a =&gt; a.Category)                 .WithMany(a =&gt; a.Transactions)                 .HasForeignKey(a =&gt; a.CategoryId)                 .WillCascadeOnDelete(false);              modelBuilder.Entity&lt;Transaction&gt;()                 .HasRequired(a =&gt; a.TransactionType)                 .WithMany(a =&gt; a.Transactions)                 .HasForeignKey(a =&gt; a.TransactionTypeId)                 .WillCascadeOnDelete(false);              modelBuilder.Entity&lt;TransactionType&gt;()                 .HasKey(a =&gt; a.TransactionTypeId)                 .Map(a =&gt; a.ToTable("TbTransactionType", "dbo"));              modelBuilder.Entity&lt;User&gt;()                 .HasKey(a =&gt; a.UserId)                 .Map(a =&gt; a.ToTable("TbUser", "dbo"));         }        } } </code></pre>  <p>MY TRANSACTION CLASS (The only with date fields)</p>  <pre><code>namespace WMoney.Persistence.Model {     public class Transaction     {         public int TransactionId { get; set; }          public int TransactionTypeId { get; set; }          public DateTime Created { get; set; }          public DateTime Date { get; set; }          public int CategoryId { get; set; }          public int AccountId { get; set; }          public decimal Value { get; set; }          [StringLength(200)]         public string Description { get; set; }          public virtual TransactionType TransactionType { get; set; }          public virtual Category Category { get; set; }          public virtual Account Account { get; set; }     } } </code></pre>  <p>MY CLASS WHO CALLS THE DATABASE The error happens already in the line: var existentUser = await _userRepository.AsQueryable().GetByEmail(email);</p>  <pre><code>namespace WMoney.Core {     public class UserCore : IUserCore     {         public IUserRepository _userRepository;          public UserCore(IWMoneyContext wMoneyContext)         {             _userRepository = wMoneyContext.UserRepository;         }          public async Task&lt;User&gt; CreateUserAsync(string email, string password)         {             var existentUser = await _userRepository.AsQueryable().GetByEmail(email);              if (existentUser != null)             {                 throw new DuplicateWaitObjectException();             }              var user = new User              {                  Email = email,                 Password = password             };              await _userRepository.AddAsync(user, true);              return user;         }          public async Task&lt;bool&gt; CheckUserAsync(string email, string password)         {             var user = await _userRepository.AsQueryable().GetByEmail(email);              if (user != null)             {                 if (user.Password == password)                 {                     return true;                 }                 else                 {                     return false;                 }             }             else             {                 throw new ArgumentException(string.Format("There's no user with email '{0}'", email));             }         }     } } </code></pre>