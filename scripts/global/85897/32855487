<p>Let's say I have two classes in my model: <code>Product</code> and <code>Category</code>.</p>  <pre><code>public class Product {     public Product() {         this.Categories = new HashSet&lt;Category&gt;();     }      [...]      public virtual ICollection&lt;Category&gt; Categories { get; set; } }  public class Category {     public Category() {         this.Products = new HashSet&lt;Product&gt;();     }      [...]      public virtual ICollection&lt;Product&gt; Products { get; set; } } </code></pre>  <p>A product has many categories and a categories apply to many products. To model this relationship I have the following code in my <code>OnModelCreating</code> method:</p>  <pre><code>    modelBuilder.Entity&lt;Product&gt;()         .HasMany( p =&gt; p.Categories )         .WithMany( p =&gt; p.Products )         .Map( m =&gt; {             m.MapLeftKey( "ProductID" );             m.MapRightKey( "CategoryID" );             m.ToTable( "CategoriesPerProduct" );         } );     modelBuilder.Entity&lt;Category&gt;()         .HasMany( p =&gt; p.Products )         .WithMany( p =&gt; p.Categories )         .Map( m =&gt; {             m.MapLeftKey( "CategoryID" );             m.MapRightKey( "ProductID" );             m.ToTable( "CategoriesPerProduct" );         } ); </code></pre>  <p>This create a new table, <code>CategoriesPerProduct</code>, which splits the M-N relationship in two 1-N relationships which is good for my needs.</p>  <p>I have now the requirement to update categories related to a product and, just to simplify my code, I did decided to remove all the existing categories and then adding back the new ones like in the following sample:</p>  <pre><code>ICollection&lt;Category&gt; productCategories = product.Categories; //First remove all existing categories  foreach ( var category in productCategories ) {     product.Categories.Remove( category ); } // ..then add the new ones from input foreach ( string categoryName in categories ) {     Category c = await _ctx.Categories.SingleOrDefaultAsync( p =&gt; p.Description == categoryName );     if ( c != null ) {         product.Categories.Add( pc );     }     else {         c = new ProductCategory() { Description = categoryName };         _ctx.Categories.Add( c );         await _ctx.SaveChangesAsync();         product.Categories.Add( c );     } } await _ctx.SaveChangesAsync(); </code></pre>  <p>Unfortunately, when the code hits the transaction <code>Commit()</code> method I get the following error:</p>  <blockquote>   <p>The relationship could not be changed because one or more of the   foreign-key properties is non-nullable. When a change is made to a   relationship, the related foreign-key property is set to a null value.   If the foreign-key does not support null values, a new relationship   must be defined, the foreign-key property must be assigned another   non-null value, or the unrelated object must be deleted.</p> </blockquote>  <p>Could anybody drive me in the right direction to solve this error?</p>