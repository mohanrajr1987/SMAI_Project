<p>The title says it... What is the correct/recommended way of adding proper CORS support to Restlet 2.3 that implements a <code>ChallengeAuthenticator</code> to allow Pre-flight options to access header info without Authorization header? </p>  <p>Originally I thought I could add the <code>@Options</code> annotation to resource interface:</p>  <pre><code>@Options void getCorsSupport(); </code></pre>  <p>and then implement it with something like this:</p>  <pre><code>@Override public void getCorsSupport() {         Series&lt;Header&gt; headers = getResponse().getHeaders();         headers.set("Access-Control-Expose-Headers", "Authorization, Link, X-RateLimit-Limit, X-RateLimit-Remaining, X-OAuth-Scopes, X-Accepted-OAuth-Scopes");          Set&lt;String&gt; head = new HashSet&lt;&gt;();         head.add("Authorization");         head.add("Content-Type");         head.add("X-Requested-With");         getResponse().setAccessControlAllowHeaders(head);          Set&lt;Method&gt; methods = new HashSet&lt;&gt;();         methods.add(Method.ALL);          getResponse().setAccessControlAllowMethods(methods);         getResponse().setAccessControlAllowCredentials(true);         Series&lt;Header&gt; reqHeaders = getRequest().getHeaders();         String requestOrigin = reqHeaders.getFirstValue("Origin", false, "*");         getResponse().setAccessControlAllowOrigin(requestOrigin);     } </code></pre>  <p>What I expected to happen was that the ajax pre-flight <code>Options</code> request would be exempt the <code>ChallengeAuthenticator</code> and the above headers would be returned. Sadly this is not the case and the ajax pre-flight <code>Options</code> request is subjected to the <code>ChallengeAuthenticator</code> like everything else. This means that the request fails because it hasn't been granted its required <code>Access-Control-Allow-Origin</code> header.</p>  <p>Then I did some research and found it appears to be possible to register a <code>CorsService</code> with the application.</p>  <pre><code>public class WebApi extends Application {      public WebApi() {         getServices().add(createCorsService());     }     ...        private CorsService createCorsService() {          CorsService corsService = new CorsService();          corsService.setAllowedOrigins(new HashSet(Arrays.asList("*")));         corsService.setAllowedCredentials(true);          corsService.setAllowedCredentials(true);         corsService.setAllowingAllRequestedHeaders(true);          Set&lt;String&gt; allowHeaders = new HashSet&lt;&gt;();         allowHeaders.add("Authorization");         allowHeaders.add("Content-Type");         allowHeaders.add("X-Requested-With");         corsService.setAllowedHeaders(allowHeaders);          Set&lt;String&gt; exposeHeaders = new HashSet&lt;&gt;();         exposeHeaders.add("Authorization");         exposeHeaders.add("Link");         exposeHeaders.add("X-RateLimit-Limit");         exposeHeaders.add("X-RateLimit-Remaining");         exposeHeaders.add("X-OAuth-Scopes");         exposeHeaders.add("X-Accepted-OAuth-Scopes");         corsService.setExposedHeaders(exposeHeaders);          return corsService;     } } </code></pre>  <p>I thought this might be a clean way to avoid having an <code>@Options</code> method for every service. However, I must be doing something wrong as this appears to do nothing at all.</p>  <p>Researching still further I found that there is also such a thing as a <code>CorsFilter</code> which seems to be instantiated in much the same way as the <code>CorsService</code> except this gets attached to the <code>Router</code> in the <code>createInboundRoot()</code> method. However I don't understand how it should be implemented to work in conjunction with the <code>ChallengeAuthenticator</code>.</p>  <p><strong>Addendum:</strong></p>  <ul> <li>I found <a href="https://github.com/adennie/vroom/blob/master/vroom-core/src/main/java/com/fizzbuzz/vroom/core/api/filter/CorsFilter.java" rel="nofollow">this</a> in the code suggesting that pre-flight should be handled.</li> </ul>