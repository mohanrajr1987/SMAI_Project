<p>I'm developing a mobile app where users can take photos with the device's camera and upload. I have a script running that transfers the captured image to my server, where I have a php script that automatically resizes the image.</p>  <p>The script works great to resize the images, however photos taken on my iPhone are automatically rotated sideways when the script is run. After doing some research, I found that this is due to extra information stored in the photo and can be fixed using another script I found on stackoverflow.</p>  <p>My new problem is this: The script I found at the link above is working to rotate my image, however it looks like it's still keeping the resized orientation but rotating the image inside that frame and leaving black space to fill the extra space. To clarify, see the samples below:</p>  <p><a href="http://www.xylo-app.com/sample_original.png" rel="nofollow">Original Photo</a><br> <a href="http://www.xylo-app.com/sample_resized.png" rel="nofollow">Resized</a></p>  <p>I have very little experience with php so I'm sure I'm probably just missing something simple. Here's the code I'm using:</p>  <pre><code>list($w_orig, $h_orig) = getimagesize($target); $scale_ratio = $w_orig / $h_orig; if (($w / $h) &gt; $scale_ratio) {        $w = $h * $scale_ratio; } else {        $h = $w / $scale_ratio; } $img = ""; $ext = strtolower($ext); if ($ext == "gif"){    $img = imagecreatefromgif($target); } else if($ext =="png"){    $img = imagecreatefrompng($target); } else {    $img = imagecreatefromjpeg($target); $exif = exif_read_data($target); if ($img &amp;&amp; $exif &amp;&amp; isset($exif['Orientation'])) {     $ort = $exif['Orientation'];      if ($ort == 6 || $ort == 5)         $img = imagerotate($img, 270, null);     if ($ort == 3 || $ort == 4)         $img = imagerotate($img, 180, null);     if ($ort == 8 || $ort == 7)         $img = imagerotate($img, 90, null);      if ($ort == 5 || $ort == 4 || $ort == 7)         imageflip($img, IMG_FLIP_HORIZONTAL); } } $tci = imagecreatetruecolor($w, $h); // imagecopyresampled(dst_img, src_img, dst_x, dst_y, src_x, src_y, dst_w, dst_h, src_w, src_h) imagecopyresampled($tci, $img, 0, 0, 0, 0, $w, $h, $w_orig, $h_orig); imagejpeg($tci, $newcopy, 80); </code></pre>  <p>Any help with this would be great. Thanks in advance.</p>