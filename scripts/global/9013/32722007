<p><strong>Executive Summary</strong></p>  <p>Is it standard behavior that shells skip over NUL bytes when doing process substitution?</p>  <p>For example, executing</p>  <pre><code>printf '\0abc' | read value &amp;&amp; echo $value </code></pre>  <p>will yield <code>abc</code>. The NUL value is skipped, even though the hexdump of the <code>printf</code> output shows it's clearly being output.</p>  <p>My first thought was "<em>word splitting</em>". However, when using an actual process substitution</p>  <pre><code>value=$(printf '\0abc') </code></pre>  <p>the results are similar and <code>=</code> does not perform word splitting.</p>  <p><strong>Long Story</strong></p>  <p>While searching for the proper answer for <a href="https://stackoverflow.com/questions/32700112/why-is-data-missing-when-i-write-to-a-python-subprocess-stdin-pipe">this question</a>, I realized that at least three of the shell implementation (ash, zsh, and bash) I am reasonably familiar with will <em>ignore</em> a NUL character when reading the value from process substitution into a variable.</p>  <p>The exact point in the pipeline when this happens seems to be different, but the result is consistently that a NUL byte gets dropped as if it was never there in the first place.</p>  <p>I have checked with some of the implementations, and well, this seems to be <em>normal</em> behavior.</p>  <p><strong><code>ash</code></strong> will <a href="https://svnweb.freebsd.org/base/stable/10/bin/sh/expand.c?revision=287752&amp;view=markup#l462" rel="nofollow">skip over <code>'\0'</code> on input</a>, but it is not clear from the code if this is pure coincidence or intended behavior:</p>  <pre><code>if (lastc != '\0') {     [...] } </code></pre>  <p>The <code>bash</code> source code contains an <a href="http://git.savannah.gnu.org/cgit/bash.git/tree/subst.c#n5267" rel="nofollow">explicit, albeit <code>#ifdef</code>'d warning</a> telling us that it skipped a NUL value on process substitution:</p>  <pre><code>#if 0       internal_warning ("read_comsub: ignored null byte in input"); #endif </code></pre>  <p>I'm not so sure about <code>zsh</code>'s behaviour. It recognizes <code>'\0'</code>as a meta character (as defined by the internal <code>imeta()</code> function) and prepends a special <code>Meta</code> surrogate character and sets bit #5 on the input character, essentially <em>unmetaing</em> it, which makes also makes <code>'\0'</code> into a space <code>' '</code>)</p>  <pre><code>if (imeta(c)) {     *ptr++ = Meta;     c ^= 32;     cnt++; } </code></pre>  <p>This seems to get stripped later because there is no evidence that <code>value</code> in the above <code>printf</code> command contains a meta character. Take this with a large helping of salt, since I'm not to familiar with <code>zsh</code>'s internals. Also note the side effect free statements.</p>  <p>Note that <code>zsh</code> also allows you to include NUL (meta-escaped) in <code>IFS</code> (making it possible to e.g. word-split <code>find -print0</code> without <code>xargs -0</code>). Thus <code>printf '\0abc' | read value</code> and <code>value=$(printf '\0abc')</code> should yield different results depending on the value of <code>IFS</code> (<code>read</code> does field splitting).</p>