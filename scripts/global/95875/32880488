<p>In my project, I have to current Maven modules setup: </p>  <pre><code>- Application  |- (application code, using Spring Boot 1.2.6)  - E2E-testing (has a dependency to Application) |- src     |- main         |- java             |- AbstractCucumberTest.java </code></pre>  <p>Before, this used to be a Spring 3 application serving JSP pages, so no Boot included. I refactored it to be a Boot application. </p>  <p>The E2E testing setup basically built a WAR file of the application code, and the E2E module booted a Jetty server, running that WAR. All was well.  Now, after the refactor, not so much. </p>  <p>The Jetty setup no longer works as-is. When I boot the WAR, I'm getting class loading exceptions, which are related to Jetty itself. Now, I'm not hung up on Jetty, it's just a testing container for me. So I started digging around in the Boot documentation, because I was convinced there had to be a way to make it all "Boot'-iful, meaning: I could simply boot the application when launching the tests. And there is, of course, so I ended up with these annotations on my AbstractCucumberTest: </p>  <pre><code>@RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(classes = ApplicationConfig.class, loader = SpringApplicationContextLoader.class) @WebIntegrationTest({"spring.profiles.active=local"}) public abstract class AbstractCucumberTest extends SeleniumTest { </code></pre>  <p>So, basically, I'm loading the application config of the application, and launching the Tomcat server from the test. And all rejoiced, because now the application was successfully booting upon launching a Cucumber test. The application boots, it reads the classpath, Liquibase boots, everything is working alright. I can call the Actuator endpoints, which all work fine. Even the REST endpoints of the application are all working, so Spring MVC is doing its thing. </p>  <p>However, 1 thing is not, and that's serving JSP's -- and that's of course a deal breaker for E2E tests. Every time I surf to a page, I get the same unnerving 404 error. Before you ask: yes, <strong>tomcat-embed-jasper</strong> and <strong>jstl</strong> are present. They are present in the application, I even added them to the E2E pom, no luck. In fact, these are the things I tried, but they all failed: </p>  <ul> <li><p>Excluding the tomcat-embed-jasper and jstl dependency from the application</p></li> <li><p>Copying over the JSP's from the application to the resources of the E2E module</p></li> <li><p>Setting up my own CucumberConfig, which basically contained the same configuration as the ApplicationConfig</p></li> </ul>  <p>It just seems to me that the application cannot find the JSP's. Everything else is working just fine, just the JSP's are not found/served. </p>  <p>Does anyone have any thoughts?</p>  <p>Oh, on a side note, I tried using the spring-boot-maven-plugin, to try and boot the application that way. Problem is, though, that it cannot be forked. In the 1.2.6 release, the fork simply ... does not fork. When I say fork, I mean it in the Jetty way: it boots the application, and gives control back to Maven. It instantiates a "stop" command, which Maven can call after all tests have run.  In the <a href="http://docs.spring.io/spring-boot/docs/current-SNAPSHOT/maven-plugin/examples/it-random-port.html" rel="nofollow">1.3.0.BUILD-SNAPSHOT version</a>, it should be present (using the start goal), but that's still not working for me. </p>  <p><strong>[EDIT]</strong> For what it's worth, the Application module is configured to build a WAR file. So it's <em>not</em> JAR packaging.</p>