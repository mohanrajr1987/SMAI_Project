<p>I am using Spring to achieve the following:</p>  <p>On a server, I receive data via a REST interface in an XML-Format. I want to transform the data into JSON and POST it to another Server. My code (I removed some sensitive classnames/URLs to avoid the wrath of my employer) looks like this:</p>  <p>Main/Configuration class:</p>  <pre><code>package stateservice;  import org.apache.http.HttpHost; import org.apache.http.client.config.RequestConfig; import org.apache.http.impl.client.HttpClientBuilder; import org.apache.http.impl.conn.PoolingHttpClientConnectionManager; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.context.annotation.Bean; import org.springframework.http.client.HttpComponentsClientHttpRequestFactory; import org.springframework.web.client.RestTemplate;  @SpringBootApplication public class App {     Logger log = LoggerFactory.getLogger(App.class);      public static void main(String[] args) {         System.out.println("Start!");         SpringApplication.run(StateServiceApplication.class, args);         System.out.println("End!");     }      @Bean     public RestTemplate restTemplate() {         log.trace("restTemplate()");         HttpHost proxy = new HttpHost("proxy_url", 8080);         PoolingHttpClientConnectionManager cm = new PoolingHttpClientConnectionManager();         // Increase max total connection to 200         cm.setMaxTotal(200);         cm.setDefaultMaxPerRoute(50);          RequestConfig requestConfig = RequestConfig.custom().setProxy(proxy).build();          HttpClientBuilder httpClientBuilder = HttpClientBuilder.create();         httpClientBuilder.setDefaultRequestConfig(requestConfig);         httpClientBuilder.setConnectionManager(cm);         HttpComponentsClientHttpRequestFactory requestFactory = new HttpComponentsClientHttpRequestFactory(                 httpClientBuilder.build());         return new RestTemplate(requestFactory);     } } </code></pre>  <p>The class representing the RESTful interface:</p>  <pre><code>package stateservice;  import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.RequestBody; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; import org.springframework.web.bind.annotation.RestController;  import foo.bar.XmlData  @RestController public class StateController {      private static Logger log = LoggerFactory.getLogger(DataController.class);      @Autowired     ForwarderService forwarder;       @RequestMapping(value = "/data", method = RequestMethod.POST)     public String postState(@RequestBody XmlData data) {         forwarder.forward(data);         return "Done!";     } } </code></pre>  <p>Finally, the Forwarder:</p>  <pre><code>package stateservice;  import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.http.HttpEntity; import org.springframework.http.HttpHeaders; import org.springframework.http.MediaType; import org.springframework.http.ResponseEntity; import org.springframework.scheduling.annotation.Async; import org.springframework.stereotype.Service; import org.springframework.web.client.RestTemplate;  import foo.bar.Converter; import foo.bar.XmlData;  @Service public class ForwarderService {     private static Logger log = LoggerFactory.getLogger(ForwarderService.class);      String uri = "forward_uri";      @Autowired     RestTemplate restTemplate;      @Async     public String forward(XmlData data) {         log.trace("forward(...) - start");         String json = Converter.convert(data);         HttpHeaders headers = new HttpHeaders();         headers.setContentType(MediaType.APPLICATION_JSON);          ResponseEntity&lt;String&gt; response = restTemplate.postForEntity(uri,                 new HttpEntity&lt;String&gt;(json, headers), String.class);         // responseEntity.getBody();         // log.trace(responseEntity.toString());         log.trace("forward(...) - end");         return response.getBody();     } } </code></pre>  <p>However, the Connection Manager seldomly seems to release connections for reuse, and additionally, the system gets flooded with connections in the CLOSE_WAIT state (which can be seen using netstat). All connections in the pool get leased, but not released, and as soon as the number of connections in the CLOSE_WAIT state reaches the ulimit, I get 'Too many open files'-exceptions</p>  <p>Because of the multithreaded nature of the code, I suspect that sockets cannot be closed/connections be released, because some other thread is somhow blocking them.</p>  <p>I would really appreciate any help or any hint you can give me to solve the problem.</p>