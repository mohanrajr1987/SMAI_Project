<p>Earlier our hosted environments were on Oracle but now we have recently switched to postgres. Porting the tables I believe was successfully since it has been working correct for a long time. I have been actually struggling with porting a procedure but is not working for some reason. I went through the documentation part of the ora2pg but I am not able to crack, which I believe is the last piece of the puzzle.</p>  <p>I've started with this one, which looks like this in Oracle:</p>  <pre><code>    create or replace     procedure c_audit(anonymous in boolean, aud_level IN varchar)     AUTHID CURRENT_USER IS         script varchar2(32000);       acc_select varchar(100);       open_cursor integer;       returnval integer;       p_id integer;       a_id integer;       p_name varchar2(100);       a_name varchar2(100);       v_count integer;       c_count integer;       doc_count integer;       curr_user varchar(100);     begin      for i in (select a.a_name a_name, a.a_id, p.name p_name, p.id p_id, ds.username username     from cb_account a     inner join c_pro p on a.a_id = p.a_id     inner join c_dat_ds_xref x on p.id = x.p_id     inner join c_data ds on x.id_datasource = ds.id     inner join c_conntypes ct on x.id_conntype = ct.id_conntype     where ct.typeid = 'CAPTURE'     order by a.a_name, p.name)     LOOP         curr_user := i.username;         IF anonymous = true         THEN             acc_select := 'select ' || '''' || i.a_id || '''' || ' a_id,' || '''' || i.p_id || '''' || ' p_id';          ELSE             acc_select := 'select ' || '''' || i.a_name || '''' || ' a_name,' || '''' || i.p_name || '''' || ' p_name';         END IF;          IF upper(aud_level) = 'VERBATIM'         THEN                        script:= acc_select || '             , count(distinct d.document_id) docCount              , sum(case when v.document_id is null or v.verbatim_type_value = ''NO_VERBATIM_TEXT'' then 0 else 1 end) VerbCount              , sum(case when v.document_id is null then (select to_number(prop_value) verbSize                                              from c_properties                                              where prop_name = ''METERING.STRUCT.ONLY.CHARGE''                                              and id_pro = 0) else v.credits end) CreditCount              from ' || i.username || '.p_document d              left outer join (                              select vi.document_id, t.verbatim_type_value                              , case when dbms_lob.substr(vi.extracted_original,8) = ''&lt;cbnull&gt;''                               or t.verbatim_type_value = ''NO_VERBATIM_TEXT''                                             then coalesce(s2.strucCredit, .25)                                                                         else ceil(vi.extracted_original_size/coalesce(s.verbSize, 2048)) end credits                                                       from ' || i.username || '.p_verbatim vi                              left outer join ' || i.username || '.pd_verbatim_type t on vi.verbatim_type_id = t.verbatim_type_id                             , (                                              select to_number(prop_value) verbSize                                              from c_properties                                              where prop_name = ''METERING.MAXSIZE.VERBATIM''                                              and id_pro = 0                              ) s                              , (                                              select to_number(prop_value) strucCredit                                              from c_properties                                              where prop_name = ''METERING.STRUCT.ONLY.CHARGE''                                              and id_pro = 0                              ) s2              ) v on d.document_id = v.document_id';         ELSE                 IF upper(aud_level) = 'DOCUMENT'             THEN                 script:= acc_select || '                 , count(distinct a.document_id) docCount                 , sum(credits) creditCount                 from (                 select d.document_id, ceil(sum(v.extracted_original_size)/coalesce(s.verbSize,2048)) credits                 from ' || i.username || '.p_document d                 inner join ' || i.username || '.p_verbatim v on d.document_id = v.document_id                 inner join ' || i.username || '.pd_verbatim_type t on v.verbatim_type_id = t.verbatim_type_id                 , (                                  select to_number(prop_value) verbSize                                  from c_properties                                  where prop_name = ''METERING.MAXSIZE.VERBATIM''                                  and id_pro = 0                  ) s                  where t.verbatim_type_value &lt;&gt; ''NO_VERBATIM_TEXT''                 and dbms_lob.substr(v.extracted_original,8) &lt;&gt; ''&lt;cbnull&gt;''                 group by d.document_id, s.verbSize                 union                 select d.document_id, coalesce(s2.strucCredit, .25)                 from ' || i.username || '.p_document d                 , (                                  select to_number(prop_value) strucCredit                                  from c_properties                                  where prop_name = ''METERING.STRUCT.ONLY.CHARGE''                                  and id_pro = 0                  ) s2                  where d.document_id not in (select distinct v.document_id from ' || i.username || '.p_verbatim v)                 union                  select distinct d.document_id, coalesce(s2.strucCredit, .25)                 from ' || i.username || '.p_document d                 inner join ' || i.username || '.p_verbatim v on d.document_id = v.document_id                 inner join ' || i.username || '.pd_verbatim_type t on v.verbatim_type_id = t.verbatim_type_id                 , (                                  select to_number(prop_value) strucCredit                                  from c_properties                                  where prop_name = ''METERING.STRUCT.ONLY.CHARGE''                                  and id_pro = 0                  ) s2                  where (t.verbatim_type_value = ''NO_VERBATIM_TEXT''                 or dbms_lob.substr(v.extracted_original,8) = ''&lt;cbnull&gt;'')                 ) a';                 ELSE                     dbms_output.put_line('Invalid choice for audit level, no audit generated');                     exit;                 END IF;         END IF;     begin      open_cursor := dbms_sql.open_cursor;             DBMS_SQL.PARSE(open_cursor, script,                        DBMS_SQL.NATIVE);             IF anonymous = true then                 dbms_sql.define_column(open_cursor,1,a_id);                 dbms_sql.define_column(open_cursor,2,p_id);             else                 dbms_sql.define_column(open_cursor,1,a_name,100);                 dbms_sql.define_column(open_cursor,2,p_name,100);             end if;             dbms_sql.define_column(open_cursor,3,doc_count);             dbms_sql.define_column(open_cursor,4,v_count);             IF upper(aud_level) = 'VERBATIM' then                 dbms_sql.define_column(open_cursor,5,c_count);             end if;             returnval := DBMS_SQL.EXECUTE(open_cursor);             loop                 if dbms_sql.fetch_rows(open_cursor) &gt; 0 then                     IF anonymous = true then                         dbms_sql.column_value(open_cursor,1,a_id);                         dbms_sql.column_value(open_cursor,2,p_id);                         dbms_sql.column_value(open_cursor,3,doc_count);                         dbms_sql.column_value(open_cursor,4,v_count);                         IF upper(aud_level) = 'VERBATIM' then                             dbms_sql.column_value(open_cursor,5,c_count);                             dbms_output.put_line(a_id || ',' || p_id || ',' || doc_count || ',' || v_count || ',' || c_count);                         else                             dbms_output.put_line(a_id || ',' || p_id || ',' || doc_count || ',' || v_count);                         end if;                     else                         dbms_sql.column_value(open_cursor,1,a_name);                         dbms_sql.column_value(open_cursor,2,p_name);                         dbms_sql.column_value(open_cursor,3,doc_count);                         dbms_sql.column_value(open_cursor,4,v_count);                         IF upper(aud_level) = 'VERBATIM' then                             dbms_sql.column_value(open_cursor,5,c_count);                             dbms_output.put_line(a_name || ',' || p_name || ',' || doc_count || ',' || v_count || ',' || c_count);                         else                             dbms_output.put_line(a_name || ',' || p_name || ',' || doc_count || ',' || v_count);                         end if;                     end if;                 else                     exit;                 end if;             end loop;              exception                  when others then                 --dbms_output.put_line('Error occured. Please check if the current user has Select access to table ' || curr_user || '.p_document ' || curr_user || '.p_verbatim ' || curr_user || '.pd_verbatim_type');           dbms_output.put_line('Error occured. Please login as ' || curr_user || ' and run the following:');           dbms_output.put_line('GRANT SELECT ON ' || curr_user || '.P_DOCUMENT to ' || user ||';');           dbms_output.put_line('GRANT SELECT ON ' || curr_user || '.P_VERBATIM to ' || user ||';');           dbms_output.put_line('GRANT SELECT ON ' || curr_user || '.pd_verbatim_type to ' || user ||';');     end;      end loop;     end; </code></pre>  <p>Does this procedure appears correct with respect to syntax?</p>  <pre><code>    CREATE OR REPLACE FUNCTION c_audit(         anonymous boolean,         aud_level text)       RETURNS void AS     $BODY$     DECLARE       script text;       acc_select text;       returnval integer;       p_id integer;       a_id integer;       i record;       p_name text;       a_name text;       v_count integer;       c_count integer;       doc_count integer;       curr_user text;     BEGIN     for i in (SELECT a.a_name a_name, a.a_id, p.name p_name, p.id p_id, ds.username username     from cb_account a     inner join c_pro p on a.a_id = p.a_id     inner join c_dat_ds_xref x on p.id = x.p_id     inner join c_data ds on x.id_datasource = ds.id     inner join c_conntypes ct on x.id_conntype = ct.id_conntype     where ct.typeid = 'CAPTURE'     order by a.a_name, p.name)     LOOP         curr_user := i.username;         IF anonymous = true         THEN             acc_select := 'PERFORM ' || '''' || i.a_id || '''' || ' a_id,' || '''' || i.p_id || '''' || ' p_id';         ELSE             acc_select := 'PERFORM ' || '''' || i.a_name || '''' || ' a_name,' || '''' || i.p_name || '''' || ' p_name';         END IF;         IF upper(aud_level) = 'VERBATIM'         THEN                        script:= acc_select || '             , count(distinct d.document_id) docCount              , sum(case when coalesce(v.document_id::text, '') = '' or v.verbatim_type_value = ''NO_VERBATIM_TEXT'' then 0 else 1 end) VerbCount              , sum(case when coalesce(v.document_id::text, '') = '' then (SELECT to_number(prop_value,''9999.99'') verbSize                                              from c_properties                                              where prop_name = ''METERING.STRUCT.ONLY.CHARGE''                                              and id_pro = 0) else v.credits end) CreditCount              from ' || i.username || '.p_document d              left outer join (                              SELECT vi.document_id, t.verbatim_type_value                              , case when dbms_lob.substring(vi.extracted_original from 8) = ''&lt;cbnull&gt;''                               or t.verbatim_type_value = ''NO_VERBATIM_TEXT''                                             then coalesce(s2.strucCredit, .25)                                                                         else ceil(vi.extracted_original_size/coalesce(s.verbSize, 2048)) end credits                                                       from ' || i.username || '.p_verbatim vi                              left outer join ' || i.username || '.pd_verbatim_type t on vi.verbatim_type_id = t.verbatim_type_id                             , (                                              select to_number(prop_value,''9999.99'') verbSize                                              from c_properties                                              where prop_name = ''METERING.MAXSIZE.VERBATIM''                                              and id_pro = 0                              ) s                              , (                                              select to_number(prop_value,''9999.99'') strucCredit                                              from c_properties                                              where prop_name = ''METERING.STRUCT.ONLY.CHARGE''                                              and id_pro = 0                              ) s2              ) v on d.document_id = v.document_id';         ELSE                 IF upper(aud_level) = 'DOCUMENT'             THEN                 script:= acc_select || '                 , count(distinct a.document_id) docCount                 , sum(credits) creditCount                 from (                 SELECT d.document_id, ceil(sum(v.extracted_original_size)/coalesce(s.verbSize,2048)) credits                 from ' || i.username || '.p_document d                 inner join ' || i.username || '.p_verbatim v on d.document_id = v.document_id                 inner join ' || i.username || '.pd_verbatim_type t on v.verbatim_type_id = t.verbatim_type_id                 , (                                  SELECT to_number(prop_value,''9999.99'') verbSize                                  from c_properties                                  where prop_name = ''METERING.MAXSIZE.VERBATIM''                                  and id_pro = 0                  ) s                  where t.verbatim_type_value &lt;&gt; ''NO_VERBATIM_TEXT''                 and dbms_lob.substring(v.extracted_original from 8) &lt;&gt; ''&lt;cbnull&gt;''                 group by d.document_id, s.verbSize                 union                 select d.document_id, coalesce(s2.strucCredit, .25)                 from ' || i.username || '.p_document d                 , (                                  select to_number(prop_value,''9999.99'') strucCredit                                  from c_properties                                  where prop_name = ''METERING.STRUCT.ONLY.CHARGE''                                  and id_pro = 0                  ) s2                  where d.document_id not in (select distinct v.document_id from ' || i.username || '.p_verbatim v)                 union                  select distinct d.document_id, coalesce(s2.strucCredit, .25)                 from ' || i.username || '.p_document d                 inner join ' || i.username || '.p_verbatim v on d.document_id = v.document_id                 inner join ' || i.username || '.pd_verbatim_type t on v.verbatim_type_id = t.verbatim_type_id                 , (                                  select to_number(prop_value,''9999.99'') strucCredit                                  from c_properties                                  where prop_name = ''METERING.STRUCT.ONLY.CHARGE''                                  and id_pro = 0                  ) s2                  where (t.verbatim_type_value = ''NO_VERBATIM_TEXT''                 or dbms_lob.substring(v.extracted_original from 8) = ''&lt;cbnull&gt;'')                 ) a';                 ELSE                     RAISE NOTICE 'Invalid choice for audit level, no audit generated';                     exit;                 END IF;         END IF;     BEGIN         IF anonymous = true then             EXECUTE script into a_id, p_id, doc_count, v_count;         else             EXECUTE script into a_name, p_name, doc_count, v_count;         end if;         IF upper(aud_level) = 'VERBATIM' then             EXECUTE script into a_name, p_name, doc_count, v_count, c_count;         end if;         GET DIAGNOSTICS returnval := ROW_COUNT;             loop                 if returnval &gt; 0 then                     IF anonymous = true then                         IF upper(aud_level) = 'VERBATIM' then                             RAISE NOTICE '%%%%%%%%%', a_id ,  ',' ,  p_id ,  ',' ,  doc_count ,  ',' ,  v_count ,  ',' ,  c_count;                         else                             RAISE NOTICE '%%%%%%%', a_id ,  ',' ,  p_id ,  ',' ,  doc_count ,  ',' ,  v_count;                         end if;                     else                         IF upper(aud_level) = 'VERBATIM' then                             RAISE NOTICE '%%%%%%%%%', a_name ,  ',' ,  p_name ,  ',' ,  doc_count ,  ',' ,  v_count ,  ',' ,  c_count;                         else                             RAISE NOTICE '%%%%%%%', a_name ,  ',' ,  p_name ,  ',' ,  doc_count ,  ',' ,  v_count;                         end if;                     end if;                  else                     exit;                 end if;             end loop;             EXCEPTION                 WHEN others THEN           RAISE NOTICE '%%%', 'Error occured. Please login as ' ,  curr_user ,  ' and run the following:';           RAISE NOTICE '%%%%;', 'GRANT PERFORM ON ' ,  curr_user ,  '.P_DOCUMENT to ' ,  user ;           RAISE NOTICE '%%%%;', 'GRANT PERFORM ON ' ,  curr_user ,  '.P_VERBATIM to ' ,  user ;           RAISE NOTICE '%%%%;', 'GRANT PERFORM ON ' ,  curr_user ,  '.pd_verbatim_type to ' ,  user ;     END;     end loop;     end;     $BODY$       LANGUAGE plpgsql VOLATILE       COST 100;     ALTER FUNCTION c_audit(boolean, text)       OWNER TO CURRENT_USER; </code></pre>  <p>The error for failure I get is -</p>  <p>ERROR: too many parameters specified for RAISE Where: PL/pgSQL function "cb_audit" line 145 at RAISE</p>  <p>I found this to be a good link which I used as a <a href="http://www.postgresmigrations.com/database-migration/stored-procedure-tool/exhibit-4-dbms-sql-example" rel="nofollow">reference</a></p>  <p>I believe that for porting DBMS_OUTPUT.PUT_LINE, RAISE NOTICE should be the right way. I had encountered another error which was for format of the - to_number(prop_value,'9999.99') which appears right as per the syntax mentioned <a href="http://www.postgresql.org/docs/8.3/static/functions-formatting.html" rel="nofollow">here</a> but then for some reason when I switched to to_number(prop_value,''9999.99''), I did not get the error but not sure why that should be or even if it should work correctly.</p>  <p>The version of Postgres -</p>  <p>PostgreSQL 9.1.10 on x86_64-unknown-linux-gnu, compiled by gcc (GCC) 4.4.7 20120313 (Red Hat 4.4.7-3), 64-bit</p>