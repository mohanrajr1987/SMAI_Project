<p>This are simplified models to demonstrate my problem:</p>  <pre><code>class User(models.Model):     username = models.CharField(max_length=30)     total_readers = models.IntegerField(default=0)  class Book(models.Model):     author = models.ForeignKey(User)     title = models.CharField(max_length=100)  class Reader(models.Model):     user = models.ForeignKey(User)     book = models.ForeignKey(Book) </code></pre>  <p>So, we have <code>Users</code>, <code>Books</code> and <code>Readers</code> (<code>Users</code>, who have read a <code>Book</code>). Thus, <code>Reader</code> is basically a many-to-many relationship between <code>Book</code> and <code>User</code>.</p>  <p>Now let's say, the current user reads a book. Now, I'd like to update the number of total readers for <em>all</em> books of this book's author:</p>  <pre><code># get the book (as an example pk=1) book = Book.objects.get(pk=1)  # save Reader object for this user and this book Reader(user=request.user, book=book).save()  # count and save the total number of readers for this author in all his books book.author.total_readers = Reader.objects.filter(book__author=book.author).count() book.author.save() </code></pre>  <p>By doing so, Django creates a <code>LEFT OUTER JOIN</code> query for PostgreSQL and we get the expected result. However, the database tables are huge and this has become a bottleneck.</p>  <p>In this example, we could simply increase the <code>total_readers</code> by one on each view, instead of actually counting the database rows. However, this is just a simplified model structure and we cannot do this in reality here.</p>  <p>What I can do, is creating another field in the Reader model called <code>book_author_id</code>. Thus, I denormalize data and can count the Reader objects without having PostgreSQL making the <code>LEFT OUTER JOIN</code> with the User table. Finally, here's my question: Is it possible to create some sort of database index, so that PostgreSQL handles this denormalization automatically? Or do I really have to create this additional model field and redundantly store the author's PK in there?</p>  <p>EDIT - to point out the essential question: I got several great answers, which work for a lot of scenarios. However, they don't solve this actual problem. The only thing I'd like to know, is if it's possible to have PostgreSQL handle such a denormalization automatically - e.g. by creating some sort of database index.</p>