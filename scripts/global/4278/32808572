<p>Consider following program:</p>  <pre><code>#include &lt;iostream&gt; struct __attribute__((__packed__)) mystruct_A {    char a;    int b;    char c; }x; int main() {     std::cout&lt;&lt;sizeof(x)&lt;&lt;'\n'; } </code></pre>  <p>From <a href="http://stackoverflow.com/questions/4306186/structure-padding-and-structure-packing">this</a> I understood following:</p>  <ul> <li>Structure packing suppresses structure padding, padding used when alignment matters most, packing used when space matters most.</li> <li>Structure Packing, on the other hand prevents compiler from doing padding</li> </ul>  <p>I am on 32 bit environment &amp; using Windows 7 OS. The 1st answer of linked question says that above code would produce structure of size 6 on a 32-bit architecture.</p>  <p>But when I compiled it using g++ 4.8.1 it gives me 9 as an output. So, is packing not happenning completely here?  Why extra 3 bytes are there in output? sizeof char is always 1. Sizeof int is 4 on my compiler. So, sizeof above struct should be 1+4+1=6 when structure is packed. </p>  <p>I tried it on <a href="http://ideone.com/rLN8t1" rel="nofollow">here</a>. It gives me expected output 6. </p>  <p>Is there any role of processor or it depends only on Compiler?</p>