<p>With help of great guys here, now I can do Minimize with symbolic math</p>  <pre><code>import numpy as np from scipy.optimize import minimize from sympy.utilities.lambdify import lambdify import sympy as sy  sy.init_printing()  # LaTeX like pretty printing for IPython   x1, x2, x3, x4 = sy.symbols('x1 x2 x3 x4') xx = (x1, x2, x3, x4) f = -2*x1**2*x3+6*x1**2*x4+13*x1**2-3*x1*x2**2+x1*x2+3*x1*x3**2-3*x4+103 f_n = lambdify(xx, f, modules='numpy')  # Build Jacobian: jac_f = [f.diff(x) for x in xx] jac_fn = [lambdify(xx, jf, modules='numpy') for jf in jac_f]   def f_v(zz):     return f_n(zz[0], zz[1], zz[2], zz[3])  def jac_v(zz):     return np.array([jfn(zz[0], zz[1], zz[2], zz[3]) for jfn in jac_fn])  bnds = ((-1, 1), (-1, 1), (-1, 1), (-1, 1)) zz0 = np.array([1, 1, 1, 1])  rslts = minimize(f_v, zz0, method='SLSQP', jac=jac_v, bounds=bnds) print(rslts) </code></pre>  <p>But If I add constraints with symbolic parameter to limit minimization result, It gives me extra errors.</p>  <pre><code>C_ToKeep = [] C_ToKeep.append(2*x1**2*x3-6*x1**2*x4-13*x1**2+3*x1*x2**2                -x1*x2-3*x1*x3**2+3*x4-103) C_ToKeep.append(2*x2**2*x3-6*x1**2*x4-13*x1**2+3*x1*x2**2                -x1*x2-3*x1*x3**2+3*x4-103)  LambdaConstToKeep = [] for i in range(len(C_ToKeep)):     LambdaConstToKeep.append(lamdify(xx, C_ToKeep[i], modules='numpy')   rslts = minimize(f_v, zz0, method='SLSQP', jac=jac_v,                   bounds=bnds, constraints= LambdaConstToKeep) print(rslts) </code></pre>  <p>Are there any sample for Symbolic minimize with constraints?</p>