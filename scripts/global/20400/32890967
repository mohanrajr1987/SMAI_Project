<p>I am asking this question because I am not quite sure which filter I should be using. </p>  <p>Mine is simply a signal made up of discrete values as such <code>s = [1 2 2 2 3 4 2 4 3 4 5 3 2 3 3]</code>. Then I would like, per window size, a filtered signal. So e.g. if I use a window size of 5 for <code>s</code> then I would get; <code>s_filtered = [2 2 2 2 2 4 4 4 4 4 3 3 3 3 3]</code>. Hence I want to keep the values that are of the highest frequency in each block. For indices 0:4 (window size 5) the values of highest frequency is 2, so I want my "filtered" signal (if that is indeed the correct terminology) to have 2 in all indices 0:4 for the "filtered" signal.</p>  <p>Currently I am using just a median filter, but I do no think this is the correct approach. </p>  <p>Here is some python code to demonstrate what I am doing (but as said, which I think is wrong).</p>  <pre><code>import numpy as np import pylab * from scipy.signal import medfilt  test = np.random.randint(10, size=1000)  fig, ax1 = plt.subplots(1,sharey=True, sharex=True, figsize=(15,5)) ax1.plot(test) ax1.plot(medfilt(test,[99]),'r') plt.show() </code></pre>  <p><a href="http://i.stack.imgur.com/9Nd0N.png" rel="nofollow"><img src="http://i.stack.imgur.com/9Nd0N.png" alt="Random data with median filtered signal in red."></a></p>  <p>Where the red line is the filtered signal for a window size of 99.</p>  <p><strong>SOLUTION:</strong></p>  <pre><code>import itertools import collections  def grouper(iterable, n, fillvalue=None):     args = [iter(iterable)] * n     return itertools.izip_longest(*args, fillvalue=fillvalue)  s = [1, 2, 2, 2, 3, 4, 2, 4, 3, 4, 5, 3, 2, 3, 3]  list(chain.from_iterable(repeat(collections.Counter(x).most_common(1)[0][0],5) for x in grouper(s,5))) </code></pre>