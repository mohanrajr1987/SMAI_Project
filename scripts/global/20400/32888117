<p>I'm trying to use scipy.optimize.linprog and it's not working for me in a simple case.  I must be doing something wrong -- help me out to find it please.</p>  <p>Here are the inputs and the expected solution and a test that the expected solution is feasible</p>  <pre><code>import numpy, scipy.optimize print "A", A_ub print "b", b_ub print "c", c print "x_expected", x_expected print "expected optimum", numpy.dot(c, x_expected) print "feasibility test", numpy.dot(A_ub, x_expected) &lt;= b_ub </code></pre>  <p>This prints</p>  <pre><code>A [[-1. -0.  0.  1.]    [-0. -1.  1.  1.]    [-1. -0. -0. -1.]    [-0. -1. -1. -1.]] b [ 2.  1. -2. -1.] c [ 1.  1.  0.  0.] x_expected [ 0  0 -1  2] expected optimum 0.0 feasibility test [ True  True  True  True] </code></pre>  <p>When I call linprog I get a feasible solution, but it seems to not be as optimal as the one I expected above.</p>  <pre><code>r = scipy.optimize.linprog(c, A_ub, b_ub) x_derived = r.x print "x_derived", x_derived print "derived optimum", numpy.dot(c, x_derived) print "derived feasibility", numpy.dot(A_ub, x_derived) &lt;= b_ub </code></pre>  <p>This prints</p>  <pre><code>x_derived [ 1.  0.  0.  1.] derived optimum 1.0 derived feasibility [ True  True  True  True] </code></pre>  <p>Is there something wrong in my reasoning that I should be getting the expected solution (or a better one if there is one) instead of the one I get?  If I'm not wrong, how do I make linprog get it for me?  Thanks!</p>