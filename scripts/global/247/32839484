<p>I am trying to write a program that will execute a function based on a string I fetch from a database. Basically what I do is:</p>  <pre><code>// Create an enum enum AFunc{  invalidFunction,  function2,  function3 }  // have a class handling the functions struct A {   static AFunc resolveStringToFunction(std::string) {...}    template&lt;int T&gt;   void execute(...)   {      // this may not be called = invalidFunction   }    template&lt;&gt;   void execute&lt;1&gt; (...)   {       // do stuff = function1   }    template&lt;&gt;   void execute&lt;2&gt; (...)   {       // do stuff = function2   } }; </code></pre>  <p>In my application i do this:</p>  <pre><code>A a; std::string funcString = getFromDatabase (...) // Not really, but this is abstract const AFunc funcType   = A::resolveStringToFunction(funcString);  a.execute&lt;funcType&gt;(...); </code></pre>  <p>The problem here is that the compiler does not accept the dynamic calling of a template function, because (as I understood it) it needs to know which function is called by compile time.</p>  <p><strong>Is there any way around this?</strong></p>  <p><strong>Is there a better solution to this problem? Maybe a design pattern?</strong></p>