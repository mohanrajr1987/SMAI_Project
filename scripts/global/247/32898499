<p>Is there anyway to do something like this:</p>  <pre><code>Type type = new TypeToken&lt;MyHappyClass&gt;(){}.getType(); List&lt;type&gt; = new LinkedList&lt;type&gt;(); </code></pre>  <p>thanks in advance</p>  <p>========================================================================</p>  <p>I'll try to explain better what I need, hope I'm not doing anything ridiculous</p>  <p>I'm using restTemplate.getForObject to get data from a webservice. However they use a custom MediaType, therefore I am implementing a CustomMessageConverter to restTemplate understand that MediaType and convert it to my data object.</p>  <p>The problem is that this data object use generics. All objects returned from this webservice have some common fields and some specific, so, to map this and not repeat the code I created a GeneralItem and each resource extends from Item. </p>  <p>So, my MessageConverter is created this way:</p>  <pre><code>public class MyMessageConverter&lt;T extends Item&gt; extends AbstractHttpMessageConverter&lt;T&gt; </code></pre>  <p>And my readInternal goes like this:</p>  <pre><code>@Override protected T readInternal(Class&lt;? extends T&gt; clazz, HttpInputMessage inputMessage)     throws IOException, HttpMessageNotReadableException {    InputStream istream = inputMessage.getBody();    String responseString = IOUtils.toString(istream);    Type type = new TypeToken&lt;GeneralItem&lt;?&gt;&gt;(){}.getType();   GeneralItem&lt;?&gt; resource = new Gson().fromJson(responseString, type);    return (T) resource.getItem(); } </code></pre>  <p>But that doesnt work because I need the clazz type instead of the wildcard (*) for gson to parse it. Am I going the wrong way?</p>