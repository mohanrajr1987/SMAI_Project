<p>I tried to implement the following function maintaining Scala's invariant view over the JVM arrays:</p>  <pre class="lang-scala prettyprint-override"><code>def cast[T](a: Any): Option[Array[T]] = ??? </code></pre>  <p>That is, given:</p>  <pre class="lang-scala prettyprint-override"><code>class Foo class Bar extends Foo </code></pre>  <p>I want the following examples to return <code>Some</code>:</p>  <pre class="lang-scala prettyprint-override"><code>val arr1: Any = Array(new Bar) cast[Bar](arr1) // OK  val arr2: Any = Array(1, 2, 3) cast[Int](arr2) // OK  val arr3: Any = Array("a", "b", "c") cast[String](arr3) // OK </code></pre>  <p>For the following one, instead, I want it to return None:</p>  <pre class="lang-scala prettyprint-override"><code>val arr: Any = Array(new Bar) cast[Foo](arr1) // I want it to be None  val arr2: Any = Array(List(new Bar)) cast[List[Foo]](arr2) // this must be None too! </code></pre>  <p>I tried through reflection using <code>ClassTag/TypeTag</code> with no luck, but since I'm no reflection expert I could be missing something.</p>  <p>P.S.: I know that having <code>Any</code> there, is a bad practice but, please, try to see the question <em>academically</em>. You know, just to find out if there's a way to do it and how to.</p>  <p><strong>Update</strong>: The solution provided below still does not work for <code>Array(List(new Bar))</code> because of type erasure.</p>