<p>I want to convert video file using <code>FFMPEG</code> at server side which is long running process. I decided to send <code>AJAX</code> request to server so conversion process should run parallel. But my controller is serving single request at a time due to this its taking long time to complete the task. I have investigated issue and I came to know that <code>SessionState</code> make's controller execution serialized. <a href="http://stackoverflow.com/questions/4428413/why-would-multiple-simultaneous-ajax-calls-to-the-same-asp-net-mvc-action-cause">Here</a> explained same issue in more details. I want to disable <code>SessionState</code> behaviour in <code>MVC 2</code>. <br/></p>  <pre><code>[SessionState(SessionStateBehavior.Disabled)]  </code></pre>  <p>This is added in <code>MVC 3+</code>. How to achieve same with <code>MVC 2</code> </p>  <p>I have simple <code>Controller Action</code> where I am calling <code>CovertFile</code> method wich convert the file using <code>FFMPEG</code>, Below is reference code </p>  <pre><code>    [HttpPost]     public ActionResult PostRecordedAudioVideoTemp()     {           string outFile = ConvertFile(audioFileName, videoFileName, output, logFileConversion);          return Json(new { fileName = Request.Form[0], uploaded = true, type = fileType });     } </code></pre>  <hr>  <p>UPDATE : <br/></p>  <p>To confirm about controller is really serialized, I run flollowing test : <br/></p>  <pre><code>    AudioVideoController     {           public ActionResult Ajax()         {             var startTime = DateTime.Now;             Thread.Sleep(_random.Next(5000, 10000));             return Json(new             {                 conttroller = "AudioVideo",                 startTime = startTime.ToString("HH:mm:ss fff"),                 endTime = DateTime.Now.ToString("HH:mm:ss fff")             }, JsonRequestBehavior.AllowGet);         }     } </code></pre>  <p>In View : </p>  <pre><code>$(function () {     for (var i = 0; i &lt; 6; i++) {         $.getJSON('/AudioVideo/ajax', function (result) {             console.log(                 result.startTime + ' | ' + result.endTime + '|'+ result.conttroller             )         });     } }); </code></pre>  <p>Result : <br/></p>  <pre><code>14:14:44 562 | 14:14:51 978|AudioVideo 14:14:52 313 | 14:14:57 821|AudioVideo 14:14:57 897 | 14:15:04 580|AudioVideo 14:15:04 995 | 14:15:13 486|AudioVideo 14:15:13 607 | 14:15:21 692|AudioVideo 14:15:21 718 | 14:15:28 459|AudioVideo </code></pre>  <p>Chrome Network console : </p>  <p><a href="http://i.stack.imgur.com/Aflmz.png" rel="nofollow"><img src="http://i.stack.imgur.com/Aflmz.png" alt="enter image description here"></a></p>  <p>From the result its clear that ajax call to controller are blocking. Request can not initiate unless previous ajax request not complete so controller is serialised and serving one request at a time. </p>  <hr>  <p>UPDATE 2:  <br/> I thinks to create two separate controller with same method and send ajax request to separate controller simultaneously to check if they executed parallel</p>  <pre><code> AudioVideo1Controller   public ActionResult Ajax()     {         HttpContext.SetSessionStateBehavior(System.Web.SessionState.SessionStateBehavior.Required);          var startTime = DateTime.Now;         Thread.Sleep(_random.Next(5000, 10000));         return Json(new         {             conttroller = "AudioVideo1",             startTime = startTime.ToString("HH:mm:ss fff"),             endTime = DateTime.Now.ToString("HH:mm:ss fff")         }, JsonRequestBehavior.AllowGet);     } </code></pre>  <p>JavaScript :</p>  <pre><code> $(function () {         for (var i = 0; i &lt; 6; i++) {             $.getJSON('/AudioVideo/ajax', function (result) {                 console.log(                     result.startTime + ' | ' + result.endTime + '|'+ result.conttroller                 )             });         }     });  $(function () {         for (var i = 0; i &lt; 6; i++) {             $.getJSON('/AudioVideo1/ajax', function (result) {                 console.log(                     result.startTime + ' | ' + result.endTime + '|'+ result.conttroller                 )             });         }     }); </code></pre>  <p>Result : </p>  <pre><code> 14:33:37 355 | 14:33:46 642|AudioVideo  14:33:46 649 | 14:33:53 782|AudioVideo1  14:33:53 790 | 14:34:00 574|AudioVideo1  14:34:00 580 | 14:34:06 147|AudioVideo1  14:34:06 151 | 14:34:12 124|AudioVideo1  14:34:12 127 | 14:34:20 766|AudioVideo1  14:34:20 770 | 14:34:29 589|AudioVideo1  14:34:29 792 | 14:34:39 112|AudioVideo  14:34:39 419 | 14:34:44 942|AudioVideo  14:34:45 003 | 14:34:54 171|AudioVideo  14:34:54 643 | 14:35:03 013|AudioVideo  14:35:03 255 | 14:35:12 062|AudioVideo </code></pre>  <p>Result are shocking. Even two different controller can not serve request simultaneously. </p>  <p>I am using <code>.NET MVC 2</code> How to make controller asynchronous ?<br> Does anyone has workaround for this.</p>