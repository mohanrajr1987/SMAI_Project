<p>I would like to INSERT lots of rows in a table. I send my values as an array to a parameterized INSERT Query with ODBC in C++ like this:</p>  <pre><code>INSERT INTO information1(Wert1,Wert2) VALUES(?,?)  select wert1  from information1 WHERE Wert2=9" </code></pre>  <p>as you see I would like to run a select statement after INSERTs.</p>  <p>This code is able to insert rows in the table, but the result of select statement is wrong (The rsualt should be <strong>d</strong>). I have this expectation that something like this runs in the database:</p>  <pre><code>INSERT INTO information1(Wert1,Wert2) VALUES(a,4) INSERT INTO information1(Wert1,Wert2) VALUES(b,3) INSERT INTO information1(Wert1,Wert2) VALUES(c,17) INSERT INTO information1(Wert1,Wert2) VALUES(d,9) INSERT INTO information1(Wert1,Wert2) VALUES(e,5) INSERT INTO information1(Wert1,Wert2) VALUES(f,45) INSERT INTO information1(Wert1,Wert2) VALUES(g,6) INSERT INTO information1(Wert1,Wert2) VALUES(h,4) INSERT INTO information1(Wert1,Wert2) VALUES(i,2) SELECT Wert1 FROM information1 WHERE Wert2=9 </code></pre>  <p>but what actually happend is:</p>  <pre><code>   INSERT INTO information1(Wert1,Wert2) VALUES(a,4)     SELECT Wert1 FROM information1 WHERE Wert2=9     INSERT INTO information1(Wert1,Wert2) VALUES(b,3)     INSERT INTO information1(Wert1,Wert2) VALUES(c,17)     INSERT INTO information1(Wert1,Wert2) VALUES(d,9)     INSERT INTO information1(Wert1,Wert2) VALUES(e,5)     INSERT INTO information1(Wert1,Wert2) VALUES(f,45)     INSERT INTO information1(Wert1,Wert2) VALUES(g,6)     INSERT INTO information1(Wert1,Wert2) VALUES(h,4)     INSERT INTO information1(Wert1,Wert2) VALUES(i,2) </code></pre>  <p>hence it returns nothing (wrong result for me). Could someone explain me why the wrong order of statements are run in database? and how should I change my code to have the correct order?</p>  <p>Here you can find my whole code:</p>  <pre><code>#include &lt;windows.h&gt;  #include &lt;stdlib.h&gt;  #include &lt;stdio.h&gt;  #include&lt;tchar.h&gt;  #include &lt;sql.h&gt;  #include &lt;sqlext.h&gt;  #include&lt;sqltypes.h&gt;   //#include&lt;odbcss.h&gt; //#include&lt;odbcinst.h&gt;  #include&lt;exception&gt; #include&lt;iostream&gt; #include&lt;stdio.h&gt;  #include &lt;conio.h&gt;   #include "Debug\sqlncli.h";  void HandleDiagnosticRecord (SQLHANDLE      hHandle,                                  SQLSMALLINT    hType,                                RETCODE        RetCode) {     SQLSMALLINT iRec = 0;     SQLINTEGER  iError;     WCHAR       wszMessage[1000];     WCHAR       wszState[SQL_SQLSTATE_SIZE+1];       if (RetCode == SQL_INVALID_HANDLE)     {         fwprintf(stderr, L"Invalid handle!\n");         return;     }      while (SQLGetDiagRec(hType,                          hHandle,                          ++iRec,                          wszState,                          &amp;iError,                          wszMessage,                          (SQLSMALLINT)(sizeof(wszMessage) / sizeof(WCHAR)),                          (SQLSMALLINT *)NULL) == SQL_SUCCESS)     {         // Hide data truncated..         if (wcsncmp(wszState, L"01004", 5))         {             fwprintf(stderr, L"[%5.5s] %s (%d)\n", wszState, wszMessage, iError);         }     }   }  #define TRYODBC(h, ht, x)   {   RETCODE rc = x;\                              if (rc != SQL_SUCCESS) \                                 { \                                     HandleDiagnosticRecord (h, ht, rc); \                                 } \                                 if (rc == SQL_ERROR) \                                 { \                                     fwprintf(stderr, L"Error in " L#x L"\n"); \                                     Sleep(30000); \                                 }  \                             }   void extract_error(       char *fn,       SQLHANDLE handle,       SQLSMALLINT type)   {     SQLINTEGER i = 0;     SQLINTEGER native;     SQLWCHAR state[ 7 ];     SQLWCHAR text[256];     SQLSMALLINT len;     SQLRETURN ret;     fprintf(stderr,             "\n"             "The driver reported the following diagnostics whilst running "             "%s\n\n",             fn);      do     {       ret = SQLGetDiagRec(type, handle, ++i, state, &amp;native, text,       sizeof(text), &amp;len );       if (SQL_SUCCEEDED(ret))       printf("%s:%ld:%ld:%s\n", state, i, native, text);     }     while( ret == SQL_SUCCESS );   }       int main()     {         SQLHENV henv=SQL_NULL_HENV;         SQLHDBC hdbc=SQL_NULL_HDBC;         SQLHSTMT hstmt=SQL_NULL_HSTMT;         RETCODE rc;          SQLTCHAR Statement[] = _T("INSERT INTO information1(Wert1,Wert2) VALUES(?,?)  select count(*) as a from information1 ") ;         SQLTCHAR sqlStatementOUT[255];         SQLINTEGER lenStatementOUT=0;         memset(sqlStatementOUT,' ',255);       SQLWCHAR dsn[30] = L"mssqltest"; //Name DNS    SQLWCHAR user[10] = L"di_test";    SQLWCHAR pass[10] = L"di_test";     SQLCHAR retValFName[256];    SQLCHAR retValLName[256];    SQLINTEGER cbLName,cbFName;    SQLLEN cName=0;     SQLCHAR *TVPTableName=(SQLCHAR *) "TableTVP";      #define PARAM_ARRAY_SIZE 9     #define STRING_SIZE 20     SQLCHAR     Arrayname1[PARAM_ARRAY_SIZE][STRING_SIZE] = {"4","3","17","9","5","45","6","4","2"}; SQLCHAR     Arrayname2[PARAM_ARRAY_SIZE][STRING_SIZE] = {"a","b","c","d","e","f","g","h","i"};      SQLLEN cbTVPTableNAme=10;     SQLLEN cbArraycode[10],cbArrayname[10];     SQLLEN  lTVPRowsUsed;      rc = SQLAllocHandle(SQL_HANDLE_ENV, SQL_NULL_HANDLE, &amp;henv);        rc= SQLSetEnvAttr(henv,SQL_ATTR_ODBC_VERSION,(void *) SQL_OV_ODBC3,0);     rc = SQLAllocHandle(SQL_HANDLE_DBC, henv, &amp;hdbc);      rc = SQLConnectW(hdbc, (SQLWCHAR *)dsn, SQL_NTS, (SQLWCHAR *) user, SQL_NTS, (SQLWCHAR *) pass, SQL_NTS); // from this line rc=-1     rc = SQLAllocHandle(SQL_HANDLE_STMT,hdbc,&amp;hstmt);      rc = SQLSetStmtAttr (hstmt, SQL_ATTR_PARAM_BIND_TYPE, SQL_PARAM_BIND_BY_COLUMN, 0);    SQLUSMALLINT Param_status_array[PARAM_ARRAY_SIZE];    SQLULEN ParamsProcessed;    rc=SQLSetStmtAttr(hstmt,SQL_ATTR_PARAMSET_SIZE,(SQLPOINTER*) PARAM_ARRAY_SIZE, 0);    rc=SQLSetStmtAttr(hstmt,SQL_ATTR_PARAM_STATUS_PTR,Param_status_array,0);    rc=SQLSetStmtAttr(hstmt,SQL_ATTR_PARAMS_PROCESSED_PTR,&amp;ParamsProcessed,0);     SQLUSMALLINT newsize=0;      rc=SQLBindParameter(hstmt,1,SQL_PARAM_INPUT, SQL_C_CHAR, SQL_VARCHAR, STRING_SIZE, 0, Arrayname1, STRING_SIZE,0);    rc=SQLBindParameter(hstmt,2,SQL_PARAM_INPUT, SQL_C_CHAR, SQL_VARCHAR, STRING_SIZE, 0, Arrayname2, STRING_SIZE,0);     rc = SQLPrepare(hstmt, (SQLTCHAR *)Statement, SQL_NTS);    rc=SQLGetStmtAttr(hstmt,SQL_ATTR_PARAMSET_SIZE,&amp;newsize,4,NULL);    newsize=0;     rc = SQLExecute(hstmt);    rc=SQLGetStmtAttr(hstmt,SQL_ATTR_PARAMSET_SIZE,&amp;newsize,4,NULL);      if(rc==SQL_SUCCESS)    {        SQLSMALLINT sNumResults;        SQLNumResultCols(hstmt,&amp;sNumResults);        SQLBindCol(hstmt,                     1,                     SQL_C_TCHAR,                     (SQLPOINTER) retValFName,                     100,                    0);    while(true)         {           rc=SQLFetch(hstmt);            if(rc==SQL_SUCCESS || rc==SQL_SUCCESS_WITH_INFO)           {               SQLGetData(hstmt,1,SQL_C_CHAR,retValFName,256, &amp;cbLName);              std::cout &lt;&lt; retValFName &lt;&lt;"   "&lt;&lt; std::endl;            }           else           {               break;           }         }    }    system("pause");    return 0; } </code></pre>