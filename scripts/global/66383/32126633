<p>I am having an issue with a crm 2011 custom workflow activity I have created. The workflow activity is part of a workflow that cancels and renews contracts. The activity works after restarting the async services but quickly stops working afterwards. I get a different error message depending on if the assembly is sandboxed or not. Below is the original message I received before deciding to try sandboxing the assembly.</p>  <p>Workflow paused due to error: Unhandled Exception: System.TypeLoadException: Could not load type 'Microsoft.Xrm.Sdk.OrganizationRequestCollection' from assembly 'Microsoft.Xrm.Sdk, Version=5.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.    at ANHWP_WF_Library.CreateWarrantyPolicy.Execute(CodeActivityContext executionContext)    at System.Activities.CodeActivity.InternalExecute(ActivityInstance instance, ActivityExecutor executor, BookmarkManager bookmarkManager)    at System.Activities.Runtime.ActivityExecutor.ExecuteActivityWorkItem.ExecuteBody(ActivityExecutor executor, BookmarkManager bookmarkManager, Location resultLocation)</p>  <p>And after sandboxing...</p>  <p>Workflow paused due to error: Unhandled Exception: System.ArgumentNullException: Value cannot be null. Parameter name: type    at System.Activator.CreateInstance(Type type, Boolean nonPublic)    at System.Activator.CreateInstance(Type type)    at Microsoft.Crm.Workflow.Services.ActivityReferenceService.InitializeActivity(ActivityReference activityReference)    at Microsoft.Xrm.Sdk.Workflow.Activities.ActivityReference.CacheMetadata(NativeActivityMetadata metadata)    at System.Activities.NativeActivity.OnInternalCacheMetadata(Boolean createEmptyBindings)    at System.Activities.Activity.InternalCacheMetadata(Boolean createEmptyBindings, IList<code>1&amp; validationErrors)    at System.Activities.ActivityUtilities.ProcessActivity(ChildActivity childActivity, ChildActivity&amp; nextActivity, Stack</code>1&amp; activitiesRemaining, ActivityCallStack parentChain, IList<code>1&amp; validationErrors, ProcessActivityTreeOptions options, ProcessActivityCallback callback)    at System.Activities.ActivityUtilities.ProcessActivityTreeCore(ChildActivity currentActivity, ActivityCallStack parentChain, ProcessActivityTreeOptions options, ProcessActivityCallback callback, IList</code>1&amp; validationErrors)    at System.Activities.ActivityUtilities.CacheRootMetadata(Activity activity, LocationReferenceEnvironment hostEnvironment, ProcessActivityTreeOptions options, ProcessActivityCallback callback, IList`1&amp; validationErrors)    at System.Activities.Hosting.WorkflowInstance.ValidateWorkflow(WorkflowInstanceExtensionManager extensionManager)    at System.Activities.WorkflowApplication.EnsureInitialized()    at System.Activities.WorkflowApplication.Enqueue(InstanceOperation operation, Boolean push)    at System.Activities.WorkflowApplication.WaitForTurn(InstanceOperation operation, TimeSpan timeout)    at System.Activities.WorkflowApplication.InternalRun(TimeSpan timeout, Boolean isUserRun)    at Microsoft.Crm.Workflow.ActivityHost.StartWorkflowExecution(Activity workflow, ICommonWorkflowContext context)    at Microsoft.Crm.Workflow.ActivityHostBase.StartWorkflow(ICommonWorkflowContext context, Activity preLoadedActivity)</p>  <p>None of these errors make any sense to me since they seem to be an issue with CRM itself and not with my code. Other activities in the same assembly still run fine so it has to be an issue with my activity. Has anyone seen this before? Thanks in advance.</p>  <p>Edit: </p>  <p>So the issue sees to be related to my desire to re-use code (Like any good developer would do). What I had done was created a service class to handle the cancelling and renewal of contracts so that I could call the same code from different parts of the workflow activity. Now it seems that CRM did not like this very much. I tried moving the methods out of the service class and into some private methods inside the workflow activity class but I was getting the same errors. Eventually I decided to see what would happen if I placed every line of code inside the actual Execute method of the workflow activity and viola! No more errors. This seems a little bit strange to me because from where I'm sitting instantiating and calling other classes should work fine in the same assembly as long as the classes are instantiated from within the execute method and are not globally defined. Any thoughts on why that might be? Thanks again for all your help so far.</p>