<p>I'm having problems trying to implement <a href="http://www.catalinzima.com/2010/07/my-technique-for-the-shader-based-dynamic-2d-shadows/" rel="nofollow">this method</a> for rendering pixel-perfect 2D shadows in java/opengl.</p>  <p>The method described is written for XNA(directX), I'm translating it to Opengl. I feel like there's a subtle detail I'm missing like XNA coordinates having 0/0 at the top-left corner - which I already figured out.</p>  <p>My implementation of the distance and distortion shader do what they should, I ran it with the original picture in the tutorial. I use RGBA32F textures, from what I learned in onlince searches this is the format I want.</p>  <p>This leaves the reduction and shadow-drawing fragmentshaders as the only sources for error. </p>  <p>Reduction shader:</p>  <pre><code>#version 330  in vec2 UV;  uniform sampler2D inputSampler; uniform vec2 targetTextureDimensions;  out vec4 minValue;  void main(){      vec2 color = texture2D(inputSampler, UV).rg;     vec2 colorR = texture2D(inputSampler,UV + vec2(targetTextureDimensions.x,0)).rg;      vec2 result = min(color,colorR);     minValue = vec4(result,0,1); } </code></pre>  <p>I'm not sure why adding targetTextureDimensions works, since UV coordinates are between 0 and 1. However the resulting image looks surprisingly correct. I tried replacing it with this:</p>  <pre><code>   vec2 lUV;    lUV.x = UV.x*0.5f;    lUV.y = UV.y;     vec2 color = texture2D(inputSampler, lUV).rg;    vec2 colorR = texture2D(inputSampler,lUV + vec2(0.5f.x,0)).rg; </code></pre>  <p>which is completely wrong and I don't get why...</p>  <p>Shadow shader:</p>  <pre><code>#version 330  in vec2 UV;   uniform sampler2D mapSampler;//tex1 uniform vec2 renderTargetSize;  out vec4 result;  float GetShadowDistanceH(vec2 TexCoord, float displacementV); float GetShadowDistanceV(vec2 TexCoord, float displacementV);   void main(){     // distance of this pixel from the center     vec2 centerToPixel = UV - vec2(0.5);     float distance = length(centerToPixel);      distance *=512;     //apply a 2-pixel bias     distance -=2.0f;      //distance stored in the shadow map     float shadowMapDistance;      //coords in [-1,1]     float nY = UV.y * 2.0 - 1.0;     float nX = UV.x * 2.0 - 1.0;      //use these to determine which quadrant we are in     if(abs(nY)&lt;abs(nX))     { //left or right segment         shadowMapDistance = GetShadowDistanceH(UV,0);     }     else     { //upper or lower segment       shadowMapDistance = GetShadowDistanceV(UV,0);     }      //compare this pixel's distance from center(light) to the one stored in      //the shadowmap closer == not in shadow     float light = distance &lt; shadowMapDistance? 1:0;     result = vec4(vec3(light),1); }   float GetShadowDistanceH(vec2 TexCoord, float displacementV) {         float u = TexCoord.x;         float v = TexCoord.y;          u = abs(u-0.5f) * 2;         v = v * 2 - 1;       float v0 = v/u;         v0+=displacementV;         v0 = (v0 + 1) / 2;          vec2 newCoords = vec2(TexCoord.x,v0);         //horizontal info was stored in the Red component         return texture2D(mapSampler, newCoords).r; }  float GetShadowDistanceV(vec2 TexCoord, float displacementV) {         float u = TexCoord.y;         float v = TexCoord.x;          u = abs(u-0.5f) * 2;         v = v * 2 - 1;         float v0 = v/u;         v0+=displacementV;         v0 = (v0 + 1) / 2;          vec2 newCoords = vec2(TexCoord.y,v0);         //vertical info was stored in the Green component         return texture2D(mapSampler, newCoords).g; } </code></pre>