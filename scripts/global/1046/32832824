<p>When setting positive value to viewport.X or viewport.Y, the XNA object moves right or up as expected. However, when setting negative value, the object disappears. Any ideas?</p>  <p>CODE:</p>  <pre><code>private GraphicsDeviceManager graphics; private Vector3 cameraPosition = new Vector3(0.0f, 0.0f, 3.0f); private BasicEffect effect; private Viewport viewport; private VertexPositionColor[] vertices  = new VertexPositionColor[] {     new VertexPositionColor(new Vector3(-1, -1, 0), Color.Red),      new VertexPositionColor(new Vector3(-1, 1, 0), Color.Blue),      new VertexPositionColor(new Vector3(1, -1, 0), Color.Green),  };  public Game1() {     graphics = new GraphicsDeviceManager(this); }  protected override void Initialize() {     effect = new BasicEffect(graphics.GraphicsDevice);     effect.VertexColorEnabled = true;      viewport = graphics.GraphicsDevice.Viewport;      graphics.GraphicsDevice.RasterizerState = new RasterizerState     {         FillMode = FillMode.WireFrame,         CullMode = CullMode.None,     };      base.Initialize(); } </code></pre>  <p>The Update method handles arrow keys and updates the position of viewport.</p>  <pre><code>protected override void Update(GameTime gameTime) {     KeyboardState keyState = Keyboard.GetState();     if (keyState.IsKeyDown(Keys.Down))     {         viewport.Y += 2;         graphics.GraphicsDevice.Viewport = viewport;     }      if (keyState.IsKeyDown(Keys.Up))     {         viewport.Y -= 2;         graphics.GraphicsDevice.Viewport = viewport;     }      if (keyState.IsKeyDown(Keys.Left))     {         viewport.X -= 2;         graphics.GraphicsDevice.Viewport = viewport;     }      if (keyState.IsKeyDown(Keys.Right))     {         viewport.X += 2;         graphics.GraphicsDevice.Viewport = viewport;     }      base.Update(gameTime); } </code></pre>  <p>The Draw method sets up effect and draws the object.</p>  <pre><code>protected override void Draw(GameTime gameTime) {     GraphicsDevice.Clear(Color.DarkGray);      effect.View = Matrix.CreateLookAt(cameraPosition, Vector3.Zero, Vector3.Up);     effect.Projection = Matrix.CreatePerspectiveFieldOfView(MathHelper.ToRadians(45.0f),         graphics.GraphicsDevice.Viewport.AspectRatio, 1.0f, 10000.0f);      foreach (var pass in effect.CurrentTechnique.Passes)     {         pass.Apply();         graphics.GraphicsDevice.DrawUserPrimitives(PrimitiveType.TriangleList, vertices, 0, vertices.Length / 3);     }      base.Draw(gameTime); } </code></pre>