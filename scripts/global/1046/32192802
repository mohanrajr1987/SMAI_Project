<p>i have been trying to get 3d collision working for a while and i think(hope) you people can help me</p>  <p>so for my project i have created a 'sprite3d' kinda class which is called ModelEntity and there there is a function that is called intersects. intersects gets another ModelEntity as a parameter.</p>  <pre><code> public bool intersects(ModelEntity entity)     {         BoundingSphere bs1 = CreateBoundingSphereForModel();         BoundingSphere bs2 = entity.CreateBoundingSphereForModel();          bs1.Center += position;         bs2.Center +=entity.position;          if (bs1.Intersects(bs2))             return true;          return false;     }  public BoundingSphere CreateBoundingSphereForModel()     {         Matrix[] boneTransforms = new Matrix[this.model.Bones.Count];         this.model.CopyAbsoluteBoneTransformsTo(boneTransforms);          BoundingSphere boundingSphere = new BoundingSphere();         BoundingSphere meshSphere;          for (int i = 0; i &lt; model.Meshes.Count; i++)         {             meshSphere = model.Meshes[i].BoundingSphere.Transform(boneTransforms[i]);             boundingSphere = BoundingSphere.CreateMerged(boundingSphere, meshSphere);         }         return boundingSphere.Transform(getWorld());     }  public Matrix getWorld()     {         return  Matrix.CreateTranslation(position) * Matrix.CreateRotationY(rotation.Y) * Matrix.CreateRotationZ(rotation.Z) * Matrix.CreateRotationX(rotation.X) ;     } </code></pre>  <p>those are the main parts of the collision in the ModelEntity class and the place where i check collision is in the PlayState class</p>  <pre><code>if (model.intersects(player) || player.intersects(model1))         {             cam.returnToLastPosition();         } </code></pre>  <p>cam.returnToLastPosition() is just returning the camera to the last place it has been so you cant pass the model.</p>  <p>in the update loop i set the player position to the camera position (i have created a first person camera class which takes care of mouse and keyboard movment)</p>  <p>if you want to see the draw function :</p>  <pre><code>public void draw(FirstPersonCamera cam)         {             Matrix[] transforms = new Matrix[model.Bones.Count];             model.CopyAbsoluteBoneTransformsTo(transforms);             foreach (ModelMesh mesh in model.Meshes)             {                 foreach (BasicEffect effect in mesh.Effects)                 {                     effect.EnableDefaultLighting();                     effect.World =  transforms[mesh.ParentBone.Index] * getWorld();                     effect.View = cam.getView();                     effect.Projection = cam.projection;                  }                 mesh.Draw();             }         } </code></pre>  <p>NOTE// in the intersects function i have tried remove the part of </p>  <pre><code>bs1.Center += position; bs2.Center +=entity.position; </code></pre>  <p>but it does not work anyways</p>  <p>EDIT</p>  <pre><code>Vector3 cameraPosition = cam.getPosition();         Vector3 PlayerDimention = new Vector3(200, 200, 200);         BoundingBox cameraBox = new BoundingBox(         new Vector3(             cameraPosition.X - (PlayerDimention.X / 2),             cameraPosition.Y - (PlayerDimention.Y),             cameraPosition.Z - (PlayerDimention.Z / 2)         ),         new Vector3(             cameraPosition.X + (PlayerDimention.X / 2),             cameraPosition.Y,             cameraPosition.Z + (PlayerDimention.Z / 2)         )     );          foreach(Sprite3D block in blocks){             if (block.getBoundings().Contains(cameraBox) != ContainmentType.Disjoint)             {                 cam.returnToLastPosition();                 break;             }         } </code></pre>  <p>in this in the sprite3d class : </p>  <pre><code>    public BoundingBox getBoundings()     {         Vector3 min = new Vector3(float.MaxValue, float.MaxValue, float.MaxValue);         Vector3 max = new Vector3(float.MinValue, float.MinValue, float.MinValue);          // For each mesh of the model         foreach (ModelMesh mesh in model.Meshes)         {             foreach (ModelMeshPart meshPart in mesh.MeshParts)             {                 // Vertex buffer parameters                 int vertexStride = meshPart.VertexBuffer.VertexDeclaration.VertexStride;                 int vertexBufferSize = meshPart.NumVertices * vertexStride;                  // Get vertex data as float                 float[] vertexData = new float[vertexBufferSize / sizeof(float)];                 meshPart.VertexBuffer.GetData&lt;float&gt;(vertexData);                  // Iterate through vertices (possibly) growing bounding box, all calculations are done in world space                 for (int i = 0; i &lt; vertexBufferSize / sizeof(float); i += vertexStride / sizeof(float))                 {                     Vector3 transformedPosition = Vector3.Transform(new Vector3(vertexData[i], vertexData[i + 1], vertexData[i + 2]), getWorld());                      min = Vector3.Min(min, transformedPosition);                     max = Vector3.Max(max, transformedPosition);                 }             }         }          // Create and return bounding box         return new BoundingBox(min, max);     } </code></pre>  <p>kinda make collision work but i am not sure this is the right way to do it and maybe it could help you identify the problem</p>  <p>Also , i must say , all the people i have seen done stuff in xna 3d use the draw distance of 1000 but for me this draw distance is not enough for anything(i use draw distance of 10000.0f)</p>