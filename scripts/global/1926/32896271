<p>I have read <strong><em><a href="http://stackoverflow.com/q/1241205/645128">this post</a></em></strong>.<br> From that, I read this:<br> From C99:  6.2.7.27  </p>  <blockquote>   <p>A pointer to void shall have the same representation and alignment   requirements as a pointer to a character type.39) <em>Similarly, pointers   to qualified or unqualified versions of compatible types shall have   the same representation and alignment requirements</em>. All pointers to   structure types shall have the same representation and alignment   requirements as each other. All pointers to union types shall have the   same representation and alignment requirements as each other.   <em>Pointers to other types need not have the same   representation or alignment requirements</em>.  (emphasis mine)</p> </blockquote>  <p>My interpretation of the parts important to me for the purpose of this question seem to say<br> if I have:  </p>  <pre><code>int *a, **b;    </code></pre>  <p>registration and alignment are guaranteed, and that all of these statements are true;  </p>  <pre><code>sizeof(a)==sizeof(*a)&amp;&amp; sizeof(int *)==sizeof(b)&amp;&amp; sizeof(*b)==sizeof(**b);// all essentially int pointers,                         // and would be equal </code></pre>  <p>but if I have:    </p>  <pre><code>int *a; float*b;   </code></pre>  <p>registration and alignment are <em>not</em> guaranteed.  i.e.:  </p>  <pre><code>sizeof(a)!=sizeof(b)&amp;&amp; sizeof(float *)!=sizeof(int *)&amp;&amp; sizeof(*b)!=sizeof(*a);//all pointers, but not of compatible types                        //therefore not guaranteed to be equal. </code></pre>  <p>The reason I ask is because of <strong><em><a href="http://stackoverflow.com/a/32874279/645128">this</a></em></strong> discussion,<br> where I posted an answer showing a function that creates a 3D array:  </p>  <pre><code>int *** Create3D(int p, int c, int r)  {     int ***arr;     int    x,y;      arr = calloc(p, sizeof(arr));      for(x = 0; x &lt; p; x++)     {         arr[x] = calloc(c ,sizeof(arr));          for(y = 0; y &lt; c; y++)         {             arr[x][y] = calloc(r, sizeof(int));         }     }     return arr; } </code></pre>  <p>Is the following statement safe in terms of using sizeof()?  </p>  <pre><code>arr = calloc(p, sizeof(arr));  </code></pre>  <p>Or, even though only <code>int</code> types are used, should it be:</p>  <pre><code>arr = calloc(p, sizeof(int **)); </code></pre>  <p><strong><em>or:</em></strong></p>  <pre><code>arr = calloc(p, sizeof *arr); </code></pre>  <p><em>The question:</em><br> Given <code>arr</code> is declared as <code>int ***</code>:<br> For allocating memory, as long as type stays <code>int</code> is there any danger of using any of the variations of int pointer (<code>int *, int **, arr, *arr, int ***</code>) as the argument to sizeof ?  </p>  <p>Is one form preferred over the other?  (please give reasons other than style)  </p>