<p>I am trying to create a class factory that uses a list of class types, calls overridden methods to find the class that matches the criteria, and then returns an instance of the "matched" class.  I am currently doing it with a list of class instances, which is ok, but using types would seem cleaner.  Otherwise we need to reinitialize the instance every time we actually use the class to "clean up" the internal working variables.  Does polymorphism work with static methods and types?  I frequently use polymorphism, but have not thought about approaching it this way before.</p>  <p>My simplified current code is like this:</p>  <pre><code>public static List&lt;RatingEngineBase&gt; RatingEngineList = new List&lt;RatingEngineBase&gt;(); RatingEngineList.Add(new RE_PPL_DTNA_Cleveland_ATT()); RatingEngineList.Add(new RE_PPL_DTNA_Cleveland_Coldiron()); RatingEngineList.Add(new RE_PPL_DTNA_Cleveland_Prestige()); RatingEngineList.Add(new RE_PPL_DTNA_MtHolly_ATT()); foreach(RatingEngineBase RatingEngine in RatingEngineList) {     if (RatingEngine.OrderItemToRatePathMatch(anOrderItemToRate))     {         RatingEngine.OrderItemToRate = anOrderItemToRate;         return RatingEngine;     } } </code></pre>  <p>But I think it would be cleaner if I could do something like:</p>  <pre><code>public static List&lt;typeof(RatingEngineBase)&gt; RatingEngineTypeList = new List&lt;typeof(RatingEngineBase)); RatingEngineTypeList.Add(typeof(RE_PPL_DTNA_Cleveland_ATT)); RatingEngineTypeList.Add(typeof(RE_PPL_DTNA_Cleveland_Coldiron)); RatingEngineTypeList.Add(typeof(RE_PPL_DTNA_Cleveland_Prestige)); RatingEngineTypeList.Add(typeof(RE_PPL_DTNA_MtHolly_ATT)); </code></pre>  <p>And then iterate through the list of types, call the overridden static OrderItemToRatePathMatch, and then create and return the instance of the matching one.</p>  <p>Hopefully this helps explain my question.</p>