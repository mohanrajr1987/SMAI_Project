<p>I've a trait:</p>  <pre><code>trait OAuthService {   def sendWithAuthorizationQueryParams[A](request: OAuthRequest)(implicit unmarshaller: Unmarshaller[ResponseEntity, A]): Future[A] = {     val httpRequest = request.toHttpRequestWithAuthorizationQueryParams      sendAndReceive(httpRequest, request.signature)   }    def sendWithAuthorizationHeader[A](request: OAuthRequest)(implicit unmarshaller: Unmarshaller[ResponseEntity, A]): Future[A] = {     val httpRequest = request.toHttpRequestWithAuthorizationHeader      sendAndReceive(httpRequest, request.signature)   }    protected def sendAndReceive[A](httpRequest: HttpRequest, id: String)(implicit unmarshaller: Unmarshaller[ResponseEntity, A]): Future[A] } </code></pre>  <p>I'm creating a subclass:</p>  <pre><code>class StreamingOAuthService()(implicit val actorPlumbing: ActorPlumbing) extends OAuthService {   private val log = LoggerFactory.getLogger(getClass())    override protected def sendAndReceive[A](httpRequest: HttpRequest, id: String)(implicit unmarshaller: Unmarshaller[ResponseEntity, A]) = {     log.debug(s"Http request: {}.", httpRequest)      import actorPlumbing._      val host = httpRequest.uri.authority.host.address()      val connectionFlow: Flow[HttpRequest, HttpResponse, Future[OutgoingConnection]] = Http().outgoingConnectionTls(host)      Source.single(httpRequest)       .via(connectionFlow)       .runWith(Sink.head)   } } </code></pre>  <p>In <code>StreamingOAuthService</code>, I want to freeze the generic type as <code>ResponseEntity</code>. In other words, I want to specify that the only type supported by the methods of <code>StreamingOAuthService</code> is <code>ResponseEntity</code>. As shown, <code>StreamingOAuthService.sendAndReceive</code> doesn't compile because the return type is <code>Future[ResponseEntity]</code> and not <code>Future[A]</code>, as specified by the trait.</p>