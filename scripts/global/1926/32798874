<p>I'm trying to implement an infinite dimensional vector space in Haskell, but I'm running into trouble. I would use a stream as the base data type and simply use the provided package for vector spaces, but I want indices to go in both the negative and positive direction. In other words, I want some sort of mapping from the integers (all of them) to some scalar values. This can be easily implemented as, say,</p>  <pre class="lang-hs prettyprint-override"><code>(^+^) :: (Integer -&gt; Double) -&gt; (Integer -&gt; Double) -&gt; (Integer -&gt; Double) a ^+^ b = (\ n -&gt; (a n) + (b n)) (^*^) :: Double -&gt; (Integer -&gt; Double) -&gt; (Integer -&gt; Double) c ^*^ a = (\ n -&gt; c * (a n)) </code></pre>  <p>And used like</p>  <pre class="lang-hs prettyprint-override"><code>vecA :: (Integer -&gt; Double) vecB :: (Integer -&gt; Double) vecA n = fromInteger n vecB n = fromInteger n print ((vecA ^+^ vecB) 4) --prints 8.0, as expected </code></pre>  <p>Okay, so I would like to make this far more general, and na√Øvely, I would want to write something like,</p>  <pre class="lang-hs prettyprint-override"><code>class AdditiveGroup v where   -- | The zero element: identity for '(^+^)'   zeroV :: v   -- | Add vectors   (^+^) :: v -&gt; v -&gt; v   -- | Additive inverse   negateV :: v -&gt; v   -- | Group subtraction   (^-^) :: v -&gt; v -&gt; v   v ^-^ v' = v ^+^ negateV v'  class AdditiveGroup v =&gt; VectorSpace v where   type Scalar v :: *   -- | Scale a vector   (*^) :: Scalar v -&gt; v -&gt; v </code></pre>  <p>(I copied and pasted this definition from Haskell's classes for this kind of thing.) But, of course, there's not a way (that I can see) to implement the mapping I had above as a data construct, and trying to change the kind of v makes me run into problems</p>  <pre class="lang-hs prettyprint-override"><code>--This doesn't even compile class InfVecSpace v where     type Index v  :: *     type Scalar v :: *     type Member v :: * -&gt; *     (^+^)   :: (Member v) -&gt; (Member v) -&gt; (Member v)     zeroV   :: (Member v)     invertV :: (Member v) -&gt; (Member v)     (^*^)   :: Scalar v -&gt; (Member v) -&gt; (Member v) </code></pre>  <p>How might I implement this, preferably as idiomatically as possible, within Haskell's type system?</p>