<p><strong>When i send the file to the client it gets corrupted, and with a size in bytes higher.</strong></p>  <p>I have a version of this server running on Windows and works perfectly,but I'm not having the same result on Linux.</p>  <p>The file size on disk may be the error in time to send the size in bytes to the client that runs on another platform?</p>  <p><strong>fread function is being used correctly?</strong></p>  <p>an <strong>expert</strong> can analyze and help find the error?</p>  <p><strong>LINUX SERVER SIDE</strong></p>  <pre><code>// FUNCTION TO UPLOAD A FILE TO CLIENT WINDOWS int Socket_Setup::FILE_UPLOAD(int iD, std::string DIR_UPLOAD) {        char Block[1024];      long FileSize;     int BytesRead;        fp = fopen(DIR_UPLOAD.c_str(), "rb");     if (!fp)     {           errno_message.append((char*)strerror(errno));           FUNCTION_LOG(errno_message);           return 1;     }      fseek(fp, 0, SEEK_END);     FileSize = ftell(fp);     rewind(fp);      long Size_Send = htonl(FileSize);     Total = FileSize;      // Sending the file size to the Windows Client       iResult = send(client[iD].socket, (const char*)&amp;Size_Send, sizeof(long), 0);             if (iResult &lt;= 0)     {           errno_message.append((char*)strerror(errno));           FUNCTION_LOG(errno_message);           return 1;     }          // LOOP TO SEND FILE       while (FileSize &gt; 0)     {         BytesRead = fread(Block, 1, sizeof(Block), fp);         if (BytesRead &lt;= 0)         {             errno_message.append((char*)strerror(errno));             FUNCTION_LOG(errno_message);             fclose(fp);             return 1;         }         if (send(client[iD].socket, Block, BytesRead, 0) != BytesRead)         {             errno_message.append((char*)strerror(errno));             FUNCTION_LOG(errno_message);             fclose(fp);             return 1;         }         FileSize -= BytesRead;           }     fclose(fp);     return 0; } </code></pre>  <p><strong>WINDOWS CLIENT SIDE:</strong></p>  <pre><code>int readBytes(SOCKET s, void *buffer, int buflen)     {         int total = 0;         char *pbuf = (char*)buffer;         while (buflen &gt; 0)         {             int iResult = recv(s, pbuf, buflen, 0);             if (iResult &lt; 0)             {                 if (WSAGetLastError() == WSAEWOULDBLOCK)                    continue;                 return SOCKET_ERROR;             }             else if (iResult == 0)                 return 0;             else             {                 pbuf += iResult;                 buflen -= iResult;                 total += iResult;             }         }         return total;     }         // FUNCTION TO DOWNLOAD FILE FROM SERVER         int Remote_Manip::FILE_DOWNLOAD(std::string directory, Socket_Setup &amp;socket_setup)         {                unsigned long FileSize;             char mfcc[65535];              File = fopen(directory.c_str(), "wb");             if (File == NULL)             {                 closesocket(socket_setup.ConnectSocket);                 WSACleanup();                 return 1;             }              // Receiving file size from server             int iResult = readBytes(socket_setup.ConnectSocket, &amp;FileSize, sizeof(FileSize));             if (iResult &lt;= 0)             {                 fclose(File);                 closesocket(socket_setup.ConnectSocket);                 WSACleanup();                 return 1;             }             FileSize = ntohl(FileSize);              // LOOP TO RECEIVING FILE             while (FileSize &gt; 0)             {                 int Received = recv(socket_setup.ConnectSocket, mfcc, sizeof(mfcc),0);                 if (Received &lt;= 0)                 {                     fclose(File);                     closesocket(socket_setup.ConnectSocket);                     WSACleanup();                     return 1;                 }                  if (fwrite(mfcc, 1, Received, File) != Received)                 {                     fclose(File);                     closesocket(socket_setup.ConnectSocket);                     WSACleanup();                     return 1;                 }                     FileSize -= Received;             }                fflush(File);             fclose(File);             return 0;         } </code></pre>