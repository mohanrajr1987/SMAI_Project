<p>I'm new to Winsock. I am writing an HTTP server and I am aiming to send a large file by reading and sending in chunks. To optimize this process, I attempt to use a nonblocking socket where I read the next chunk from the disk while I send the current one.</p>  <p>My problem now is that I get an FD_WRITE message even when it seems the buffer should be full and my function deletes the associated data from memory prematurely. I believe this causes my responses contain less data than they should send() stops sending prematurely and the client (which is a well-known one) receives about 70% of the data. When I use blocking sockets it works fine, it's just longer.</p>  <p>I tried using Wget, a simple HTTP client, to get a better idea of what's going on. From what I can see, the datastream thins out when I detect WSAEWOULDBLOCK errors when checking for errors after using send(). It looks like during those sends, not all the data gets sent.</p>  <p>When I set the sleep time to over 2000ms after checking for the FD_WRITE message, everything works as it basically comes down to using a blocking socket. I also tried setting times around 100-200ms, but those fail as well. As it is, the condition checking for FD_WRITE always returns valid before entering the loop.</p>  <pre><code>WSAEVENT event = WSACreateEvent(); const int sendBufferSize = 1024 * 64; int connectionSpeed = 5; //estimated, in MBytes/s const int sleepTime = sendBufferSize / (connectionSpeed * 1024 * 1024); size = 0; const int bufSize = 1024 * 1024 * 35; int lowerByteIndex = 0; int upperByteIndex = bufSize; size = bufSize; int totalSIZE = 0; unsigned char* p; unsigned char* pt; clock_t t = std::clock();  p = getFileBytesC(resolveLocalPath(path), size, lowerByteIndex, upperByteIndex); lowerByteIndex += bufSize; upperByteIndex += bufSize; totalSIZE += size; while (upperByteIndex &lt;= fileSize + bufSize) {     int ret = send(socket, (char*)p, size, 0);     pt = getFileBytesC(resolveLocalPath(path), size, lowerByteIndex, upperByteIndex);     totalSIZE += size;     lowerByteIndex += bufSize;     upperByteIndex += bufSize;     if (ret == SOCKET_ERROR &amp;&amp; WSAGetLastError() == WSAEWOULDBLOCK)     {         while (SOCKET_ERROR == WSAEventSelect(socket, event, FD_WRITE))         {             Sleep(50);         }     }     Sleep(sleepTime); //should be around 30-50ms. Wait for the buffer to be empty     delete[] p;     p = pt;     std::cout &lt;&lt; std::endl &lt;&lt; (std::clock() - t) / (double)CLOCKS_PER_SEC; } send(socket, (char*)p, size, 0); delete[] p; std::cout &lt;&lt; std::endl &lt;&lt; (std::clock() - t) / (double)CLOCKS_PER_SEC ; if (totalSIZE == fileSize) std::cout &lt;&lt; std::endl &lt;&lt; "finished transfer. UBI=" &lt;&lt; upperByteIndex; else {     std::cout &lt;&lt; std::endl &lt;&lt; "ERROR: finished transfer\r\nBytes read=" &lt;&lt; totalSIZE; } Sleep(2000); closeSocket(socket); </code></pre>