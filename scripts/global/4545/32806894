<p>I have Frege code as follows (mostly, just pay attention to the type signature for getDatabase)</p>  <pre><code>module fregeHelper.FregeCode where   --Java's String.split method pure native split :: String -&gt; String -&gt; JArray String  --Java's ArrayList&lt;t&gt; data ArrayList t =native java.util.ArrayList where     native new :: () -&gt; STMutable s (ArrayList t)     native add::Mutable s (ArrayList t)-&gt; t -&gt; ST s ()  getDatabase::String-&gt;(IO (STMutable s (ArrayList (String, String)))) getDatabase s = do         fileContents &lt;- readFile s         let processedData = map ((\x-&gt;(elemAt x 0, elemAt x 1)) . (flip split ";")) . lines $ fileContents         return $ fold foldAdd (ArrayList.new ()) processedData     where         foldAdd::ST s (Mutable s (ArrayList t)) -&gt; t -&gt; ST s (Mutable s (ArrayList t))         foldAdd list elem = list &gt;&gt;= \x-&gt;(ArrayList.add x elem &gt;&gt; return x) </code></pre>  <p>Then from Java I want to define the following function thusly (where DATABASE is a string constant):</p>  <pre><code>private void readDatabase() {     myList = Delayed.&lt;ArrayList&lt;TTuple2&gt;&gt;forced(             fregeHelper.FregeCode.getDatabase(DATABASE)); } </code></pre>  <p>However, this gives me a <code>java.lang.ClassCastException: frege.prelude.PreludeBase$TST$1 cannot be cast to java.util.ArrayList</code></p>  <p>Through experimentation, I had to change the code to be</p>  <pre><code>private void readDatabase() {     fighters = Delayed.&lt;ArrayList&lt;TTuple2&gt;&gt;forced(             fregeHelper.FregeCode.getDatabase(DATABASE)             .apply(null)             .apply(null)             ); } </code></pre>  <p>I've put null in the latter applies just to show that it doesn't matter what I pass in. I have no idea why I have to apply the function three times (I can't just immediately force evaluation). Is there any way I can either remove the applies or have some rationalization as to why they're necessary? (Note: using .result() doesn't help the case.)</p>