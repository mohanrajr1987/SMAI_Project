<p>I thought I had solved my mouseEvent problem for Sprites containing a Bitmap with an alpha channel but I've encountered a new issue shown in the image below: the bounding box of the "Eurasia" map Sprite is triggering a `MouseEvent.Roll_Out" for the "Africa" Sprite.</p>  <p><img src="http://i.stack.imgur.com/VfZfH.png" alt="enter image description here"></p>  <p><strong>My setup:</strong> Each map piece is a Sprite with a child Bitmap (PNG with alpha) and a "hitArea" Sprite derived from the Bitmap. The relevant code is below. This works great – except in the case where there are bounding box overlaps. The <code>eventListeners</code> I attach to each Sprite use <code>MouseEvent.ROLL_OVER</code> and <code>MouseEvent.ROLL_OUT</code> but I have also tried <code>MouseEvent.MOUSE_OVER</code> and <code>MouseEvent.MOUSE_OUT</code>.</p>  <p>I've tried attaching eventlisteners to the "hitArea" Sprite and various other things but I can't get the bounding box to be ignored. Are there any settings I may have missed – or a workaround?</p>  <hr>  <p><strong>Code:</strong></p>  <pre><code>buttonImage = new Bitmap(upImageData); buttonImage.smoothing = true; this.addChild(buttonImage); hitSprite = createHitArea(upImageData, 4); this.addChild(hitSprite); hitSprite.visible = false; hitSprite.mouseEnabled = false; this.hitArea = hitSprite; </code></pre>  <hr>  <pre><code>    public function createHitArea(bitmapData:BitmapData, grainSize:uint=1):Sprite     {            var _hitarea:Sprite = new Sprite();         _hitarea.graphics.beginFill(0x000000, 1.0);                  for(var x:uint=0;x&lt;bitmapData.width;x+=grainSize) {             for(var y:uint=grainSize;y&lt;bitmapData.height;y+=grainSize) {                                     if(x&lt;=bitmapData.width &amp;&amp; y&lt;=bitmapData.height &amp;&amp; bitmapData.getPixel(x,y)!=0) {                     _hitarea.graphics.drawRect(x,y,grainSize,grainSize);                 }                                }         }                    _hitarea.graphics.endFill();         _hitarea.cacheAsBitmap = true;         return _hitarea;     } </code></pre>