<p>I have created nested checkbox in flex. </p>  <p>I want only that one parent checkbox should be selected. If I select parent checkbox (Cluster1) all child checkboxes of that parent checkbox should be selected, and other parent checkboxes should not be clicked until the current checkbox is unchecked.</p>  <p><a href="http://i.stack.imgur.com/KCM2i.png" rel="nofollow"><img src="http://i.stack.imgur.com/KCM2i.png" alt="enter image description here"></a> </p>  <p>current XML strcture for checkbox tree:</p>  <pre><code>public var treeData:XML =  &lt;item name="vCenter Server" type="Server"&gt;                                        &lt;item name = "Datacenter" type="Datacenter" checked="false"&gt;                                             &lt;item name="Cluster1" type="ClusterComputeResource" id="mycusterOne" checked="false"&gt;                                                 &lt;item name = "Host 1" type="HostSystem" checked="false"/&gt;                                                 &lt;item name = "Host 2" type="HostSystem" checked="false"/&gt;                                             &lt;/item&gt;                                              &lt;item name="Cluster2" type="ClusterComputeResource" id="mycusterTwo" checked="false"&gt;                                                 &lt;item name = "Host 1" type="HostSystem" checked="false"/&gt;                                                 &lt;item name = "Host 2" type="HostSystem" checked="false"/&gt;                                             &lt;/item&gt;                                        &lt;/item&gt;                                          &lt;item name = "Host 3" type="HostSystem" checked="false"&gt; &lt;/item&gt;                                     &lt;/item&gt;; </code></pre>  <p>and Code :</p>  <pre><code>protected function chk_clickHandler(event:MouseEvent):void         {             var myListData:TreeListData = TreeListData(this.listData);             var selectedNode:Object = myListData.item;             var tree:Tree = Tree(myListData.owner);             var toggle:Boolean = chk.selected;             if(this.chk.selected){                 //this.checked = true;                 this.itemXml.@checked = "true";             }             else             {                 //this.checked = false;                 this.itemXml.@checked = "false";             }             var toggle:Boolean = chk.selected;              if (toggle)             {                 toggleChildren(data, tree, "true");             }             else             {                 toggleChildren(data, tree, "false");                 if( this.itemXml.@type == "HostSystem" ){                     toggleParents(data, tree, "false");                 }             }          }   private function toggleChildren (item:Object, tree:Tree, checked:String):void         {             if (item == null) {                 return;             } else {                 if(item.@type == 'HostSystem') {                     item.@checked = checked;                 }                 var treeData:ITreeDataDescriptor = tree.dataDescriptor;                 if (treeData.hasChildren(item)) {                     var children:ICollectionView = treeData.getChildren (item);                     var cursor:IViewCursor = children.createCursor();                     while (!cursor.afterLast) {                         toggleChildren(cursor.current, tree, checked);                         cursor.moveNext();                     }                 }             }          }          private function toggleParents (item:Object, tree:Tree, checked:String):void         {              if (item == null)             {                 return;             }             else             {                 if(item.@type == 'ClusterComputeResource')                 {                     item.@checked = checked;                 }                 item.@checked = checked;                 toggleParents(tree.getParentItem(item), tree, checked);             }         } </code></pre>