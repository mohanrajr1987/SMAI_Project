<p>I want to compute a lazy sequence of primes.</p>  <p>Here is the interface:</p>  <pre><code>user=&gt; (take 10 primes) (2 3 5 7 11 13 17 19 23 29) </code></pre>  <p>So far, so good.</p>  <p>However, when I take 500 primes, this results in a stack overflow.</p>  <pre><code>                  core.clj:  133  clojure.core/seq                   core.clj: 2595  clojure.core/filter/fn               LazySeq.java:   40  clojure.lang.LazySeq/sval               LazySeq.java:   49  clojure.lang.LazySeq/seq                    RT.java:  484  clojure.lang.RT/seq                   core.clj:  133  clojure.core/seq                   core.clj: 2626  clojure.core/take/fn               LazySeq.java:   40  clojure.lang.LazySeq/sval               LazySeq.java:   49  clojure.lang.LazySeq/seq                  Cons.java:   39  clojure.lang.Cons/next               LazySeq.java:   81  clojure.lang.LazySeq/next                    RT.java:  598  clojure.lang.RT/next                   core.clj:   64  clojure.core/next                   core.clj: 2856  clojure.core/dorun                   core.clj: 2871  clojure.core/doall                   core.clj: 2910  clojure.core/partition/fn               LazySeq.java:   40  clojure.lang.LazySeq/sval               LazySeq.java:   49  clojure.lang.LazySeq/seq                    RT.java:  484  clojure.lang.RT/seq                   core.clj:  133  clojure.core/seq                   core.clj: 2551  clojure.core/map/fn               LazySeq.java:   40  clojure.lang.LazySeq/sval               LazySeq.java:   49  clojure.lang.LazySeq/seq                    RT.java:  484  clojure.lang.RT/seq                   core.clj:  133  clojure.core/seq                   core.clj: 3973  clojure.core/interleave/fn               LazySeq.java:   40  clojure.lang.LazySeq/sval </code></pre>  <p>I'm wondering what is the problem here and, more generally, when working with lazy sequences, how should I approach this class of error?</p>  <p>Here is the code.</p>  <pre><code>(defn assoc-nth   "Returns a lazy seq of coll, replacing every nth element by val    Ex:   user=&gt; (assoc-nth [3 4 5 6 7 8 9 10] 2 nil)   (3 nil 5 nil 7 nil 9 nil)   "   [coll n val]   (apply concat          (interleave           (map #(take (dec n) %) (partition n coll)) (repeat [val]))))  (defn sieve   "Returns a lazy seq of primes by Eratosthenes' method    Ex:   user=&gt; (take 4 (sieve (iterate inc 2)))   (2 3 5 7)    user=&gt; (take 10 (sieve (iterate inc 2)))   (2 3 5 7 11 13 17 19 23 29)   "   [s]   (lazy-seq    (if (seq s)      (cons (first s) (sieve                       (drop-while nil? (assoc-nth (rest s) (first s) nil))))      [])))  (def primes   "Returns a lazy seq of primes    Ex:   user=&gt; (take 10 primes)   (2 3 5 7 11 13 17 19 23 29)   "   (concat [2] (sieve (filter odd? (iterate inc 3))))) </code></pre>