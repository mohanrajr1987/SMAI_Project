<p>I have two unidirectional <code>core.async</code> channels :</p>  <ul> <li>channel out can only <code>put!</code></li> <li>channel in can only <code>take!</code></li> </ul>  <p>And since this is ClojureScript the blocking operations are not available. I would like to make one bidirectional (in-out) channel out of those two (in and out).</p>  <pre><code>  (def in (async/chan))   (def out (async/chan))   (def in-out (io-chan in out)) ;; io or whatever the solution is    (async/put! in "test")   (async/take! ch (fn [x] (println x))) ;; should print "test"   (async/put! ch) ;; put into ch is equivalent to putting into `out` </code></pre>  <p>I tried something like the following (not working) :</p>  <pre><code>(defn io-chan [in-ch out-ch]   (let [io (chan)]     (go-loop []       (&gt;! out-ch (&lt;! io ))       (&gt;! io (&lt;! in-ch))       (recur))     io)) </code></pre>  <p>A schema might help :</p>  <pre><code>    out                              in-out  ---------------&gt; (unused)           &lt;---------------             &lt;---------------     in ----------------&gt;             ----------------&gt; &lt;---------------- (unused) </code></pre>  <p>Also, closing the bidirectional channel should close both underlying channels.</p>  <p>Is is possible ?</p>