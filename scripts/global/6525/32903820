<p>I want to map a large number of tuples. My map looks something like:</p>  <pre><code>{[1 2] :thing} </code></pre>  <p>Except there may be a few million of them. I have a feeling that a tree-map <em>might</em> be a good thing to test so I'm trying to get it working. I can't seem to get the comparison function right though.</p>  <pre><code>(defn compare    [[x y] [xx yy]]   (cond    (and (= x xx) (= y yy)) 0    (and (&lt;= x xx) (&lt;= y yy)) -1    (and (&lt;= x xx) (&gt; y yy)) -1    (and (&gt; x xx) (&lt;= y yy)) 1    (and (&gt; x xx) (&gt; y yy)) 1)) </code></pre>  <p>Some trivial inputs seem to work</p>  <pre><code>user=&gt; (compare [1 1] [1 1]) 0 user=&gt; (compare [1 1] [2 2]) -1 user=&gt; (compare [1 2] [2 1]) -1 user=&gt; (compare [2 1] [1 2]) 1 </code></pre>  <p>But if I create inputs that cover all combinations, the map should consider them all different. </p>  <pre><code>(def inputs     "All tuples of [0-4, 5-10]."     (clojure.math.combinatorics/cartesian-product       (range 0 4)        (range 5 10)))  (def input-pairs      "All possible pairs of tuples"      (clojure.math.combinatorics/cartesian-product inputs inputs)) </code></pre>  <p>If I test the comparison function, it returns zero <em>only</em> when the two vectors are structurally identical. </p>  <pre><code>user=&gt; (doseq [[a b] input-pairs]   #_=&gt;   (when (zero? (compare a b)) (prn a b))) (0 5) (0 5) (0 6) (0 6) (0 7) (0 7) (0 8) (0 8) (0 9) (0 9) (1 5) (1 5) etc </code></pre>  <p><strong>So</strong> I think my compare function is correct. Using it in the treemap, however, gives some strange results:</p>  <pre><code>(def inputs-kvs     "Inputs in the format that the hash-map and sorted-map constructor understand"     (mapcat #(vector % (apply str %))             (clojure.math.combinatorics/cartesian-product               (range 0 4)                (range 5 10)))) </code></pre>  <p>Putting these in a hashmap gives the correct answer</p>  <pre><code>(count (apply assoc (hash-map) inputs-kvs)) =&gt; 20 </code></pre>  <p>But putting them in the treemap with the given comparison:</p>  <pre><code>(def structure (sorted-map-by compare)) (count (apply assoc structure inputs-kvs)) =&gt; 4  (apply assoc structure inputs-kvs) =&gt; {(0 5) "25", (1 6) "36", (2 7) "37", (3 5) "39"} </code></pre>  <p>"25" has been stored in the <code>(0 5)</code> slot. But the compare function doesn't say that <code>(0 5)</code> and <code>(2 5)</code> are the same:</p>  <pre><code>=&gt; (compare [0 5] [2 5]) -1 </code></pre>  <p>What am I doing wrong? Can I make this work? Is it even meaningful to project a 2-dimensional space onto a 1-dimensional one?</p>  <p>(To head off a question you may have, yes I've tried a 2-dimensional structure, e.g. <code>(sorted-map 1 (sorted-map 2 :value))</code>, but I'm trying to find alternatives with better performance)</p>