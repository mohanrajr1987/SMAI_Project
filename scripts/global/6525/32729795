<p>I'm representing a tree</p>  <pre><code>     A     / \    B   C   /\      D  E     </code></pre>  <p>like <code>[A [B [D] [E]] [C]]</code> in a clojure vector. I need to use breadth first search to find the shortest path to a goal. My actual vector looks like this -</p>  <pre><code>["33L" ["32R" ["31L" ["30R" [false]] ["11R" ["01L" ["00R" [true]]] ["00L" [false]]]] ["30L" [false]] ["22L" ["11R" ["01L" ["00R" [true]]] ["00L" [false]]] ["02R" ["01L" ["00R" [true]]] ["00L" [false]]]]] ["31R" ["30L" [false]] ["11L" ["01R" ["00L" [false]]] ["00R" [true]]]] ["22R" ["11L" ["01R" ["00L" [false]]] ["00R" [true]]] ["02L" ["01R" ["00L" [false]]] ["00R" [true]]]]] </code></pre>  <p>All the nodes that end with a true are the ones I'm interested in. There are multiple nodes that end with true. I need to find the shortest path from "33L" which is the first node to the true node. For e.g If you look at the tree at the top and assume D is true and C is true. The shortest path from A that would lead me to a true node is A -> C</p>  <p>I figured out how to print all the nodes like they're being searched using a breadth first algorithm.</p>  <pre><code>(defn bfs [&amp; nodes]     (if (seq nodes)         (concat (map first nodes)             (apply bfs (apply concat (map rest nodes)))))) </code></pre>  <p>Running it on my tree gives me - </p>  <pre><code>("33L" "32R" "31R" "22R" "31L" "30L" "22L" "30L" "11L" "11L" "02L" "30R" "11R" false "11R" "02R" false "01R" "00R" "01R" "00R" "01R" "00R" false "01L" "00L" "01L" "00L" "01L" "00L" "00L" true "00L" true "00L" true "00R" false "00R" false "00R" false false false false true true true) </code></pre>  <p>which is exactly how a breadth first search would skim through the entire data set. However, I can't figure out how I'd find and print the shortest path to a true node. Before you ask me, I've already looked at other breadth first algorithms on stack overflow. </p>  <p>Update:</p>  <p>I've looked at clojure zipper and it solves my problem. However, it's depth first and I need something that's breadth first. Is there a way I could use the z/down, z/left, z/right functions to create a breadth first wrapper around it?</p>