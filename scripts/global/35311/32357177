<p>I have a .NET (3.5) WCF application running in IIS 7.5 which is used by client devices frequently. The application pool used by the service is configured to recycle once a day and usually the recycle is smooth with no problems. However there has been a couple incidents where we have perpetual occurances of <strong>System.Reflection.TargetInvocationException</strong> immediately after the recycle event. It is obvious from the stack trace that it is caused by accessing an XSD which is used as an <strong>Embedded Resource</strong> and loaded using <strong>reflection</strong>. The base class and the stacktrace are as follows. If anyone has a clue please point me in the right direction.</p>  <pre><code>System.Reflection.TargetInvocationException: Exception has been thrown by the target of an invocation. ---&gt; System.Xml.XmlException: SchemaVersion MUST be present, with a fixed value, on the root element in the XSD definition: Varan.Core_Objects.Validator.AuthenticationValidator    at Varan.Utils.Validation.XmlValidator.GetSchemaVersion()    at Varan.Utils.Validation.XmlValidator.HandleVersioning(XDocument xDocument)    at Varan.Utils.Validation.XmlValidator.Validate(XDocument xDocument) </code></pre>  <p>The XmlValidator class:</p>  <pre><code>public abstract class XmlValidator : IValidator&lt;XDocument&gt; {     public static bool PerformValidation = true;     private readonly XmlQualifiedName schemaVersionName = new XmlQualifiedName("SchemaVersion");     private IXmlUpgrade cacheXmlUpgrade;     private XmlSchemaSet schema;      protected virtual bool IsNullAllowed     {         get { return false; }     }      #region IValidator&lt;XDocument&gt; Members      public void Validate(XDocument xDocument)     {         if (!PerformValidation)         {             return;         }         if (xDocument == null)         {             if (IsNullAllowed)             {                 return;             }             else             {                 throw new XmlException("XML document is null");             }         }         GetCachedSchema();         HandleVersioning(xDocument);         xDocument.Validate(schema, (sender, e) =&gt; { throw e.Exception; });     }      #endregion      private void HandleVersioning(XDocument xDocument)     {         // Sort out versioning.         // If there is no version currently applied, then auto-apply the current version.         // If there is an old version currently applied, then auto-transform to the new version         XElement root = xDocument.Root;         XAttribute versionAttr = root.Attribute("SchemaVersion");         int currentVersion = GetSchemaVersion();         if (versionAttr == null)         {             // No current version             root.Add(new XAttribute("SchemaVersion", currentVersion));         }         else         {             // Currently versioned - upgrade if required.             var xmlVersion = (int) versionAttr;             if (xmlVersion &lt; currentVersion)             {                 // Auto-upgrade XML.                 UpgradeXml(xDocument, xmlVersion, currentVersion);                 root.SetAttributeValue("SchemaVersion", currentVersion);             }             else if (xmlVersion &gt; currentVersion)             {                 // Version is too high, error.                 throw new InvalidOperationException("XML version is larger than the current version.");             }         }     }      private void UpgradeXml(XDocument xDocument, int transformFromVersion, int transformToVersion)     {         IXmlUpgrade upgrade = GetCachedXmlUpgrade();         upgrade.XmlUpgrade(xDocument, transformFromVersion, transformToVersion);     }      private IXmlUpgrade GetCachedXmlUpgrade()     {         if (cacheXmlUpgrade == null)         {             // Find the upgrade class             Type upgradeType = GetType();             foreach (Assembly assm in AppDomain.CurrentDomain.GetAssemblies())             {                 if (assm.GlobalAssemblyCache)                 {                     continue;                 }                 try                 {                     foreach (Type type in assm.GetTypes())                     {                         var attr = type.GetAttribute&lt;XmlUpgradeAttribute&gt;(false);                         if (attr != null)                         {                             if (attr.XmlValidatorType == upgradeType)                             {                                 // Found the correct type                                 cacheXmlUpgrade = (IXmlUpgrade) Activator.CreateInstance(type);                                 goto found;                             }                         }                     }                 }                 catch                 {                 }             }             throw new NotSupportedException("Cannot find XML schema upgrade class for type: " + upgradeType);         }         found:         return cacheXmlUpgrade;     }      private int GetSchemaVersion()     {         try         {             XmlSchemaElement rootElement = schema.GlobalElements.Values.OfType&lt;XmlSchemaElement&gt;()                 .Where(x =&gt; x.QualifiedName.Namespace.IsEmpty())                 .Single();             var rootType = (XmlSchemaComplexType) rootElement.ElementSchemaType;             var schemaVersionAttr = (XmlSchemaAttribute) rootType.AttributeUses[schemaVersionName];             int currentVersion = int.Parse(schemaVersionAttr.FixedValue);             return currentVersion;         }         catch (Exception)         {             throw new XmlException(                 "SchemaVersion MUST be present, with a fixed value, on the root element in the XSD definition: " +                 GetType());         }     }      private XmlSchemaSet GetCachedSchema()     {         if (schema == null)         {             schema = GetSchema(null);             if (schema == null)             {                 throw new XmlException("Invalid XML schema");             }             schema.Compile();         }         return schema;     }      protected void CreateXmlResolver(XmlSchemaSet schemaSet, ResourceInformation schemaInfo)     {         schemaSet.XmlResolver = new XmlResourceResolver(schemaInfo);     }      protected virtual XmlSchemaSet GetSchema(XDocument xDocument)     {         ResourceInformation schemaInfo = GetSchemaInformation();         Stream schemaStream = schemaInfo.Assembly.GetManifestResourceStream(schemaInfo.ResourceName);         var schemaSet = new XmlSchemaSet();         CreateXmlResolver(schemaSet, schemaInfo);         XmlReader xsd = XmlReader.Create(schemaStream);         schemaSet.Add("", xsd);         return schemaSet;     }      protected virtual ResourceInformation GetSchemaInformation()     {         throw new NotImplementedException("This function must be overridden");     }      #region Nested type: XmlResourceResolver      private class XmlResourceResolver : XmlResolver     {         private readonly Assembly assembly;         private readonly string baseNamespace;          public XmlResourceResolver(ResourceInformation parentInfo)         {             assembly = parentInfo.Assembly;             string[] parts = parentInfo.ResourceName.Split('.');             baseNamespace = string.Join(".", parts.Take(parts.Length - 2).ToArray());         }          public override ICredentials Credentials         {             set { }         }          public override object GetEntity(Uri absoluteUri, string role, Type ofObjectToReturn)         {             string xsdName = absoluteUri.Segments[absoluteUri.Segments.Length - 1];             Stream xsd = assembly.GetManifestResourceStream(baseNamespace + "." + xsdName);             return xsd;         }     }      #endregion } </code></pre>