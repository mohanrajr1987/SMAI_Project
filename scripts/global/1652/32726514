<p>I have a an application from which I need to send live updates to web clients. </p>  <p>I'm currently happily using websockets for that, via the <a href="http://wamp.ws/" rel="nofollow">WAMP</a> protocol, as it provides both <strong>publish-subscribe</strong> and <strong>RPC</strong> methods.</p>  <p>Now, I find that in lots of situations, when a user starts the application or a view, I need to send an initial state to the client, and then keep sending updates. I do the first with an RPC call, and the latter via publish-subscribe. </p>  <p>Now, this forces me to write server-side and client-side code for both of the methods, even while I'm basically conveying the same information in both cases.</p>  <p>On server side, I'm moving appropriate code to a common method, but I still need to take care of both sending the event and provide an entry point for the RPC call:</p>  <pre><code># RPC endpoint for getting mission info def get_mission_info(self):     return self.get_mission_info()  # Scheduled or manually called method to send mission info to all users def publish_mission_info(self):     self.wamp.publish("UPDATE_INFO", [self.get_mission_info()])  def get_mission_info(self):     # Here we generate a JSON serializable dict with the info     return info </code></pre>  <p>And you canimagine, client side (JS or Python) shows a similar duplicity (two handler methods).</p>  <p>Question is: is there a more clever way of handling this, and avoiding that boilerplate code? Some approach I could follow, perhaps automatically sending last event of each type just to clients that ask for it, or that just subscribed? Perhaps something at crossbar level?</p>  <p>In general terms, I feel I could be doing a better state synchronization strategy leveraging these two channels (pub-sub and RPC). How does people do it?</p>  <p>My WAMP server is <a href="http://crossbar.io/" rel="nofollow">Crossbar</a>, and my client library is <a href="http://autobahn.ws" rel="nofollow">autobahn.js</a> in Python and JS.</p>