<p>I have this scenrio:</p>  <pre><code>private static final Map&lt;String, Boolean&gt; availables = new HashMap&lt;String, Boolean&gt;(); </code></pre>  <p><strong>1 single Thread keep  getting an available task and distribute it among worker (let's call it distributor)</strong></p>  <pre><code>public static String getAnAvailable() {      synchronized (availables){          for(Map.Entry&lt;String, Boolean&gt; entry : availables.entrySet()){             if(entry.getValue() == true){                 entry.setValue(false);                 return entry.getKey();             }         }      }      return null; } </code></pre>  <p><strong>1 single Thread run this code (let's call it Updater):</strong></p>  <pre><code>while(true){   ...   synchronized (availables) {       for(String deleteIt : delete){           if(available.containsKey(deleteIt)){               available.remove(deleteIt);           }       }       for(String name : names){           if(!available.containsKey(name)){               available.put(name, true);           }       }   }   ... } </code></pre>  <p>I tried to use <code>ConcurrentHashMap</code> instead of manual <code>synchronization</code> but it can <code>throw Exception</code> in <code>getAnAvailable</code> method, the reason is obvious, because if updater thread changes the size of the map then within getAnAvailable we get iteration exception. so no point of using that.</p>  <p>now my problem is that for some reason <code>Updater</code> starves indefinitely on exactly the third run...  basically it gets stock when it tries to acquire the <code>luck</code>.</p>  <p>for the life of me I have no idea why that happens. can anyone see something that I don't see here?</p>