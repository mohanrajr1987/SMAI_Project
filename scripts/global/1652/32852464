<p>If we have 2 classes that operate on the same object under different threads and we want to avoid race conditions, we'll have to use  synchronized blocks with the same monitor like in the example below:</p>  <pre><code>class A {     private DataObject mData; // will be used as monitor      // thread 3     public setObject(DataObject object) {        mData = object;     }      // thread 1     void operateOnData() {         synchronized(mData) {             mData.doSomething();             .....             mData.doSomethingElse();         }     } }    class B {     private DataObject mData;  // will be used as monitor      // thread 3     public setObject(DataObject object) {        mData = object;     }      // thread 2     void processData() {         synchronized(mData) {             mData.foo();             ....             mData.bar();         }     } } </code></pre>  <p>The object we'll operate on, will be set by calling <code>setObject()</code> and it will <strong>not change</strong> afterwards. We'll use the object as a monitor. However, intelliJ will warn about synchronization on a non-final field. </p>  <p>In this particular scenario, is the non-local field an acceptable solution?</p>  <p>Another problem with the above approach is that it is not guaranteed that the monitor (mData) will be <strong>observed</strong> by thread 1 or thread 2 after it is set by thread 3, because a "happens-before" relationship hasn't been established between setting and reading the monitor. It could be still observed as <code>null</code> by thread 1 for example. Is my speculation correct?</p>  <p>Regarding possible solutions, making the <code>DataObject</code> thread-safe is not an option. Setting the monitor in the constructor of the classes and declaring it <code>final</code> can work.</p>  <p><strong>EDIT</strong> Semantically, the mutual exclusion needed is related to the <code>DataObject</code>. This is the reason that I don't want to have a secondary monitor. One solution would be to add <code>lock()</code> and <code>unlock()</code> methods on <code>DataObject</code> that need to be called before working on it. Internally they would use a <code>Lock</code> Object. So, the <code>operateOnData()</code> method becomes:</p>  <pre><code> void operateOnData() {      mData.lock()      mData.doSomething();      .....      mData.doSomethingElse();      mData.unlock();  } </code></pre>