<p>I'm trying to design a two digit counter the counts between 00 and 99 in a circular fashion both up and down. I have it working for the most part, however, no matter what I try I can't get the decade digit to stay in synch with the first digit. My results right now give me stuff like this:</p>  <p>08 -> 09 -> 00 -> 11 ... 18 -> 19 -> 10 -> 21</p>  <p>and</p>  <p>21 -> 20 -> 29 -> 18 ... 11 -> 10 -> 19 -> 08</p>  <p>From this it seems that the overflow from the first digit is delayed in reaching the decade digit. I've tried several things to try and fix this. The only thing to provide any beneficial result was to add an additional if statement that sent the overflow a state early, but that was only a supperficial fix. If I stopped the counter while the first digit was 8 or 0, and started it again, I'd be back to the same problem as before.</p>  <p>I also tried making an additional 'synchronizer' module, thinking maybe I could set it up, so even though they're out of sync, they'd be displayed as if they were in sync, but it didn't change anything.</p>  <p>I've been working on trying to fix this for over two weeks and I'm at my wits end.</p>  <p>Here's my code for the counter, and the synchronizer if anyone wants to check that out, any and all help is appreciated.</p>  <p>**I'm using VHDL, programming the Zybo Digilent Board with Vivado 2015.2</p>  <p>Counter Module for single digit, the overflow becomes the enable of the decade digit.</p>  <pre><code>library IEEE; use IEEE.STD_LOGIC_1164.all; use ieee.numeric_std.all;  entity counter is     generic(N      : positive := 4);     port(         AR       : in  STD_LOGIC;         clk      : in  STD_LOGIC;         ld       : in  STD_LOGIC;         en       : in  STD_LOGIC;         up_dn    : in  STD_LOGIC;         D        : in  STD_LOGIC_VECTOR(N - 1 downto 0);         overflow : out STD_LOGIC;         Q        : out STD_LOGIC_VECTOR(N - 1 downto 0);         sync_in  : in STD_LOGIC;         sync_out : out STD_LOGIC     ); end counter;  architecture counter of counter is     signal Qt : std_logic_vector(N - 1 downto 0);     signal OvrFlw : std_logic;     signal sync : std_logic;  begin     process(clk, AR)     begin         if (AR = '1') then             Qt       &lt;= (others =&gt; '0');             OvrFlw &lt;= '0';             sync &lt;= sync_in;         elsif (clk = '1' and clk'event) then             if ld = '1' then                 Qt &lt;= D;                 sync &lt;= sync_in;             elsif en = '1' then                 if up_dn = '0' then     -- if counting down                     if (unsigned(Qt) = 0) then                         Qt       &lt;= "1001";--(others =&gt; '1');                         OvrFlw &lt;= '1';                         sync &lt;= sync_in and en;                     --elsif (unsigned(Qt) = 1) then                     --    Qt       &lt;= std_logic_vector(unsigned(Qt) - 1);                     --    OvrFlw &lt;= '1';                     else                         Qt       &lt;= std_logic_vector(unsigned(Qt) - 1);                         OvrFlw &lt;= '0';                         sync &lt;= sync_in and en;                     end if;                 else                    -- if counting up                     if (unsigned(Qt) = 2**N-7) then                         Qt       &lt;= (others =&gt; '0');                         OvrFlw &lt;= '1';                         sync &lt;= sync_in and en;                     --elsif (unsigned(Qt) = 2**N-8) then                     --    Qt       &lt;= std_logic_vector(unsigned(Qt) + 1);                     --    OvrFlw &lt;= '1';                     else                         Qt       &lt;= std_logic_vector(unsigned(Qt) + 1);                         OvrFlw &lt;= '0';                         sync &lt;= sync_in and en;                     end if;                 end if;             end if;         end if;     end process;      sync_out &lt;= sync;     Q &lt;= Qt;     overflow &lt;= OvrFlw; end counter; </code></pre>  <p>Here's the code for the synchronizer I tried to put together. Don't know if it's really relevant but I thought I'd put it up just in case.</p>  <pre><code>library IEEE; use IEEE.STD_LOGIC_1164.ALL;  entity Synchronizer is     generic(N      : positive := 4);     Port (             MSB_Sync : in  STD_LOGIC;           LSB_Sync : in  STD_LOGIC;           MSB_Q    : in  STD_LOGIC_VECTOR(N-1 downto 0);           LSB_Q    : in  STD_LOGIC_VECTOR(N-1 downto 0);           MSB_Out  : out STD_LOGIC_VECTOR(N-1 downto 0);           LSB_Out  : out STD_LOGIC_VECTOR(N-1 downto 0)); end Synchronizer;  architecture Behavioral of Synchronizer is  begin process (MSB_Sync, LSB_Sync)     begin     if ((MSB_Sync and LSB_Sync) = '1') then         MSB_Out &lt;= MSB_Q;         LSB_Out &lt;= LSB_Q;     end if; end process;  end Behavioral; </code></pre>