<p>I try to synchronize 3 child process (named "1", "2" and "3") created by father process using Semaphore.In father process, user input 1 string as :<strong>MP count hello text1.txt text2.txt text3.txt</strong>.(MP : multi process).after that,father process will create 3 child process to find the number of occurrences "hello" in text1.txt , text2.txt and text3.txt.i have done father process and child process, it work ok,but when print results,the number of occurrences was shuffled,results like wrong, i tried to find some way to use semarphore synchronize 3 child process but failed.you can give me a simple code  of synchronize 3 child process?and where i need put this code to?(in child process).I'm vietnamese,my English is not good,sorry about that. Thank you so much. My last output was:</p>  <pre><code>appear :C4nnot open file!    times! apprear : 6 times! </code></pre>  <p>Here is my code:</p>  <p>father code :</p>  <pre><code>#include &lt;iostream&gt; #include &lt;string&gt; #include &lt;tchar.h&gt;  using namespace std;  HANDLE *proc;     int _tmain(int argc, TCHAR *argv[]){      if (argc &lt;4){         cout &lt;&lt; "wrong command !\n";         cout &lt;&lt; "standard command :MP count &lt;chuoi&gt; &lt;text1.txt&gt; &lt;text2.txt&gt;";         return 0;     }       STARTUPINFO *s = new STARTUPINFO[argc-3];     PROCESS_INFORMATION *p = new PROCESS_INFORMATION[argc-3];     int temp=3;     int count_proc =0;  //count how many file text to do : new HANDLE[so_luong_file_text];       while(temp!=argc)     {         count_proc++;         temp++;     }     proc = new HANDLE[count_proc]; //start s va p     temp=3;      while(temp!=argc)     {         ZeroMemory(&amp;s[temp-3],sizeof(s[temp-3]));         s[temp-3].cb=sizeof(s[temp-3]);         ZeroMemory(&amp;p[temp-3],sizeof(p[temp-3]));         temp++;     } //create child process ( Multi Process )         temp=3;         string space=" ";         string find_command_line;         for(int i=3;temp!=argc;i++,temp++)             {                 find_command_line.erase(0,100); //find correctly command line after that create child process i-1                                for (int j=1;j&lt;=i;j++)                 {                     if(j==1 || j==2)                     {                         find_command_line=find_command_line+argv[j]+space;                     }                     if(j==i)                     {                         find_command_line+=argv[j];                     }                 }                  TCHAR *Tfind_command_line=new TCHAR[find_command_line.size()+1];                 Tfind_command_line[find_command_line.size()]=0;                 copy(find_command_line.begin(),find_command_line.end(),Tfind_command_line);                   CreateProcess(NULL,(TCHAR*)(Tfind_command_line),NULL,NULL,FALSE,0,                       NULL,NULL,&amp;s[temp-3],&amp;p[temp-3]);               }    //take handle of child process build to array proc handle     temp=3;     while(temp!=argc)     {         proc[temp-3]=p[temp-3].hProcess;         temp++;     }  //father process wait n=temp-2 child process work done.     WaitForMultipleObjects(argc-3,proc,TRUE,INFINITE); /*CODE BY DUYDO*/ //release handles        temp=3;     while(temp!=argc)     {         CloseHandle(p[temp-3].hProcess);         CloseHandle(p[temp-3].hThread);         temp++;     }      return 0; } </code></pre>  <p>child process :</p>  <pre><code>#include &lt;pthread.h&gt; #include &lt;windows.h&gt;  using namespace std;      int Count_String(string s1,string s2); void converted_into_ordinary_characters(); bool OpenFile(fstream &amp;file, char *name);     int main(int argc, char* argv[]){      fstream dataFile;         if (argc &lt;3){     cout &lt;&lt; "wrong command !\n";     cout &lt;&lt; "standard command :MP count &lt;chuoi&gt; &lt;text1.txt&gt; &lt;text2.txt&gt;";     return 0;     }      if(!OpenFile(dataFile, argv[2]))      {      cout &lt;&lt; "cannot open file !\n";      return 0;      }     else     {          int count_text1 = 0;           ifstream t(argv[2]);         string str((istreambuf_iterator&lt;char&gt;(t)),         istreambuf_iterator&lt;char&gt;());            count_text1 = Count_String(str,argv[1]);           cout &lt;&lt; "appear :" &lt;&lt; count_text1 &lt;&lt; " times !" &lt;&lt;endl;           t.close();      }       dataFile.close();     return 0; }  bool OpenFile(fstream &amp;file, char *name)  {      file.open(name, ios::in);      if(file.fail())          {             file.close();             return false;           }     else          {             file.close();             return true;          } }   void converted_into_ordinary_characters(string str) {     transform(str.begin(), str.end(), str.begin(), ::tolower);   }  int Count_String(string s1,string s2) {     int ns1=s1.length();     int ns2=s2.length();     int i=0,j,k;     int count =0;     converted_into_ordinary_characters(s1);     converted_into_ordinary_characters(s2);      while(s1[i]!='\0')     {         k=i;         j=0;         while(s1[k]==s2[j])         {             k++;             j++;         }         if(j==ns2)         {             count +=1;           }     i++;     }     return count; } </code></pre>