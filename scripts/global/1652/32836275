<p>We increment checkedOut variable when a connection is get and decrement when a connection is freed. </p>  <blockquote>   <p>I figured out that the checkedOut variable gets the neagtive value   and using this class i found that multiple threads are trying to get   the same connection object. where is the problem in this class?</p> </blockquote>  <pre><code>class DBConnectionManager{   private Hashtable pools = new Hashtable();   public void freeConnection(String name, Connection con)      {          DBConnectionPool pool = (DBConnectionPool) pools.get(name);         if (pool != null)          {             pool.freeConnection(con);         }         else         {             log("Error: In Freeing Connection pool is null.");         }     }  public Connection getConnection(String name)      {         DBConnectionPool pool = (DBConnectionPool) pools.get(name);          if (pool != null)          {             return pool.getConnection();         }         else         {             log("Error: In Calling for Connection pool is null.");         }         return null;     }  public Connection getConnection(String name, long time)      {          DBConnectionPool pool = (DBConnectionPool) pools.get(name);         if (pool != null)          {             return pool.getConnection(time);         }         else         {             log("Error: In Calling for Connection with time stamp pool is null.");         }          return null;     }      class DBConnectionPool {                 private int checkedOut;                 private Vector freeConnections = new Vector();             public synchronized void freeConnection(Connection con) {                 if (con == null) {                     return;                 }                 freeConnections.addElement(con);                 checkedOut--;                 log("FreeConnection is called, No checkout connection: " + checkedOut + " , No of connection in FreePool :" + freeConnections.size());                 notifyAll();             }              public synchronized Connection getConnection() {                 Connection con = null;                 if (freeConnections.size() &gt; 0){                         con = (Connection) freeConnections.firstElement();                     freeConnections.removeElementAt(0);                     if (!isAlive(con)){                         log("Removed bad connection from " + name);                         con = getConnection();                     }                 }                 else if (maxConn == 0 || checkedOut &lt; maxConn) {                     con = newConnection();                 }                 if (con != null) {                     checkedOut++;                 }                 log("No of checkout connection :" + checkedOut);                 return con;             }         public synchronized Connection getConnection(long timeout) {                 long startTime = new Date().getTime();                 Connection con;                 while ((con = getConnection()) == null) {                     try {                         wait(timeout);                     } catch (InterruptedException e) {            }                     if ((new Date().getTime() - startTime) &gt;= timeout) {                         return null;                     }                 }                 return con;             }             private Connection newConnection() {                 Connection con = null;                 try {                     if (user == null) {                         con = DriverManager.getConnection(URL);                     } else {                         con = DriverManager.getConnection(URL, user, password);                     }                 } catch (SQLException e) {                     e.printStackTrace();                     log(e, "Can't create a new connection for " + URL);                     return null;                 }                 return con;             }         } } </code></pre>