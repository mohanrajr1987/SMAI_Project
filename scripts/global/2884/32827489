<p>I have such method: </p>  <pre><code>@Transactional     @PUT     @Path("/{servicePointNumber : \\d+}")     @Produces({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML})     public Response updateServicePoint( @PathParam("userId") Long userId,                                         @PathParam("servicePointNumber") Integer servicePointNumber,                                         ServicePoint servicePoint,                                         @BeanParam GenericBeanParam params) throws ForbiddenException, UnprocessableEntityException, InternalServerErrorException {          if(params.getAuthToken() == null) throw new ForbiddenException("Unauthorized access to web service.");         logger.log(Level.INFO, "updating existing Service Point by executing ProviderResource.ServicePointResource.updateServicePoint(servicePoint) method of REST API");          // set resource ID passed in path param on updated resource object         Provider foundProvider = providerFacade.find(userId);         servicePoint.setProvider(foundProvider);         servicePoint.setServicePointNumber(servicePointNumber);          ServicePoint updatedServicePoint = null;         try {             // reflect updated resource object in database             updatedServicePoint = servicePointFacade.update(servicePoint);             // populate created resource with hypermedia links             pl.salonea.jaxrs.ServicePointResource.populateWithHATEOASLinks(updatedServicePoint, params.getUriInfo());          } catch (EJBTransactionRolledbackException ex) {             ExceptionHandler.handleEJBTransactionRolledbackException(ex);         } catch (EJBException ex) {             ExceptionHandler.handleEJBException(ex);         } catch(Exception ex) {             throw new InternalServerErrorException(ExceptionHandler.ENTITY_UPDATE_ERROR_MESSAGE);         }          return Response.status(Status.OK).entity(updatedServicePoint).build();     } </code></pre>  <p>And this method is defined inside <strong>ServicePointResource</strong> class of JAX-RS layer. This is inner class of <strong>ProviderResource</strong> class.  The problem here is that the code throws exception: </p>  <pre><code>Transaction aimed at persisting entity instance has been rolled back: detached entity passed to persist: pl.salonea.entities.Provider </code></pre>  <p>Provider is @ManyToOne association with ServicePoint and moreover Provider ID is part of ServicePoint composite Primary Key. </p>  <p>If I move this part: </p>  <pre><code>// set resource ID passed in path param on updated resource object             Provider foundProvider = providerFacade.find(userId);             servicePoint.setProvider(foundProvider);             servicePoint.setServicePointNumber(servicePointNumber);              ServicePoint updatedServicePoint = null;             try {                 // reflect updated resource object in database                 updatedServicePoint = servicePointFacade.update(servicePoint); </code></pre>  <p>to external EJB class that is @Stateless session bean and has default Transaction Management of type REQUIRED this will update correctly and error with detach method doesn't appear. <strong>So I suppose this @Transactional annotation demarcation on above method has no effect and doesn't work!</strong></p>