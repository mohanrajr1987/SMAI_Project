<p>I have not been able to find a satisfactory explanation as to why calling GC.Collect before a large <em>unmanaged</em> allocation (in my case, before creating a large (~250Mb) DirectX resource) prevents an out-of-memory exception.  Why does a compaction of the managed heap allow an unmanaged allocation?  </p>  <p>How does a .Net process share its address space between the managed and unmanaged heaps?</p>  <p>My best guess is the .Net process maintains a moveable boundary between the two types of heap and GC.Collect allows that boundary to move in favour of a larger unmanaged heap.  Something like this:</p>  <ul> <li>(M)anaged allocations </li> <li>(U)nmanaged allocations </li> <li>(F)ree memory </li> <li>Process address space 0-9</li> </ul>  <p><strong><em>Scenario #1 – no GC.Collect</em></strong></p>  <p>About to make unmanaged allocation of 3 blocks, managed heap fragmented:</p>  <pre><code>0123456789 MMFFMFFMFU </code></pre>  <p>"High-water mark" of managed heap at 7</p>  <p>Allocate 3 unmanaged blocks – <strong>fails!</strong> Note high-water mark of managed heap leaves no space for the unmanaged allocation.</p>  <p><strong><em>Scenario #2 – with GC.Collect</em></strong></p>  <p>About to make unmanaged allocation of 3 blocks, managed heap fragmented</p>  <pre><code>0123456789 MMFFMFFMFU </code></pre>  <p>"High water mark" of managed heap at 7</p>  <p>Call GC.Collect</p>  <pre><code>0123456789 MMMMFFFFFU </code></pre>  <p>"High water mark" of managed heap at 3</p>  <p>Allocate 3 unmanaged blocks – <strong>succeeds!</strong></p>  <pre><code>0123456789 MMMMFFUUUU </code></pre>  <p>Is this how it works?</p>