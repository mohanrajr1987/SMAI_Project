<p>I have a scenario which uses a C library using JNA:<br> I have override the finalize method where I send the call to delete the object that is created through C.<br> My code looks somewhat like this:  </p>  <pre><code>protected void finalize() throws Throwable     {         if (LicensingAPIHelper.instance == null)             throw new NullPointerException("LicensingAPIHelper is not initialized");                    LicensingAPIHelper.instance.sntl_licensing_app_context_delete(nativeAppContext.getValue());     } </code></pre>  <p><code>sntl_licensing_app_context_delete</code> is the API, which deletes the object created in the C library.<br> <code>nativeAppContext</code> is PointerByReference and <code>nativeAppContext.getValue()</code> sends the pointer of the object to be deleted.<br> What is happening right now is, when GC is called a crash occurs because the <code>nativeAppContext</code> reference is cleaned first by GC and since it does not find any reference so when it tries to get the value for sending to C library it crashes.  </p>  <p>Is there any way to enforce GC to call finalize method first before cleaning up the objects?  </p>  <p>In this case, I assume GC cleans up the object first and then calls the <code>finalize</code> method.</p>