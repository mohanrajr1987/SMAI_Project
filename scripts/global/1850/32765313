<p>I have that Haskell function, that's causing more than 50% of all the allocations of my program, causing 60% of my run time to be taken by the GC. I run with a small stack (<code>-K10K</code>) so there is no stack overflow, but can I make this function faster, with less allocation?</p>  <p>The goal here is to calculate the product of a matrix by a vector. I cannot use <a href="http://hackage.haskell.org/package/hmatrix" rel="nofollow"><code>hmatrix</code></a> for example because this is part of a bigger function using the <a href="https://hackage.haskell.org/package/ad" rel="nofollow"><code>ad</code> Automatic Differentiation</a> package, so I need to use lists of <code>Num</code>. At runtime I suppose the use of the <code>Numeric.AD</code> module means my types must be <code>Scalar Double</code>.</p>  <pre><code>listMProd :: (Num a) =&gt; [a] -&gt; [a] -&gt; [a] listMProd mdt vdt = go mdt vdt 0   where     go [] _  s = [s]     go ls [] s = s : go ls vdt 0     go (y:ys) (x:xs) ix = go ys xs (y*x+ix) </code></pre>  <p>Basically we loop through the matrix, multiplying and adding an accumulator until we reach the end of the vector, storing the result, then continuing restarting the vector again. I have a <code>quickcheck</code> test verifying that I get the same result than the matrix/vector product in hmatrix.</p>  <p>I have tried with <code>foldl</code>, <code>foldr</code>, etc. Nothing I've tried makes the function faster (and some things like <code>foldr</code> cause a space leak).</p>  <p>Running with profiling tells me, on top of the fact that this function is where most of the time and allocation is spent, that there are loads of <a href="https://hackage.haskell.org/package/ad-4.2.4/docs/Numeric-AD-Internal-Reverse.html#t:Cells" rel="nofollow"><code>Cells</code></a> being created, <code>Cells</code> being a data type from the <code>ad</code> package.</p>  <p>A simple test to run:</p>  <pre><code>import Numeric.AD  main = do     let m :: [Double] = replicate 400 0.2         v :: [Double] = replicate 4 0.1         mycost v m = sum $ listMProd m v          mygrads = gradientDescent (mycost (map auto v)) (map auto m)     print $ mygrads !! 1000 </code></pre>  <p>This on my machine tells me GC is busy 47% of the time.</p>  <p>Any ideas?</p>