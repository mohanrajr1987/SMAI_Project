<p>It seems some update changed GC behavior when built in Debug configuration or with debugger attached:</p>  <pre><code>//Code snippet 1 var a = new object(); var w = new WeakReference(a); a = null;  GC.Collect(); GC.WaitForPendingFinalizers(); GC.Collect(); Console.WriteLine(w.IsAlive ? "Alive" : "Dead"); </code></pre>  <p>Such code used to print <code>Dead</code>, and it was very handy for writing unit-tests checking that certain parts that should be GCed are not being held.</p>  <p>After some .NET 4.x update, this code passes successfully on .NET 2.x and 3.x, but fails on all variants of 4.x. I tried to call it as <code>GC.Collect(2, GCCollectionMode.Forced, blocking: true)</code>, making <code>&lt;gcConcurrent enabled="false"/&gt;</code> in <code>App.config</code> and <code>GCSettings.LatencyMode = GCLatencyMode.Batch</code> - nothing helps. If I run the code without debugger attached and it is built in Release configuration (i.e. with optimizations) - it outputs <code>Dead</code>. Otherwise it is <code>Alive</code>.</p>  <p>I understand that relying on GC is not a good idea in production. But for tests I don't know how to replace ability to check through test that particular code piece does not leak memory. It is pure test assembly, I'm fine with turning some compatibility switches, or something alike. My goal is to check my own code, not the GC optimizations.</p>  <p>Is there a way to force GC to previous behavior somehow?</p>  <p>P.S. I saw almost identical <a href="http://stackoverflow.com/questions/16771249/how-to-force-full-garbage-collection-in-net-4-x">question</a>, but at that time it was related to NCrunch. I don't have it installed. I ran the code even from command line, without VS at all, with the same results.</p>  <hr>  <p><strong>UPD:</strong> I found that if I move code with allocating and setting reference to null into separate method - it consistently outputs <code>Dead</code>, though.</p>  <pre><code>//Code snippet 2 internal class Program {     private static void Main(string[] args)     {         var w = DoWorkAndGetWeakRef();          GC.Collect();         GC.WaitForPendingFinalizers();         GC.Collect();         Console.WriteLine(w.IsAlive ? "Alive" : "Dead");         Console.ReadLine();     }      private static WeakReference DoWorkAndGetWeakRef()     {         var a = new object();         var w = new WeakReference(a);         a = null;         return w;     } } </code></pre>  <p>Same result if I move out to separate method GC collection calls and WeakReference check:</p>  <pre><code>//Code snippet 3 internal class Program {     private static void Main(string[] args)     {         var a = new object();         var w = new WeakReference(a);         a = null;          CollectAndCheckWeakRef(w);         Console.ReadLine();     }      private static void CollectAndCheckWeakRef(WeakReference w1)     {         GC.Collect();         GC.WaitForPendingFinalizers();         GC.Collect();         Console.WriteLine(w1.IsAlive ? "Alive" : "Dead");     } } </code></pre>  <p>The important point though as it seems is that original <code>w</code> variable is not in current scope. If I move <code>Console.WriteLine(w1.IsAlive ? "Alive" : "Dead");</code> back to <code>Main</code> - it becomes <code>Alive</code> again.</p>  <p>Both variants are not very convenient sometimes, but at least consistent (<code>Debug</code> or <code>Release</code> configuration, debugger is attached or not - still outputs <code>Dead</code>).</p>  <p>Now I'm curious how mere presence of WeakReference variable in current execution scope prevents GC from cleaning its Target and why having it somewhere in scope buried in call stack doesn't do the same.</p>