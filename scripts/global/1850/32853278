<p>i am trying to make a robust application that can download  blob files from a mysql server. The files are executables or other binary files. The download itself works well, but i want to bullet proof it to survive an internet cutoff midway in a download. If the internet cutoff occurs before the preparedstatement.execute(),everything goes well, the memory is cleared of garbage and the program exits gracefully . On the other hand ,if i cutoff the internet 5 seconds into the execution of the preparedstatement.execute(),the thread that is downloading hangs indefinitely and is never cleared by the Garbage collector and the program never exits. The main exits,the downloader manager exits,but the downloading thread never exits. Methodology:</p>  <ul> <li><p>(1)Main thread to trigger Downloadmanager object into existence.</p></li> <li><p>(2)Downloadermanager object trigggers a separate Puredownload<br> object(in a separate thread) to invoke prepared statement to get<br> binary data to make downloads.</p></li> <li><p>(3)Downloadermanager  polls    PureDownload object to detect if a cutoff connection has caused it to    become unresponsive and tries to kill it.</p></li> </ul>  <p>Observing from heap dump on netbeans, a puredownload object that has been cutoff midway in a preparestatement never gets garbage collected,and waits indefinitely I have tried all possible ways :</p>  <ul> <li>(1)Thread.isinterrupted() to close the puredownload object and get it to be GCed.</li> <li>(2)CLose all resultset,statements,connections in separate try catch<br> but they never het triggered.</li> <li>(3)Place a try catch around the preparedstatement.executequery in the hope the failed internet connection will make it throw an exception and be able to close all remaining objects and exit. no success.</li> <li>(4)Outputstream.close() and inputsream.close()</li> <li>(5)inputstream.read(buffer) is placed in a thread.interrupted() while loop.</li> </ul>  <p>and many other combinations to get it to respond to a closed internet connection midway during the download. I ahve failed all my trials. ANyone has a suggestion?</p>  <p>///////////////////////////////////////main class/////////////////////////////////////////////////</p>  <pre><code>/*  * this calss launches the program and outputs a counter on sysout every 1000 milliseocnds.It will create a downloader manager object in an executor.  */  package learningthreads;  import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.Future; import java.util.logging.Level; import java.util.logging.Logger;   public class LearningThreads {       public static void main(String[] args) {           ExecutorService executor = Executors.newFixedThreadPool(3);          //the object that will run the dwonload on another thread         downloadermanager dm = new downloadermanager();          Future&lt;?&gt; wf = executor.submit(dm);           ///just a counter on another thread to give the time when events are occuring..it will just ouput numbers on sys out,together with other messages from other threads.           executor.submit(new Runnable(){             public void run(){                    for (int i = 0; i &lt; 25; i++) {                     try {                         System.out.println("the time is " + i);                         Thread.sleep(1000);                     } catch (InterruptedException ex) {                         Logger.getLogger(LearningThreads.class.getName()).log(Level.SEVERE, null, ex);                     }                 }               }           });            executor.shutdown();        }  } //////////////////////////////////end of main class////////////////////////////////////////////////             //////////////////////////////////////////////////downloader manager class/////////////////////////////////////////////////////////////////////////////     /*      * thhis object will manage and monitor a puredownload object .Its responsibility if to keep track of what the puredownload object is doing,and kill it if necessary when the latter has become unresponsive.      *In this test, it tries to kill the duredownload object after 15 seconds as the puredownload object takes around 5-10 seconds to connect,and the preparedstatement.execute() is in full operation after 15 seconds.      *so this is the best time to cut off the internet and see what happens.      */      package learningthreads;      import java.lang.reflect.InvocationTargetException;     import java.lang.reflect.Method;     import java.util.concurrent.Callable;     import java.util.logging.Level;     import java.util.logging.Logger;      /**      *      * @author DELL PC      */     public class downloadermanager implements Callable{         PureDownload PDS;         Thread T;         int memoryint=0;         int deadbeatcounter=0;         private volatile boolean running=true;           downloadermanager(){             PDS=new PureDownload();         T=new Thread(PDS);         T.start();         }              @Override         public Object call(){             try {                 Thread.sleep(15000);                       } catch (InterruptedException ex) {                 Logger.getLogger(downloadermanager.class.getName()).log(Level.SEVERE, null, ex);             }              kill();                 return null;         }          //after various ways of trying to kill the puredownload object, as a last resort ,here i cam trying to kill the thread forcefully without any good practice of terminating a thread,as the puredwonload object refuses any attempt to be garbage collected.         public void kill(){             try {                  System.out.println("kill");                  Thread f = T;                 Method m = Thread.class.getDeclaredMethod( "stop0" , new Class[]{Object.class} );                 m.setAccessible( true );                 m.invoke( f , new ThreadDeath() );                 System.out.println("end kill");             } catch (NoSuchMethodException ex) {                 Logger.getLogger(downloadermanager.class.getName()).log(Level.SEVERE, null, ex);             } catch (SecurityException ex) {                 Logger.getLogger(downloadermanager.class.getName()).log(Level.SEVERE, null, ex);             } catch (IllegalAccessException ex) {                 Logger.getLogger(downloadermanager.class.getName()).log(Level.SEVERE, null, ex);             } catch (IllegalArgumentException ex) {                 Logger.getLogger(downloadermanager.class.getName()).log(Level.SEVERE, null, ex);             } catch (InvocationTargetException ex) {                 Logger.getLogger(downloadermanager.class.getName()).log(Level.SEVERE, null, ex);             }         }       }      /////////////////////////////////////////////////end of downloadermanagerclass/////////////////////////////////////////////////////////////////////////          //////////////////////////////////////////////////////////puredownload class////////////////////////////////////////////////////////////////////////      /*     *This is the object that does the actual download.     *everything works fine.The problem is it refuses to exit gracefully and be garbage collected if an internet cutoff occurs 5 seconds after the preparedstatement is executing.     *all standard methods to cut off and close all obejcts have been tried ,in various combinations .     */      package learningthreads;      import java.io.File;     import java.io.FileOutputStream;     import java.io.IOException;     import java.io.InputStream;     import java.sql.Connection;     import java.sql.DriverManager;     import java.sql.PreparedStatement;     import java.sql.ResultSet;     import java.sql.SQLException;     import java.util.concurrent.Callable;     import java.util.logging.Level;     import java.util.logging.Logger;        public class PureDownload implements Callable,Runnable {          String dbname = "SMSVerautoDB";         String connectionString = "jdbc:xxxxxxxxxxxxxxxxxxxxxxxxxxxxx.com:3306/" + dbname;         String username = "xxxxxx";         String password = "xxxxxx";         String filename = "file.exe";         String outputpath = "C:\\xxxxxx";         Connection conn;         InputStream input;         private volatile boolean running = true;         private volatile int counter=0;         downloadermanager dm;          ResultSet rs = null;PreparedStatement pstmt;              public void stop() {                     //this function tries to kill the object from memory as it is not responding              //various attempts have been made here as well to have a stopping method to set flags etc.             //setting all as null is just one example             System.out.println("puredownload.stop.58");             rs=null;             pstmt=null;             conn=null;             System.out.println(" puredownload.stop.64");               }          public Void call() throws Exception {              //this function executes if i am using executor             download();              return null;          }          @Override         public void run() {             //this function executes if i am using thread                     download();         }           public void download(){        // update sql             String selectSQL = "SELECT xxxxx FROM xxxxx WHERE x=?";             try {                           Class.forName("com.mysql.jdbc.Driver");                  conn = DriverManager.getConnection(connectionString, username, password);                 pstmt = conn.prepareStatement(selectSQL);                  // set parameter;                 pstmt.setString(1, filename);                 System.out.println("physically remove internet connection in 5 seconds when you see this message");                  try {                     //pstmt.setQueryTimeout(2);                     rs = pstmt.executeQuery();                 } catch (Exception E) {                     System.out.println("trying to get an exception from exceute query here,when connection is cut off" + E.getMessage());                     //pstmt.cancel();                 }                 // write binary stream into file                  String outputpath_2 = outputpath + filename;                 File file = new File(outputpath_2);                 FileOutputStream output = new FileOutputStream(file);                  while (rs.next()) {                      input = rs.getBinaryStream("Logiciel");                     byte[] buffer = new byte[2048];                      while (input.read(buffer) &gt; 0) {                                                   output.write(buffer);                     }                  }             } catch (SQLException | IOException e) {                 Logger.getLogger(PureDownload.class.getName()).log(Level.SEVERE, null, e);                        } catch (ClassNotFoundException ex) {                 Logger.getLogger(PureDownload.class.getName()).log(Level.SEVERE, null, ex);             } finally {                     }           }          }      //////////////////////////////////////////////////////////end of puredownload class/////////////////////////////////////////////////////////// </code></pre>