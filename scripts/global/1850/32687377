<p>I'm working on a chess-playing program.  As part of it, I wrote a static method that is supposed to recursively operate on its input by calling itself with varied versions of the board, a <strong>Piece * board[8][8]</strong>, and pass back the the location of the "best" version of the board inside a <strong>std::unique_ptr</strong>, which is the return type of the method.</p>  <p>Node is defined as such:</p>  <pre><code>class node {     public:     node();     ~node();     std::unique_ptr&lt;node&gt; l;     std::unique_ptr&lt;node&gt; r;     std::unique_ptr&lt;node&gt; m;     node * best;     int bestval;      Piece * (*board)[8]; }; </code></pre>  <p>The goal is to eventually have the result of the initial call to the recursive method contain a "best" value which links to the whole chain of best path choices through the chessboard.  I would then draw the series of board states that result.</p>  <p>As part of this, the board must be preserved.  Whichever board "wins" at each recursive step gets copied to dynamic memory, and the board pointer of the return ( <strong>Piece * (*board)[8]</strong> in the <strong>node</strong> declaration) is set to this dynamically allocated memory.</p>  <p>This is done like so:</p>  <pre><code>    std::unique_ptr&lt;node&gt; ret (new node);     Piece *** reboard = new Piece**[8];     for (int i = 0; i &lt; 8; i++)     {         reboard[i] = new Piece*[8];     }     ...code to copy values to reboard and set other ret property values...     ret-&gt;board = reboard;     return ret; </code></pre>  <p>All the local values of the winning chess board are then copied to reboard.  This all works fine.  If I copy all the values of reboard to a global board at this stage, return, and directly draw that global board to the screen, it draws the correct result.  Likewise, if I set <strong>ret->board</strong> to point to that global board and then copy values to the global board and return, it draws the correct values.</p>  <p>But, if I do what I've written above and try to draw <strong>ret->board</strong>, I get invalid memory access errors in my draw method, and I'm pulling my hair out trying to pin this problem down.  It seems that immediately after return, the memory pointed to by <strong>reboard</strong> is reclaimed somehow.  In this memory which should only be data, I see that entries into the array appear to point to code in msctf.dll, among other invalid data pointers.  I thought it was being reclaimed by garbage collection, so I've even tried putting in some <strong>std::declare_reachable</strong> calls on any and every pointer I can see, but this has not helped.</p>  <p>Anyone notice recognize what's going on here?  Shouldn't that dynamically allocated memory stick around until I free it?</p>