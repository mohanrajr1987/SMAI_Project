<p>I'm storing Events in a Queue when the Android app is not in foreground. Events can be a lot, so I'd like to remove the oldest, when I reach a certain limit, to avoid memory issues. Events can be of different type and I'd like to to avoid removing certain (if not really needed, eg. onTrimMemory()).</p>  <pre><code>public void enqueue(T event) {     synchronized (events) {         if (events.size() &gt; 2000) {             for (int i = 0; i &lt; events.size(); i++) {                 if (canRemove(events.get(i))) {                     events.remove(i);                     break;                 }             }         }          events.add(event);     } } </code></pre>  <p>canRemove(event) check if the Event is instanceof of something that can be removed and returns true/false.</p>  <p>After a bit Logcat is giving me: "long monitor contention event with owner method" and after a while Logcat reports</p>  <p>Starting a blocking GC Alloc</p>  <p>Waiting for a blocking GC Alloc</p>  <p>Clamp target GC heap from 65MB to 64MB and then, after a lot of different messages... the app crash.</p>  <p>From what I've understand reading a similar question (<a href="http://stackoverflow.com/questions/29073847/what-might-be-the-cause-of-long-monitor-contention-event-with-owner-method">What might be the cause of &quot;long monitor contention event with owner method&quot;?</a>) the problem is that I'm receveing a lot of Events and locking on events for "too much" time.</p>  <p>So the question is... what can I do? I can optimize it a bit by saving the last position I removed and the next time start the for loop from it, but I don't think it's enough. Or I can do different Queue for different Events so that I always remove the first one, but I always need to lock it. Any better idea?</p>  <p>I forgot to say I'm declaring: private LinkedList events = new LinkedList&lt;>();</p>