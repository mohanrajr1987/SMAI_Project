<p>I have a java program which allocates and deallocates many objects and I would like to know how I can get some GC information, as for instance:</p>  <ul> <li>how many collection cycles and</li> <li>how much time is spent doing GC</li> <li>how many bytes are allocated and deallocated</li> </ul>  <p>I've seen mainly 3 options:</p>  <p>1) use the command -verbose:gc which prints lines of the style </p>  <pre><code>[GC (Allocation Failure)  131553K-&gt;131145K(228864K), 0.1332768 secs] </code></pre>  <p>indicating that there was a collection cycle which took 0.1332768 secs, as far as I understand.</p>  <p>2) use the code below</p>  <pre><code>private static void gcReport() {   int cycles = 0;   long collectionTime = 0;     for (GarbageCollectorMXBean bean:        ManagementFactory.getGarbageCollectorMXBeans()) {         collectionTime += bean.getCollectionTime();            cycles += bean.getCollectionCount();       }       System.out.println("Collection cycles: " + cycles);        System.out.println("Collection time: "   + collectionTime + "msec");  } </code></pre>  <p>3) use a profiler like visualVM (I'm not that interested in this option).</p>  <p>I could use already options 1 and 2 and I would like to know how accurate are these options. For instance, if we use the parallel collector ( -XX:+UseParallelOldGC), does the variable collectionTime keep the sum of time spent by all the threads doing GC?  And does each line with GC information, in option 1, represent the time spent by 1 thread? Or some average (or other calculation) among all the threads?</p>  <p>I would assume that these are good options when we use a sequential GC with stop-the-world, where we can actually see for how long the program is paused. However, I'm not sure that they actually give the time overhead of parallel and concurrent collectors. Do they? If so, how are they calculated?</p>  <p>Is there any other options I can use with the concurrent and parallel collectors?</p>  <p>Thanks.</p>