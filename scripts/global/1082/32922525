<p>Please check this link to know the problem in my code:</p>  <p><a href="http://www.dreamincode.net/forums/topic/382465-need-to-circle-on-button-click-and-add-it-to-the-scribblepane/" rel="nofollow">http://www.dreamincode.net/forums/topic/382465-need-to-circle-on-button-click-and-add-it-to-the-scribblepane/</a></p>  <p>I want to add drawPane to scribblePane in this way which is not working: This is my Scribble code:</p>  <pre><code>public class FrameFormula extends JComponent implements     DragGestureListener, // For recognizing the start of drags     DragSourceListener, // For processing drag source events     DropTargetListener, // For processing drop target events     MouseListener, // For processing mouse clicks     MouseMotionListener // For processing mouse drags {     static ArrayList aListNumbers = new ArrayList();   static ArrayList scribbles = new ArrayList(); // A list of Scribbles to draw    static Scribble currentScribble; // The scribble in progress    Scribble beingDragged; // The scribble being dragged    DragSource dragSource; // A central DnD object    boolean dragMode; // Are we dragging or scribbling?    // These are some constants we use   static final int LINEWIDTH = 3;    static final BasicStroke linestyle = new BasicStroke(LINEWIDTH);    static final Border normalBorder = new EmptyBorder(0,0,0,0);   //static final Border normalBorder = new BevelBorder(BevelBorder.LOWERED);    static final Border dropBorder = new BevelBorder(BevelBorder.RAISED);    /** The constructor: set up drag-and-drop stuff */   public FrameFormula() {     // Give ourselves a nice default border.     // We'll change this border during drag-and-drop.     setBorder(normalBorder);      // Register listeners to handle drawing     addMouseListener(this);     addMouseMotionListener(this);      // Create a DragSource and DragGestureRecognizer to listen for drags     // The DragGestureRecognizer will notify the DragGestureListener     // when the user tries to drag an object     dragSource = DragSource.getDefaultDragSource();     dragSource.createDefaultDragGestureRecognizer(this, // What component         DnDConstants.ACTION_COPY_OR_MOVE, // What drag types?         this);// the listener      // Create and set up a DropTarget that will listen for drags and     // drops over this component, and will notify the DropTargetListener     DropTarget dropTarget = new DropTarget(this, // component to monitor         this); // listener to notify     this.setDropTarget(dropTarget); // Tell the component about it.   }    /**    * The component draws itself by drawing each of the Scribble objects.    */   public void paintComponent(Graphics g) {     super.paintComponent(g);     Graphics2D g2 = (Graphics2D) g;     g2.setStroke(linestyle); // Specify wide lines      int numScribbles = scribbles.size();     for (int i = 0; i &lt; numScribbles; i++) {       Scribble s = (Scribble) scribbles.get(i);       System.out.println("Paint: " + scribbles.get(i));       g2.draw(s); // Draw the scribble     }     //System.out.println(scribbles);   }    /**    * This method implements the DragGestureListener interface. It will be    * invoked when the DragGestureRecognizer thinks that the user has initiated    * a drag. If we're not in drawing mode, then this method will try to figure    * out which Scribble object is being dragged, and will initiate a drag on    * that object.    */   public void dragGestureRecognized(DragGestureEvent e) {     // Don't drag if we're not in drag mode     if (!dragMode)       return;      // Figure out where the drag started     MouseEvent inputEvent = (MouseEvent) e.getTriggerEvent();     int x = inputEvent.getX();     int y = inputEvent.getY();      // Figure out which scribble was clicked on, if any by creating a     // small rectangle around the point and testing for intersection.     Rectangle r = new Rectangle(x - LINEWIDTH, y - LINEWIDTH,         LINEWIDTH * 2, LINEWIDTH * 2);     int numScribbles = scribbles.size();     for (int i = 0; i &lt; numScribbles; i++) { // Loop through the scribbles       Scribble s = (Scribble) scribbles.get(i);       if (s.intersects(r)) {         // The user started the drag on top of this scribble, so         // start to drag it.          // First, remember which scribble is being dragged, so we can         // delete it later (if this is a move rather than a copy)         beingDragged = s;          // Next, create a copy that will be the one dragged         Scribble dragScribble = (Scribble) s.clone();         // Adjust the origin to the point the user clicked on.         dragScribble.translate(-x, -y);          // Choose a cursor based on the type of drag the user initiated         Cursor cursor;         switch (e.getDragAction()) {         case DnDConstants.ACTION_COPY:           cursor = DragSource.DefaultCopyDrop;           break;         case DnDConstants.ACTION_MOVE:           cursor = DragSource.DefaultMoveDrop;           break;         default:           return; // We only support move and copys         }          // Some systems allow us to drag an image along with the         // cursor. If so, create an image of the scribble to drag         if (dragSource.isDragImageSupported()) {           Rectangle scribbleBox = dragScribble.getBounds();           Image dragImage = this.createImage(scribbleBox.width,               scribbleBox.height);           Graphics2D g = (Graphics2D) dragImage.getGraphics();           g.setColor(new Color(0, 0, 0, 0)); // transparent background           g.fillRect(0, 0, scribbleBox.width, scribbleBox.height);           g.setColor(Color.black);           g.setStroke(linestyle);           g.translate(-scribbleBox.x, -scribbleBox.y);           g.draw(dragScribble);           Point hotspot = new Point(-scribbleBox.x, -scribbleBox.y);            // Now start dragging, using the image.           e.startDrag(cursor, dragImage, hotspot, dragScribble, this);         } else {           // Or start the drag without an image           e.startDrag(cursor, dragScribble, this);         }         // After we've started dragging one scribble, stop looking         return;       }     }   }      private final DrawingPanel panel = new DrawingPanel();      private static int[] generateRandomValues(int maxX, int maxY,                                         int minSize, int maxSize) {         Random random = new Random();         int[] values = new int[3];         values[0] = random.nextInt(maxX);         values[1] = random.nextInt(maxY);         values[2] = Math.min(random.nextInt(maxSize) + minSize, maxSize);         return values;     }      static class Circle {          int x, y, width, height;          public Circle(int x, int y, int width, int height) {             this.x = x;             this.y = y;             this.width = width;             this.height = height;         }          public void draw(Graphics g) {             g.drawOval(x, y, width, height);         }     }      static class DrawingPanel extends JPanel {          List&lt;Circle&gt; circles = new ArrayList&lt;&gt;();          @Override         protected void paintComponent(Graphics g) {             super.paintComponent(g);             for (Circle circle : circles) {                 circle.draw(g);             }         }          public void addCircle(Circle circle) {             circles.add(circle);             repaint();         }          @Override         public Dimension getPreferredSize() {             return new Dimension(400, 400);         }     }     /**    * The main method. Creates a simple application using this class. Note the    * buttons for switching between draw mode and drag mode.    */   public static void main(String[] args) {     // Create a frame and put a scribble pane in it     JFrame frame = new JFrame("FrameFormula");     frame.setDefaultCloseOperation(EXIT_ON_CLOSE);     FrameFormula scribblePane = new FrameFormula();     DrawingPanel drawPane = new DrawingPanel();     JPanel shapePanel = new JPanel();     String gapList[] = {"0", "10", "15", "20"};     int maxGap = 20;     JButton horGap = new JButton(new ImageIcon("circle.png"));          horGap.addActionListener(new ActionListener(){             public void actionPerformed(ActionEvent e) {                 int[] circleValues = generateRandomValues(300, 300, 50, 150);                 int x = circleValues[0];                 int y = circleValues[1];                 int width = circleValues[2];                 int height = width;                 Circle circle = new Circle(x, y, width, height);                 drawPane.addCircle(circle);                 System.out.println("Scribbles: " + scribbles);                  scribblePane.add(drawPane);       // THIS IS NOT WORKING? WHY?                           }         });      shapePanel.setLayout(new BoxLayout(shapePanel, BoxLayout.Y_AXIS));     shapePanel.setMaximumSize(new Dimension(400, 100));     //shapePanel.add(firstPanel);     shapePanel.add(horGap);     frame.add(shapePanel, BorderLayout.WEST);     frame.getContentPane().add(scribblePane, BorderLayout.CENTER);      // Create two buttons for switching modes     JToolBar toolbar = new JToolBar();     ButtonGroup group = new ButtonGroup();     JToggleButton draw = new JToggleButton("Draw");     JToggleButton drag = new JToggleButton("Drag");     draw.addActionListener(new ActionListener() {       public void actionPerformed(ActionEvent e) {         scribblePane.setDragMode(false);       }     });     drag.addActionListener(new ActionListener() {       public void actionPerformed(ActionEvent e) {         scribblePane.setDragMode(true);       }     });     group.add(draw);     group.add(drag);     toolbar.add(draw);     toolbar.add(drag);     frame.getContentPane().add(toolbar, BorderLayout.NORTH);      // Start off in drawing mode     draw.setSelected(true);     scribblePane.setDragMode(false);      // Pop up the window     frame.setSize(400, 400);     frame.setVisible(true);   } }  class Scribble implements Shape, Transferable, Serializable, Cloneable {   protected double[] points = new double[64]; // The scribble data    protected int numPoints = 0; // The current number of points    double maxX = Double.NEGATIVE_INFINITY; // The bounding box    double maxY = Double.NEGATIVE_INFINITY;    double minX = Double.POSITIVE_INFINITY;    double minY = Double.POSITIVE_INFINITY;    /**    * Begin a new polyline at (x,y). Note the use of Double.NaN in the points    * array to mark the beginning of a new polyline    */   public void moveto(double x, double y) {     if (numPoints + 3 &gt; points.length)       reallocate();     // Mark this as the beginning of a new line     points[numPoints++] = Double.NaN;     // The rest of this method is just like lineto();     lineto(x, y);   }     /**    * Add the point (x,y) to the end of the current polyline    */   public void lineto(double x, double y) {     if (numPoints + 2 &gt; points.length)       reallocate();     points[numPoints++] = x;     points[numPoints++] = y;      // See if the point enlarges our bounding box     if (x &gt; maxX)       maxX = x;     if (x &lt; minX)       minX = x;     if (y &gt; maxY)       maxY = y;     if (y &lt; minY)       minY = y;   }   } } </code></pre>