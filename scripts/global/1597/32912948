<p>I currently have the following code to find the (x,y) coordinate of an image within an image.</p>  <pre><code>   public static Point search(BufferedImage big, BufferedImage small) {          for (int x = 0; x &lt; big.getWidth() - small.getWidth(); x++) {             for (int y = 0; y &lt; big.getHeight() - small.getHeight(); y++) {                 if (compare(x, y, big, small)) {                     return new Point(x, y);                 }             }         }         return null;     }      private static boolean compare(int xs, int ys, BufferedImage img1, BufferedImage img2) {          for (int x = 0; x &lt; img2.getWidth(); x++) {             for (int y = 0; y &lt; img2.getHeight(); y++) {                 if (img1.getRGB(x + xs, y + ys) != img2.getRGB(x, y)) {                     return false;                 }             }         }         return true;     } </code></pre>  <p>Basically my current code takes the small image and looks for an exact pixel for pixel match in the big image. If it finds a match, it reports the (x,y) location. The problem I am having with my program is that my "big" image sometimes changes slightly which causes the location of my "small" image to not be found.</p>  <p>What I would like to do is make it so that instead of the program finding an exact pixel for pixel match, it would find the location of the small image in the big image with a set amount of uncertainty. So maybe instead of this line:</p>  <pre><code>      if (img1.getRGB(x + xs, y + ys) != img2.getRGB(x, y)) {                     return false;       } </code></pre>  <p>I am looking for a way to make it so that it does this:</p>  <pre><code>      if (img1.getRGB(x + xs, y + ys) is not within plus or minus SOMEFACTOR of img2.getRGB(x, y)) {                     return false;       } </code></pre>  <p>Or maybe that is not the best way to go about this.</p>