<p>I have an unmanaged class that is running a message loop for a child Win32 window.  When the program goes to close, it starts the finalizer for the managed class that holds the unmanaged reference to this class.  Because another thread is dependent on this class, I need the finalizer to wait until the message loop thread has completed a loop and exits and terminates.  However, the timeout loop I have apparently takes too long for the GC finalizer thread or the main thread terminates destroying the entire process.  </p>  <p>Is there a way to tell the GC to not timeout a thread for finalizers?  I.E. - I need the finalizer thread to block for a little while in the finalizer so it can complete terminating the message loop thread and then release the unmanaged resource.</p>  <p>Here is my finalizer so you get an idea of what's going on:</p>  <pre><code>PONms::NestedWin32:: !NestedWin32() {      if (msgLoop-&gt;IsAlive)     {         winProcess-&gt;EndThread(); // blocks and waits for message loop thread to terminate                                 // and GC apparently doesn't like this causeing the                                 // entire process to terminate here.     }     if (childHandle != nullptr)     {         DestroyWindowCore(childHandle);     }     if (winProcess != nullptr)     {         delete winProcess; // memory leak due to resource not being released     } } </code></pre>  <p>I'm thinking I went about this the wrong way, just expecting the code to behave properly and the finalizer to complete.</p>  <p>Here is the simple method I use to poll the other thread to see if it has terminated:</p>  <pre><code>void PONms::NestedWin32UM:: EndThread() {     int timeOut = 5000;     threadContinue = false;     SendNotifyMessage(childWin, WM_CLOSE, 0, 0);     while (threadActive &amp;&amp; timeOut &gt; 0)     {         POCPP::Threading::SleepThreadOne();         timeOut--;     } } </code></pre>