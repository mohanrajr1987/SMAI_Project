<p>I am compiling an existing C++ library as a C++/CLI DLL.  The C++ library has two initialization routines which need to be called to set up various lookup tables.</p>  <p>The C++ library originally used <code>std::once_flag</code> and <code>std::call_once()</code> from &lt;mutex&gt; to perform one-time initialization of the lookup tables.  However, in C++/CLI, the &lt;mutex&gt; header is not supported:<br> <a href="http://stackoverflow.com/questions/26585714/error-mutex-is-not-supported-when-compiling-with-clr-or-clrpure">Error &lt;mutex&gt; is not supported when compiling with /clr or /clr:pure</a></p>  <p>I then tried using <code>std::atomic_flag</code> from &lt;atomic&gt;, but the &lt;atomic&gt; header is also unsupported in C++/CLI.</p>  <p>After seeing <a href="http://stackoverflow.com/questions/335256/where-do-i-initialize-a-managed-c-cli-dll">Where do I initialize a managed C++/CLI DLL?</a> I then tried implementing DllMain(), but I ran into the problem that the C++ library's initialization routines needed to call managed code.  In my case, I am not able to compile the initialization routines as unmanaged code (using <code>#pragma unmanaged</code>).</p>  <p>I then tried out a module initializer:</p>  <pre class="lang-c++ prettyprint-override"><code>#pragma warning( disable : 4483 ) void __clrcall __identifier(".cctor")() {     InitLookupTables1();     InitLookupTables2(); } </code></pre>  <p>However, this causes 33 linker warnings of the form:</p>  <blockquote>   <p>1>some.obj : warning LNK4210: .CRTMP section exists; there may be unhandled static initializers or terminators</p> </blockquote>  <p>I suppose that my custom module initializer is overriding a compiler-generated module initializer that properly runs all static initialization, such as setting global variables' initial values.</p>  <p>Is there a way to customize the compiler-generated module initializer or otherwise arrange to have the library initialization routines called by the compiler-generated module initializer?</p>