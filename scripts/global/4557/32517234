<p>I am working on an application with Visual Studio 2015 on Windows 7. The application has a C# frontend, a C++ CLR wrapper and C++ native code.</p>  <p>My application crashes with an access violation while initializing a static variable at function scope with C++ native code. But only on Windows Server 2003 Enterprise SP2 and not on Windows 7 or Windows Server 2012. I know Windows Server 2003 is out of support, but I have to target that platform for a few additional months and Visual Studio 2015 provides a platform toolset to target it.</p>  <p>I created a small reproducible example which you find at the end.</p>  <p>The crash only happens with all three parts involved (C#, C++ CLR, C++). If I remove any, the crash is gone.</p>  <p>The crash only happens with a custom constructor defined. If I remove the constructor, the crash is gone.</p>  <p>I am no assembly expert, but for me it looks like the crash is caused by the code which checks if the static initialization is required. The constructor is not even called.</p>  <p>My question is: Why does it crash on Windows Server 2003? Am I missing some important project setting?</p>  <h1>The error message</h1>  <pre class="lang-none prettyprint-override"><code>Unhandled exception at 0x1000167E (Native.dll) in Managed.exe.dmp: 0xC0000005: Access violation reading location 0x00000000. </code></pre>  <h1>Visual C# Console Application "Managed.exe"</h1>  <h2>Program.cs</h2>  <pre class="lang-cs prettyprint-override"><code>// Target framework: .NET Framework 4 // Platform target: x86  using System;  namespace Managed {     class Program     {         static void Main(string[] args)         {             Console.Write("Press enter to start test...");             Console.ReadLine();              Native.Wrapper wrapper = new Native.Wrapper();             Console.WriteLine("Test was successful");              Console.Write("Press enter to exit...");             Console.ReadLine();         }     } } </code></pre>  <h1>Visual C++ CLR Class Library "Native.dll"</h1>  <h2>Wrapper.hpp</h2>  <pre class="lang-cpp prettyprint-override"><code>#pragma once  namespace Native {  public ref class Wrapper { public:     Wrapper();  }; // public ref class Wrapper  } // namespace Native </code></pre>  <h2>Wrapper.cpp</h2>  <pre class="lang-cpp prettyprint-override"><code>// Platform Toolset: Visual Studio 2015 - Windows XP (v140_xp) // Common Language Runtime Support: Common Language Runtime Support (/clr) // .NET Target Framework Version: v4.0 // Warning Level: Level4 // Treat Warnings As Errors: Yes (/WX) // Precompiled Header: Not Using Precompiled Headers // SubSystem: Console (/SUBSYSTEM:CONSOLE) // Optimization: Disabled (/Od)  #pragma once  #include "Wrapper.hpp" #include "Caller.hpp"  namespace Native {  Wrapper::Wrapper() {     Caller* caller = new Caller();     delete caller; }  } // namespace Native </code></pre>  <h2>Caller.hpp</h2>  <pre class="lang-cpp prettyprint-override"><code>#pragma once  namespace Native {  class Caller { public:     Caller();  }; // class Caller  } // namespace Native </code></pre>  <h2>Caller.cpp</h2>  <pre class="lang-cpp prettyprint-override"><code>// Platform Toolset: Visual Studio 2015 - Windows XP (v140_xp) // Common Language Runtime Support: No Common Language RunTime Support // Warning Level: Level4 // Treat Warnings As Errors: Yes (/WX) // Precompiled Header: Not Using Precompiled Headers // SubSystem: Console (/SUBSYSTEM:CONSOLE) // Optimization: Disabled (/Od)  #include "Caller.hpp" #include "Singleton.hpp"  namespace Native {  Caller::Caller() {     Singleton::GetInstance()-&gt;DoSomething(); }  } // namespace Native </code></pre>  <h2>Singleton.hpp</h2>  <pre class="lang-cpp prettyprint-override"><code>#pragma once  #include &lt;iostream&gt;  namespace Native {  class Singleton { public:     Singleton() // !!! remove constructor to prevent crash !!!     { }      static Singleton* GetInstance()     {         static Singleton Instance; // !!! crashes here !!!         return &amp;Instance;     }      void DoSomething()     {         std::wcout &lt;&lt; L"Doing something...\n";     }  }; // class Singleton  } // namespace Native </code></pre>  <h1>The disassembly</h1>  <pre class="lang-none prettyprint-override"><code>    static Singleton* GetInstance()     { 10001650  push        ebp   10001651  mov         ebp,esp   10001653  push        0FFFFFFFFh   10001655  push        10006A8Ch   1000165A  mov         eax,dword ptr fs:[00000000h]   10001660  push        eax   10001661  mov         eax,dword ptr ds:[1001B334h]   10001666  xor         eax,ebp   10001668  push        eax   10001669  lea         eax,[ebp-0Ch]   1000166C  mov         dword ptr fs:[00000000h],eax           static Singleton Instance; 10001672  mov         eax,dword ptr ds:[1001B5D0h]   10001677  mov         ecx,dword ptr fs:[2Ch]   1000167E  mov         edx,dword ptr [ecx+eax*4] // !!! access violation here !!! 10001681  mov         eax,dword ptr ds:[1001B5A4h]   10001686  cmp         eax,dword ptr [edx+4]   1000168C  jle         Native::Singleton::GetInstance+79h (100016C9h)   </code></pre>  <h1>The registers</h1>  <pre class="lang-none prettyprint-override"><code>EAX = 00000000 EBX = 00000000 ECX = 00000000 EDX = 006A0003 ESI = 001647C8 EDI = 0012F3BC EIP = 1000167E ESP = 0012F394 EBP = 0012F3A4 EFL = 00010282  </code></pre>  <h1>Edit 1</h1>  <p>While debugging locally where the crash does not happen, a few more symbols are visible with the assembly:</p>  <pre class="lang-none prettyprint-override"><code>    static Singleton* GetInstance()     { 0FBD1650  push        ebp   0FBD1651  mov         ebp,esp   0FBD1653  push        0FFFFFFFFh   0FBD1655  push        offset __ehhandler$?GetInstance@Singleton@Native@@SAPAV12@XZ (0FBD86BCh)   0FBD165A  mov         eax,dword ptr fs:[00000000h]   0FBD1660  push        eax   0FBD1661  mov         eax,dword ptr [___security_cookie (0FBF03CCh)]   0FBD1666  xor         eax,ebp   0FBD1668  push        eax   0FBD1669  lea         eax,[ebp-0Ch]   0FBD166C  mov         dword ptr fs:[00000000h],eax           static Singleton Instance; 0FBD1672  mov         eax,dword ptr [__tls_index (0FBF0668h)]   0FBD1677  mov         ecx,dword ptr fs:[2Ch]   0FBD167E  mov         edx,dword ptr [ecx+eax*4]   0FBD1681  mov         eax,dword ptr [TSS0&lt;`template-parameter-2',Native::Singleton::tInstance,Native::Singleton * * const volatile,void,int, ?? &amp;&gt; (0FBF063Ch)]   0FBD1686  cmp         eax,dword ptr [edx+4]   0FBD168C  jle         Native::Singleton::GetInstance+79h (0FBD16C9h)   </code></pre>  <p>The symbol <code>__tls_index</code> seems to belong to some thread local store (guessed from the name). This matches with <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2660.htm" rel="nofollow">Magic statics</a> which uses thread local store as a performance optimization in the reference implementation. When crashing, the thread local store returns <code>0</code>.</p>  <p>Could this be a bug with the runtime environment on Windows Server 2003 which manages and initializes the thread local store?</p>  <h1>Edit 2</h1>  <p>Reported as bug through Microsoft Connect: <a href="https://connect.microsoft.com/VisualStudio/feedback/details/1789709/visual-c-2015-runtime-broken-on-windows-server-2003-c-11-magic-statics" rel="nofollow">Bug report</a></p>