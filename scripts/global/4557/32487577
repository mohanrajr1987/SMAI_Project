<p>I have a C++ function that is called with a char* buffer to be used for the output. Now i want to write to it using C# so i need to call a managed method from the C++ function. What i can't figure out is how to pass it as a StringBuilder.</p>  <p>I previously used <a href="https://sites.google.com/site/robertgiesecke/Home/uploads/unmanagedexports" rel="nofollow">Robert Giesecke's Unmanaged Exports</a> which worked fine and did this automatically using a default string marshalling scheme, but i want to use the size parameter for the MaxCapacity of the StringBuilder.</p>  <p>Is there a nicer way to do this than creating a new StringBuilder instance, writing to it, getting a CLR string with <code>ToString()</code>, and then copying the contents to the buffer? The strings in question might be as long as 10,000 characters and i don't really like the idea of copying it twice each time.</p>  <p><strong>C#</strong></p>  <pre><code>public static void MyMethod(StringBuilder buffer) {     //... } </code></pre>  <p><strong>C++/CLI</strong></p>  <pre><code>extern "C" __declspec(dllexport) void __stdcall MyFunction(char* buffer, int length) {     MyNamespace::MyClass::MyMethod( /* ? */ ); } </code></pre>