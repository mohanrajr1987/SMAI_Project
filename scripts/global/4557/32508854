<p>I have a C# DLL that is used by a C# app, and it now needs to be also used by a C++ app for the same functionality. To save having to re-write it, it was packaged up and installed as a COM library, and I have it linked into the C++ app, and calls from the app to test methods in the library are working. I do not, however, know how to use a C# event (subscribe to it) from within a C++ app. All the examples I've seen so far, haven't panned out for me.</p>  <p>This is the C# DLL side:</p>  <pre><code>[ComVisible(true)] [Guid("32529FAE-6137-4c62-9945-DE4198FA9D1B")] [InterfaceType(ComInterfaceType.InterfaceIsDual)] public interface IEventServer {          //C# Implementation         event Action&lt;string&gt; EventServerCall;         event Action&lt;string&gt; EventServerMessage;          //C++ Implemenation         event EventServerCallDelegate cEventServerCall;         event EventServerMessageDelegate cEventServerMessage;      };      [ComVisible(true)]     public delegate void EventServerCallDelegate(String message);      [ComVisible(true)]     public delegate void EventServerMessageDelegate(String message);  } </code></pre>  <p>and then...</p>  <pre><code>public class EventServer : IEventServer {     //C# Implementation     public event Action&lt;string&gt; EventServerCall;     public event Action&lt;string&gt; EventServerMessage;      //C++ Implementation ?     public event EventServerCallDelegate cEventServerCall;     public event EventServerMessageDelegate cEventServerMessage;      //Event Triggers            [ComVisible(true)]     public void CallEvent(string call)     {         //C#         if (EventServerCall != null)             EventServerCall(call);         //C++         if (cEventServerCall != null)             cEventServerCall(call);      }       [ComVisible(true)]     public void MessageEvent(string message)     {         //C#         if (EventServerMessage != null)             EventServerMessage(message);         //C++         if (cEventServerMessage != null)             cEventServerMessage(message);     } </code></pre>  <p>(the C++ bit are gleaned from examples I've seen where a delegate must be involved).</p>  <p>In the C# app that uses the DLL, wiring into the events is as simple as:</p>  <pre><code>public MainWindow() {     InitializeComponent();      //subscribe to events     EventServer.EventServerCall += NotifyOnEventServerCallEvent;     EventServer.EventServerMessage += NotifyOnEventServerMessageEvent; }  private void NotifyOnEventServerCallEvent(string eventCall) {     //actions to be performed on received event...     Debug.WriteLine("&gt;&gt;&gt; MainWindow - INCOMING CALL EVENT:  " + eventCall);  }  private void NotifyOnEventServerMessageEvent(string eventMessage) {     //actions to be performed on received event...     Debug.WriteLine("&gt;&gt;&gt; MainWindow - INCOMING MESSAGE EVENT:  " + eventMessage);  } </code></pre>  <p>So in the C++ implementation, it seems to be alot less clear. This is a WinForms app I'm using for testing, however in the end my DLL has to be able to run in any C++ project):</p>  <pre><code>#import "EventServerClientDLL.tlb" using namespace EventServerClientDLL;      public:         MainWindow(void)         {             InitializeComponent();              // Initialize COM.             HRESULT hr = CoInitialize(NULL);              // Create the interface pointer.             IEventServerPtr pIEventServer(__uuidof(EventServer));      pIEventServer-&gt;add_cEventServerCall += gcnew EventHandler(MyOwnEventHandler);          }          public: static void MyOwnEventHandler(Object^ sender, EventArgs^ e)         {            //*I NEED TO CAPTURE THE STRING FROM THE EVENT HERE*         } </code></pre>  <p>..this doesn't compile though ("error C2659: '+=' : function as left operand"). The value being passed through the events from the DLL side is a string, and that's what needs to make it to the C++ side.</p>