<p>I have almost no expertise when working with isolated scopes on angular but i found something for a project that i was using to check the strength of an username with an Angular directive.</p>  <p>This is the directive: </p>  <pre><code>function usernameStrength() {   return {     require: 'ngModel',     restrict: 'E',     scope: {       username: '=ngModel'     },      link: function(scope, elem, attrs, ctrl) {        /** Watch password fields **/       scope.$watch('username', function(newVal) {         scope.strength = isSatisfied(newVal &amp;&amp; newVal.length &gt;= 8) +           isSatisfied(newVal &amp;&amp; /[A-z]/.test(newVal)) +           isSatisfied(newVal &amp;&amp; /(?=.*\W)/.test(newVal)) +           isSatisfied(newVal &amp;&amp; /\d/.test(newVal));          function isSatisfied(criteria) {            return criteria ? 1 : 0;          }       }, true);   } } </code></pre>  <p>Then on my HTML (JADE) i had an input and the directive on whom the strength progress bar is displayed and manipulated.</p>  <pre><code>input.form-control(autocomplete="off", type='text', required='', ng-model="register.username") </code></pre>  <p>label Strength    username-strength(ng-model="register.username")</p>  <p>Till here everything works fine, but then if i add an object on the controller to store all the data from the form (which is a wizard) and set the input <code>ng-model</code> like this <code>ng-model="register.data.username"</code> (Same thing on the <strong>username-strength</strong> directive) Being <strong>data</strong> in the controller this object</p>  <pre><code>vm.data  = {}; </code></pre>  <p>The $watches in the directive no longer have access to the input.</p>