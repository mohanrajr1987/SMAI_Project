<p>This code is a little wild but I am more concerned about concepts here than definite code responses. I am working on a combat system for a game. I have npc characters running on an "attack" loop. Once the player has reduced an npc bad guy's hit points to zero, I want to remove that entity from the map/DOM/scope etc.  ...some code (the code in question will be towards the end) -</p>  <p>Loading the npc character data from database..an array, all same properties, but different values. $scope.encounters gets ng-repeated in the HTML and builds out the characters on the screen. That data is then send to $scope.encounter_a() function to do more stuff. </p>  <pre><code>db.getNpcCombat(npc_combat_set).success(function(data){   $scope.encounters = [];   $scope.encounters = data;   angular.forEach(data, function(value, key){     console.log(value);     $scope.encounter_a(value);   });  </code></pre>  <p>This sets a timer for a progress bar with different rates for different npcs, once the time hits 100, cancels timer and then runs the attack function...which was looped through, so it is running with different times for each npc according to their data. So value is the data from one npc entity. </p>  <pre><code>$scope.encounter_a = function(value){     value.attack_count = 0;     $timeout(function(){         var set_timer = $interval(function() {         value.attack_count += 1;         if(value.attack_count &gt;= 100){         $interval.cancel(set_timer);         $scope.attack(value);       }    }, value.attack_rate);  }, 500);  } </code></pre>  <p>This part looks a little crazy but does it's job. This is still receiving the data of one npc entity. Each enemy has different attacks, so basically, this is getting that certain NPC's attacks data from the database, then randomizing which attack will get used, it then calculates whether or not the attack will hit the player character. Whether or not the attack hits or misses, it will loop back to encounter_a().  </p>  <pre><code>$scope.attack = function(data){    $timeout(function(){        db.getNpcFeats(data.feats).success(function(feat_data){   //randomize which feat is used ...get amount of feats         var count = feat_data.length;   //randomize number        count = getRandomInt(1, count);        count = count - 1;   //get feat_hit success - gets random number between 1-10       feat_success = getRandomInt(1, 10);       $('#enemy_'+data.id+' ul li .attack_text h5').html(feat_data[count].feat_name + '!');       $('.attack_text').removeClass('fadeOut').addClass('fadeIn');       $timeout(function(){          $('.attack_text').removeClass('fadeIn').addClass('fadeOut');       }, 1000);       if(feat_data[count].feat_chance &gt;= feat_success){          $scope.damage_amount= getRandomInt(parseInt(feat_data[count].feat_min_damage), parseInt(feat_data[count].feat_max_damage));          $scope.$watch('damage_amount', function() {              $('.feat_name').html(feat_data[count].feat_name);              $('.feat_damage').html('Damage - ' +$scope.damage_amount);              $('.feat_hit .text-danger').html("You've been hit!!");              $('.outer-container').addClass('tada');             $('.feat_hit').removeClass('fadeOutDown').addClass('fadeInUp');             $scope.player_hp = $scope.player_hp - $scope.damage_amount;             if($scope.player_hp &gt;= 0){            //future player death function             }             $timeout(function(){              $('.feat_hit').removeClass('fadeInUp').addClass('fadeOutDown');       }, 2000);         });       }      });      $scope.encounter_a(data);     }, data.attack_delay);    } </code></pre>  <p>Finally, here is the code that is giving me trouble. This code is essentially disconnected from the above code. This is the attack code for the player attacking the NPCs. Which has worked, except for when the NPC's hitpoints reach zero, not sure what to do. </p>  <pre><code>$scope.playerFeatAttack = function(player_feat){    //if player has not selected npc to attack, show message and prevent attack then remove message else allow attack     if (!$('.enemy_container').hasClass('attack_selected')){        $('.helper_dialog_area').removeClass('lightSpeedOut');        $('.helper_dialog_area').removeClass('hide');        $('.helper_dialog_area h4').html('CLICK AN ENEMY TO ATTACK!!!');        $('.helper_dialog_area').addClass('lightSpeedIn');        $timeout(function() {           $('.helper_dialog_area').removeClass('lightSpeedIn');           $('.helper_dialog_area').addClass('lightSpeedOut');   }, 2500); }else{   //calculate hit damage   var hit_damage = getRandomInt(parseInt(player_feat.feat_min_damage), parseInt(player_feat.feat_max_damage));   //calculate attack success   var attack_success_roll = getRandomInt(1, 10);   //if attack passes, run attack   if(player_feat.feat_chance &gt;= attack_success_roll){     //determine which NPC to attack based on the .attack_selected class      //not sure if this is a good way but this is how getting the specific NPC hitpoints       var elem = angular.element($(".attack_selected .npc_hp")).scope();       $scope.npc_hp = $('.attack_selected .npc_hp').html();     //watch for changes in the hitpoints       $scope.$watch('npc_hp', function(){    //change the hitpoints on the screen using jquery..probably not ideal way         var npc_hp = parseInt($scope.npc_hp) - parseInt(hit_damage);         $('.attack_selected .npc_hp').html(npc_hp);         var hp_after_attack = $('.attack_selected .npc_hp').html(); </code></pre>  <p>This main code in question -             </p>  <pre><code>         if(hp_after_attack &lt;= 0){           $('.attack_selected').addClass('flipOutX');           var what = angular.element($('.attack_selected')).scope();         }     });    } } </code></pre>  <p>} </p>  <p>This last part is the code in question. If the NPC's hitpoints go below 0, first planning to add a CSS class to do an animation, then want to remove that character from the game. If I console log this - </p>  <pre><code> var what = angular.element($('.attack_selected')).scope(); </code></pre>  <p>Which is the element I want to remove, I can see the encounter object in the main scope which is that NPC entities data. I tried to change that to NULL, figuring it would eliminate the entity's data, hence not being able to do anything. Also just tried removing the element from the DOM, which of course, removes it from the screen, but then it keeps running attacks.  In $parent of the scope, I can see the $scope.attack() function..I changed that to NULL, but then that stops all of the NPCs from attack. </p>  <p>What I need to do is kill the attack() function for the specific NPC...but when I console $scope, it looks to me like there is only 1 attack function in the scope, not seperate ones for each "encounter" entity/npc.</p>  <p>Is there some way I can code the attack() function to be attack to the main scope of each of these elements? Maybe an isolated scope (which I don't really understand what it is)? </p>  <p>This is my learning AngularJS project...so any advice on a better way to accomplish the above and also to eliminate the NPC from the battle after it's be killed would be really great. Let me know if you need any more info from me.  </p>