<p>I always used this code on x86 machines without problems:</p>  <pre><code>PIDHandle:= OpenProcess(PROCESS_QUERY_INFORMATION or PROCESS_VM_OPERATION or                                           PROCESS_VM_READ, false, Struct.th32ProcessID); if (PIDHandle &lt;&gt; 0)  ScanMemory(PIDHandle, Struct.szExeFile);  procedure TForm1.ScanMemory(PIDHandle: THandle; const ProcessName: string); var   MemStart, ReceivedBytes: SIZE_T;   MemInfo: MEMORY_BASIC_INFORMATION; begin   MemStart:= 0;   while (VirtualQueryEx(PIDHandle, Pointer(MemStart), MemInfo, SizeOf(MemInfo)) &lt;&gt; 0) do   begin     if ((MemInfo.State = MEM_COMMIT) and (not (MemInfo.Protect = PAGE_GUARD)     or (MemInfo.Protect = PAGE_NOACCESS)) and (MemInfo.Protect = PAGE_READWRITE)) then     begin       SetLength(Buff, MemInfo.RegionSize);       if (ReadProcessMemory(PIDHandle, MemInfo.BaseAddress, Buff,           MemInfo.RegionSize, ReceivedBytes)) then         begin           //do particular stuff with memory         end; //if readprocessmemory     end; //if mempages     MemStart:= MemStart + MemInfo.RegionSize;   end;  end;  </code></pre>  <p>Now I compiled a x64 binary and it stops responding in some random processes, which I'm not sure if they are x86/x64... </p>  <p>Are there any known issue on running ReadProcessMemory from a x64 bin, into x86 processes? Is really necessary to keep a x86 bin to read memory of other x86 processes and a x64 bin to read x64 processes? Or there are any workaround?</p>