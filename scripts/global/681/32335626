<p>I have the following simple program that uses a union to convert between a 64 bit integer and its corresponding byte array:</p>  <pre><code>union u {   uint64_t ui;   char c[sizeof(uint64_t)]; };  int main(int argc, char *argv[]) {   u test;   test.ui = 0x0123456789abcdefLL;   for(unsigned int idx = 0; idx &lt; sizeof(uint64_t); idx++)     {       cout &lt;&lt; "test.c[" &lt;&lt; idx &lt;&lt; "] = 0x" &lt;&lt; hex &lt;&lt; +test.c[idx] &lt;&lt; endl;     }   return 0; } </code></pre>  <p>What I would expect as output is:</p>  <pre><code>test.c[0] = 0xef test.c[1] = 0xcd test.c[2] = 0xab test.c[3] = 0x89 test.c[4] = 0x67 test.c[5] = 0x45 test.c[6] = 0x23 test.c[7] = 0x1 </code></pre>  <p>But what I actually get is:</p>  <pre><code>test.c[0] = 0xffffffef test.c[1] = 0xffffffcd test.c[2] = 0xffffffab test.c[3] = 0xffffff89 test.c[4] = 0x67 test.c[5] = 0x45 test.c[6] = 0x23 test.c[7] = 0x1 </code></pre>  <p>I'm seeing this on Ubuntu LTS 14.04 with GCC.</p>  <p>I've been trying to get my head around this for some time now. Why are the first 4 elements of the char array displayed as 32 bit integers, with 0xffffff prepended to them? And why only the first 4, why not all of them?<br> Interestingly enough, when I use the array to write to a stream (which was the original purpose of the whole thing), the correct values are written. But comparing the array char by char obviously leads to problems, since the first 4 chars are not equal 0xef, 0xcd, and so on.</p>