<p>The implementation of unrolled popcount below yields a wrong result, I managed to observer that only elements <code>b[0]</code> and <code>b[2]</code> are counted while <code>b[1]</code> and <code>b[3]</code> are not. </p>  <pre><code>#include &lt;stdio.h&gt;  int count_multiple_bits(unsigned long long *b, int size) {   unsigned long long *d = b;   int c;   __asm__("LD2 {v0.D, v1.D}[0], [%1], #16  \n\t"           "LD2 {v0.D, v1.D}[1], [%1]       \n\t"           "CNT v0.16b, v0.16b              \n\t"           "CNT v1.16b, v1.16b              \n\t"           "UADDLV h2, v0.16b               \n\t"           "UADDLV h2, v1.16b               \n\t"           "UMOV %0, v2.d[0]                \n\t"           : "+r"(c)           : "r"(d) : "v0", "v1", "v2");   return c; }  int main(int argc, const char *argv[]) {   unsigned long long bits[] = { -1ull, -1ull, -1ull, -1ull };   printf("Test: %i\n", count_multiple_bits(bits, 4));   return 0; } </code></pre>  <p>This one which counts 2 elements at a time works fine:</p>  <pre><code>int count_multiple_bits(unsigned long long *b, int size) {   unsigned long long *d = b;   int c;   __asm__("LD1 {v0.D}[0], [%1], #8   \n\t"           "LD1 {v0.D}[1], [%1]       \n\t"           "CNT v0.16b, v0.16b        \n\t"           "UADDLV h1, v0.16b         \n\t"           "UMOV %0, v1.d[0]          \n\t"           : "+r"(c)           : "r"(d) : "v0", "v1");   return c; } </code></pre>  <p>With all else being equal, I'd guess that the loads are wrong, here's the layout I presume:</p>  <pre><code>  v0.D[0] = b[0]   v1.D[0] = b[1]   v0.D[1] = b[2]   v1.D[1] = b[3] </code></pre>