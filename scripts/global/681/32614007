<p>As I understand the x64 calling convention in Windows (based on <a href="https://msdn.microsoft.com/en-us/library/ms235286.aspx" rel="nofollow">this</a> and <a href="https://en.wikipedia.org/wiki/X86_calling_conventions#Microsoft_x64_calling_convention" rel="nofollow">this</a>):</p>  <ul> <li>The first 4 arguments are passed in registers, although 32 bytes of shadow size is reserved in the stack.</li> <li>The overall stack must be 16-byte aligned (although individual arguments don't have to be).</li> <li>Arguments that are 1, 2, 4, or 8 bytes can go on the stack.  All other arguments must be passed by reference.</li> </ul>  <p>How are individual arguments aligned? Since I couldn't find anything that specifically addressed this, and based on how I thought alignment worked in x86, I assumed that 32-bit ints could be aligned at 4-byte boundaries.  So, for example, if function arguments 5 and 6 were both 32-bit ints, I would have expected them to be at stack offsets 32 and 36.  However, from looking at my compiler's assembly output, they're at offsets 32 and 40 (i.e., they're 8-byte aligned, even though they take up 4 bytes).</p>  <p>In other words, why does the following function call work in x64, even though it's passing 64-bit <code>uint64_t</code>s when 32-bit ints are expected?</p>  <pre><code>int i = 1; uint64_t p = 6; double v = 2.5; printf("%i %.*f\n%i %.*f\n", i, p, v, i, p, v); </code></pre>