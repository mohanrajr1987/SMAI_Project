<p>I'm writing some small programs in x64 asm, and I have trouble completing this one. I get a segfault on the scasb instruction. I guess the problem comes from the <code>mov eax, my_str       ; address of buffer passed to ... ?</code> line, in the strLen block. I tried with different registers, of course eax is not the right one (32 bits) to use. I'm on FreeBSD, hence the syscall. Any idea?</p>  <p>Here is the code :</p>  <pre><code> ;   ; StrLen.asm : Read a string on stdin and return its length using a strLen replacement  ;    section .data   userMsg :   db "Please enter a string (max 1024 bytes): ", 0   lenUserMsg equ $-userMsg    dispMsg :   db "Length: ", 0   lenDispMsg equ $-dispMsg    section .bss ;Uninitialized data   my_strLength equ 1024 ; Input buffer size   my_str :   resb my_strLength ; Input buffer     section .text   global _start    _start:    ;;; User Prompt ;;;   mov rax, 4 ; write   mov rdi, 1 ; stdout   mov rsi, userMsg ; msg text   mov rdx, lenUserMsg ; msg length   syscall    ;;; Read and store the string ;;;   mov rax, 3            ; read   mov rdi, 0            ; stdin   mov rsi, my_str       ; address of my_str passed to rsi   mov edx, my_strLength ; read n bytes in one go   syscall   ;mov r9, rax          ; keep sys_read return value (nb of bytes read)    ;;; strLen() ;;;   mov eax, my_str       ; address of buffer passed to ... ?   sub al, al            ; zeroes al   not rcx               ; 1/ecx = ecx highest value   cld                   ; clear direction flag for byte search   repne scasb           ; repeat byte search until match   not rcx               ; ecx contains 1/length +1   dec rcx               ; -1 &amp; ok we have the length    ;;; Write back the length ;;;   mov rax, rdi          ; write   mov rdi, 1            ; stdout   ; mov rcx, rcx        ; nb bytes read   mov rdx, my_strLength   syscall    ;;; Exit ;;;   mov rax, 1            ; exit   xor rdi, rdi          ; return value   syscall  </code></pre>