<p>So when I started the conversion and set the target to 'x64', I get 7 unresolved externals. Two examples:</p>  <pre><code>error LNK2001: unresolved external symbol _m_empty    ...CONVOLUTION_2D_USHORT.obj  CONVOLUTION_2D_USHORT error LNK2001: unresolved external symbol _mm_setzero_si64  ...CONVOLUTION_2D_USHORT.obj    CONVOLUTION_2D_USHORT </code></pre>  <p>So I tried investigating these a bit deeper, and I found that it doesn't like the __m64 inside the header files: Specifically mmintrin.h (there might be others).  In my amateur hour with C++, because I haven't messed with the language in years, (I'm usually in the C# department), I attempted to edit the header files, and replace __m64 with __m128i ??!!.  Don't know what is the correct route, to get this and other DLLs to compile against MachineX64.  After editing and putting the source of the header in my local directory, it still doesn't allow me to compile via right-click... again-Amateur-hour. There has been a few people that have asked similar questions, but I couldn't find the right one for me.  </p>  <p>Here is a sample of 'mmintrin.h' with unsupported __m64...</p>  <pre><code>typedef union __declspec(intrin_type)_CRT_ALIGN(8) __m64 { unsigned __int64    m64_u64; float               m64_f32[2]; __int8              m64_i8[8]; __int16             m64_i16[4]; __int32             m64_i32[2]; __int64             m64_i64; unsigned __int8     m64_u8[8]; unsigned __int16    m64_u16[4]; unsigned __int32    m64_u32[2]; } __m64;  /* General support intrinsics */ void  _m_empty(void); __m64 _m_from_int(int _I); int   _m_to_int(__m64 _M); __m64 _m_packsswb(__m64 _MM1, __m64 _MM2); __m64 _m_packssdw(__m64 _MM1, __m64 _MM2); __m64 _m_packuswb(__m64 _MM1, __m64 _MM2); __m64 _m_punpckhbw(__m64 _MM1, __m64 _MM2); __m64 _m_punpckhwd(__m64 _MM1, __m64 _MM2); __m64 _m_punpckhdq(__m64 _MM1, __m64 _MM2); __m64 _m_punpcklbw(__m64 _MM1, __m64 _MM2); __m64 _m_punpcklwd(__m64 _MM1, __m64 _MM2); __m64 _m_punpckldq(__m64 _MM1, __m64 _MM2); ... </code></pre>