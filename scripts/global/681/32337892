<p>I always use double to do calculations but double offers far better accuracy than I need (or makes sense, considering that most of the calculations I do are approximations to begin with).</p>  <p>But since the processor is already 64bit, I do not expect that using a type with less bits will be of any benefit.</p>  <p>Am I right/wrong, how would I optimize for speed (I understand that smaller types would be more memory efficient)</p>  <p>here is the test</p>  <pre><code>#include &lt;cmath&gt; #include &lt;ctime&gt; #include &lt;cstdio&gt;  template&lt;typename T&gt; void creatematrix(int m,int n, T **&amp;M){     M = new T*[m];     T *M_data = new T[m*n];      for(int i=0; i&lt; m; ++i)      {         M[i] = M_data + i * n;     } }  void main(){     clock_t start,end;     double diffs;     const int N = 4096;     const int rep =8;      float **m1,**m2;     creatematrix(N,N,m1);creatematrix(N,N,m2);      start=clock();     for(int k = 0;k&lt;rep;k++){         for(int i = 0;i&lt;N;i++){             for(int j =0;j&lt;N;j++)                 m1[i][j]=sqrt(m1[i][j]*m2[i][j]+0.1586);         }     }     end = clock();     diffs = (end - start)/(double)CLOCKS_PER_SEC;     printf("time = %lf\n",diffs);       delete[] m1[0];     delete[] m1;      delete[] m2[0];     delete[] m2;      getchar(); } </code></pre>  <p>there was no time difference between double and float, however when square root is not used, float is twice as fast.</p>