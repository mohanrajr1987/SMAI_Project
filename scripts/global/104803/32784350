<p>I added iCloud sync into my app. I don't know the reason but it's not updating in live time. Sometimes it updates at the startup and sometimes it updates while using the app. But it's not updating shortly after i add new data from an other device. Sometimes it takes hours and sometimes it takes days till the new data appears. </p>  <p>My code:</p>  <pre><code>override func viewWillAppear(animated: Bool) {     super.viewWillAppear(animated)     NSNotificationCenter.defaultCenter().addObserver(self, selector: "persistentStoreDidChange", name: NSPersistentStoreCoordinatorStoresDidChangeNotification, object: nil)     NSNotificationCenter.defaultCenter().addObserver(self, selector: "persistentStoreWillChange:", name: NSPersistentStoreCoordinatorStoresWillChangeNotification, object: moc.persistentStoreCoordinator)     NSNotificationCenter.defaultCenter().addObserver(self, selector: "recieveICloudChanges:", name: NSPersistentStoreDidImportUbiquitousContentChangesNotification, object: moc.persistentStoreCoordinator)  }  override func viewWillDisappear(animated: Bool) {      let moc = self.fetchedResultsController.managedObjectContext      NSNotificationCenter.defaultCenter().removeObserver(self, name: NSPersistentStoreCoordinatorStoresDidChangeNotification, object: nil)     NSNotificationCenter.defaultCenter().removeObserver(self, name: NSPersistentStoreCoordinatorStoresWillChangeNotification, object: moc.persistentStoreCoordinator)     NSNotificationCenter.defaultCenter().removeObserver(self, name: NSPersistentStoreDidImportUbiquitousContentChangesNotification, object: moc.persistentStoreCoordinator) }  func persistentStoreDidChange() {     //load data     tableView.reloadData() }  func persistentStoreWillChange(notification:NSNotification) {      let moc = self.fetchedResultsController.managedObjectContext     //disable UI (changes in progress)     managedObjectContext?.performBlock{ () -&gt; Void in         if moc.hasChanges {             var error: NSError? = nil             if moc.save(&amp;error) {                 abort()             }             else{                 moc.reset()             }         }     } }   func recieveICloudChanges(notification:NSNotification) {      let moc = self.fetchedResultsController.managedObjectContext     moc.performBlock { () -&gt; Void in          moc.mergeChangesFromContextDidSaveNotification(notification)         //load data         self.tableView.reloadData()     } }   func loadData() {      let appDelegate = UIApplication.sharedApplication().delegate as! AppDelegate     let managedContext = appDelegate.managedObjectContext!     let fetchRequest = NSFetchRequest(entityName:"Person")      var error: NSError?     let fetchedResults = managedContext.executeFetchRequest(fetchRequest, error: &amp;error) as! [NSManagedObject]?     if let results = fetchedResults {         people = results     } else {         println("Could not fetch \(error), \(error!.userInfo)")     }      tableView.reloadData() } </code></pre>  <p>AppDelegate:</p>  <pre><code>lazy var managedObjectModel: NSManagedObjectModel = {     // The managed object model for the application. This property is not optional. It is a fatal error for the application not to be able to find and load its model.     let modelURL = NSBundle.mainBundle().URLForResource("AppName", withExtension: "momd")!     return NSManagedObjectModel(contentsOfURL: modelURL)!     }()  lazy var persistentStoreCoordinator: NSPersistentStoreCoordinator? = {     // The persistent store coordinator for the application. This implementation creates and return a coordinator, having added the store for the application to it. This property is optional since there are legitimate error conditions that could cause the creation of the store to fail.     // Create the coordinator and store     var coordinator: NSPersistentStoreCoordinator? = NSPersistentStoreCoordinator(managedObjectModel: self.managedObjectModel)      let documentsDirectory = NSFileManager.defaultManager().URLsForDirectory(NSSearchPathDirectory.DocumentDirectory, inDomains: NSSearchPathDomainMask.UserDomainMask).last as! NSURL     let storeURL = documentsDirectory.URLByAppendingPathComponent("AppName.sqlite")      var error: NSError? = nil     var failureReason = "There was an error creating or loading the application's saved data."      let storeOptions = [NSPersistentStoreUbiquitousContentNameKey:"CloudNoteStore"]      if coordinator!.addPersistentStoreWithType(NSSQLiteStoreType, configuration: nil, URL: storeURL, options: storeOptions, error: &amp;error) == nil {         coordinator = nil         // Report any error we got.         var dict = [String: AnyObject]()         dict[NSLocalizedDescriptionKey] = "Failed to initialize the application's saved data"         dict[NSLocalizedFailureReasonErrorKey] = failureReason         dict[NSUnderlyingErrorKey] = error         error = NSError(domain: "YOUR_ERROR_DOMAIN", code: 9999, userInfo: dict)         // Replace this with code to handle the error appropriately.         // abort() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development.         NSLog("Unresolved error \(error), \(error!.userInfo)")         abort()     }      return coordinator     }() </code></pre>  <p>I'm using Xcode 6.4, iOS 8.4 and Swift. </p>