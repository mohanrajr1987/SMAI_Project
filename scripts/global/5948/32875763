<p>I'm borrowing <a href="http://www.pjrc.com/teensy/td_libs_Encoder.html" rel="nofollow">PJRC's Encoder library</a> to manage a stepper-powered syringe pump I am running off a <a href="https://www.sparkfun.com/products/12757" rel="nofollow">Sparkfun RedBoard</a> and a <a href="https://www.sparkfun.com/products/12859" rel="nofollow">BigEasy Driver</a>.</p>  <p>I've been developing the program modularly, defining lower-level classes first and working up from there. It is my <em>desire</em> that higher-level classes take instances of lower classes as properties. In my current nightmare, I'm building a syringe Pump class with Stepper motor and Encoder objects as properties.</p>  <p>I'm organizing the library into a header file and '.cpp' file as recommended by the Arduino Tutorials. The Pump class is declared as follows in 'Pump.h':</p>  <pre><code>#include "Arduino.h" #include "Stepper.h" #include "Encoder.h"  #define PUMP_TOP_SPEED 50   // ml/min               top pump speed #define PUMP_ERROR 10       // encoder counts       acceptable error  class Pump {      private:          Stepper motor;          // object       stepper motor         Encoder encoder;        // object       attached encoder         int countPerRev;        // #            encoder counts per relovlution         float nominalVolume;    // mL           nominal syringe volume         float innerDiameter;    // cm           syringe inner diameter         float shaftLead;        // cm           driveshaft threading lead distance         float degVolume;        // mL           effective volume change per degree of rotation         bool state;             // boolean      T = ready, F = slept      public:          // constructor         Pump(const Stepper&amp; stp, const Encoder&amp; enc, int cpr, float vol, float diam, float lead);          float volume();                         // returns nominalVolume         float position();                       // returns current pump position in mL         void hold();                            // high power state to resist back-pressure         void relax();                           // low power state         void pump(float vol, float rate);       // pumps the requested volume at requested rate         void release();                         // moves the plunger all the way out so syringe can be serviced         void set();                             // returns plunger to zero mL }; </code></pre>  <p>The relevant code in 'Pump.cpp' file which I have been testing with is the constructor and the definition of the <code>pump()</code> method, which goes like so:</p>  <pre><code>// constructor Pump::Pump(const Stepper&amp; stp, const Encoder&amp; enc, int cpr, float vol, float diam, float lead) : motor(stp), encoder(enc), countPerRev(cpr), nominalVolume(vol), innerDiameter(diam), shaftLead(lead) {      // calculate volume per degree     // (diameter^2 / 4) * PI * (lead / 360) = mL / deg     // diam * diam * lead * PI / 360 / 4 = (diam diam lead PI) / 1440     degVolume = innerDiameter * innerDiameter * shaftLead * PI / 1440;      // construct the encoder inside here     /*encoder = new(Encoder(2,3));      // set it to 0     encoder.write(0);*/ }  // pumping function void Pump::pump(float vol, float rate) {      /*         vol &lt; 0         INFUSE         vol &gt; 0         WITHDRAW     */      if (rate &gt; PUMP_TOP_SPEED) rate = PUMP_TOP_SPEED; // limit rate      if (!state) hold(); // wake up the motor if it's asleep      // make sure this doesn't push outside of the acceptable range     if (position() + vol &lt;= nominalVolume &amp;&amp; position() + vol &gt;= 0) {          // (mL) / (mL/deg) = deg         float degrees = vol / degVolume; // find number of degrees to turn the motor         Serial.print("Looking to turn ");         Serial.print(degrees, DEC);         Serial.print(" degrees at ");          // (count) + (deg) * (count/rev) / (deg/rev) = count         long goal = encoder.read() + degrees * countPerRev / 360; // set target encoder reading          // (mL/min) / (mL/deg) / (deg/rev) = RPM         int rpm = abs(rate) / degVolume / 360; // find RPM to turn the motor         Serial.print(rpm, DEC);         Serial.println(" RPM in full-stepping mode");         Serial.print("Going from encoder count ");         Serial.print(encoder.read(), DEC);         Serial.print(" to ");         Serial.println(goal, DEC);          motor.drive(degrees, 1, rpm); // drive the pump          int err = goal - encoder.read(); // how far from the goal are we in counts?         Serial.print("Reached encoder count ");         Serial.println(encoder.read(), DEC);         Serial.print("Missed by ");         Serial.println(err, DEC);      } } </code></pre>  <p>I've been testing my <code>pump()</code> method and threw in a whole bunch of <code>Serial.print()</code> to try to debug and figure out what is happening and from what I can see, the Encoder object that is a <strong>property of the Pump object</strong> doesn't have its position updated as the shaft turns, whereas the Encoder object <strong>declared in the Arduino sketch</strong> and passed to the Pump constructor does.</p>  <p>As you can see above I've tried to initialize the encoder within the pump constructor but the 2 or 3 things I tried all threw a bunch of cryptic errors in the Arduino IDE when I tried to compile, left that commented out section so you can see what I was trying.</p>  <p>What I find exceedingly annoying is that while my own Stepper object works fine, the Pump object can turn the motor, the Encoder object won't function inside the Pump object. When I run the sketch:</p>  <pre><code>#include &lt;Stepper.h&gt; #include &lt;Encoder.h&gt; #include &lt;Pump.h&gt;  // initialize stepper Stepper motor(4, 5, 6, 7, 8, 9, 10, 11);  // initialize encoder Encoder encoder(2, 3);  // initialize the pump Pump pump(motor, encoder, 1440, 25, 2.328, 0.1);  void setup() {   // start the Serial connection   Serial.begin(9600);    // set up the motor   motor.enable();   motor.reset();    // pump   pump.pump(0.25,25);    Serial.print("Pump reading:       ");   Serial.println(pump.position(), DEC);   Serial.print("Encoder reading:    ");   Serial.println(encoder.read(), DEC);    // cool boards   pump.relax();  }  void loop() {} </code></pre>  <p>I get back the following in the Serial monitor:</p>  <pre><code>Looking to turn 211.4397277832 degrees at 58 RPM in full-stepping mode Going from encoder count 0 to 845 Reached encoder count 0 Missed by 845 Pump reading:       0.0000000000 Encoder reading:    845 </code></pre>  <p>So, the method <code>encoder.read()</code> always returns zero in the Pump object but when I called it at the end of my sketch in the <code>setup()</code> function it turns I turned exactly as far as I wanted to.</p>  <p>Thank you for reading. I'd appreciate guidance on how to either properly pass an active Encoder object to Pump, or how to properly initialize an Encoder object within Pump without freaking out the compiler.</p>