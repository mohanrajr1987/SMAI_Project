<p>I'm writing a Web API, using CGI under linux.  All is great, using gcc. I am returning an image (jpeg) to the host: std::cout &lt;&lt; "Content-Type: image/jpeg\n\n" and now must send the binary jpeg image.  Loading the image into a char* buffer and std::cout &lt;&lt; buffer; does not work. I do get back an empty image. I suspect stdout stops on the first 00 byte.</p>  <p>I'm receiving from the web server a 200 OK with an incomplete image.  </p>  <p>I was going to redirect to the file in an open folder on the device, but this must be a secure transfer and not available to anyone who knows the url.</p>  <p>I'm stumped!</p>  <p>The code snippet looks like this: </p>  <pre><code>std:string imagePath;  syslog(LOG_DEBUG, "Processing GetImage, Image: '%s'", imagePath.c_str()); std::cout &lt;&lt; "Content-Type: image/jpeg\n\n"; int length; char * buffer;  ifstream is; is.open(imagePath.c_str(), ios::in | ios::binary); if (is.is_open()) {     // get length of file:     is.seekg(0, ios::end);     length = (int)is.tellg();     is.seekg(0, ios::beg);      // allocate memory:     buffer = new char[length];  // gobble up all the precious memory, I'll optimize it into a smaller buffer later                                   // OH and VECTOR Victor!      syslog(LOG_DEBUG, "Reading a file: %s, of length %d", imagePath.c_str(), length);      // read data as a block:     is.read(buffer, length);     if (is)     {         syslog(LOG_DEBUG, "All data read successfully");     }     else     {         syslog(LOG_DEBUG, "Error reading jpg image");         return false;     }     is.close();      // Issue is this next line commented out - it doesn't output the full buffer     // std::cout &lt;&lt; buffer;      // Potential solution by  Captain Obvlious - I'll test in the morning     std::cout.write(buffer, length); } else {     syslog(LOG_DEBUG, "Error opening file: %s", imagePath.c_str());     return false; } return true; </code></pre>