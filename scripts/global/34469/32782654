<p>I'm building a dynamic animation &amp; rendering system and I would like to use <a href="http://www.boost.org/doc/libs/release/libs/units/" rel="nofollow">Boost.Units</a> for representing physical quantities to get the nice dimensional safety. However, I will have to pass arrays of quantities around to functions which know nothing about Boost, such as:</p>  <ul> <li><p>OpenGL buffer-filling commands. These simply take a <code>const void *</code> and expect to find an array of either <code>float</code> or <code>double</code> values when dereferencing it. They read the data.</p></li> <li><p>Linear algebra functions (such as <code>gemm</code> or <code>gesv</code>) from different implementations of BLAS and LAPACK. These generally take either a <code>float *</code> or <code>double *</code> to a given array. They both read and write to the data.</p></li> </ul>  <p>I know that <code>boost::units::quantity&lt;U, T&gt;</code> has a <code>const T&amp; value()</code> member which gives direct reference access to the contained <code>T</code> value. I have also verified that a <code>boost::units::quantity&lt;U, T&gt;</code> is a standard-layout struct with exactly one non-static data member, of type <code>T</code>.</p>  <p>So, let's assume that for a <code>boost::units::quantity&lt;U, T&gt; q</code>, the following holds:</p>  <ul> <li><code>static_cast&lt;const void*&gt;(&amp;q) == static_cast&lt;const void*&gt;(&amp;q.value())</code></li> <li><code>sizeof(q) == sizeof(T)</code></li> </ul>  <p><strong>My question is</strong>: given an array <code>boost::units::quantity&lt;U, T&gt; a[100];</code>, is it safe to:</p>  <ol> <li><p>Pass <code>&amp;a[0].value()</code> to a function which expects to read an array of 100 objects of type <code>T</code> at the address?</p></li> <li><p>Pass <code>reinterpret_cast&lt;T*&gt;(&amp;a[0])</code> to a function which will write 100 sequential values of type <code>T</code> at the address?</p></li> </ol>  <p>I am well aware this is probably Undefined Behaviour, but right now I have to follow the "Practicality beats purity"<sup>(1)</sup> principle. Even if this is UB, is it one which will do the expected thing, or will it bite in unforeseen ways? Since this might be compiler-specific: I need this for modern MSVC (from VS 2015).</p>  <p>And if this is not safe, is there a way to actually do this safely? With "this" referring to "using Boost.Units with OpenGL and with number crunchers which only have a C interface," <em>without</em> unnecessarily copying data.</p>  <hr>  <p><sup>(1)</sup> Adapted from the <a href="https://www.python.org/dev/peps/pep-0020/" rel="nofollow">Zen of Python</a>.</p>