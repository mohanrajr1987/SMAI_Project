<p>I am currently working on extracting Contours path attributes from a particular image file. I am able to extract Contours using Open CV function <code>findContours()</code> the output look like this</p>  <pre><code>[98, 81][97, 80][95, 80][94, 79][93, 79][92, 78][91, 78][88, 75][87, 75][85, 73][84, 73][83, 72][82, 72] </code></pre>  <p>But my desired output is look like this</p>  <p><code>M 398.7,106.8 c -5.5,-2.7 -20.7,-4.7 -36.1,-4.6 -15.4,0.1</code></p>  <p>How can I get it </p>  <p>This is my code:</p>  <pre><code>using namespace cv; using namespace std; Mat src_grays; int threshs = 100; int max_threshs = 255; RNG rng(12345); void thresh_callbacks(int, void* ); void main(  ) { Mat src = imread( "F:/academic/pro4/t/download.jpg" ); imshow("real Image", src); Mat gray,edge,edges, draw,draws; Mat samples(src.rows * src.cols, 3, CV_32F); for( int y = 0; y &lt; src.rows; y++ ) for( int x = 0; x &lt; src.cols; x++ )   for( int z = 0; z &lt; 3; z++)     samples.at&lt;float&gt;(y + x*src.rows, z) = src.at&lt;Vec3b&gt;(y,x)[z]; int clusterCount = 5; Mat labels; int attempts = 10; Mat centers; kmeans(samples, clusterCount, labels, TermCriteria(CV_TERMCRIT_ITER|CV_TERMCRIT_EPS, 10000, 0.0001), attempts, KMEANS_PP_CENTERS, centers ); Mat new_image( src.size(), src.type() ); for( int y = 0; y &lt; src.rows; y++ ) for( int x = 0; x &lt; src.cols; x++ ) {    int cluster_idx = labels.at&lt;int&gt;(y + x*src.rows,0);   new_image.at&lt;Vec3b&gt;(y,x)[0] = centers.at&lt;float&gt;(cluster_idx, 0);   new_image.at&lt;Vec3b&gt;(y,x)[1] = centers.at&lt;float&gt;(cluster_idx, 1);   new_image.at&lt;Vec3b&gt;(y,x)[2] = centers.at&lt;float&gt;(cluster_idx, 2); } imshow( "clustered image", new_image ); char filename[80];     sprintf(filename,"F:/academic/pro4/t/seg.png");     imwrite(filename, new_image);      cvtColor(src, gray, CV_BGR2GRAY); Canny( new_image, edges, 50, 150, 3); edges.convertTo(draws, CV_8U); namedWindow("imageAfterSegmnetation", CV_WINDOW_AUTOSIZE); imshow("imagesAfterCluster", draws); cvtColor( new_image, src_grays, CV_BGR2GRAY ); blur( src_grays, src_grays, Size(3,3) ); char* source_window = "Source"; namedWindow( source_window, CV_WINDOW_AUTOSIZE ); imshow( source_window, src ); createTrackbar( " Canny thresh:", "Source", &amp;threshs, max_threshs, thresh_callbacks ); thresh_callbacks( 0, 0 );   waitKey( 0 );  } void thresh_callbacks(int, void* ) { Mat canny_output; vector&lt;vector&lt;Point&gt; &gt; contours; vector&lt;Vec4i&gt; hierarchy; /// Detect edges using canny Canny( src_grays, canny_output, threshs, threshs*2, 3 ); /// Find contours findContours( canny_output, contours, hierarchy, CV_RETR_TREE, CV_CHAIN_APPROX_SIMPLE, Point(0, 0) ); for(int i= 0; i &lt; contours.size(); i++) { for(int j= 0; j &lt; contours[i].size();j++) // run until j &lt; contours[i].size(); {     int a=  contours[i][j].x  ;      int b =contours[i][j].y ;    // printf("Point(x,y)=" + a, b);     std::cout &lt;&lt; contours[i][j] &lt;&lt; std::endl;        } printf ("%i", i + "\n"); } /// Draw contours int a=contours.size();  for( int i = 0; i&lt;contours.size(); i++ )  {      Mat drawing_i = Mat::zeros( canny_output.size(), CV_8UC3 );    Scalar color = Scalar( rng.uniform(0, 255), rng.uniform(0,255), rng.uniform(0,255) );    drawContours( drawing_i, contours, i, color, 2, 8, hierarchy, 0, Point() );     namedWindow( "Contours_i", CV_WINDOW_AUTOSIZE );     imshow( "Contours_i", drawing_i );    }    } </code></pre>  <p>Note:<br> I need Contours path, that mean how to contours connected for example it can be M = moveto L = lineto H = horizontal lineto V = vertical lineto C = curveto S = smooth curveto Q = quadratic Bézier curve T = smooth quadratic Bézier curveto A = elliptical Arc Z = closepath just like SVG path</p>