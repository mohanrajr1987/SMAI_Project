<p>I have an executor service which handles the processing of tasks asynchronously. As part of this processing, each task invokes a service bean which I've defined as being <code>@Transactional</code>. </p>  <pre><code>processingTasks.add(executorService.submit(() -&gt; {      Action action = ...     return actionService.processAction(action, Arrays,asList());  })); </code></pre>  <p>This service method invokes a JpaRepository method to check if a entity record exists in the database. If this repository returns a null record, then a new entity object is created, then this object is processed and saved back using the repository.</p>  <pre><code>@Override @Transactional public ServiceAction processAction(Action action, List&lt;HttpMethod&gt; methods) {      final Action databaseAction  = Optional.ofNullable(actionRepository.findByType(action.getType()))         .orElseGet(() -&gt; actionRepository.save(action));      // processing of databaseAction      return actionRepository.save(databaseAction);  } </code></pre>  <p>The Action entity has a unique key constraint on the <code>type</code> field. At the moment, the application is throwing a Hibernate duplicate key exception because the transaction hasn't been flushed from the first persistence of the object.</p>  <p>The problem I'm having is how to manage the hibernate session in this scenario? I have tried specifying an isolation level of <code>READ_COMMITTED</code> to the method to ensure each thread doesn't dirty-read. But get errors saying that manually setting the isolation level isn't supported by JPA. </p>  <p>What's the ideal way to manage the hibernate transaction in this scenario, such that, each thread gets the most up-to-date data from the action table.</p>  <p>Thanks.</p>