<p>I've been reading through mongos own documents here, where they mention different ways of creating your schema:</p>  <p><a href="http://blog.mongodb.org/post/87892923503/6-rules-of-thumb-for-mongodb-schema-design-part-2" rel="nofollow">http://blog.mongodb.org/post/87892923503/6-rules-of-thumb-for-mongodb-schema-design-part-2</a></p>  <p>One of their methods mention partial normalization, whereby you may save a few fields of one document in another document in order to speed up reads for frequently used fields at the expense of having to save the same data in two separate documents using two separate writes.</p>  <p>This sounds great except for the fact that just about everywhere I've looked I've been told that mongo is not very good at atomic updates and many times I have seen people say, "In your case, if transaction is a must, mongo seems not a good fit.". This seems very contradictory... I cannot imagine a case where I would want to update two documents with the same data but not have a guaranteed update across both a "must". If I were to implement this pattern and the server was to somehow go down between the time I updated the second document, how would I ever know be able to recover? The data would be forever out of sync. If this makes mongo a bad fit, then it has very limited use cases.</p>  <p>Now, I've found this article about how to attempt transactions but it seems excessively complex when all I want to do is create some simple normalized schemas:</p>  <p><a href="http://docs.mongodb.org/manual/tutorial/perform-two-phase-commits/" rel="nofollow">http://docs.mongodb.org/manual/tutorial/perform-two-phase-commits/</a></p>  <p>Am I missing something here? Why does the data normalization article seem to be so contradictory to mongos ability to handle transactions? I'm trying to learn how to design mongo schemas properly and am finding this all very confusing.</p>