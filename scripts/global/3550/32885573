<p>I have a fairly big table that has 150 individual PHP scripts connect, select data to process, update as <code>in_use</code>, then process.</p>  <p>So that no script selects the same data as another in the same session, <code>in_use</code> is set, and a transaction lock is used to ensure no script selects the same data as another. Here is the code (in PHP):</p>  <pre><code>$sql - "select data....FOR UPDATE;" // &lt;-- real query is much longer and not really neccesary here.  mysqli_autocommit($db_connect, FALSE); mysqli_begin_transaction($db_connect, MYSQLI_TRANS_START_READ_WRITE); $b = mysqli_query($db_connect, $sql); $to_process = mysqli_fetch_all($b, MYSQLI_ASSOC); $s = "'" . implode("', '", $to_process) . "'"; mysqli_query($db_connect, "UPDATE `users` SET `in_use` = 1 WHERE `username` IN ({$s});"); mysqli_commit($db_connect); </code></pre>  <p>The issue is that each select, which takes seconds when done manually, takes like 10 minutes between each of the 150 queries (meaning 1500 mins in total just selecting data). Is there a frequency variable that <code>MySQL</code> uses to see when to check when the lock should be free? I really need to speed this up as each <code>SELECT</code> query should only take seconds between each other.</p>  <p>Thanks all!</p>  <p>EDIT</p>  <p>The query is :</p>  <pre class="lang-sql prettyprint-override"><code>SELECT DISTINCT `username`  FROM `users`  WHERE `in_use` = 0    AND `username_from` IN        ( SELECT DISTINCT `username`          FROM `source_accounts`          WHERE `group_users` = '{$owner['group_users']}'            AND (`type` = 'users' OR `type` = 'both')            AND `use` = '1'       )     AND `username` NOT IN        ( SELECT `user_request`          FROM `request_history`          WHERE `owner_account` = '{$owner['username']}'       )     LIMIT {$owner['follow']} FOR UPDATE; </code></pre>