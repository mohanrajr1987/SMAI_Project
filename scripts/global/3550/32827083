<p>I have a table with a <code>CLUSTERED PRIMARY KEY</code> made by the following fields:</p>  <pre><code>| Group |  ID  | Other non-key fields... |   A   |   1  |   foo |   A   |   2  |   bar |   B   |   1  |   so </code></pre>  <p>I always access this table filtering by a specific Group value (<code>WHERE Group = @Something</code>). I know that only 1 client can access each group (because it creates it, and no other clients know which other groups exists) so my question is: Is there a way to garantee concurrent access to the table, given the fact that the table is always accessed by the Group Column and only one client works on one Group?</p>  <p>I've looked around and I saw that <code>SERIALIZABLE ISOLATION LEVEL</code> allows Key-Range Locking, but every way I try it, I always fail.</p>  <p>I've setup 2 Management Studio tabs, each one with the same code, just different Group value (<code>A</code> in this example, <code>B</code> in the other tab)</p>  <pre><code>SET TRANSACTION ISOLATION LEVEL SERIALIZABLE BEGIN TRANSACTION SELECT * FROM MyTable WHERE Group = 'A' GO UPDATE MyTable SET AField = 'something' WHERE Group = 'A'  --ROLLBACK </code></pre>  <p>The fact is that the first transaction I run, that locks everything, and stops the other one to even read the data from the table.</p>  <p>So how those Key-Range Locks works? Is it even possible to obtain what I'm asking for?</p>  <p>Other things I tried:</p>  <ul> <li><code>ROWLOCK</code> hint. Doesn't work, also on MSDN pages, I've found that <code>ROWLOCK</code> hint does not block a lock escalation to the table level.</li> <li><code>1211</code> trace flag for disabling lock escalation. Doesn't work either (it actually disable the lock escalation to the table level, but that does not change anything).</li> <li>Looking for groups very far away from each other. (maybe there were some pages in common... I don't know)</li> </ul>