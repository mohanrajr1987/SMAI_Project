<p><strong>At first glance, I concede that this question looks like a duplicate of this question and any other related to it:</strong></p>  <p><a href="http://stackoverflow.com/questions/53497/regular-expression-that-matches-valid-ipv6-addresses/17871737#comment52593228_17871737" title="Regular expression that matches valid IPv6 addresses">Regular expression that matches valid IPv6 addresses</a></p>  <p>That question in fact has an answer that nearly answers my question, <strong>but not fully.</strong></p>  <p>The code from that question which I have issues with, yet had the most success with, is as shown below:</p>  <pre><code>private string RemoveIPv6(string sInput) {     string pattern = @"(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))";     //That is one looooong regex! From: http://stackoverflow.com/a/17871737/3472690     //if (IsCompressedIPv6(sInput))       //  sInput = UncompressIPv6(sInput);     string output = Regex.Replace(sInput, pattern, "");     if (output.Contains("Addresses"))         output = output.Substring(0, "Addresses: ".Length);      return output; } </code></pre>  <p>The issues I had with the regex pattern as provided in this answer, <a href="http://stackoverflow.com/a/17871737/3472690" title="David M. Syzdek&#39;s Answer">David M. Syzdek's Answer</a>, is that it doesn't match and remove the full form of the IPv6 addresses I'm throwing at it.</p>  <p>I'm using the regex pattern to mainly replace IPv6 addresses in strings with blanks or null value.</p>  <p>For instance,</p>  <pre><code>    Addresses:  2404:6800:4003:c02::8a </code></pre>  <p>As well as...</p>  <pre><code>    Addresses:  2404:6800:4003:804::200e </code></pre>  <p>And finally...</p>  <pre><code>    Addresses:  2001:4998:c:a06::2:4008 </code></pre>  <p>All either don't get fully matched by the regex, or failed to be completely matched.</p>  <p>The regex will return me the remaining parts of the string as shown below:</p>  <pre><code>    Addresses:  8a      Addresses:  200e      Addresses:  2:4008 </code></pre>  <p>As can be seen, it has left remnants of the IPv6 addresses, which is hard to detect and remove, due to the varying formats that the remnants take on. Below is the regex pattern by itself for better analysis:</p>  <pre><code>(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])) </code></pre>  <p>Therefore, <strong>my question is</strong>, how can this regex pattern be corrected so it can match, and therefore allow the complete removal of any IPv6 addresses, from a string that doesn't solely contain the IPv6 address(es) itself?</p>  <p><strong>Alternatively</strong>, how can the code snippet I provided above be corrected to provide the required outcome?</p>  <p><em>For those who may be wondering, I am getting the string from the StandardOutput of nslookup commands, and the IPv6 addresses will always differ. For the examples above, I got those IPv6 addresses from "google.com" and "yahoo.com".</em></p>  <p><em>I am not using the built-in function to resolve DNS entries for a good reason, which I don't think will matter for the moment, therefore I am using nslookup.</em></p>  <p><em>As for the code that is calling that function, if required, is as below: (It itself is also another function/method, or rather part of one)</em></p>  <pre><code>string output = ""; string garbagecan = ""; string tempRead = ""; string lastRead = ""; using (StreamReader reader = nslookup.StandardOutput) {      while (reader.Peek() != -1)      {          if (LinesRead &gt; 3)          {              tempRead = reader.ReadLine();              tempRead = RemoveIPv6(tempRead);               if (tempRead.Contains("Addresses"))                  output += tempRead;              else if (lastRead.Contains("Addresses"))                  output += tempRead.Trim() + Environment.NewLine;              else                  output += tempRead + Environment.NewLine;              lastRead = tempRead;          }          else              garbagecan = reader.ReadLine();          LinesRead++;      }  }  return output; </code></pre>  <p>The corrected regex should only allow the removal of IPv6 addresses, and leave IPv4 addresses untouched. <em>The string that will be passed to the regex will not contain the IPv6 address(es) alone, and will almost always contain other details, and as such, it is unpredictable at which index will the addresses appear.</em> The regex is also skipping all other IPv6 addresses after the first occuring IPv6 addresses as well for some reason, it should be noted.</p>  <p>Apologies if there are any missing details, I will try my best to include them in when alerted. I would also prefer working code samples, if possible, as I have almost zero knowledge regarding regex.</p>