<p>I'm running a command line process in a Windows window, with redirected stdin/stdout/stderr. The process might be interactive, so I need to pass the keyboard input to it. I do so by writing typed bytes to the process' <code>StandardInput</code>, with <code>AutoFlush=true</code>.</p>  <p>I'm testing on cmd.exe. I can see that cmd receives the input - if I type "dir[Enter]", the command is executed as expected. The characters are passed to StandardInput exactly when they're typed, I've checked.</p>  <p><strong>However, here's the weirdness: the typed characters are only echoed back to the process' stdout when I press Enter.</strong></p>  <p>This looks like a flushing issue, but I can't modify cmd's behavior; I can't force it to flush after every byte.</p>  <p>Here's the KeyPressed handler:</p>  <pre><code>    Process m_Proc;      //...      private void OnConsoleKey(object sender, KeyPressEventArgs e)     {         if (m_Proc != null &amp;&amp; !m_Proc.HasExited)         {             char c = e.KeyChar;             if (c == '\r')                 m_Proc.StandardInput.Write("\r\n"); //Enter key delivered as CR, no LF             else                 m_Proc.StandardInput.Write(c);             m_Proc.StandardInput.Flush();         }     } </code></pre>  <p>I am processing stdout on per-byte basis, not on per-line basis, like this:</p>  <pre><code>    m_Proc.Start();     new Thread(StreamReaderProc).Start(m_Proc.StandardOutput);      //...      private void StreamReaderProc(object o)     {         StreamReader sr = o as StreamReader;         for (; ; )         {             int c = sr.Read();             if (c == -1) //End of file - that means the process quit                 break;             else                 BeginInvoke(new Action&lt;char&gt;(LogChar), (char)c);  //Can't modify the log contents from a worker thread         }     } </code></pre>  <p>Any idea what's the matter here?</p>