<p>I am working through a memory issue with one of our webapps. I am using Chrome's heap profiler. I want to make sure I understand something very explicitely, as I'm making assumptions on this information. </p>  <p><a href="http://i.stack.imgur.com/GfFZZ.png" rel="nofollow"><img src="http://i.stack.imgur.com/GfFZZ.png" alt="CHrome debuggger"></a></p>  <p>The <code>@</code> symbol in the heap profile screenshot above. I want to make sure I understand crystal clear: equal object ids implies the same object</p>  <p><code> a.objectId == b.objectId implies a same as b a.objectId == b.objectId implies NOT a same as b </code></p>  <p>Therefore if I have two objects that I expected to actually be the same thing, yet their object id differs, this implies an unexpected copy occurred? This implies I can go and figure out in my code where I might  be creating unnecessary duplicates?</p>  <p>The <a href="https://developer.chrome.com/devtools/docs/javascript-memory-profiling#memory-profiling-faq" rel="nofollow">documentation</a> appears to say this, but they don't quite say it explicitly, going on to say why they have an object id, not what it represents.</p>  <blockquote>   <p>This is an object ID. Displaying an object's address makes no sense, as objects are moved during garbage collections. Those object IDs are real IDs — that means, they persist among multiple snapshots taken and are unique. This allows precise comparison between heap states. Maintaining those IDs adds an overhead to GC cycles, but it is only initiated after the first heap snapshot was taken — no overhead if heap profiles aren't used.</p> </blockquote>  <p>I get that. But I need to fit this back into my C programmer head. I realize, even with native heaps, pointer values can change over time. Can I effectively treat object ids as pointer addresses unique over time?</p>