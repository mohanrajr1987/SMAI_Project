<p>Short Version:</p>  <p>Before the TL;DR section, my main question is this, what is difference when building to profile using instruments then a regular build that would result in reduced CPU load of my app by over 200%?</p>  <p>When building to run, it uses well over 200% CPU as reported by activity monitor, but with everything else the same, when building for profiling, using the Time Profiler, it reduces the CPU load down to  &lt;5%, which is a dramatic (orders of magnitude) difference.</p>  <p>TL;DR Version:</p>  <p>As an exercise to learn Cocoa, Swift and DSP (yes all three at once), I am working on writing a simple radio scanner OS X application using the cheap rtl-sdr dongles.</p>  <p>I have written a simple Swift wrapper around librtlsdr, a simple UI to be able to set the frequency, and a couple of simple DSP routines.  My wrapper around librtlsdr uses an NSOperationQueue and my DSP routines use GCD queues in order to move the IO and CPU intense routines off the main thread / queue.</p>  <p>Currently, everything is working to the extent that I can successfully demodulate an AM transmission.</p>  <p>I have implemented a simple low-pass FIR filter and while working on the algorithm, I was surprised when I realized that I couldn’t use much more than about 30 coefficients before my filter routine started taking too long and the audio became choppy.  As well, Activity Monitor shows up to 300% CPU usage for my app, which seems crazy high considering my filter contains nothing but a nested loop to do some multiply and accumulate operations.  Anything higher than about 40 coefficients and the UI becomes unresponsive.</p>  <p>For the DSP minded, it’s a decimating filter where I am using the entire sample set for filtering (960000 sps) , but only filtering the samples that I need for the rate reduction (48000), using a rectangular windowed sinc function for the coefficients, pre computed.  Not the most efficient algorithm, but on my quad core i7 Macbook Pro and iMac, it should still scream.</p>  <p>To get some insight on where my program was using up all the CPU cycles, I decided to give Instruments a go.  Product->Profile, choosing the Time Profiler and running my app gave my some interesting information.  </p>  <p>1) My filter routine was NOT using the most CPU cycles.<br> 2) Activity monitor showed that my app  wasn’t even at 5% CPU usage</p>  <p>So I decided to find out how far I can stress things before I see any stress on the CPU and I was up to a 50,000 tap filter before it started to be noticeably choppy and the CPU usage went close to 300%.  So… to recap, normal build and run, I max out at about 35-40 filter taps; profile build and run, I max out at about 50,000 filter taps.</p>  <p>Also worthy of note, while profiling with 50,000 filter taps, the UI still responds instantly and I can change frequency, start / stop the radio and it has choppy audio.  During a normal run, the UI starts to freeze just as soon as I start the radio with no audio, and that happens after I get to only about 50 taps.</p>  <p>Again, why the dramatic difference in CPU usage between between running while profiling, and running just a standard build; what’s different aside from the elevated privileges for Instruments and what do I need to do to make it the normal behavior for my app?</p>  <p>JE</p>