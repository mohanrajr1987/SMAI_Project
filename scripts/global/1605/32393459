<p>I want to profile the time used for every line in a specific function <code>export()</code>, which is in the IO part of my library and thus has the path <code>mylib.io.export()</code>. In order to test it with real world data I need to run <code>load_transform_export.py</code>, which more or less contains the following code:</p>  <pre><code>import mylib  i_data = mylib.io.read(...) t_data = mylib.utils.transform(i_data) train, test = mylib.utils.split(t_data) mylib.io.export(train, 'train.h5') mylib.io.export(test, 'test.h5') </code></pre>  <p>I've tried using <a href="https://github.com/rkern/line_profiler" rel="nofollow">line_profiler</a> by adding <code>@profile</code> to <code>mylib.io.export()</code> and running the script with <code>kernprof -l -v load_transform_export.py</code>. However, it seems that it cannot inject into a function in a library (e.g. not the main script). How can I profile the time used for each line in my function with this setup?</p>  <p><strong>Edit:</strong></p>  <p>The output for the profiling should be per-line basis, and therefore similar to <a href="http://www.huyng.com/posts/python-performance-analysis/" rel="nofollow">this</a>:</p>  <pre><code>Wrote profile results to primes.py.lprof Timer unit: 1e-06 s  File: primes.py Function: primes at line 2 Total time: 0.00019 s  Line #      Hits         Time  Per Hit   % Time  Line Contents ==============================================================      2                                           @profile      3                                           def primes(n):       4         1            2      2.0      1.1      if n==2:      5                                                   return [2]      6         1            1      1.0      0.5      elif n&lt;2:      7                                                   return []      8         1            4      4.0      2.1      s=range(3,n+1,2)      9         1           10     10.0      5.3      mroot = n ** 0.5     10         1            2      2.0      1.1      half=(n+1)/2-1     11         1            1      1.0      0.5      i=0     12         1            1      1.0      0.5      m=3     13         5            7      1.4      3.7      while m &lt;= mroot:     14         4            4      1.0      2.1          if s[i]:     15         3            4      1.3      2.1              j=(m*m-3)/2     16         3            4      1.3      2.1              s[j]=0     17        31           31      1.0     16.3              while j&lt;half:     18        28           28      1.0     14.7                  s[j]=0     19        28           29      1.0     15.3                  j+=m     20         4            4      1.0      2.1          i=i+1     21         4            4      1.0      2.1          m=2*i+3     22        50           54      1.1     28.4      return [2]+[x for x in s if x] </code></pre>