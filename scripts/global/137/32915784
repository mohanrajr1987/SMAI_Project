<p>This question builds upon the one <a href="http://stackoverflow.com/questions/32895553/passing-a-cython-function-vs-a-cython-method-to-scipy-integrate">here</a></p>  <p>I have the following cython code that imports a file (<code>cGslInteg.pxd</code>) containing the cython declarations for the relevant parts of the <code>gsl/gsl_integration.h</code> and <code>gsl/gsl_math.h</code> header files and then defines a class to compute an integral:</p>  <pre><code>from libc.math cimport log from libc.math cimport sqrt from cGslInteg cimport *  ctypedef double * double_ptr  cdef double integrand(double x, void * params):     """integrand implemented outside class """      cdef double alpha = (&lt;double_ptr&gt; params)[0]     cdef double f = log(alpha*x) / sqrt(x)     return f   cdef class CalcSomething(object):      def integrate(self, double a, double b, double alpha):         """This does the integral"""          cdef double result, error          cdef gsl_integration_workspace * W         W = gsl_integration_workspace_alloc(1000)          cdef gsl_function F          F.function = &amp;integrand          # works          # F.function = &amp;self._integrand  # doesn't work          cdef double params[1]         params[0] = alpha         F.params = &amp;params          cdef double epsabs = 0.         cdef double epsrel = 1e-7         gsl_integration_qags(&amp;F, a, b, epsabs, epsrel, 1000, W, &amp;result, &amp;error)         gsl_integration_workspace_free(W)          return result       cdef double _integrand(self, double x, void * params):         """integrand implemented inside class """          cdef double alpha = (&lt;double_ptr&gt; params)[0]         cdef double f = log(alpha*x) / sqrt(x)         return f </code></pre>  <p>The above code compiles and runs correctly as the integrand function <em>outside the class</em> is used (<code>F.function = &amp;integrand</code>). However, changing this line to the one commented out beneath (<code>F.function = &amp;self._integrand</code>) in order to use instead the integrand function <em>inside the class</em>, brings the following compilation error:</p>  <pre><code>cython_class_gsl.pyx:31:21: Cannot assign type 'double (*)(CalcSomething, double, void *)' to 'double (*)(double, void *)' </code></pre>  <p>Which makes sense because my declaration for <code>gsl_function</code> in <code>cGslInteg.pxd</code> is:</p>  <pre><code>cdef extern from "gsl/gsl_math.h":      # Definition of an arbitrary function with parameters     ctypedef struct gsl_function:         double (* function) (double x, void * params)         void * params </code></pre>  <p>My question is: can I re-declare <code>gsl_function</code> so it expects something with type e.g. <code>double (*)(PythonObject, double, void *)</code> or can I wrap <code>self._integrand</code> so it appears to have type <code>double (*)( double, void *)</code>?</p>