<p>I'm adapting the <a href="http://letstalkdata.com/2014/08/how-to-write-a-text-adventure-in-python/" rel="nofollow">text adventure game tutorial</a>, <a href="https://github.com/phillipjohnson/text-adventure-tut/" rel="nofollow">github</a>, to fit python 2.7. I'm using the PyCharm 4.5.4 community edition for my IDE. When I don't override a parent method it gives me an error:</p>  <blockquote>   <p>Class WolfRoom must implement all abstract methods</p> </blockquote>  <p>At first to get rid of this error I defined the missing method <code>def modify_player(self, the_player):</code> as <code>pass</code> but I quickly realized I was overriding the method with nothing which isn't what I wanted. Now if I just remove the method from the WolfRoom class I get an IDE error, as seen above, but it appears to work just fine when I run my game. Should I leave this method out or define it and use <code>super()</code>? </p>  <p>Here are some code snippets:</p>  <pre><code>class MapTile(object):     """The base class for all Map Tiles"""      def __init__(self, x, y):         """Creates a new tile.         Attributes:             :param x: The x coordinate of the tile.             :param y: The y coordinate of the tile.         """         self.x = x         self.y = y      def intro_text(self):         """Information to be displayed when the player moves into this tile."""         raise NotImplementedError()      def modify_player(self, the_player):         """Process actions that change the state of the player."""         raise NotImplementedError()      def adjacent_moves(self):         """Returns all move actions for adjacent tiles."""         moves = []         if world.tile_exists(self.x + 1, self.y):             moves.append(actions.MoveEast())         if world.tile_exists(self.x - 1, self.y):             moves.append(actions.MoveWest())         if world.tile_exists(self.x, self.y - 1):             moves.append(actions.MoveNorth())         if world.tile_exists(self.x, self.y + 1):             moves.append(actions.MoveSouth())         return moves      def available_actions(self):         """Returns all of the available actions in this room"""         moves = self.adjacent_moves()         moves.append(actions.ViewInventory())         return moves </code></pre>  <p>...</p>  <pre><code>class EnemyRoom(MapTile):     def __init__(self, x, y, enemy):         self.enemy = enemy         super(EnemyRoom, self).__init__(x, y)      def intro_text(self):         pass      def modify_player(self, the_player):         if self.enemy.is_alive():             the_player.hp = the_player.hp - self.enemy.damage             print("Enemy does {} damage. You have {} HP remaining.".format(self.enemy.damage, the_player.hp))      def available_actions(self):         if self.enemy.is_alive():             return [actions.Flee(tile=self), actions.Attack(enemy=self.enemy)]         else:             return self.adjacent_moves() </code></pre>  <p>...</p>  <pre><code>class WolfRoom(EnemyRoom):     def __init__(self, x, y):         super(WolfRoom, self).__init__(x, y, enemies.Wolf())      def intro_text(self):         if self.enemy.is_alive():             return """             A grey wolf blocks your path. His lips curl to expose canines as white as             the nights sky. He crouches and prepares to lunge.             """         else:             return"""             The corpse of a grey wolf lays rotting on the ground.             """ </code></pre>