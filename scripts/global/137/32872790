<p>I have some a <code>ConnectFour</code> class and I have a method:</p>  <pre><code>def apply_move!(column_number, symbol, row_number = 0)   # Some gravity logic   @board[row_number][column_number] = symbol end </code></pre>  <p>That modifies the class in place.</p>  <p>I tried writing a wrapper around it that returns a board and does not change the original, so that Function Programming techniques could be used.</p>  <p>My attempt is:</p>  <pre><code>def apply_move(column_number, symbol)   dummy = ConnectFour.new(@board)   dummy.apply_move!(column_number, symbol)   dummy end </code></pre>  <p>But the trouble is that modifying <code>dummy</code> also modifies the original class itself! How could I modify <code>dummy</code> and <code>dummy</code> only?</p>  <p><strong>More code and context</strong></p>  <p>You probably are interested in:</p>  <pre><code>class CpuWinIfPossible &lt; Player   def decide_move(board)     (0...6).find do |move|       board.apply_move(move, self.symbol).is_won?(self.symbol)     end || (0...6).to_a.sample   end end </code></pre>  <p>Here I loop and execute <code>apply_move</code> to my board, as you can see from my definition above, <code>apply_move</code> should not change the board, but the board shows 7 (+ 1) moves after this code is run: it looks like this:</p>  <pre><code>Player X: Where would you like to play (Number from 1 to 7) ?  2      O   O  OXOOOO  The winner is O </code></pre>  <p><strong>The constructor</strong></p>  <pre><code>class ConnectFour   attr_accessor :board     def initialize(board)     @board = board   end </code></pre>