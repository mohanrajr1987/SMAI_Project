<p>Suppose I have a base abstract class:</p>  <pre><code>class Foo { public:     struct FooStruct;     virtual FooStruct *DoFoo() = 0; }; </code></pre>  <p>And now I would like to implement the <code>DoFoo</code> in <code>Bar</code> and also define the <code>FooStruct</code> inside it:</p>  <pre><code>class Bar: public Foo { public:     struct FooStruct {         int data;     };     FooStruct *DoFoo() {         FooStruct *fs = new FooStruct;         fs-&gt;data = 42;         return fs;     } }; </code></pre>  <p>However, <code>g++</code> (in my case) recognizes <code>Foo::FooStruct</code> and <code>Bar::FooStruct</code> as two different structures and will complain about <code>invalid covariant type ...</code> because I redefine return type of a method.</p>  <p>How can I fix this? </p>