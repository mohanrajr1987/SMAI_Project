<p>I am trying to understand some behaviour that I have seen for a query that I am trying to optimise in MSSQL Sever 2012 Engine.</p>  <p>For privacy reasons, I cannot post the entire 3 sets of union query, but I have managed to identify the UNION portion which incurred almost 16% of the cost:</p>  <pre><code>SELECT      p.user_id AS user_identification_part,      '' AS subscriber_identification_part,     ISNULL(p.name, '') AS name,      CASE         WHEN ISNULL(p.subject_id, '') = s.subject_id THEN ISNULL(sl.name, s.name)         ELSE ''       END AS subject_name,     ISNULL(bl.name, b.name) AS book_name,     'general reader' AS type,      NULL AS end_date  FROM userz p (NOLOCK), subjects s (NOLOCK) LEFT JOIN subject_language sl (NOLOCK) ON (s.subject_id = sl.subject_id AND sl.locale = 'en_US'), book b (NOLOCK) LEFT JOIN book_language bl (NOLOCK) ON (b.book_id = bl.book_id AND bl.locale = 'en_US')  WHERE      p.ncode = 'JC001'      AND p.ccode = 'DJ01'     AND (ISNULL(p.subject_id, '') = s.subject_id OR ISNULL(p.subject_id, '') = '')     AND (ISNULL(p.book_id, '') = b.book_id)     AND p.user_type = 1          AND p.person_id != '00abcdefghi'     AND p.active_user = 1     AND (ISNULL(p.end_date, '') = '' OR ISNULL(p.end_date, '') &gt;= cast(getdate() as date)) </code></pre>  <p>I came to know about the 16% cost on Hash Matching effort by right-clicking the entire query and selecting execution plan on SQL server. I am doing UNION between the above and two other queries which perform similar joins. None of the other queries take so much time. The total execution tame was 28 seconds.</p>  <p>When I changed the query above to the following, the speed improved drammatically (~2s) and I believe it's mainly due to performing LEFT JOINS instead of INNER LEFT joins (from userz p inner join subjects left join subject language):</p>  <pre><code>        SELECT          p.user_id AS user_identification_part,          '' AS subscriber_identification_part,         ISNULL(p.name, '') AS name,          ISNULL(ISNULL(sl.name, s.name), '')as subject_name,         ISNULL(bl.name, b.name) AS book_name,         'general reader' AS type,          NULL AS end_date      FROM userz p (NOLOCK)     LEFT JOIN subjects s (nolock) on (s.ccode='DJ01' and ISNULL(p.subject_id, '') = s.subject_id)     LEFT JOIN subject_language sl (nolock) on (s.subject_id= sl.subject_id and sl.locale = 'en_US'),     book_name b (NOLOCK) LEFT JOIN book_language bl (NOLOCK) ON (b.book_id = bl.book_id AND bl.locale = 'en_US')      WHERE          p.ncode = 'JC001'          AND p.ccode = 'DJ01'         AND (ISNULL(p.book_id, '') = b.book_id)         AND p.user_type = 1              AND p.user_id != '00abcdefghi'         AND p.active_user = 1         AND (ISNULL(p.end_date, '') = '' OR ISNULL(p.end_date, '') &gt;= cast(getdate() as date)) </code></pre>  <p>I am treating the UNIONS as a table using WITH AS and then selecting the top 20 results. So the entire query looks like the following:</p>  <pre><code>WITH bill_table (user_identification_part, subscriber_identification, part, name, subject_name, book_name, type, end_date) AS (      -- First query (what I have put the above)     UNION     -- Second query     UNION     -- third query) SELECT TOP 20 * from bill_table </code></pre>  <p>I am seeing a discrepancy between the results I saw before changing the query and after changing the query. For example, 2/3 rows were replaced by the ones that were not there before, but did match the query criteria. This makes me wonder, is it because how the TOP results are chosen by the SQL executor engine is different even though the query conditions would return correct results? Also, Is my understanding about how the query speed has improved over the use of different JOINs correct?</p>  <p>P.S. My understanding about how SQL execution works is the following (not sure if this is correct):</p>  <p>1) FROM and JOINS are evaluated first</p>  <p>2) From the results above, WHERE (if any) conditions are evaluated</p>  <p>3) From the results above any ORDER/GROUPING is done</p>  <p>4) Selection of columns is made for the results above.</p>  <p>** I also tried to check if the expected results are correct for other scenarios where there are not more than 20 results, and they are being displayed correctly.</p>  <p>Any suggestion/guidance is appreciated.</p>