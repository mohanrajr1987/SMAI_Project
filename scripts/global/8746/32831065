<p>I'm quite new to Prolog, and this way of thinking is kind of messing with my mind. I'm currently using SWI-Prolog to run and debug my code. I have implemented a tail recursive algorithm to solve the N'th fibonnaci-number. I have tried debugging step by step, and I cannot explain why my implementation is skipping the base case. Where am I thinking wrong?</p>  <pre><code>fib(0, A,_, A). %Base case, when we reach N = 0, return. %Tail recursion. Use N as counter, iterate until base value (N=0) is  reached. fib(N, A, B, F) :-    Nnew is N - 1,    Sum is (A + B),    fib(Nnew, B, Sum, F).  fib(N, F) :-    fib(N, 0, 1, F). %set start values for when fib(N,F). is called </code></pre>  <p>My implementation is working great (and fast) if I want to calculate the nth fib number. For example, if I run <code>?- fib(5,F).</code>, I get F = 5 back. Great. If I want to check <code>?- fib(5,5).</code> I get <code>True</code> back, which is correct. Great.</p>  <p>But, if I input a false statement, for example: <code>?- fib(5,4).</code> then the program is looping forever. What happens is that N passes 0, ignores the base case(?), and continues on to be decremented. Why is the base case skipped? In my eyes, <code>fib(0,A,_,A).</code> is satisfied. Where am I wrong?</p>