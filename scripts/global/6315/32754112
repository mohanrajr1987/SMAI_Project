<p>This is my Jtable code.filter combo box separately working fine. but in jtable when i typed in combo box field that accept only one char as a input and perform filtering.. i can not type more characters or word.</p>  <pre><code>import javax.swing.DefaultCellEditor; import javax.swing.JComboBox; import javax.swing.JFrame; import javax.swing.JPanel; import javax.swing.JScrollPane; import javax.swing.JTable; import javax.swing.JTextField; import javax.swing.RowFilter; import javax.swing.table.AbstractTableModel; import javax.swing.table.DefaultTableCellRenderer; import javax.swing.table.TableCellRenderer; import javax.swing.table.TableColumn; import javax.swing.table.TableRowSorter;  import java.awt.Component; import java.awt.Dimension; import java.awt.GridLayout; import java.util.Vector;   public class TableRenderDemo extends JPanel { private boolean DEBUG = false; private TableRowSorter&lt;MyTableModel&gt; sorter; FilterComboBox acb; public TableRenderDemo() {     super(new GridLayout(1,0));     acb = new FilterComboBox(populateArray());     JTable table = new JTable(new MyTableModel());     table.setPreferredScrollableViewportSize(new Dimension(500, 70));     table.setFillsViewportHeight(true);     //Create a table with a sorter.   /*  MyTableModel model = new MyTableModel();     sorter = new TableRowSorter&lt;MyTableModel&gt;(model);     table = new JTable(model);     table.setRowSorter(sorter);     final JTextField textfield = (JTextField) acb.getEditor().getEditorComponent();     RowFilter rowFilter = RowFilter.regexFilter(textfield.getText(), 1);      sorter.setRowFilter(rowFilter);     table.remove();*/     //table.setRowSorter(sorter);     //Create the scroll pane and add the table to it.     JScrollPane scrollPane = new JScrollPane(table);      //Set up column sizes.     initColumnSizes(table);      //Fiddle with the Sport column's cell editors/renderers.     setUpSportColumn(table, table.getColumnModel().getColumn(2));      //Add the scroll pane to this panel.     add(scrollPane); }  /*  * This method picks good column sizes.  * If all column heads are wider than the column's cells'  * contents, then you can just use column.sizeWidthToFit().  */ private void initColumnSizes(JTable table) {     MyTableModel model = (MyTableModel)table.getModel();     TableColumn column = null;     Component comp = null;     int headerWidth = 0;     int cellWidth = 0;     Object[] longValues = model.longValues;     TableCellRenderer headerRenderer =         table.getTableHeader().getDefaultRenderer();      for (int i = 0; i &lt; 5; i++) {         column = table.getColumnModel().getColumn(i);          comp = headerRenderer.getTableCellRendererComponent(                              null, column.getHeaderValue(),                              false, false, 0, 0);         headerWidth = comp.getPreferredSize().width;          comp = table.getDefaultRenderer(model.getColumnClass(i)).                          getTableCellRendererComponent(                              table, longValues[i],                              false, false, 0, i);         cellWidth = comp.getPreferredSize().width;          if (DEBUG) {             System.out.println("Initializing width of column "                                + i + ". "                                + "headerWidth = " + headerWidth                                + "; cellWidth = " + cellWidth);         }          column.setPreferredWidth(Math.max(headerWidth, cellWidth));     } } public static Vector&lt;String&gt; populateArray() {     Vector&lt;String&gt; test = new Vector&lt;String&gt;();     test.add("");     test.add("Mountain Flight");     test.add("Mount Climbing");     test.add("Trekking");     test.add("Rafting");     test.add("Jungle Safari");     test.add("Bungie Jumping");     test.add("Para Gliding");     return test; } public void setUpSportColumn(JTable table,                              TableColumn sportColumn) {     //Set up the editor for the sport cells.   /*  JComboBox comboBox = new JComboBox();     comboBox.addItem("Snowboarding");     comboBox.addItem("Rowing");     comboBox.addItem("Knitting");     comboBox.addItem("Speed reading");     comboBox.addItem("Pool");     comboBox.addItem("None of the above");     comboBox.setEditable(true);*/     acb = new FilterComboBox(populateArray());     sportColumn.setCellEditor(new DefaultCellEditor(acb));      //Set up tool tips for the sport cells.   /*  DefaultTableCellRenderer renderer =             new DefaultTableCellRenderer();     renderer.setToolTipText("Click for combo box");     sportColumn.setCellRenderer(renderer);*/ }  class MyTableModel extends AbstractTableModel {     private String[] columnNames = {"First Name",                                     "Last Name",                                     "Sport",                                     "# of Years",                                     "Vegetarian"};     private Object[][] data = {     {"Kathy", "Smith",      "", new Integer(5), new Boolean(false)},     {"John", "Doe",      "Rowing", new Integer(3), new Boolean(true)},     {"Sue", "Black",      "Knitting", new Integer(2), new Boolean(false)},     {"Jane", "White",      "Speed reading", new Integer(20), new Boolean(true)},     {"Joe", "Brown",      "Pool", new Integer(10), new Boolean(false)}     };      public final Object[] longValues = {"Jane", "Kathy",                                         "None of the above",                                         new Integer(20), Boolean.TRUE};      public int getColumnCount() {         return columnNames.length;     }      public int getRowCount() {         return data.length;     }      public String getColumnName(int col) {         return columnNames[col];     }      public Object getValueAt(int row, int col) {         return data[row][col];     }      /*      * JTable uses this method to determine the default renderer/      * editor for each cell.  If we didn't implement this method,      * then the last column would contain text ("true"/"false"),      * rather than a check box.      */     public Class getColumnClass(int c) {         return getValueAt(0, c).getClass();     }      /*      * Don't need to implement this method unless your table's      * editable.      */     public boolean isCellEditable(int row, int col) {         //Note that the data/cell address is constant,         //no matter where the cell appears onscreen.         if (col &lt; 2) {             return false;         } else {             return true;         }     }      /*      * Don't need to implement this method unless your table's      * data can change.      */     public void setValueAt(Object value, int row, int col) {         if (DEBUG) {             System.out.println("Setting value at " + row + "," + col                                + " to " + value                                + " (an instance of "                                + value.getClass() + ")");         }          data[row][col] = value;         fireTableCellUpdated(row, col);          if (DEBUG) {             System.out.println("New value of data:");             printDebugData();         }     }      private void printDebugData() {         int numRows = getRowCount();         int numCols = getColumnCount();          for (int i=0; i &lt; numRows; i++) {             System.out.print("    row " + i + ":");             for (int j=0; j &lt; numCols; j++) {                 System.out.print("  " + data[i][j]);             }             System.out.println();         }         System.out.println("--------------------------");     } }  /**  * Create the GUI and show it.  For thread safety,  * this method should be invoked from the  * event-dispatching thread.  */ private static void createAndShowGUI() {     //Create and set up the window.     JFrame frame = new JFrame("TableRenderDemo");     frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);      //Create and set up the content pane.     TableRenderDemo newContentPane = new TableRenderDemo();     newContentPane.setOpaque(true); //content panes must be opaque     frame.setContentPane(newContentPane);      //Display the window.     frame.pack();     frame.setVisible(true); }  public static void main(String[] args) {     //Schedule a job for the event-dispatching thread:     //creating and showing this application's GUI.     javax.swing.SwingUtilities.invokeLater(new Runnable() {         public void run() {             createAndShowGUI();         }     }); } </code></pre>  <p>}</p>  <p>FilterComboBox.java</p>  <pre><code>import java.awt.event.KeyAdapter; import java.awt.event.KeyEvent; import java.util.ArrayList; import java.util.List; import java.util.Vector;  import javax.swing.DefaultComboBoxModel; import javax.swing.JComboBox; import javax.swing.JFrame; import javax.swing.JTextField; import javax.swing.SwingUtilities; import javax.swing.UIManager;  public class FilterComboBox extends JComboBox { private List&lt;String&gt; array; JTextField textfield; public FilterComboBox(Vector&lt;String&gt; array) {     super(array.toArray());     this.array = array;     this.setEditable(true);     textfield = (JTextField)       this.getEditor().getEditorComponent();             textfield.addKeyListener(new KeyAdapter() {         public void keyReleased(KeyEvent ke) {              SwingUtilities.invokeLater(new Runnable() {                 public void run() {                     final String inputTxt=textfield.getText();                     comboFilter(inputTxt);                 }             });         }     });  }  public void comboFilter(String enteredText) { if (!this.isPopupVisible()) {     this.showPopup(); }  Vector&lt;String&gt; filterArray= new Vector&lt;String&gt;(); for (int i = 0; i &lt; array.size(); i++) {     if (array.get(i).toLowerCase().contains(enteredText.toLowerCase())) {         filterArray.add(array.get(i));     }  } System.out.println("val "+enteredText+" size "+filterArray); if (filterArray.size() &gt; 0) {     DefaultComboBoxModel model = (DefaultComboBoxModel) this.getModel();     model.removeAllElements();     for (String s: filterArray)         model.addElement(s);      textfield.setText(enteredText);     //System.out.println("set txt "+enteredText); } else if(filterArray.size()==0) {     DefaultComboBoxModel model = (DefaultComboBoxModel) this.getModel();     model.removeAllElements();     textfield.setText(enteredText);   // System.out.println("set txt "+enteredText); } }   /* Testing Codes */    public static Vector&lt;String&gt; populateArray() {     Vector&lt;String&gt; test = new Vector&lt;String&gt;();     test.add("");     test.add("Mountain Flight");     test.add("Mount Climbing");     test.add("Trekking");     test.add("Rafting");     test.add("Jungle Safari");     test.add("Bungie Jumping");     test.add("Para Gliding");     return test; }  public static void makeUI() {     JFrame frame = new JFrame("Adventure in Nepal - Combo Filter Test");     FilterComboBox acb = new FilterComboBox(populateArray());     frame.getContentPane().add(acb);     frame.pack();     frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);     frame.setVisible(true); }  public static void main(String[] args) throws Exception {      //UIManager.setLookAndFeel("com.sun.java.swing.plaf.windows.WindowsLookAndFeel");     makeUI(); } } </code></pre>