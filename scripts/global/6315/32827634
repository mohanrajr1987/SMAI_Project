<p>I have a <code>JTable</code> for which the renderer returns a <code>JPanel</code> composed of multiple <code>JLabel</code> instances. One of those <code>JLabel</code>s can contain HTML used among other things to split the output over multiple lines using <code>&lt;br/&gt;</code> tags.</p>  <p>To show the multiple lines in the table, the renderer calls in the <code>getTableCellRendererComponent</code> method </p>  <pre><code>table.setRowHeight(row, componentToReturn.getPreferredSize().height); </code></pre>  <p>to dynamically update the row height, based on the contents. This only works correctly if <code>componentToReturn</code> indicates a correct preferred size.</p>  <p>It looks however that the <code>getPreferredSize</code> returns bogus values. The preferred height of the returned component is smaller than the sum of the heights of the labels inside the component.</p>  <p>Here is a little program illustrating this behaviour (without using a <code>JTable</code>)</p>  <pre><code>import java.awt.*; import javax.swing.*;  public class SwingLabelTest {   public static void main(String[] args) {     EventQueue.invokeLater(new Runnable() {       @Override       public void run() {         LabelPanel renderer = new LabelPanel();         Component component = renderer.getComponent(false);         //asking for a bigger component will not         //update the preferred size of the returned component         component = renderer.getComponent(true);       }     });   }    private static class LabelPanel {     private final JPanel compositePanel;     private final JLabel titleLabel = new JLabel();     private final JLabel propertyLabel = new JLabel();      public LabelPanel() {       JPanel labelPanel = new JPanel();       labelPanel.setLayout(new BoxLayout(labelPanel, BoxLayout.PAGE_AXIS));        labelPanel.add(titleLabel);       labelPanel.add(propertyLabel);        compositePanel = new JPanel(new BorderLayout());       //normally it contains more components,       //but that is not needed to illustrate the problem       compositePanel.add(labelPanel, BorderLayout.CENTER);     }      public Component getComponent( boolean aMultiLineProperty ) {       titleLabel.setText("Title");       if ( aMultiLineProperty ){         propertyLabel.setText("&lt;html&gt;First line&lt;br/&gt;Property: value&lt;/html&gt;");       } else {         propertyLabel.setText("Property: value");       }        int titleLabelHeight = titleLabel.getPreferredSize().height;       int propertyLabelHeight = propertyLabel.getPreferredSize().height;       int compositePanelHeight = compositePanel.getPreferredSize().height;       if ( compositePanelHeight &lt; titleLabelHeight + propertyLabelHeight){         throw new RuntimeException("Preferred size of the component returned "                                    + "by the renderer is incorrect");       }        return compositePanel;     }   } } </code></pre>  <p>As I am aware that the previous example is a bit far-fetched, here an example which includes a <code>JTable</code></p>  <pre><code>import java.awt.*; import javax.swing.*; import javax.swing.table.*;  public class SwingTableTest {    public static void main(String[] args) {     EventQueue.invokeLater(new Runnable() {       @Override       public void run() {         DefaultTableModel tableModel = new DefaultTableModel(0, 1);         JTable table = new JTable(tableModel);         table.setDefaultRenderer(Object.class, new DataResultRenderer());         tableModel.addRow(new Object[]{new Object()});         tableModel.addRow(new Object[]{new Object()});         tableModel.addRow(new Object[]{new Object()});          JFrame testFrame = new JFrame("TestFrame");         testFrame.getContentPane().add(new JScrollPane(table));         testFrame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);         testFrame.setSize(new Dimension(300, testFrame.getPreferredSize().height));         testFrame.setVisible(true);       }     });   }    private static class DataResultRenderer implements TableCellRenderer {     private final JPanel compositePanel;     private final JLabel titleLabel = new JLabel();     private final JLabel propertyLabel = new JLabel();      public DataResultRenderer() {        JPanel labelPanel = new JPanel();       labelPanel.setOpaque(false);       labelPanel.setLayout(new BoxLayout(labelPanel, BoxLayout.PAGE_AXIS));        labelPanel.add(titleLabel);       labelPanel.add(propertyLabel);        compositePanel = new JPanel(new BorderLayout());       //normally it contains more components,       //but that is not needed to illustrate the problem       compositePanel.add(labelPanel, BorderLayout.CENTER);     }      @Override     public Component getTableCellRendererComponent(         JTable table, Object value, boolean isSelected,          boolean hasFocus, int row, int column) {       titleLabel.setText("Title");        if ( row == 2 ){         propertyLabel.setText("&lt;html&gt;Single property: value&lt;/html&gt;");       } else {         String text = "&lt;html&gt;";         text += "First property&lt;br/&gt;";         text += "Second property&lt;br/&gt;";         text += "Third property:value";         text += "&lt;/html&gt;";         propertyLabel.setText(text);       }        int titleLabelHeight = titleLabel.getPreferredSize().height;       int propertyLabelHeight = propertyLabel.getPreferredSize().height;       int compositePanelHeight = compositePanel.getPreferredSize().height;       if ( compositePanelHeight &lt; titleLabelHeight + propertyLabelHeight){         throw new RuntimeException("Preferred size of the component returned "                                    + "by the renderer is incorrect");       }       table.setRowHeight(row, compositePanel.getPreferredSize().height);       return compositePanel;     }    } } </code></pre>  <p>I am looking for a way to update the row height of the table to ensure that the multi-line content is completely visible, without knowing up front how many lines each row will contain.</p>  <p>So either I need a solution to retrieve the correct preferred size, or my approach is completely wrong and then I need a better one.</p>  <p>Note that the above examples are simplified. In the real code, the "renderer" (the code responsible for creating the component) is decorated a few times. This means that the outer renderer is the only with access to the <code>JTable</code>, and it has no knowledge about what kind of <code>Component</code> the inner code returns.</p>