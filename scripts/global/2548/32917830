<p>I am trying to receive a UDP packet using Boost asio. My code is based off of <a href="http://www.boost.org/doc/libs/1_56_0/doc/html/boost_asio/example/cpp03/timeouts/blocking_udp_client.cpp" rel="nofollow">this blocking UDP client example from the asio documentation</a>.</p>  <p>I am trying to receive a BOOTP-like UDP packet from a C6655 TI DSP, which are being transmitted in 3 second intervals. I have Wireshark watching the same interface my program is listening on, and it can see the packets arriving (see below for the exact packet data, exported from Wireshark). The packets aren't <em>really</em> coming from the DSP, I captured one with <code>tcpdump</code> and I'm simulating it from a Raspberry Pi with <a href="http://packeth.sourceforge.net/packeth/Home.html" rel="nofollow">packeth</a>.</p>  <p>However, my program does not receive the packets. It has a 4 second timeout (since the DSP broadcasts every 3 seconds). If it hits the timeout, it prints a message to that effect, otherwise it's supposed to print the number of bytes received. The full (compilable) source code of the program follows (about 100 lines).</p>  <p>The command is being invoked with the parameters <code>192.168.5.122 67 4000</code>, which means listen on 192.168.5.122:67 with a 4000 millisecond timeout.</p>  <p>Edit: In addition to the code below, I also tried this as my endpoint: <code>udp::endpoint listen_endpoint(boost::asio::ip::address_v4::any(), atoi(argv[2]));</code> as well as the IP address <code>0.0.0.0</code> as suggested by a search result somewhere.</p>  <p>I also added the following to no avail:</p>  <pre><code>boost::asio::socket_base::broadcast option(true); socket_.set_option(option); </code></pre>  <p>Here is the complete program:</p>  <pre><code>// // blocking_udp_client.cpp // ~~~~~~~~~~~~~~~~~~~~~~~ // #include &lt;boost/asio/deadline_timer.hpp&gt; #include &lt;boost/asio/io_service.hpp&gt; #include &lt;boost/asio/ip/udp.hpp&gt; #include &lt;boost/bind.hpp&gt; #include &lt;boost/date_time/posix_time/posix_time_types.hpp&gt; #include &lt;iostream&gt;  using boost::asio::deadline_timer; using boost::asio::ip::udp;  class listener { public:     listener(const udp::endpoint&amp; listen_endpoint)         : socket_(io_service_, listen_endpoint)         , deadline_(io_service_)     {         deadline_.expires_at(boost::posix_time::pos_infin);         check_deadline();     }      std::size_t receive(const boost::asio::mutable_buffer&amp; buffer, boost::posix_time::time_duration timeout, boost::system::error_code&amp; ec)     {         deadline_.expires_from_now(timeout);         ec = boost::asio::error::would_block;         std::size_t length = 0;         socket_.async_receive(boost::asio::buffer(buffer), boost::bind(&amp;listener::handle_receive, _1, _2, &amp;ec, &amp;length));          // TODO: The following do/while is hinky. Does run_one() need to happen before the comparison?         do io_service_.run_one();         while (ec == boost::asio::error::would_block);          return length;     }  private:     void check_deadline()     {         if (deadline_.expires_at() &lt;= deadline_timer::traits_type::now())         {             // cancel() won't work on XP. Something about using close() instead... Look it up. I'm doing this on Win10.             socket_.cancel();             deadline_.expires_at(boost::posix_time::pos_infin);         }         deadline_.async_wait(boost::bind(&amp;listener::check_deadline, this));     }      static void handle_receive(const boost::system::error_code&amp; ec, std::size_t length, boost::system::error_code* out_ec, std::size_t* out_length)     {         *out_ec = ec;         *out_length = length;     }  private:     boost::asio::io_service io_service_;     udp::socket socket_;     deadline_timer deadline_; };  int main(int argc, char* argv[]) {     try     {         if (argc != 4)         {             std::cerr &lt;&lt; "Usage: blocking_udp_timeout &lt;listen_addr&gt; &lt;listen_port&gt; &lt;timeout_ms&gt;\n";             return 1;         }          udp::endpoint listen_endpoint(boost::asio::ip::address::from_string("0.0.0.0"), atoi(argv[2]));         std::cout &lt;&lt; "Endpoint: " &lt;&lt; listen_endpoint &lt;&lt; std::endl;          auto timeout = atoi(argv[3]);         std::cout &lt;&lt; "Timeout : " &lt;&lt; timeout &lt;&lt; std::endl;          listener c(listen_endpoint);          for (;;)         {             char data[1024];             boost::system::error_code ec;             auto n = c.receive(boost::asio::buffer(data), boost::posix_time::milliseconds{timeout}, ec);              if (ec)             {                 std::cout &lt;&lt; "Receive error: " &lt;&lt; ec.message() &lt;&lt; "\n";             }             else             {                 std::cout &lt;&lt; "Received " &lt;&lt; n &lt;&lt; " bytes." &lt;&lt; std::endl;             }         }     }     catch (std::exception&amp; e)     {         std::cerr &lt;&lt; "Exception: " &lt;&lt; e.what() &lt;&lt; "\n";     }      return 0; } </code></pre>  <p>Here is the packet that I'm trying to receive. This includes the Ethernet frame:</p>  <pre><code>0000   ff ff ff ff ff ff c4 ed ba aa 28 35 08 00 45 00  ..........(5..E. 0010   01 48 00 01 00 00 10 11 a9 a5 00 00 00 00 00 00  .H.............. 0020   00 00 00 44 00 43 01 34 00 00 01 01 06 00 12 34  ...D.C.4.......4 0030   56 78 00 01 00 00 00 00 00 00 00 00 00 00 00 00  Vx.............. 0040   00 00 00 00 00 00 c4 ed ba aa 28 35 00 00 00 00  ..........(5.... 0050   00 00 00 00 00 00 74 69 2d 62 6f 6f 74 2d 74 61  ......ti-boot-ta 0060   62 6c 65 2d 73 76 72 00 00 00 00 00 00 00 00 00  ble-svr......... 0070   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................ 0080   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................ 0090   00 00 00 00 00 00 74 69 2d 62 6f 6f 74 2d 74 61  ......ti-boot-ta 00a0   62 6c 65 2d 30 30 30 37 00 00 00 00 00 00 00 00  ble-0007........ 00b0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................ 00c0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................ 00d0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................ 00e0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................ 00f0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................ 0100   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................ 0110   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................ 0120   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................ 0130   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................ 0140   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................ 0150   00 00 00 00 00 00                                ...... </code></pre>