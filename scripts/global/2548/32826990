<p>I am creating an application which has to receive compressed video stream via Wi-Fi with UDP protocol. The source of video stream is DIY project with ARM microcontroller and WLAN module. I have a problem when try to reconnect. When first time I set learnObject var to true everything is all right. But there is an error when I close that connection calling closeUdpSocket() and then try to connect one more time. Error is: java.net.SocketTimeoutException at libcore.io.IoBridge.maybeThowAfterRecvForm(IoBridge.java:551). How do You think what can be wrong with it? Thank You for help</p>  <pre><code>    public CameraView(Context context) {         super(context);         // TODO Auto-generated constructor stub         surfaceHolder = getHolder();          // Create Bitmap for video frame         bitmap = Bitmap.createBitmap(WIDTH, HEIGHT, Bitmap.Config.ARGB_8888/*Bitmap.Config.ALPHA_8*//*Bitmap.Config.RGB_565*/);         screenRect = new Rect(0, 0, 680, 510);          // Create and set paint color and its transparency         paint = new Paint(Paint.ANTI_ALIAS_FLAG); //      paint.setARGB(100, 255, 0, 0);          // Prepare for drawing Rects         outerRect = new Rect(0, 0, 0, 0);         innerRect = new Rect(0, 0, 0, 0);          Log.d("S3", "stworzono bitmape");     }      public void onResumeCameraView() {         running = true;         thread = new Thread(this);         thread.start();     }      public void onPauseCameraView() {         boolean retry = true;         running = false;         while (retry) {             try {                 thread.join();                 retry = false;             } catch (InterruptedException e) {                 // TODO Auto-generated catch block                 e.printStackTrace();             }         }     }      @Override     public void run() {         long ticksPS = 1000 / FPS;         long startTime;         long sleepTime;         int blobx = MainActivity.blobx, bloby = MainActivity.bloby, blobw = MainActivity.blobw, blobh = MainActivity.blobh;         Canvas canvas;         int len = 0, n, j;          // TODO Auto-generated method stub         while (running) {             startTime = System.currentTimeMillis();              if (!/*isSurfaceCreated*/surfaceHolder.getSurface().isValid()) {                 continue;             }              if (MainActivity.wlanStatus == 1)                 Log.d("S3", "wlan activ");             else if (MainActivity.wlanStatus == 2)                 Log.d("S3", "wlan deactivated");             else if (MainActivity.wlanStatus == 3)                 Log.d("S3", "wlan error occured");  //          canvas = null;             // try locking the canvas for exclusive pixel editing             // in the surface //          try {                  // Create Canvas and set white background color                 canvas = surfaceHolder.lockCanvas(); //              synchronized (surfaceHolder) {                     canvas.drawColor(0xFF5C5C5C);                      if (MainActivity.learnObject == false &amp;&amp; MainActivity.wlanStatus == MainActivity.WLAN_STATUS_DEINITIALIZED) {                         MainActivity.wlanStatus = MainActivity.WLAN_STATUS_OFF;                         closeUdpSocket();                         Log.d("S3", "Socket zamkniety");                     }                     if (MainActivity.learnObject == true &amp;&amp; MainActivity.wlanStatus == MainActivity.WLAN_STATUS_INITIALIZED) {                         MainActivity.wlanStatus = MainActivity.WLAN_STATUS_RUNNING;                         createUdpSocket();                         Log.d("S3", "Socket utworzony");                     }                      if (MainActivity.learnObject &amp;&amp; (MainActivity.wlanStatus == MainActivity.WLAN_STATUS_RUNNING)) {                         buffer.rewind();                         try {                             sock.send(header);                              if (D)                                 Log.d(TAG,"Start of receiving jpeg.");                              len = 0;                             j = 0;                             do {                                 sock.receive(packet);                                 n = packet.getLength();                                 buffer.put(packet.getData(), 0, n);                                  if (D) {                                     Log.d(TAG, "Read: " + n + " bytes");                                     ++j;                                 }                                  len += n;         //                      packet.setLength(1024);                             } while (n == 1024);                             if (D)                                 Log.d(TAG, "End of receiving jpeg, received: " + j + " packets");                          } catch (IOException e) {                             // TODO Auto-generated catch block                             e.printStackTrace();                         }                          buffer.rewind();                              if(frameData == null) { // do it only once at the beginning                                 frameData = new byte[IMAGE_SIZE];                                  if(D)                                     Log.d(TAG, "Memory allocated for frameData: " + IMAGE_SIZE);                              }                              buffer.get(frameData, 0, len);  // copy data from main buffer into temporary frameData buffer                         try {                                retval = pixeltobmp(frameData, len, bitmap);    // for mjpeg decoding we can use this external jpeg library         //                  bitmap = BitmapFactory.decodeStream(new ByteArrayInputStream(frameData, 0, len));   // or this Java built-in library          //                  bitmap = BitmapFactory.decodeByteArray(frameData, 0, len);  // or this Java built-in library                               if ((bitmap != null) &amp;&amp; (retval == 0)) {    // check if new bitmap is available                                 canvas.drawBitmap(bitmap, null, screenRect, paint);                             } else {                                 if (D)                                     Log.d(TAG,"Error: Can't decode the incoming data");                             }                              freeCameraMemory();                         } catch (Exception e) {}                     } //              } //          } finally { //             // in case of an exception the surface is not left in  //             // an inconsistent state //             if (canvas != null) { //                 surfaceHolder.unlockCanvasAndPost(canvas); //             } //          }   // end finally              surfaceHolder.unlockCanvasAndPost(canvas);  //          SystemClock.sleep(10000);              sleepTime = ticksPS-(System.currentTimeMillis() - startTime);             try {                    if (sleepTime &gt; 0) {                           Thread.sleep(sleepTime);                    }                    else {                           Thread.sleep(10);                    }             } catch (Exception e) {}         }     }      private void createUdpSocket()     {         try {             sock = new DatagramSocket();             sock.setSoTimeout(500); // 10000             header = new DatagramPacket("HEADER".getBytes(), 6, InetAddress.getByName(SERVER_ADDR), SERVER_PORT);             packet = new DatagramPacket(new byte[1024], 1024);         } catch (SocketException e) {             // TODO Auto-generated catch block             Toast.makeText(getContext(), "Error: Can't create Socket", Toast.LENGTH_SHORT).show();              e.printStackTrace();         } catch (UnknownHostException e) {             // TODO Auto-generated catch block             Toast.makeText(getContext(), "Error: Invalid Host IP Address", Toast.LENGTH_SHORT).show();              e.printStackTrace();         }        }      private void closeUdpSocket()     {         if (sock != null)             sock.close();     } } </code></pre>