<p>I have a Linux program split into two parts. </p>  <p>One part does NAT traversal to obtain either a UDP socket (UDP hole punching) or a TCP socket (TCP hole punching). Part one is written in C to allow for native features which facilitate or enhance the NAT traversal process. Part two actually uses the connected socket obtained via the NAT traversal performed in part one.</p>  <p>Now here is the problem. I want the first part, the part that obtains the socket, to be independent of the second part, the part that uses the socket for an application specific purpose. For example, I want the first part to be reusable for a variety of different applications that all need UDP and TCP connections that were established between peers. </p>  <p>Right now, I would like the second part (the application part) to be written in Java rather than C or C++. I want the second part to use a socket connection that was obtained by the C code responsible for NAT traversal. Let's say the first part established a connection and then returns a struct:</p>  <pre><code>// Represents a TCP or UDP connection that was obtained in part one. struct ConnectionObtained {     int socket_file_descriptor;     int source_port;     int destination_port;     int source_address; // 4 byte ipv4 address     int destination_address;     int is_UDP; // 1 for UDP client socket, 0 for TCP client socket  }; </code></pre>  <p>The C code in part one can provide this POD/struct to the Java code in part two either via JNI (Java Native Interface) or via inter-proceess communication. </p>  <p>I want the Java code to use that information to construct an object whose declared type is either java.net.DatagramSocket or java.net.Socket and then use that object wherever a DatagramSocket or Socket would be expected.</p>  <p>As a starting point, consider the following sample code...</p>  <pre><code>/**   * Determines the Unix file descriptor number of the given  {@link ServerSocket}.  */ private int getUnixFileDescriptor(ServerSocket ss) throws NoSuchFieldException, IllegalAccessException, NoSuchMethodException, InvocationTargetException {   Field $impl=ss.getClass().getDeclaredField("impl");   $impl.setAccessible(true);   SocketImpl socketImpl=(SocketImpl)$impl.get(ss);   Method $getFileDescriptor=SocketImpl.class.getDeclaredMethod("getFileDescriptor");   $getFileDescriptor.setAccessible(true);   FileDescriptor fd=(FileDescriptor)$getFileDescriptor.invoke(socketImpl);   Field $fd=fd.getClass().getDeclaredField("fd");   $fd.setAccessible(true);   return (Integer)$fd.get(fd); } </code></pre>  <p>The code makes it appear that it may be possible to "recreates a bound  {@link ServerSocket} on the given file descriptor." Does this mean that it is possible to "recreates a bound  {@link java.net.Socket} on the given file descriptor" as well? What about a bound {@link java.net.DatagramSocket}? </p>  <pre><code>/**   * Recreates a bound  {@link ServerSocket} on the given file descriptor.  */ private ServerSocket recreateServerSocket(int fdn) throws Exception {   FileDescriptor fd=new FileDescriptor();   Field $fd=FileDescriptor.class.getDeclaredField("fd");   $fd.setAccessible(true);   $fd.set(fd,fdn);   Class $PlainSocketImpl=Class.forName("java.net.PlainSocketImpl");   Constructor $init=$PlainSocketImpl.getDeclaredConstructor(FileDescriptor.class);   $init.setAccessible(true);   SocketImpl socketImpl=(SocketImpl)$init.newInstance(fd);   ServerSocket ss=new ServerSocket();   ss.bind(new InetSocketAddress(0));   Field $impl=ServerSocket.class.getDeclaredField("impl");   $impl.setAccessible(true);   $impl.set(ss,socketImpl);   return ss; } </code></pre>