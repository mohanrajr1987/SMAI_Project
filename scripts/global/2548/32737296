<p>I'm trying to connect UDP client which is written in C# to UDP server which is written in C. If I don't use <strong>select()</strong> and <strong>accept()</strong> and <strong>fd_set functions</strong> and use recv function directly which <strong>HANGS</strong> then I can send and receive data without any trouble.</p>  <p>I'm not able to connect if I use those functions in Server side UDP. I know that UDP is connection-less but the problem is that I don't know how to use fd_set without having to use accept. </p>  <p>Weird thing: <strong>I'm able to connect via TCP client</strong> but can't connect via UDP client in C#. <strong>I'm able to connect to server socket if client UDP is written in C</strong> but since I want client side to be in C# then I really need to solve this.</p>  <p>UDP Client in C# </p>  <pre><code>    using System;     using System.Net;     using System.Net.Sockets;     using System.Text;      public class SynchronousSocketClient     {          public static void StartClient()         {  // UDP doesn't work. Can't connect nor send data              Socket s = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);  // TCP works perfectly              Socket s = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);             IPAddress broadcast = IPAddress.Parse("0.0.0.0");             byte[] sendbuf = Encoding.ASCII.GetBytes("Why are you sad?");             IPEndPoint ep = new IPEndPoint(broadcast, 55004);             s.Connect(ep);             s.SendTo(sendbuf, ep);               while (true)             {              }         }          public static int Main(String[] args)         {             StartClient();             return 0;         }     } </code></pre>  <p>UDP Server in C</p>  <pre><code>#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt; #include &lt;netinet/in.h&gt; #include &lt;arpa/inet.h&gt; #include &lt;netdb.h&gt;  #define PORT "55004"   // port we're listening on  // get sockaddr, IPv4 or IPv6: void *get_in_addr(struct sockaddr *sa) {     if (sa-&gt;sa_family == AF_INET) {         return &amp;(((struct sockaddr_in*)sa)-&gt;sin_addr);     }      return &amp;(((struct sockaddr_in6*)sa)-&gt;sin6_addr); }  int main(void) {     fd_set master;    // master file descriptor list     fd_set read_fds;  // temp file descriptor list for select()     int fdmax;        // maximum file descriptor number      int listener;     // listening socket descriptor     int newfd;        // newly accept()ed socket descriptor     struct sockaddr_storage remoteaddr; // client address     socklen_t addrlen;      char buf[256];    // buffer for client data     int nbytes;      char remoteIP[INET6_ADDRSTRLEN];      int yes=1;        // for setsockopt() SO_REUSEADDR, below     int i, j, rv;      struct addrinfo hints, *ai, *p;      FD_ZERO(&amp;master);    // clear the master and temp sets     FD_ZERO(&amp;read_fds);      // get us a socket and bind it     memset(&amp;hints, 0, sizeof hints);     hints.ai_family = AF_UNSPEC;     hints.ai_socktype = SOCK_STREAM;     hints.ai_flags = AI_PASSIVE;     if ((rv = getaddrinfo(NULL, PORT, &amp;hints, &amp;ai)) != 0) {         fprintf(stderr, "selectserver: %s\n", gai_strerror(rv));         exit(1);     }      for(p = ai; p != NULL; p = p-&gt;ai_next) {         listener = socket(p-&gt;ai_family, p-&gt;ai_socktype, p-&gt;ai_protocol);         if (listener &lt; 0) {              continue;         }          // lose the pesky "address already in use" error message         setsockopt(listener, SOL_SOCKET, SO_REUSEADDR, &amp;yes, sizeof(int));          if (bind(listener, p-&gt;ai_addr, p-&gt;ai_addrlen) &lt; 0) {             close(listener);             continue;         }          break;     }      // if we got here, it means we didn't get bound     if (p == NULL) {         fprintf(stderr, "selectserver: failed to bind\n");         exit(2);     }      freeaddrinfo(ai); // all done with this      // listen     if (listen(listener, 10) == -1) {         perror("listen");         exit(3);     }      // add the listener to the master set     FD_SET(listener, &amp;master);      // keep track of the biggest file descriptor     fdmax = listener; // so far, it's this one      // main loop     for(;;) {         read_fds = master; // copy it         if (select(fdmax+1, &amp;read_fds, NULL, NULL, NULL) == -1) {             perror("select");             exit(4);         }          // run through the existing connections looking for data to read         for(i = 0; i &lt;= fdmax; i++) {             if (FD_ISSET(i, &amp;read_fds)) { // we got one!!                 if (i == listener) {                     // handle new connections                     addrlen = sizeof remoteaddr;                     newfd = accept(listener,                         (struct sockaddr *)&amp;remoteaddr,                         &amp;addrlen);                      if (newfd == -1) {                         perror("accept");                     } else {                         FD_SET(newfd, &amp;master); // add to master set                         if (newfd &gt; fdmax) {    // keep track of the max                             fdmax = newfd;                         }                         printf("selectserver: new connection from %s on "                             "socket %d\n",                             inet_ntop(remoteaddr.ss_family,                                 get_in_addr((struct sockaddr*)&amp;remoteaddr),                                 remoteIP, INET6_ADDRSTRLEN),                             newfd);                     }                 } else {                     // handle data from a client                     if ((nbytes = recv(i, buf, sizeof buf, 0)) &lt;= 0) {                         // got error or connection closed by client                         if (nbytes == 0) {                             // connection closed                             printf("selectserver: socket %d hung up\n", i);                         } else {                             perror("recv");                         }                         close(i); // bye!                         FD_CLR(i, &amp;master); // remove from master set                     } else {                         // we got some data from a client                         for(j = 0; j &lt;= fdmax; j++) {                             // send to everyone!                             if (FD_ISSET(j, &amp;master)) {                                 // except the listener and ourselves                                 if (j != listener &amp;&amp; j != i) {                                     if (send(j, buf, nbytes, 0) == -1) {                                         perror("send");                                     }                                 }                             }                         }                     }                 } // END handle data from client             } // END got new incoming connection         } // END looping through file descriptors     } // END for(;;)--and you thought it would never end!      return 0; } </code></pre>  <p>Source for C UDP server side code: <a href="http://beej.us/guide/bgnet/output/html/singlepage/bgnet.html#advanced" rel="nofollow">http://beej.us/guide/bgnet/output/html/singlepage/bgnet.html#advanced</a></p>