<p>The architecture of the program consists of a PySide GUI executable build with Py2exe. Furthermore it has a second python console application build with Py2exe. </p>  <p>The GUI-App starts the console application using a named Pipe to be able to send CTRL_C and capture stdout/stderr. This is done using the pywin32 module.</p>  <p>Inside the console application several other Windows applications are executed in blocking mode using the subprocess module. Now the console application got extended by some code to execute another program in nonblocking mode. </p>  <p>If the GUI application and the Console application are executed (Before being build to a Py2exe App) everything works as expected and wanted. If the applications are build with Py2exe the external Windows application freezes and a windows error pops up. (application stopped working)</p>  <p>If the execution code of the external Windows app is isolated and a py2exe  executable build, everything works.</p>  <p>So the problem must be py2exe and calling the console app from a GUI app.</p>  <p>I hope someone can point me in the right direction.</p>  <p>I got asked for a minimal example. The problem is that the architecture does not really allow a minimal working example. I tried my best and i hope the given Example draws a clearer image of the problem. As explained through testing the problem could be reduced to py2exe. As soon as the GUI app is "compiled" to start of a nonblocking application inside the console app works but the new application causes a windows error. </p>  <p>Minimal Example:</p>  <p>Console App console.py:</p>  <pre><code>import logging import subprocess from time import sleep  def exec_program_nonblocking(args, cwd=None):     if cwd:         logging.debug("Change working directory to: %s", cwd)      subprocess.Popen(args,                  cwd=cwd,                  universal_newlines=True)  def main():     args = ["program.exe", "arg1", "arg2"]     exec_program_nonblocking(args)     while (True):         print "do something \n"         sleep(5)  if __name__ == '__main__':           main() </code></pre>  <p>setup.py for console App:</p>  <pre><code>from distutils.core import setup import py2exe  setup(console=['console.py']) </code></pre>  <p>PySide GUI application gui_app.py:</p>  <pre><code>from PySide.QtGui import QApplication  def start_console_app():     pass     # complex implementation of openening named pipe,     # handling callbacks, allowing to send CTRL_C to new process etc.     # Minimal example is not possible...  app = QtGui.QApplication([])  button = QtGui.QPushButton('Start Console App') button.clicked.connect(start_console_app) button.show()  app.exec_() </code></pre>  <p>setup.py for GUI Application:</p>  <pre><code>from distutils.core import setup import py2exe  setup(     options = {         'py2exe' : {             'packages' : 'encodings',             'unbuffered' : True             #dll_excludes....         }     },     zipfile = None,      windows = ['gui_app.py'] ) </code></pre>