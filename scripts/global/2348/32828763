<p>I'm writing a python script that launches programs in the background and then monitors to see if they encounter an error. I am using the subprocess module to start the process and keep a list of running programs.</p>  <p><code>processes.append((subprocess.Popen(command, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE), command))</code></p>  <p>I have found that when I try to monitor the programs by calling communicate on the subprocess object, the main program waits for the program to finish. I have tried to use poll(), but that doesn't give me access to the error code that caused the crash and I would like to address the issue and retry opening the process. runningProcesses is a list of tuples containing the subprocess object and the command associated with it.</p>  <pre><code>def monitorPrograms(runningProcesses):     for program in runningProcesses:         temp = program[0].communicate()         if program[0].returncode:             if program[0].returncode == 1:                 print "Program exited successfully."             else:                 print "Whoops, something went wrong. Program %s crashed." % program[0].pid </code></pre>  <p>When I tried to get the return code without using communicate, the crash of the program didn't register. Do I have to use threads to run the communication in parallel or is there a simpler way that I am missing?</p>