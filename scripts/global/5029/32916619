<p>I'm writing a database interface in Google Go. It takes <code>encoding.BinaryMarshaler</code> objects to save and saves them as []byte slices, and it loads data into <code>encoding.BinaryUnmarshaler</code> to return it:</p>  <pre><code>func (db *DB) Get(bucket []byte, key []byte, destination encoding.BinaryUnmarshaler) (encoding.BinaryUnmarshaler, error) { </code></pre>  <p>I want to implement being able to load an arbitrary length slice of <code>encoding.BinaryUnmarshaler</code>s in one go (for example "load all data from a bucket X"). I want the function to be able to load any number of data objects without knowing beforehand how many objects are to be loaded, so I don't expect the final user to pass me a slice to be filled. Instead, I take a <code>encoding.BinaryUnmarshaler</code> sample object to know what structures I'm dealing with:</p>  <pre><code>func (db *DB) GetAll(bucket []byte, sample encoding.BinaryUnmarshaler) ([]encoding.BinaryUnmarshaler, error) { </code></pre>  <p>The problem I ran into while coding this, is that I'm not sure how to initialize new instances of a given object, since I don't know what object I am dealing with, only what interface it conforms to. What I tried doing was:</p>  <pre><code>tmp:=new(reflect.TypeOf(sample)) </code></pre>  <p>but that just caused an error.</p>  <p>How can I create a new object in go without knowing what structure it is, having an example object instead?</p>