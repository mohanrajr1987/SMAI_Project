<p>In Haskell (and Rust, and others) I can have instances that are constrained by other instances:</p>  <pre><code>data Pair a b = Pair a b  instance (Eq a, Eq b) =&gt; Eq (Pair a b) where      Pair a b == Pair a' b' = a == a' &amp;&amp; b == b' </code></pre>  <p>With Java interfaces I can't. I must require the type parameters of <code>Pair</code> to always implement <code>Eq</code>, or I can't implement <code>Eq&lt;Pair&lt;A, B&gt;&gt;</code> at all:</p>  <pre><code>interface Eq&lt;A&gt; {     public boolean eq(A other); }  class Pair&lt;A extends Eq&lt;A&gt;, B extends Eq&lt;B&gt;&gt; implements Eq&lt;Pair&lt;A, B&gt;&gt; {     A a;     B b;     public boolean eq(Pair&lt;A, B&gt; other){         return a.eq(other.a) &amp;&amp; b.eq(other.b);     } } </code></pre>  <p>I'd like to have something like:</p>  <pre><code>class Pair&lt;A, B&gt; implements Eq&lt;Pair&lt;A, B&gt;&gt; if (A implements Eq&lt;A&gt; &amp;&amp; B implements Eq&lt;B&gt;) {...} </code></pre>  <p>So far the Internet has told me that my desired functionality isn't directly supported in Java. Nevertheless I find this a rather critical factor in the (re)usability of interfaces. I'd like to know if there are workarounds or solutions that approximately cover the same ground.</p>