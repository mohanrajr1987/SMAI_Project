<p>is it possible to inherit the implementation of an interface without implementing it for each implementation?</p>  <p><a href="http://i.stack.imgur.com/1aGmw.jpg" rel="nofollow"><img src="http://i.stack.imgur.com/1aGmw.jpg" alt="enter image description here"></a></p>  <p>In the image above <code>IBase</code> and <code>Ichild</code> are classes having only pure virtual methods and <code>Base</code> implements the methods of <code>IBase</code> and <code>Child</code> implements the methods of <code>IChild</code>. Is it now somehow possible for <code>Child</code> to inherit the implementations of the methods of <code>IBase</code> via <code>Base</code>, so that <code>Child</code> does not have to implement these methods itself?</p>  <p>I tried to implement it like this:</p>  <pre><code>struct IBase {     virtual void do_something_Base() = 0; };  struct IChild : public virtual IBase {     virtual void do_something_Child() = 0; };   struct Base : public virtual IBase {     virtual void do_something_Base() { //implementation IBase method         //do sth     } };  struct Child : public Base , public IChild {     virtual void do_something_Child() { //implementation IChild method         //do sth     } };  int main() {      IBase* B = new Child;     B-&gt;do_something_Base();      delete B;      return 0; } </code></pre>  <p>The problem with this code is that the copiler gives a warning:</p>  <blockquote>   <p>warning C4250: 'Child': inherits 'Base::Base::do_something_Base' via dominance</p> </blockquote>  <p>Futhermore the program crashes as at the line <code>delete B</code>. (If I use <code>IChild* B</code> instead of <code>IBase* B</code> the program does not crash. why is that?)</p>  <p>Thanks in advance</p>