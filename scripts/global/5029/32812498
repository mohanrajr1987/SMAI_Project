<p>I'm implementing Python (2.7.9) as an interface between my Arduino with a joystick and a couple of buttons and my Linux machine to control Megaman on an emulator. The joystick does x/y movements and the buttons do fire and jump. My code receives a string formatted as (X_Y_FIRE_JUMP), and parses out the values to then see what it should input on the keyboard by using the <a href="https://github.com/SavinaRoja/PyUserInput" rel="nofollow">PyUserInput</a> library. </p>  <p>One weird bug is happening though: Whenever I move to the right, even without pressing either one of the buttons, Megaman fires frenetically. I've checked my serial output to see if this was hardware sided, and it isn't; the serial string being received is clean as it should be looking something like this "[X>510]_[Y~510]_k_t". So, the X is telling it to move to the right, Y doesn't really do anything, k is telling it not to jump and  t is telling it not to fire. Why am I nonetheless getting sketchy unexpected firing <strong>only</strong> when I move to the right?</p>  <p>Python Code:</p>  <pre><code>import serial from pykeyboard import PyKeyboard   control = PyKeyboard()   def getxy():     while True:         try:             ab = arduino.readline()             a, b, c, d = ab.split("_")             a = int(a)             a = a - 512     # This is pure jiggery-pokery and apple sauce. The joystick controller is     # totally kaput (#german) and I didn't want to mess with the wiring (damn     # color wires. Don't touch this, it will hurt your family.)             b = int(b)             b = (b - 512) * -1             return a, b, c, d         except Exception:             continue         break   def procxy():     x, y, s, j = getxy()     mov = ""     if (x &gt; 100):         mov = mov + "r"     if (x &lt; -100):         mov = mov + "l"     if (y &gt; 100):         mov = mov + "u"     if (y &lt; -100):         mov = mov + "d"     if ("f" in s):         mov = mov + "f"     if ("j" in j):         mov = mov + "j"     return mov   def doshot(instr):     if ("f" in instr):         control.press_key('z')     if ("f" not in instr):         control.release_key('z')   def dojump(instr):     if ("j" in instr):         control.press_key('s')     if ("j" not in instr):         control.release_key('s')   def domove():     movstr = procxy()     doshot(movstr)     dojump(movstr)     while ("r" in movstr):         control.press_key(control.right_key)         movstr = procxy()         doshot(movstr)         dojump(movstr)     control.release_key(control.right_key)     while ("l" in movstr):         control.press_key(control.left_key)         movstr = procxy()         doshot(movstr)         dojump(movstr)     control.release_key(control.left_key)   try:     arduino = serial.Serial('/dev/ttyACM1', 9600) except:     print ("Failed to connect on /dev/ttyACM0") while True:     x, y, s, j = getxy()     domove()     print ("X = {0}\nY = {1}".format(x, y)) </code></pre>  <p>Arduino C code:</p>  <pre><code>int y = 0; int x = 0; int fire = 0; int jump = 0; void setup(){   Serial.begin(9600); }  void loop(){   y = analogRead(A0);   x = analogRead(A1);   fire = analogRead(A2);   jump = analogRead(A3);   String out = "";   out.concat(x);   out.concat("_");   out.concat(y);   if(fire &gt; 900)   {     out.concat("_");     out.concat("f");   }   else   {     out.concat("_");     out.concat("t");   }   if (jump &gt; 900)   {     out.concat("_");     out.concat("j");   }   else   {     out.concat("_");     out.concat("k");   }   out.concat("\n");   Serial.print(out); } </code></pre>