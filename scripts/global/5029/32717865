<p>I want to replace a part of a library with the Eigen library. Because there are a lot of dependencies, I wanted to write an Eigen based interface. </p>  <p>This interface below uses cxx11 typedefs and overloading to recreate the old class interface for a 3D vector. The problem with this approach is that it seems that I have to reimplement all the operator functions/constructors which already exist in Eigen (+/-/*/..).</p>  <p>The example below illustrates the problem. If I use the overloaded operators of Eigen with my derived class, I get a compiler error. The base class works fine as expected. Is there a way to add the desired interface functions/members to the Eigen classes with less effort? E.g. by automatically converting the derived classes to base classes? I totally don't want to reimplement all Eigen functions :D</p>  <pre><code>#include &lt;iostream&gt; using namespace std; #include &lt;eigen3/Eigen/Core&gt; #include &lt;eigen3/Eigen/Dense&gt;   namespace InterfDef {     template &lt;class T&gt;     using Vector3 = Eigen::Matrix&lt;T, 3, 1&gt;; };  namespace InterfImp {     template &lt;class T&gt;     class Vector3 : public InterfDef::Vector3&lt;T&gt; {     public:         // This is all what I wanted to add :)         T &amp;x = (*this)[0];         T &amp;y = (*this)[1];         T &amp;z = (*this)[2];          // All this crap below, I don't want to implement :(         Vector3(InterfDef::Vector3&lt;T&gt; v) :             InterfDef::Vector3&lt;T&gt;(v) {          }          Vector3(T x, T y, T z) :             InterfDef::Vector3&lt;T&gt;(x,y,z) {          }          Vector3&amp; operator=(const InterfDef::Vector3&lt;T&gt;&amp; v) {             (*this)[0] = v[0];             (*this)[1] = v[2];             (*this)[2] = v[2];             return *this;         }     }; }; </code></pre>  <p>Here comes to problem. Calling the scalar multiplication operator only works for the non-derived class, because the conversion of the vector class fails after deriving. </p>  <pre><code>int main() {     InterfDef::Vector3&lt;float&gt; a(1,2,3);     InterfImp::Vector3&lt;float&gt; b(2,3,4);     InterfImp::Vector3&lt;float&gt; c(a);     InterfImp::Vector3&lt;float&gt; d = b;      cout &lt;&lt; "Hello World!" &lt;&lt; c.x &lt;&lt; "; " &lt;&lt; c.y &lt;&lt; "; " &lt;&lt; c.z &lt;&lt; std::endl;     cout &lt;&lt; "Hello World!" &lt;&lt; d.x &lt;&lt; "; " &lt;&lt; d.y &lt;&lt; "; " &lt;&lt; d.z &lt;&lt; std::endl;      InterfImp::Vector3&lt;float&gt; e = 2 * d; // error with my derived class      InterfDef::Vector3&lt;float&gt; e = 2 * d; // works      cout &lt;&lt; "Hello World!" &lt;&lt; e[0] &lt;&lt; "; " &lt;&lt; e[1] &lt;&lt; "; " &lt;&lt; e[2] &lt;&lt; std::endl;      return 0; } </code></pre>