<p>I'm writing code in which a class implements two interfaces that happens to have two abstract methods with the same name,and two constants with the same identifier:  </p>  <pre><code>public class Test implements A,B {    public void doStuff() {}    public void make() {}    public static void main(String[] args) {     Test t=new Test();     System.out.println(A.VALUE);     System.out.println(B.VALUE);     //System.out.println(Test.VALUE);     //System.out.println(t.VALUE);   }  }   interface A {              // implicitly abstract    int VALUE=11;            // implicitly public static and final    void doStuff();               // implicitly public and abstract  }   interface B {    int VALUE=14;    void make();    void doStuff();  } </code></pre>  <p>now, I know that as of Java 7, I don't have to worry about name clashing,as far as abstract methods are concerned (right??): I just provide a suitable implementation and I'm good (all methods that share the same name are covered), so I don't get multiple-inheritance-like issues or "diamonds" (which is something I'm going to deal with when I get to Java 8,I suppose).</p>  <p>BUT, as far as constants are concerned, I noticed that if I implement the two interfaces and does not try to access the VALUE field,the compiler doesn't complain.It does,when I uncomment the printing statement.</p>  <p>How is it? is this a normal behaviour? I get an error only when I access those members?</p>  <p><strong>EDIT</strong> I mean, why doesn't the compiler warn me of the ambiguity when I try to implement the interfaces?</p>