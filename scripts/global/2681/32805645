<p>I'm very new to network programming.</p>  <p>I've written the below exe which I've then executed on two separate machines on my local network. The idea is that it spawns a thread to listen to and react to datagrams on a specific port and then in the main thread it allows the user to send data.</p>  <p>Via Wireshark, I can see the datagrams being sent from the other machine, hitting this machine on the correct port, however my exe is not reacting to it. I cannot see what part of my async receive is incorrect.</p>  <p>Also in Wireshark I can see the send messages being sent to the correct machines IP on the correct port, again, on the other machine the .exe doesn't appear to receive the messages.</p>  <p>What am I doing wrong?</p>  <pre><code>class UDPConnector { public:     UDPConnector(asio::io_service&amp; io_service)     : m_socket(io_service)     {         auto endpoint = asio::ip::udp::endpoint(asio::ip::udp::v4(),34724);         m_socket.open(endpoint.protocol());         m_socket.bind(endpoint);          StartReceiving();     }  protected:      void StartReceiving()     {         m_socket.async_receive_from(asio::buffer(m_receiveBuffer), m_remoteEndpoint,                                     std::bind(&amp;UDPConnector::HandleReceive, this,                                               std::placeholders::_1,                                               std::placeholders::_2));     }      void HandleReceive(const asio::error_code&amp; error, std::size_t bytes)     {         if(!error)         {             std::stringstream ss;             for(auto c : m_receiveBuffer)                 ss &lt;&lt; c;             std::cout &lt;&lt; "received: " &lt;&lt; ss.str() &lt;&lt; std::endl;              /* listen for the next post */             StartReceiving();         }         else if(error == asio::error::message_size)         {             std::cout &lt;&lt; "Message was larger than receive buffer" &lt;&lt; std::endl;         }     }      asio::ip::udp::socket m_socket;     asio::ip::udp::endpoint m_remoteEndpoint;     std::vector&lt;char&gt; m_receiveBuffer; };  asio::io_service io_serviceListen;  void Listen() {     UDPConnector udpServer(io_serviceListen);     io_serviceListen.run(); }  int main() {     std::thread listenThread(Listen);      asio::io_service io_serviceSend;     asio::ip::udp::resolver resolver(io_serviceSend);      std::string dest;     std::cout &lt;&lt; "dest: ";     std::cin &gt;&gt; dest;     std::cout &lt;&lt; std::endl;      while(1)     {         std::cout &lt;&lt; "Broadcast something: " &lt;&lt; std::endl;         std::string msg;         std::cin &gt;&gt; msg;          if(msg == "exit")             break;          asio::ip::udp::resolver::query query(asio::ip::udp::v4(), dest, "34724");         asio::ip::udp::endpoint receiverEndpoint = *resolver.resolve(query);         asio::ip::udp::socket socket(io_serviceSend);         socket.open(asio::ip::udp::v4());         socket.send_to(asio::buffer(msg), receiverEndpoint);     }      io_serviceListen.stop();     listenThread.join();      return 0; } </code></pre>  <p>I also have another off-hand question. I noticed in wireshark that despite sending to a specific port, the source port is some random number. Why is this, I thought that it would go through the same port.</p>  <h2>EDIT</h2>  <p>So I've worked out that I am receiving the packets in the .exe, however there is something wrong. In the <code>HandleReceive</code> member, I've found that there is an asio::error_code <code>234</code> (<code>More data is available</code>) and that the <code>bytes</code> parameter is 0. </p>  <p>I can't find anything in the asio reference material that specifies how and when the different errors are received. In Wireshark, I can see that the data is in the packet that the .exe is receiving.</p>