<p>I am writing a distributed programming framework and I have reached a wall on what it comes to templated object declaration and creation on client side. The problem is that I have a object that I need to create in the client side of the network. Somewhere in the client I have:</p>  <p>At Server Side:</p>  <pre><code>template &lt;typename T&gt; class myRemoteObject{     myRemoteObject&lt;T&gt;(){         // tells client to create an object of type T         sendCreateObject( encodeType(T) );     // This is working     } };  int main(){     ...     myRemoteObject obj;     ... } </code></pre>  <p>At the client side:</p>  <pre><code>case (message.type){     OBJ_TYPE_INT:         objPtr = new myObject&lt;int&gt;();         break;     OBJ_TYPE_FLOAT:         objPtr = new myObject&lt;float&gt;();         break; } </code></pre>  <p>That brings me lots of problems. First, it is <strong>not flexible</strong> because I have to explicitly declare every type I use inside my framework statically, if I want to also use containers (vector etc) I also would have to explicetly instantiate them.</p>  <p>Second, it is very <strong>slow</strong> to compile. myObject has a lot of templated functions and compiling just 4 of those instantiations would occupy 1.5G of ram and would take a while too. I got to the point that it would occupy 6GB of RAM and take more than 1h (never finished).</p>  <p>So, I opted for <strong>explicit instantiation</strong>. I created several .cpp files (12) that explicetly instantiated myObject with different types, declared myObject templates in a separate file and included just the .h containig template signatures in the code cited before. Although, that sill limits the frameworks capabilities and</p>  <p><strong>Anybody knows a way to do that purely as a template?</strong> So I need to instantiate only the types being used by the main program? I tried to put the instantiation of myObject inside myRemoteObject, but it didn't work...</p>  <p>ps.: I am using C++2011</p>