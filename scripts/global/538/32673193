<p>Erlang is great about cleaning things up by not having shared state. But what happens when you do want shared state? For example: configuration options, statistics gathering, event/callback servers. Spawning up a new processes with some record as state or using the process dictionary is a way to accomplish shared state. You would loop that process over and over and reply to any messages. Multiple processes will just query that process using what are essentially impure getter and setter functions that wrap around message passing, but here we just turned Erlang into an impure object that's slower than a java object because of the reduction system taking turns is slower than just having a memory mutex around each global state. It even has the possibility of having a mailbox overflow if we're not careful.</p>  <p>So what do you do if you want fast shared state? Reddis, a database, mnesia, spawns looping state? How do you make centralized state more purely functional in erlang?</p>