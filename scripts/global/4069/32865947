<p>I have a following Spring(Boot) configuration for AWS SQS:</p>  <pre><code>    /**      * AWS Credentials Bean      */     @Bean     public AWSCredentials awsCredentials() {         return new BasicAWSCredentials(accessKey, secretAccessKey);     }      /**      * AWS Client Bean      */     @Bean(destroyMethod="shutdown")     public AmazonSQSAsync amazonSQSAsyncClient() {         AmazonSQSAsync sqsClient = new AmazonSQSAsyncClient(awsCredentials());         sqsClient.setRegion(regionProvider().getRegion());         return new AmazonSQSBufferedAsyncClient(sqsClient);     }      /**      * AWS Connection Factory      */     @Bean     public SQSConnectionFactory connectionFactory() {         SQSConnectionFactory.Builder factoryBuilder = new SQSConnectionFactory.Builder(regionProvider().getRegion());         factoryBuilder.setAwsCredentialsProvider(awsCredentialsProvider());         return factoryBuilder.build();     }      @Bean     public AWSCredentialsProvider awsCredentialsProvider() {         return new StaticCredentialsProvider(awsCredentials());     }      @Bean     public RegionProvider regionProvider() {         return new StaticRegionProvider(regionName);     }      /**      * Registering MyQueueListener      */     @Bean(destroyMethod="shutdown")     public DefaultMessageListenerContainer defaultMessageListenerContainer() {         DefaultMessageListenerContainer messageListenerContainer = new DefaultMessageListenerContainer();         messageListenerContainer.setConnectionFactory(connectionFactory());         messageListenerContainer.setDestinationName(queueName);         messageListenerContainer.setMessageListener(new MessageListenerAdapter(new MyQueueListener(reportJobService)));         messageListenerContainer.setErrorHandler(new QueueListenerErrorHandler());         messageListenerContainer.setTaskExecutor(defaultMessageListenerContainerTaskExecutor());         messageListenerContainer.setMaxConcurrentConsumers(taskExecutorMaxConcurrentConsumers);          return messageListenerContainer;     }      @Bean(destroyMethod="shutdown")     public Executor defaultMessageListenerContainerTaskExecutor() {         return Executors.newFixedThreadPool(taskExecutorThreadsNumber);     } </code></pre>  <p>This is my queue listener:</p>  <pre><code>public class MyQueueListener {      final static Logger logger = LoggerFactory.getLogger(MyQueueListener.class);      private ReportJobService reportJobService;      public MyQueueListener(ReportJobService reportJobService) {         this.reportJobService = reportJobService;     }      public void handleMessage(String messageContent) {         try {             logger.info(String.format("message received: %s", messageContent));              try {                 reportJobService.runReportJob(messageContent);             } catch (JobExecutionAlreadyRunningException | JobRestartException | JobInstanceAlreadyCompleteException                     | JobParametersInvalidException e) {                 logger.error(e.getMessage(), e);             }         } catch (Throwable th) {             logger.error(th.getMessage(), th);             throw new QueueListenerException(messageContent, th);         }     } } </code></pre>  <p>ReportJobService:</p>  <pre><code>@Service public class ReportJobServiceImpl implements ReportJobService {      final static Logger logger = LoggerFactory.getLogger(ReportJobServiceImpl.class);      private static final String REPORT_ID = "reportId";      @Autowired     @Qualifier(ReportJobConfig.REPORT_JOB_NAME)     private Job reportJob;      @Autowired     private JobLauncher jobLauncher;      @Override     public void runReportJob(String messageContent) throws JobExecutionAlreadyRunningException, JobRestartException,             JobInstanceAlreadyCompleteException, JobParametersInvalidException {         Map&lt;String, JobParameter&gt; parameters = new HashMap&lt;&gt;();         JobParameter reportIdParameter = new JobParameter(messageContent);         parameters.put(REPORT_ID reportIdParameter);          jobLauncher.run(reportJob, new JobParameters(parameters));     }  } </code></pre>  <p>On Tomcat 8 during the <code>Reload</code> via Tomcat Web Application Manager this configuration leads to the memory leak:</p>  <pre><code>The following web applications were stopped (reloaded, undeployed), but their classes from previous runs are still loaded in memory, thus causing a memory leak (use a profiler to confirm): /domain-api /domain-api </code></pre>  <p>My Tomcat log does not contain messages about possible memory leaks..</p>  <p>Looks like right now I have a 2 instances of my application(domain-api) up and running.. How to check it and how to fix it ?</p>  <p><strong>UPDATED</strong></p>  <p>I deploy this application to Tomcat 8, perform some tasks and then undeploy application via Tomcat Web Application Manager.</p>  <p>With Java VisualVM tool I compared memory snapshots before and after and see that there are a lot of Spring JMS(<code>org.springframework.jms.*</code>) related objects still exist in memory:</p>  <p><a href="http://i.stack.imgur.com/myjHm.png" rel="nofollow"><img src="http://i.stack.imgur.com/myjHm.png" alt="enter image description here"></a></p>  <p>What could be causing this issue ?</p>