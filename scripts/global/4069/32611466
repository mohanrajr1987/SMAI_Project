<p>I have a problem by using Apache Camel in combination with Oracle Advanced Queues and JMS.</p>  <p>It's about an application to distribute messages. Messages are received and  enqueued in Oracle Advanced Queues with the help of Camel. Then they are consumed with Camel and forwarded to the target system. For the case that the message delivery fails, there is an retry count defined in the Advanced Queue, so that the message delivery is repeated.</p>  <p>If Camel now dequeue a message and sends it to a target system that is not available, either a HttpOperationFailedException or NoSuchEndpointException is thrown. These are caught and there is a rollback performed.</p>  <p>At this point, the expectation is that the message delivery will be retried as often as defined in the Retry Count and then moved to an exception queue. However, what is happening is that the next message in the queue is send.</p>  <p>Because the contents of the messages are partially dependent on each other, they must be processed sequentially.</p>  <p>I think that there is an misconfiguration in the usage of the JMS Library, but I'm not sure and have found nothing I could influence this behavior.</p>  <p>The used JMS library is Oracle AqApi v 11.2.0.3.</p>  <p>Here is the code for the Camel route:</p>  <pre><code>from("jms-camel-component:myComponent.AQ?jmsMessageType=Text").routeId("deliveryToTarget")         .transacted()                         .setExchangePattern(ExchangePattern.InOut)                                 .setHeader(Exchange.HTTP_QUERY, constant("throwExceptionOnFailure=false"))         .setHeader(Exchange.CONTENT_TYPE, constant("application/xml; charset=UTF-8"))         .doTry()             .recipientList(header("endpointTarget"))             .endDoTry()             .process(ResponseProzessor.getInstance())             .log("Message was delivererd.")         .doCatch(HttpOperationFailedException.class, NoSuchEndpointException.class)                 .process(ResponseProzessor.getInstance())             .log("Error occured.")             .rollback()         .end(); </code></pre>  <p>Here is the JmsComponent configuration:</p>  <pre><code>JmsComponent jmsComponent = new JmsComponent(scc); jmsComponent.setConnectionFactory(connectionFactory); jmsComponent.setTransactionManager(tm); jmsComponent.setMaxConcurrentConsumers(1);             jmsComponent.setMaxMessagesPerTask(1);                   jmsComponent.setIncludeSentJMSMessageID(true); </code></pre>  <p>Thank you in advance for your help! </p>  <p><strong>UPDATE</strong></p>  <p>I think, I've found the reason for the described behavior. There is a delay configured on the Advanced Queue. As long as the delay lasts, the next message from the queue is dequeued. The messages are not dequeued randomly, they are dequeued according to the priorities. </p>  <p>I really think this is something that has to be configured on the consumer. Is there any trick to configure the camel-jms-component to consume the first message from queue as long as it's not commited or moved to the exception queue? I didn't find an option to configure it directly on camel...</p>