<p>I'm working on a series of methods that execute many different database calls using entity framework. Many of these methods can run asynchronously as I really don't care about their output, and don't rely on them.</p>  <p>However, when I try implementing certain methods, I get a warning from the compiler saying: "Because this call is not awaited, the current method continues to run before the call is completed"</p>  <p>But to me, this seems like that's my desired behavior, as I don't care what the methods do.</p>  <p>Here's an example of the methods</p>  <pre><code>public async Task SetupAccessControl(int objectTypeId, int objectId, int? organizationId) {     using (var context = new SupportContext(CustomerId))     {         ... // omitted for brevity         if (objectTypeId == (int) ObjectType.User)         {             AddToUserRoleBridge("Everyone", objectId);//Warning on this line             AddToUserRoleBridge("Default", objectId); //Warning on this line         }         ... // omitted for brevity     } }  public async Task AddToUserRoleBridge(string role, int userId) {     using (var context = new SupportContext(CustomerId))     {         var defaultRole = context.Roles.FirstOrDefault(n =&gt; n.Name == role);         if (defaultRole != null)         {             var urb = new UserRoleBridge             {                 RoleId = defaultRole.Id,                 UserId = userId             };              context.UserRoleBridges.Add(urb);             await context.SaveChangesAsync();         }     } }  </code></pre>  <p><strong>edit</strong></p>  <p>Essentially, when I run the main function, I want a series of method calls to all fire off somewhat simultaneously and handle everything in their own threads so that I don't have to worry about it. Here is a pseudo-code example.</p>  <pre><code>public async void RunAllAsync() {     taskA(*some value*);     taskA(*some value*);     taskB(*some value*);     taskB(*some value*);      await AllTasksCompleted }  public async Task taskA(int item){      //do something with item }   public async Task taskB(int item) {     subTaskB(*some value*)     subTaskB(*some value*) }  public async Task subTaskB(int item) {     // do something }  </code></pre>  <p>In the above example, when <code>#RunAllAsync</code> is called, every function call it makes (and the function calls they make) are fired off simultaneously. When all of these calls are completed, whatever method called <code>#RunAllAsync</code> would continue to execute. </p>