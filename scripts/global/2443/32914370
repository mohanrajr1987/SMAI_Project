<p>We have a generic <code>Job</code> class which have an abstract <code>HeavyTask</code> method like this: </p>  <pre><code>abstract class Job {     private Task m_task;      protected abstract void HeavyTask();       public void StartJob(){         m_task = Task.Run(() =&gt; HeavyTask());     }     public async Task WaitJob(){         await m_task;      } } </code></pre>  <p>And the derived class override the <code>HeavyTask</code> function and also make it async:</p>  <pre><code>class JobFoo : Job {     protected override async void HeavyTask()     {         await Task.Delay(1000);         Debug.WriteLine("JobFoo is done");     } } </code></pre>  <p>Then when we are using this method, it seems that the <code>HeavyTask()</code> is not awaited: </p>  <pre><code>Job job = new JobFoo(); job.StartJob(); await job.WaitJob(); Debug.WriteLine("All Done"); </code></pre>  <p>Output: </p>  <blockquote>   <p>All Done<br>   JobFoo is Done</p> </blockquote>  <p>If we don't have <code>async</code> for the override <code>HeavyTask</code>, then it is working as expected. But I cannot guarantee those whose override the <code>Job</code> won't make the <code>HeavyTask</code> <code>async</code>. I want to understand why it is not awaited successfully and is there a way to make sure it will awaited? If you can, could you also explain whether it is a good practice to override a non-async function as async as shown above?  </p>