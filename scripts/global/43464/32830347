<p>I have, say, 4 keys in a Redis database.  The keys have an expiration of 10 seconds from now.  I have added the keys to a set.  When the keys expire, they are effectively not in the database anymore (get returns null value).  However, the keys are still members of the set.  The set will continue to exist until the keys are removed from the set, at which point it too effectively is gone from the database.</p>  <p>Is it possible to automatically remove a key from the set(s) to which it belongs when the key expires?</p>  <p>I am thinking of maintaining one set per key to maintain the sets which it belongs to (making a digraph set relationship between keys and sets), and then registering for key expiration events to remove the set members when necessary.  This is a lot of overhead to do as a consumer of the db, rather than as some kind of background cleanup thread inside.  And, such an approach would be "best-effort" to cleanup sets, as the consumer code which subscribes to the expiration events might crash, not get the notification, get backlogged, etc.</p>  <p>I may have been able to avoid any trickery by modeling the set of keys as fields in a hash set, but I wish to have different expiration TTLs per key in practice.  If that is possible, then how so?</p>  <p>For example, here is my set of "foo" keys.</p>  <pre><code>mine:0&gt;set foo1 barA OK  mine:0&gt;set foo2 barB OK  mine:0&gt;set foo3 barC OK  mine:0&gt;set foo4 barD OK </code></pre>  <p>They can be added to a set.</p>  <pre><code>mine:0&gt;sadd foo foo1 foo2 foo3 foo4 4  mine:0&gt;smembers foo 1) foo1 2) foo3 3) foo4 4) foo2 </code></pre>  <p>The keys can then expire...</p>  <pre><code>mine:0&gt;expire foo1 10 1  mine:0&gt;expire foo2 10 1  mine:0&gt;expire foo3 10 1  mine:0&gt;expire foo4 10 1  mine:0&gt;get foo1  NULL  mine:0&gt;get foo2 NULL  mine:0&gt;get foo3 NULL  mine:0&gt;get foo4 NULL  mine:0&gt;get foo5 NULL </code></pre>  <p>At this point the keys don't exist, but the set does, and it references the keys.</p>  <pre><code>mine:0&gt;smembers foo 1) foo1 2) foo3 3) foo4 4) foo2 </code></pre>  <p>Removing the keys explicitly will remove them from the set, and then make the set non-existent once all are removed.</p>  <pre><code>mine:0&gt;srem foo foo1 1  mine:0&gt;srem foo foo2 1  mine:0&gt;srem foo foo3 1  mine:0&gt;srem foo foo4 1  mine:0&gt;smembers foo [nothing returned] </code></pre>