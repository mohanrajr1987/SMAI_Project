<h2>What I'm trying to do</h2>  <p>I have a web app hosted on Heroku, which uses Django, with the domain (say) <code>example.com</code>. I wanted to make all incoming <code>http://example.com</code> requests redirect to <code>https://example.com</code>.</p>  <h2>What I've done</h2>  <p>I set up <a href="https://docs.djangoproject.com/en/1.8/ref/middleware/#django.middleware.security.SecurityMiddleware" rel="nofollow">SecurityMiddleware</a> in Django and set <code>SECURE_SSL_REDIRECT</code> to be <code>True</code>, which <a href="https://docs.djangoproject.com/en/1.8/ref/settings/#std:setting-SECURE_SSL_REDIRECT" rel="nofollow">"redirects all non-HTTPS requests to HTTPS"</a>. This seems to work.</p>  <h2>The problem</h2>  <p>Heroku serves as a proxy to my Django app. So when the Heroku load-balancer gets an HTTPS request, it (probably) routes to my web app using a non-HTTPS connection. Which freaks out my app, and it redirects it to HTTPS again, setting off a redirect loop.</p>  <p><a href="https://docs.djangoproject.com/en/1.8/ref/settings/#secure-proxy-ssl-header" rel="nofollow">The way to solve this seems to be</a> to set <code>SECURE_PROXY_SSL_HEADER = ('HTTP_X_FORWARDED_PROTO', 'https')</code> as a setting in Django. This tells my app: if the proxy sends the header 'HTTP_X_FORWARDED_PROTO', and if its value is 'https', then trust the connection. I tried this, and it works.</p>  <p>However, I'm warned by the Django docs that I should make sure that my proxy strips incoming 'X_FORWARDED_PROTO' headers, which makes sense:  if a malicious agent sends this header over a <code>http</code> connection with an <code>https</code> value my web app will be fooled.</p>  <p><strong>How do I check if Heroku strips the <code>X_FORWARDED_PROTO</code> header from incoming requests?</strong></p>