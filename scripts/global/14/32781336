<p>I have a questions about multiple if-statements in lisp. If <code>count</code> is not equal to <code>n</code> I want to continue on with the <code>let</code> and <code>if</code> statements, else I want to do <code>(= (abs (- row i))</code> and if that is <code>t</code> return nil.</p>  <p>However, I find that whenever <code>count</code> is not <code>n</code> I will return <code>nil</code> because <code>progn</code> always returns the last line of code in the block. Please share with me how I can write the program so that I only when <code>count</code> is not <code>n</code> I will only return <code>nil</code> when any of the <code>or</code> clauses are <code>t</code>. </p>  <pre><code>(loop for i below n       do (if (/= count n)              (progn                (let ((tcol (getqueencol i n)))                  (if (or (= col tcol) (= (abs (- row i)) (abs (- col tcol))))                      (return-from queen-can-be-placed-here nil))))            (if (= (abs (- row i)))                (return-from queen-can-be-placed-here nil)))) </code></pre>  <p>UPDATED:</p>  <p>Thank you for good response. Yes, indeed I am trying to solve the N queen puzzle :P The problem I have right now is that my control to determine if placing a queen at a certain row and column is not working when the row is empty. That is because <code>getqueencol</code> will return <code>nil</code> when the row is empty and in <code>queen-can-be-placed-here</code> there will be a <code>(= nil NUMBER)</code>. </p>  <p>To combat that I tried to make a count variable in <code>queen-can-be-placed-here</code> that knows whether a row is empty or not, and that would enable me to not call <code>getqueencol</code> on an empty row. The problem is though that I do not know how the check will be in <code>queen-can-be-placed-here</code> when a queen is to be added to an empty row.</p>  <p>Here is the code so far:    </p>  <pre><code>(defvar *board* (make-array '(5 5) :initial-element nil))   (defun getqueencol (row n) "Traverses through the columns of a certain row  and returns the column index of the queen."   (loop for i below n         do (if (aref *board* row i)                (return-from getqueencol i))))  (defun print-board (n) "Prints out the solution, e.g. (1 4 2 5 3),  where 1 denotes that there is a queen at the first   column of the first row, and so on."   (let ((solutionlist (make-list n)))     (loop for row below n           do (loop for col below n                    do (when (aref *board* row col)                         (setf (nth row solutionlist) col))))     (print solutionlist)))   (defun queen-can-be-placed-here (row col n) "Returns t if (row,col) is a possible place to put queen, otherwise nil."   (let ((count 0))     (loop for i below n  ;This is the block I added to keep track of if a     row is empty (count = n)           do (if (not (aref *board* row i))                     (setf count (+ 1 count))))      (loop for i below n           do (if (/= count n)                  (let ((tcol (getqueencol i n)))                    (if (or (= col tcol) (= (abs (- row i)) (abs (- col     tcol))))                        (return-from queen-can-be-placed-here nil)))                (if (= (abs (- row i)))   ;Here is where I don't know what to check                    (return-from queen-can-be-placed-here nil)))))    (return-from queen-can-be-placed-here t))   (defun backtracking (row n) "Solves the NxN-queen problem with backtracking"   (if (&lt; row n)       (loop for i below n           do (when (queen-can-be-placed-here row i n)                   (setf (aref *board* row i) 't)                   (backtracking (+ row 1) n)                   (setf (aref *board* row i) 'nil)))     (print-board n)))  (defun NxNqueen-solver (k) "Main program for the function call to the recursive solving of the problem"   (setf *board* (make-array (list k k) :initial-element nil))   (backtracking 0 k)) </code></pre>