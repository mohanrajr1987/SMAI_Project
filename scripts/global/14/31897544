<p>I'm writing a program in Common Lisp for editing binary files generated by Minecraft that use the NBT format, documented here: <a href="http://minecraft.gamepedia.com/NBT_format?cookieSetup=true">http://minecraft.gamepedia.com/NBT_format?cookieSetup=true</a> (I'm aware that such tools exist, such as NBTEditor and MCEdit, but neither are written in Common Lisp, and I thought this project would make an excellent learning exercise).</p>  <p>So far one of the only things that I haven't managed to implement on my own is a function for reading a UTF-8 string of known length that contains characters that are represented using more than one octet (i.e. non-ASCII characters). In the NBT format, every string is UTF-8 encoded and is preceded by a short (two octet) integer <code>n</code> denoting the string's length. So, assuming that only ASCII characters are present in the string, I can simply read a sequence of <code>n</code> octets from the stream and convert it to a string using like so:</p>  <pre><code>(defun read-utf-8-string (string-length byte-stream)   (let ((seq (make-array string-length :element-type '(unsigned-byte 8)                                        :fill-pointer t)))     (setf (fill-pointer seq) (read-sequence seq byte-stream))     (flexi-streams:octets-to-string seq :external-format :utf-8))) </code></pre>  <p>But if one or more of the characters has a character code greater than 255, it is encoded in two or more bytes, as seen in this example:</p>  <pre><code>(flexi-streams:string-to-octets "wife" :external-format :utf-8) ==&gt; #(119 105 102 101)  (flexi-streams:string-to-octets "жена" :external-format :utf-8) ==&gt; #(208 182 208 181 208 189 208 176) </code></pre>  <p>Both strings have the same length, but each character of the Russian word is encoded in double the number of octets, so the total size of the string is double that of the English one. So knowing the string length does not help if using read-sequence. Even if the size of the string (i.e. the number of octets needed to encode it) was known, there would still be no way of knowing which of those octets to convert to character form individually and which to group together for conversion. So instead of rolling my own function, I tried to find a way to get either the implementation (Clozure CL) or an external library do the work for me. Unfortunately this too has been problematic, because my parser relies on using the same file stream for all reading functions, like this:</p>  <pre><code>(with-open-file (stream "test.dat" :direction :input                                    :element-type '(unsigned-byte 8))   ;;Read entire contents of NBT file from stream here) </code></pre>  <p>which limits me to the <code>:element-type '(unsigned-byte 8)</code> and therefore prohibits me from specifying a character encoding and using read-char (or equivalent) like this:</p>  <pre><code>(with-open-file (stream "test.dat" :external-format :utf-8)   ...) </code></pre>  <p>The <code>:element-type</code> has to be <code>'(unsigned-byte 8)</code> so that I can read and write integers and floats of various sizes. To avoid having to manually convert sequences of octets to strings, I first wondered whether there was a way to change the element type to that of a character while the file is open, which led me to this discussion here: <a href="https://groups.google.com/forum/#!searchin/comp.lang.lisp/binary">https://groups.google.com/forum/#!searchin/comp.lang.lisp/binary</a>$20write$20read/comp.lang.lisp/N0IESNPSPCU/Qmcvtk0HkC0J Apparently some CL implementations such as SBCL use bivalent streams by default, so both read-byte and read-char can be used on the same stream; if I were to take this approach, I would still need to be able to specify an <code>:external-format</code>to the stream (<code>:utf-8</code>), although this format should only apply when reading characters, and not when reading raw bytes.</p>  <p>I have used a couple of functions from flexi-streams in the above examples for brevity's sake, but as yet my code uses only the built-in stream types, and I have yet to use flexi-streams themselves. <strong>Is this problem a good candidate for flexi-streams? Having an additional layer of abstraction that would allow me to read raw bytes and UTF-8 characters interchangeably from the same stream would be ideal.</strong></p>  <p>Any advice from those familiar with flexi-streams (or other relevant approaches) would be very much appreciated.</p>  <p>Thank you.</p>