<p>I'm implementing a simple algorithm in Clojure that insists on blowing the memory, even with <code>:jvm-opts ["-Xmx4G"]</code> set on my <code>project.clj</code>. assuming the following data structures:</p>  <pre><code>(def inf Double/POSITIVE_INFINITY) (def min-dist (atom {:1 {:1 0 :2 4} :2 {:1 4 :2 0 :3 5} :3 {:2 5 :3 0}})) (def vertexes [:1 :2 :3]) </code></pre>  <p>The following will run out of memory on bigger inputs (<code>|vertexes| = 100</code>):</p>  <pre><code>(for [k vertexes i vertexes j vertexes]   (do     (println " " i " " j " "k)     (let [s (+ (get-in @min-dist [i k] inf) (get-in @min-dist [k j] inf))]       (if (&gt; (get-in @min-dist [i j] inf) s) (swap! min-dist assoc-in [i j] s))))) </code></pre>  <p>output:</p>  <pre><code>OutOfMemoryError Java heap space  java.util.Arrays.copyOf (Arrays.java:2367) </code></pre>  <p>I'm pretty sure that that is a <code>reduce</code> option here that will make everything clean and fast, but I just can't find it. It looks like <code>swap!</code>takes a lot of memory space, am I right?</p>  <hr>  <p>Two bonus questions:</p>  <ol> <li><p>if I remove the <code>println</code> line (as well as the do, of course), the code will run fast, but <code>min-dist</code> will not be updated, as if the loops were not executed. Why is it?</p></li> <li><p>The same behavior is seen when running with <code>lein run</code>, even with the <code>println</code> in there. Why?</p></li> </ol>  <p>Any help to a new Clojurist will be appreciated. =)</p>