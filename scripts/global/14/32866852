<p>Why I couldn't do exhaustive search e.g. (1 1)(1 2)(1 3)(1 4)....(4 4) for 4 queens using lisp? I am a beginner in lisp, and hence referenced from tutorials websites and other people psedo-code to code this out. Someone please help me.</p>  <pre><code>;n - size of the board &amp; no of queen ;first queen will be place on 1st row  ;initial state on board ;cons - construct list to have few elements in it, e.g. row  &amp; column (like      java's array) (defun initialS (size &amp;optional (board nil))    (dotimes (row size)      (setq column (+ 1 row))     (setq row (+ 1 (- row row)))      (setq board (cons (list row column) board))  )   (setq board (reverse board))   board)  ;check if 2 queen conflict ;first queen (a b) second queen (c d) a,c:Row; b,d:Column ;conflict if same row, column, or diagonal ;2 queen same diagonals if sum or difference of their row column are equal  ;e.g. queen in (1,3) (2,2) are in the same diagonal (defun checkConflict (a b c d)   (cond    ((not a) nil)    ((not b) nil)    ((not c) nil)    ((not d) nil)   ((or (= a c) (= b d)        (= (- a b) (- c d))       (= (+ a b) (+ c d))) t)))  ;check any conflicts on board ;check first queen w every other queen, second queen with every other queen, etc....... ;count=0, no conflict exists on board ;e.g.board1 have all the queens that is going to compare w board2,loop till board1 has compared finish all the queens w board2 (defun conflict (board)       (setq board1 board)   (setq board2 board)   (setq count 0)   (loop do         (loop do               (if (checkConflict (first(first board2)) (second(first board2)) (first(second board1)) (second(second board1)))                   (progn                     (setq count (+ count 1))                     (return))                 (setq board1 (rest board1)))               while (not(null board1)))         (setq board2 (rest board2))         (setq board1 board2)         while (not(null board2)))   count)   ;check how many conflict a queen in particular row has w every other queen on board ;same as herself that queen, skip count (defun count-conflict (row column board)   (setq count 0)   (setq extraBoard board)   (loop do         (cond          ((= row (first(first extraBoard))) t)          ((checkConflict row column (first(first extraBoard)) (second(first extraBoard))) (setq count (+ count 1))))          (setq extraBoard (rest extraBoard))         while (not(null extraBoard)))   count)  ;main func (defun q1 (size &amp;optional (board nil) (maxstep 50)) (loop do   (setq board (initialS size))   (format t "Initial board: ~S~%" board)      (setq row (first(nth (- row 1) board)))    (setq column (second(nth (- row 1) board)))   (setq extraBoard board)   (setq count 0)   (dotimes (n maxstep)     (setq count (+ count 1))     (cond      ((= (conflict board) 0) (progn (format t "Solution found!~%")                                (format t "~S~%" board)                                (return))) (t       (setq column (second(nth (- row 1) board))) (setq min (count-conflict row column board)) (setq tempColumn 1)   (loop do             (if (= min 0) (progn                             (setq minColumn column)                             (return)))              (setq temp (count-conflict row tempColumn board))  (cond              ((= tempColumn column) t)              ((= temp 0) (progn                            (setq min temp)                            (setq minColumn tempColumn)                            (return))) ((&gt;= min temp) (progn                              (setq min temp)                              (setq minColumn tempColumn))))  (setq tempColumn (+ tempColumn 1))             while (&lt; tempColumn size))  ;shift the queen to the new spot with next position on board ;nth - returns the nth element of list ;second - second list =&gt; object ;put minColumn into second item object (column) of row-1  (setf (second(nth (- row 1) board)) minColumn)        ;find row of a piece which conflict with the new queen    ;if new queen has no conflict, move to next row            (if (= min 0) (setq row (+ row 1))         (progn           (setq extraBoard board)         (loop do               (if (and (checkConflict row minColumn (first(first extraBoard)) (second(first extraBoard)))                        (not (and (= row (first(first extraBoard))) (= minColumn (second(first extraBoard))))))                   (progn                     (setq row (first(first extraBoard)))                     (return))                 (setq extraBoard (rest extraBoard)))               while (not(null extraBoard))))))))   (if (and (= (conflict board) 0) (&lt;= count maxstep))       (return)     (format t "No solution found.~%"))   while t)) </code></pre>