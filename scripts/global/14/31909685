<p>I have the following procedure for creating all prime-pairs in a list:</p>  <pre><code>(define (prime-pairs lst)   (define (split lst pos)     (list (drop-right lst pos) (take-right lst pos)))   (define (prime-pairs-iter n acc)     (cond ((= n 0) (filter (lambda (e) (not (null? e))) acc))           (else (prime-pairs-iter (- n 1)                                    (let ((s (split lst n)))                                     (if (and (prime? (list-&gt;number (car s)))                                              (prime? (list-&gt;number (cadr s))))                                         (append s acc)                                         acc))))))   (prime-pairs-iter (- (length lst) 1) '())) </code></pre>  <p>(Full code: <a href="https://gist.github.com/anonymous/b8cfcb0bf021be9ef9c8" rel="nofollow">https://gist.github.com/anonymous/b8cfcb0bf021be9ef9c8</a>)</p>  <p>What I want <code>prime-pairs</code> to do is create a list of every pair in the <code>lst</code> that consists of two primes. The numbers are represented in a list format as follows: 11 would be <code>'(1 1)</code>.</p>  <p>Unfortunately, when I run this code the <code>(filter (lambda (e) (not (null? e))) acc))</code> does not seem to remove the <code>'()</code> from the end result, and I end up with a long list of empty values and the wanted pairs.</p>  <p>If I use a <code>(filter null? acc))</code> a list of empty values does remain. So the other way around (filtering out the actual values) does work.</p>  <p>How can I filter out the nulls of the returned list?</p>