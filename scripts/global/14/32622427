<p>For integer (32bit or 4 bytes) I can do as follows;</p>  <pre><code>(defun get-u4 (arr pos)   (let ((u4 0))     (setf (ldb (byte 8 0) u4) (aref arr pos))     (setf (ldb (byte 8 8) u4) (aref arr (+ pos 1)))     (setf (ldb (byte 8 16) u4) (aref arr (+ pos 2)))     (setf (ldb (byte 8 24) u4) (aref arr (+ pos 3)))   u4))  (defun put-u4 (arr pos int)   (setf (aref arr pos) (ldb (byte 8 0) int))   (setf (aref arr (+ pos 1)) (ldb (byte 8 8) int))   (setf (aref arr (+ pos 2)) (ldb (byte 8 16) int))   (setf (aref arr (+ pos 3)) (ldb (byte 8 24) int))) </code></pre>  <p>However, I cannot figure out how can I do this for 64bit or 8byte double-float? Little-Endianess is assumed.</p>  <p>=============</p>  <p>I found one solution (using external library); <a href="https://www.quicklisp.org/beta/UNOFFICIAL/docs/ieee-floats/doc/index.html" rel="nofollow">https://www.quicklisp.org/beta/UNOFFICIAL/docs/ieee-floats/doc/index.html</a> using this one, I can encode/decode double-float to/from integer with proper size.</p>