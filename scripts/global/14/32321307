<p>I'm new to lisp, and have been trying to learn Common Lisp by diving in and writing some code. I've read plenty of documentation on the subject, but it's taking a while to really sink in.</p>  <p>I have written a couple of macros (<code>?</code> and <code>??</code>) for performing unit tests, but I'm having some difficulty. The code is at the end of the post, to avoid cluttering the actual question.</p>  <p>Here is an example of usage:</p>  <pre><code>(??   (? "Arithmetic tests"     (? "Addition"         (= (+ 1 2) 3)         (= (+ 1 2 3) 6)         (= (+ -1 -3) -4)))) </code></pre>  <p>And an example of output:</p>  <pre><code>[Arithmetic tests]   [Addition]     (PASS) '(= (+ 1 2) 3)'     (PASS) '(= (+ 1 2 3) 6)'     (PASS) '(= (+ -1 -3) -4)'  Results: 3 tests passed, 0 tests failed </code></pre>  <p>Now, the existing code works. Unfortunately, the <code>(? ...)</code> macro is ugly, verbose, resistant to change - and I'm pretty sure also badly structured. For example, do I really have to use a list to store pieces of output code and then emit the contents at the end?</p>  <p>I'd like to modify the macro to permit description strings (or symbols) to optionally follow each test, whereupon it would replace the test literal in the output, thus:</p>  <pre><code>(??   (? "Arithmetic tests"     (? "Addition"         (= (+ 1 2) 3)    "Adding 1 and 2 results in 3"         (= (+ 1 2 3) 6)         (= (+ -1 -3) -4)))) </code></pre>  <p>Output:</p>  <pre><code>[Arithmetic tests]   [Addition]     (PASS) Adding 1 and 2 results in 3     (PASS) '(= (+ 1 2 3) 6)'     (PASS) '(= (+ -1 -3) -4)' </code></pre>  <p>But unfortunately I can't find a sensible place in the macro to insert this change. Depending on where I put it, I get errors like <code>you're not inside a backquote expression</code>, <code>label is not defined</code> or <code>body-forms is not defined</code>. I know what these errors mean, but I can't find a way to avoid them.</p>  <p>Also, I'll be wanting to handle exceptions in the test, and treat that as a failure. Currently, there is no exception handling code - the test result is merely tested against nil. Again, it is not clear how I should add this functionality.</p>  <p>I'm thinking that maybe this macro is over-complex, due to my inexperience in writing macros; and perhaps if I simplify it, modification will be easier. I don't really want to separate it out into several smaller macros without good reason; but maybe there's a terser way to write it?</p>  <p>Can anyone help me out here, please?</p>  <p>A complete code listing follows:</p>  <pre><code>(defmacro with-gensyms ((&amp;rest names) &amp;body body)     `(let ,(loop for n in names collect `(,n (gensym)))          ,@body))  (defmacro while (condition &amp;body body)     `(loop while ,condition do (progn ,@body)))  (defun flatten (L)   "Converts a list to single level."   (if (null L)     nil     (if (atom (first L))       (cons (first L) (flatten (rest L)))       (append (flatten (first L)) (flatten (rest L))))))  (defun starts-with-p (str1 str2)   "Determine whether `str1` starts with `str2`"   (let ((p (search str2 str1)))     (and p (= 0 p))))  (defmacro pop-first-char (string)     `(with-gensyms (c)         (if (&gt; (length ,string) 0)             (progn                 (setf c (schar ,string 0))                 (if (&gt; (length ,string) 1)                     (setf ,string (subseq ,string 1))                     (setf ,string ""))))     c))  (defmacro pop-chars (string count)     `(with-gensyms (result)         (setf result ())         (dotimes (index ,count)             (push (pop-first-char ,string) result))         result))  (defun format-ansi-codes (text)     (let ((result ()))         (while (&gt; (length text) 0)             (cond                 ((starts-with-p text "\\e")                     (push (code-char #o33) result)                     (pop-chars text 2)                 )                 ((starts-with-p text "\\r")                     (push (code-char 13) result)                     (pop-chars text 2)                 )                 (t (push (pop-first-char text) result))         ))         (setf result (nreverse result))         (coerce result 'string)))  (defun kv-lookup (values key)     "Like getf, but works with 'keys as well as :keys, in both the list and the supplied key"     (setf key (if (typep key 'cons) (nth 1 key) key))     (while values         (let ((k (pop values)) (v (pop values)))             (setf k (if (typep k 'cons) (nth 1 k) k))             (if (eql (symbol-name key) (symbol-name k))                 (return v)))))  (defun make-ansi-escape (ansi-name)     (let ((ansi-codes '( :normal "\\e[00m" :white "\\e[1;37m" :light-grey "\\e[0;37m" :dark-grey "\\e[1;30m"                                     :red "\\e[0;31m" :light-red "\\e[1;31m" :green "\\e[0;32m" :blue "\\e[1;34m" :dark-blue "\\e[1;34m"                                     :cyan "\\e[1;36m" :magenta "\\e[1;35m" :yellow "\\e[0;33m"                                     :bg-dark-grey "\\e[100m"                                     :bold "\\e[1m" :underline "\\e[4m"                                     :start-of-line "\\r" :clear-line "\\e[2K" :move-up "\\e[1A")))     (format-ansi-codes (kv-lookup ansi-codes ansi-name))     ))  (defun format-ansi-escaped-arg (out-stream arg)     (cond         ((typep arg 'symbol) (format out-stream "~a" (make-ansi-escape arg)))         ((typep arg 'string) (format out-stream arg))         (t (format out-stream "~a" arg))     ))  (defun format-ansi-escaped (out-stream &amp;rest args)     (while args         (let ((arg (pop args)))             (if (typep arg 'list)                 (let ((first-arg (eval (first arg))))                     (format out-stream first-arg (second arg))                 )                 (format-ansi-escaped-arg out-stream arg)         ))     ))  (defmacro while-pop ((var sequence &amp;optional result-form) &amp;rest forms)     (with-gensyms (seq)         `(let (,var)             (progn                 (do () ((not ,sequence))                     (setf ,var (pop ,sequence))                     (progn ,@forms))                 ,result-form))))  (defun report-start (form)     (format t "(    ) '~a'~%" form))  (defun report-result (result form)         (format-ansi-escaped t "(" (if result :green :red) `("~:[FAIL~;PASS~]" ,result) :normal `(") '~a'~%" ,form))         result)  (defmacro ? (name &amp;body body-forms)     "Run any number of test forms, optionally nested within further (?) calls, and print the results of each test"     (with-gensyms (result indent indent-string)         (if (not body-forms)             :empty             (progn                 (setf result () indent 0 indent-string "  ")                 (cond                     ((typep (first body-forms) 'integer)                         (setf indent (pop body-forms))))                 `(progn                     (format t "~v@{~A~:*~}" ,indent ,indent-string)                     (format-ansi-escaped t "[" :white ,name :normal "]~%")                     (with-gensyms (test-results)                         (setf test-results ())                         ,(while-pop (body-form body-forms `(progn ,@(nreverse result)))                             (cond                                 ( (EQL (first body-form) '?)                                     (push `(progn                                         (setf test-results (append test-results (? ',(nth 1 body-form) ,(1+ indent) ,@(nthcdr 2 body-form))))                                         (format t "~%")                                         test-results                                     ) result)                                 )                                 (t                                     (push `(progn                                         (format t "~v@{~A~:*~}" ,(1+ indent) ,indent-string)                                         (report-start ',body-form)                                         (with-gensyms (result label)                                             (setf result ,body-form)                                             (format-ansi-escaped t :move-up :start-of-line :clear-line)                                             (format t "~v@{~A~:*~}" ,(1+ indent) ,indent-string)                                             (push (report-result result ',body-form) test-results)                                             test-results                                     )) result))))))))))  (defun ?? (&amp;rest results)     "Run any number of tests, and print a summary afterward"     (setf results (flatten results))     (format-ansi-escaped t "~&amp;" :white "Results: " :green `("~a test~:p passed" ,(count t results)) :normal ", "         (if (find NIL results) :red :normal) `("~a test~:p failed" ,(count NIL results))         :yellow `("~[~:;, ~:*~a test~:p not run~]" ,(count :skip results))         :brown `("~[~:;, ~:*~a empty test group~:p skipped~]" ,(count :empty results))         :normal "~%")) </code></pre>