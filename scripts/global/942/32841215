<p>I'm a great fan of using Angular's services to do things in my Angular application. So it seems like a natural choice for me to use $log for logging. It has many benefits over console.log() like the way I can omit debug-logging in a production situation. </p>  <p>One thing I regret, though, and I wonder if I can overcome this. I used to use console.group / console.groupCollapsed and console.groupEnd in my application to clean up my console when debugging iterators.</p>  <p>I tried the following decorator, but it's not even close (and certainly no cigar) to the desired behavior:</p>  <pre><code>app.config([ '$provide', function($provide) {   // Use the `decorator` solution to substitute or attach behaviors to   // original service instance; @see angular-mocks for more examples....    $provide.decorator('$log', [ '$delegate', function($delegate) {     // Save the original $log.debug()     var debugFn = $delegate.debug;      $delegate.debug = function() {       var args    = [].slice.call(arguments),       now     = new Date(),       logtime = now.getHours() + ':' + now.getMinutes() + ':' + now.getSeconds() + '.' + now.getMilliseconds()        // Prepend timestamp       args[0] = logtime + ' - ' + args[0];        // Call the original with the output prepended with formatted timestamp       debugFn.apply(null, args)     };     $delegate.group = function() {       var args    = [].slice.call(arguments),       now     = new Date(),       logtime = now.getHours() + ':' + now.getMinutes() + ':' + now.getSeconds() + '.' + now.getMilliseconds()        // Prepend timestamp       args[0] = ' --&gt; ' + args[0];        // Call the original with the output prepended with formatted timestamp       debugFn.apply(null, args)     };       return $delegate;   }]); }]); </code></pre>  <p>Is there a way to get Angular $log to mimic this behavior any better?</p>