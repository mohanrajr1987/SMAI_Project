<p>In my Python project I have a core module which initialize and start some managers. These managers (e.g. Task Manager and Service Manager) do their stuff on their own thread. </p>  <p>To be sure that these managers do their stuff correctly during development I use the standard python logging module to create a log (file and console).</p>  <p>I wanted to spice up the logging in the console, so I added support for colors (<a href="https://pypi.python.org/pypi/colorama" rel="nofollow">colorama</a>). For this I created my own StreamHandler and FileHandler. In the StreamHandler I added some stuff to be able to print the log lines with color in the console. In the FileHandler I added some stuff to be able to filter those colorcodes, so the logfiles are clean and do not contain the colorcodes. </p>  <p><strong>The Logging issue</strong> <a href="http://i.stack.imgur.com/G9BLq.png" rel="nofollow"><img src="http://i.stack.imgur.com/G9BLq.png" alt="enter image description here"></a></p>  <p>It seems that the Task Manager and the Service Manager are writing to the log at the same time. Both log lines are mixed in the console (which also breaks my colors). The file logging, on the other hand, is correct. Both log lines are on a new line and do not get mixed.</p>  <p>Each manager creates its own logging instance by running this piece of code:</p>  <pre><code>from log.logmanager import getLogger, LogColor  log = getLogger("TASK MANAGER")  class TaskManager(object):     # class code.. </code></pre>  <p>The getLogger() function</p>  <pre><code>def getLogger(name):     """Get Logger by name.      Get and initialize a colorized logging instance if the system      supports it as defined by the log.has_color.      Args:         name (str): Name of the logger.      Returns:         (Logger) Logger instance.     """     log = logging.getLogger(name)      # Only enable color if support was loaded properly     console_handler = ColorStreamHandler() if has_color else logging.StreamHandler()      if has_color:         console_handler.createLock()      console_handler.setLevel(LOG_LEVEL)     console_handler.setFormatter(logging.Formatter(LOG_FORMAT))      file_handler = FileHandler()     file_handler.setLevel(LOG_LEVEL)     file_handler.setFormatter(logging.Formatter(LOG_FORMAT))      log.addHandler(console_handler)     log.addHandler(file_handler)     log.setLevel(LOG_LEVEL)     log.propagate = 0     return log  </code></pre>  <p>The write function in the StreamHandler:</p>  <pre><code>def emit(self, record):     try:         message = self.format(record)          self.acquire()         if not self.is_tty:             self.stream.write(message)         else:             self.stream.write(self.default_colors[record.levelname] + message)          self.stream.write(getattr(self, 'terminator', '\n'))         self.flush()         self.release()      except:         # Handle exception         pass </code></pre>  <p>I've read in <a href="https://docs.python.org/3.4/library/logging.html#logging.Handler.createLock" rel="nofollow">the docs</a> that the python logging handlers are able to use thread locks. Since I created my own handlers, I've added the <code>createLock()</code>, <code>acquire()</code> and <code>release()</code> functions to the StreamHandler.</p>  <p>Unfortunately doesn't solve this my problem. Now I am wondering if it is possible to fix my problem with the default thread lock functions from the logging module. Or should I push all log messages into a queue, which a different thread will use to write them to console and file.</p>