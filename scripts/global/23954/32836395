<p>I know this question has asked many times and it has many answers but none of post has solved my problem.  I have implemented a service that has static broadcast receiver as an inner class. I'm calling a non static method from the inner class but the problem is the non-static method has an instance of database class which is also not static and my log shows gives null exception from accessing the database. I tried passing context but that also not solved the issue. </p>  <pre><code>public class AlarmServices extends Service {      UserSQLiteDB dbHelper;     Cursor cursor;     String where = "1=1";       @Override     public void onCreate() {         // TODO Auto-generated method stub         super.onCreate();         scheduleAlarm();      }       public void CallMethodAfter() {          Log.v("call method after","yes");         dbHelper = new UserSQLiteDB(AlarmServices.this);         dbHelper.open();         cursor = dbHelper.getInCompleteAttendance(where);          // Daily Attendance         int rows = cursor.getCount();         if (rows &gt; 0) {             cursor.moveToFirst();              for (int i = 0; i &lt; rows; i++) {                 int Id;                 String recvdate, ffcode, terr_code, drcode, drname, addr, createddate, ffmgr, shift, lat, lon,droidrefno,locAddress, sync_status, curr_date, date_only;                 Id = cursor.getInt(0);                 recvdate = cursor.getString(1);                 ffcode = cursor.getString(2);                 terr_code = cursor.getString(3);                 drcode = cursor.getString(4);                 drname = cursor.getString(5);                 addr = cursor.getString(6);                 createddate = cursor.getString(7);                 ffmgr = cursor.getString(8);                 shift = cursor.getString(9);                 lat = cursor.getString(10);                 lon = cursor.getString(11);                 droidrefno = cursor.getString(12);                 locAddress = cursor.getString(13);                 sync_status = cursor.getString(14);                 curr_date = cursor.getString(15);                 date_only = cursor.getString(16);                  // Sync Server                 ChkInsertDailyAttendanceOperation insertAttd = new ChkInsertDailyAttendanceOperation(AlarmServices.this,                         recvdate, ffcode, terr_code, drcode, drname, addr,                         createddate, ffmgr,shift,Double.parseDouble(lat),Double.parseDouble(lon),locAddress,                         droidrefno,curr_date,date_only);                   insertAttd.execute();                   cursor.moveToNext();              }          } else {          }            dbHelper.close();      }       public void scheduleAlarm() {         AlarmManager am=(AlarmManager)getSystemService(ALARM_SERVICE);         Intent alarmintent1 = new Intent(this, MyExtBroadcastReceiver.class);         PendingIntent sender1=PendingIntent.getBroadcast(this, 100, alarmintent1, PendingIntent.FLAG_UPDATE_CURRENT | Intent.FILL_IN_DATA);          Calendar cal=Calendar.getInstance();         cal.add(Calendar.MINUTE,2);         am.setRepeating(AlarmManager.RTC_WAKEUP, cal.getTimeInMillis(), 1000*2*60, sender1);         System.out.println("alarm set...........");     }      public static class MyExtBroadcastReceiver extends BroadcastReceiver {          public MyExtBroadcastReceiver() {               super();         }           @Override         public void onReceive(final Context context, final Intent intent) {                      new AlarmServices().CallMethodAfter();         }     }      @Override     public IBinder onBind(Intent intent) {         // TODO: Return the communication channel to the service.         throw new UnsupportedOperationException("Not yet implemented");     } } </code></pre>