<p><strong>Problem:</strong></p>  <p>In Opencl 1.2, there is no built-in function like </p>  <pre><code>long sum_int4_elements_into_long(int4 v); </code></pre>  <p><strong>What I've tried:</strong></p>  <p>So I'm using the code below (prefetched inner part of an unrolled loop)</p>  <pre><code>// acc is long int4 tmp=arr[i+7]; acc+=tmp.x+tmp.y+tmp.z+tmp.w; tmp=arr[i+6]; acc+=tmp.x+tmp.y+tmp.z+tmp.w; tmp=arr[i+5]; acc+=tmp.x+tmp.y+tmp.z+tmp.w; tmp=arr[i+4];" acc+=tmp.x+tmp.y+tmp.z+tmp.w; tmp=arr[i+3]; acc+=tmp.x+tmp.y+tmp.z+tmp.w; tmp=arr[i+2]; acc+=tmp.x+tmp.y+tmp.z+tmp.w; tmp=arr[i+1]; acc+=tmp.x+tmp.y+tmp.z+tmp.w; tmp=arr[i]; acc+=tmp.x+tmp.y+tmp.z+tmp.w;        </code></pre>  <p>to sum(reduction) all elements of an integer array (int4 arr) into a single long variable with a speed-up of only +%20 to +%30 compared to serial code. If it could enable SSE or AVX, it would be much faster.</p>  <p><strong>also tried:</strong></p>  <p>using pure integer accumulator speeds the summing operation up by 3x but integer overflows so I can only use a long variable. Then I tried using a long4 and long2 variable as</p>  <pre><code>   // acc is a long4, arr is an int4 array    acc+=convert_long4(arr[...])     //  acc is a long2, arr is an int2 array    acc+=convert_long2(arr[...])    </code></pre>  <p>but it failed and locked the computer(checked indexing and limits, there is no problem) so there must be a problem with longn to intn under the hardware instruction mappings with AMD CPU. </p>  <p><strong>Clarification:</strong></p>  <p>There must be some equivalent SIMD(SSE or AVX) assembly instruction of AMD and INTEL for</p>  <pre><code>        32 bit integers in a 128-bit SSE register          |       |       |      |           acc+=tmp.x + tmp.y + tmp.z + tmp.w    ^        |    64-bit register  </code></pre>  <p>but somehow opencl doesnt have mapping to this or I did not pack C99 instructions well enough so cl-compiler couldnt use SSE/AVX instructions.</p>  <p>The closest built-in float version is </p>  <pre><code> acc=dot(v,(float4)(1,1,1,1)); </code></pre>  <p>but I need an integer version of this, because fp needs Kahan's Summation Correction which needs extra time.</p>  <p><strong>Edit:</strong></p>  <p>Im not sure if int+int+int+int will have a proper long result or just have an overflowed int into a long.</p>  <p>Opencl version: 1.2 running on CPU (Java ----> Jocl)</p>  <p>CPU: AMD fx-8150</p>  <p>OS:64 bit windows 10</p>  <p>Driver: latest one by amd.</p>  <p>Date: 23.09.2015</p>  <p><strong>For comparison:</strong></p>  <p>16M 32-bit integers, FX8150 @ 3300MHz (using 6 cores out of 8)</p>  <p>Serial code on java 1.8_25 takes 16.5 ms on average.</p>  <p>IntStream of Java-1.8 takes 13.5 ms on average (X.reduce(0, Integer::sum))</p>  <p>Parallel code in this question takes 12.5 ms on average  (<em>using single workgroup</em>)</p>  <p>Parallel code in this question takes 5.8 ms on average  (<em>using four workgroups</em>)</p>  <p>Parallel but overflowing non-long version takes 5ms. (hitting memory bandwidth)</p>  <p><strong>mfa's answer:</strong></p>  <pre><code> acc=dot(v,(double4)(1,1,1,1)); </code></pre>  <p>takes 13.5 ms on average but float version takes 12.2 ms on average.</p>  <p>Im not sure if a float can keep its precision always to add 1.0 (or even 0.0) to a very big fp number.</p>