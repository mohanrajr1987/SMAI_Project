<p>I am to make a mobile painting game in Unity and I've encountered a serious problem: the Input class in Unity is frame-dependent. Thus I can't get the position of touch frequent enough to make my application draw smoothly; as a result I get something like just points on the background, not connected between each other.</p>  <p>I tried to just connect the points that are detected in Unity, and than my result was just the same points connected with lines, of course. I was trying this in Unity Editor with about 180-200 fps, and on mobile phone with 30-50 fps it looks even worse. I expect that I have to get the touch positions somehow in android studio or Xcode, and only then use them in my C# code in Unity editor.</p>  <p>Am I thinking right to use extern from Unity tools, or there is another easier way to do it directly in Unity? If there is none and I am right, can somebody give me some links to guides/tutorials how to do it and integrate it with Unity? I have never worked outside of Unity and have no experience in integration some external tools with it.</p>  <p>Note: I've tried FixedUpdate without any luck - it doesn't matter how often I try to get the position variables, it is about how often they are updated; I also tried Event.current.mousePosition(in unity editor) in OnGUI method, but it also gave me no difference.</p>  <p>Upd: As I have already said, I need to get positions more frequently than the Input class gives me. It updates not fast enough! Here's what I get without connecting the points. The image shows the mousePosition detection frequency in 180-200 fps. On phones it is even slower! <a href="http://i.stack.imgur.com/ogX2s.jpg" rel="nofollow"><img src="http://i.stack.imgur.com/ogX2s.jpg" alt="enter image description here"></a></p>  <p>Upd: Here is my simplified code.</p>  <pre><code>void Draw() //this method is invoked every frame      {          //some calculations of x and y based on Input variables          currentMousePosition = new Vector2( x, y); //current mouse position on sprite          if(currentMousePosition != previousMousePosition)              {                  while(currentMousePosition != previousMousePosition)                  {                  mySprite.texture.SetPixels((int)previousMousePosition.x, (int)previousMousePosition.y, 3,3, myColorArray);                                  if (currentFrameMousePos.x &gt; previousFrameMousePos.x)                                      previousFrameMousePos.x++;                                  if (currentFrameMousePos.x &lt; previousFrameMousePos.x)                                      previousFrameMousePos.x--;                                  if (currentFrameMousePos.y &gt; previousFrameMousePos.y)                                      previousFrameMousePos.y++;                                  if (currentFrameMousePos.y &lt; previousFrameMousePos.y)                                      previousFrameMousePos.y--;                    }              } else mySprite.texture.SetPixels((int)currentMousePosition.x, (int)currentMousePosition.y, 3,3, myColorArray);              previousMousePosition = currentMousePosition;      }      //mySprite.texture.Apply() is invoked independently in another place to improve performance </code></pre>