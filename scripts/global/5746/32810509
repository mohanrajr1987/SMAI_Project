<p>My code keeps crashing and I believe it's because as i loop backwards in the insert function for Vector class, I decrement the iterator past the original pointer variable. Here's the insert function: </p>  <pre><code>iterator insert(iterator &amp; iter, const Object&amp; obj){         if (theSize  &gt;= theCapacity){             resize(theSize+1);             int *p = iter;             for (iter; iter != this-&gt;end(); iter++){                 //cout &lt;&lt; "test1" &lt;&lt; endl;             }             for (iter; iter != p; iter--){                 *(iter-1) = *(iter-2);                 cout &lt;&lt; "test1" &lt;&lt; endl;                 //cout &lt;&lt; *(iter - 2) &lt;&lt; endl;                 //cout &lt;&lt; *(iter - 1) &lt;&lt; endl;             }         }         else{             int *p = iter;             for (iter; iter != this-&gt;end(); iter++){                 cout &lt;&lt; "test" &lt;&lt; endl;             }             for (iter; iter != p; iter--){                 *(iter-1) = (*iter-2);             }          }         *iter = obj;         cout &lt;&lt; theSize &lt;&lt; endl &lt;&lt; theCapacity &lt;&lt; endl;         //theSize++;         return this-&gt;begin();     } </code></pre>  <p>The goal of the insert function is to insert the object to the iterator position and in my code, i make sure that the Vector array is long enough and then I move every object in the array to the next indexed-space; and then I insert the object to the position designated by the iterator.</p>  <p>Also the entire Vector class is this:</p>  <pre><code>#ifndef VECTOR_H #define VECTOR_H  #include &lt;algorithm&gt; #include &lt;iostream&gt;  template &lt;typename Object&gt; class Vector { public:     explicit Vector(int initSize = 0)         : theSize{ initSize }, theCapacity{ initSize + SPARE_CAPACITY }     {         objects = new Object[theCapacity];     }      Vector(const Vector &amp; rhs)         : theSize{ rhs.theSize }, theCapacity{ rhs.theCapacity }, objects{ nullptr }     {         objects = new Object[theCapacity];         for (int k = 0; k &lt; theSize; ++k)             objects[k] = rhs.objects[k];     }      Vector &amp; operator= (const Vector &amp; rhs)     {         Vector copy = rhs;         std::swap(*this, copy);         return *this;     }      ~Vector()     {         delete[] objects;     }      Vector(Vector &amp;&amp; rhs)         : theSize{ rhs.theSize }, theCapacity{ rhs.theCapacity }, objects{ rhs.objects }     {         rhs.objects = nullptr;         rhs.theSize = 0;         rhs.theCapacity = 0;     }      Vector &amp; operator= (Vector &amp;&amp; rhs)     {         std::swap(theSize, rhs.theSize);         std::swap(theCapacity, rhs.theCapacity);         std::swap(objects, rhs.objects);          return *this;     }      bool empty() const     {         return size() == 0;     }     int size() const     {         return theSize;     }     int capacity() const     {         return theCapacity;     }      Object &amp; operator[](int index)     {         return objects[index];     }      const Object &amp; operator[](int index) const     {         return objects[index];     }      void resize(int newSize)     {         if (newSize &gt; theCapacity)             reserve(newSize * 2);         theSize = newSize;     }      void reserve(int newCapacity)     {         if (newCapacity &lt; theSize)             return;          Object *newArray = new Object[newCapacity];         for (int k = 0; k &lt; theSize; ++k)             newArray[k] = std::move(objects[k]);          theCapacity = newCapacity;         std::swap(objects, newArray);         delete[] newArray;     }      // Stacky stuff     void push_back(const Object &amp; x)     {         if (theSize == theCapacity)             reserve(2 * theCapacity + 1);         objects[theSize++] = x;     }     // Stacky stuff     void push_back(Object &amp;&amp; x)     {         if (theSize == theCapacity)             reserve(2 * theCapacity + 1);         objects[theSize++] = std::move(x);     }      void pop_back()     {         --theSize;     }      const Object &amp; back() const     {         return objects[theSize - 1];     }      // Iterator stuff: not bounds checked     typedef Object * iterator;     typedef const Object * const_iterator;      iterator begin()     {         return &amp;objects[0];     }     const_iterator begin() const     {         return &amp;objects[0];     }     iterator end()     {         return &amp;objects[size()];     }     const_iterator end() const     {         return &amp;objects[size()];     }      static const int SPARE_CAPACITY = 2;      iterator insert(iterator &amp; iter, const Object&amp; obj){         if (theSize  &gt;= theCapacity){             resize(theSize+1);             int *p = iter;             for (iter; iter != this-&gt;end(); iter++){                 //cout &lt;&lt; "test1" &lt;&lt; endl;             }             for (iter; iter != p; iter--){                 *(iter-1) = *(iter-2);                 cout &lt;&lt; "test1" &lt;&lt; endl;                 //cout &lt;&lt; *(iter - 2) &lt;&lt; endl;                 //cout &lt;&lt; *(iter - 1) &lt;&lt; endl;             }         }         else{             int *p = iter;             for (iter; iter != this-&gt;end(); iter++){                 cout &lt;&lt; "test" &lt;&lt; endl;             }             for (iter; iter != p; iter--){                 *(iter-1) = (*iter-2);             }          }         *iter = obj;         cout &lt;&lt; theSize &lt;&lt; endl &lt;&lt; theCapacity &lt;&lt; endl;         //theSize++;         return this-&gt;begin();     }     iterator erase(iterator iter){      }     iterator find(iterator x, iterator y, const Object obj){      } private:     int theSize;     int theCapacity;     Object * objects; };  #endif </code></pre>  <p>And my test file is this:</p>  <pre><code>#include "Vector.h" #include &lt;iostream&gt; using namespace std;  int main(){     Vector&lt;int&gt; input;     Vector&lt;int&gt;::iterator iter;     int data = 0;     cout &lt;&lt; "Enter five int digits: " &lt;&lt; endl;     for (int i = 0; i &lt; 5; i++){         cin &gt;&gt; data;         input.push_back(data);     }     data = 7654;     iter = input.begin();     iter++;     input.insert(iter, data);      for (iter = input.begin(); iter != input.end(); iter++){         cout &lt;&lt; *iter &lt;&lt; endl;     }      system("PAUSE");  } </code></pre>