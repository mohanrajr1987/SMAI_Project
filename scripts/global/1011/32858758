<p>I wanted to use Base64.java to encode and decode files. <code>Encode.wrap(InputStream)</code> and <code>decode.wrap(InputStream)</code> worked but runned slowly. So I used following code. </p>  <pre><code>public static void decodeFile(String inputFileName,         String outputFileName)         throws FileNotFoundException, IOException {      Base64.Decoder decoder = Base64.getDecoder();     InputStream in = new FileInputStream(inputFileName);     OutputStream out = new FileOutputStream(outputFileName);      byte[] inBuff = new byte[BUFF_SIZE];  //final int BUFF_SIZE = 1024;     byte[] outBuff = null;     while (in.read(inBuff) &gt; 0) {         outBuff = decoder.decode(inBuff);         out.write(outBuff);     }     out.flush();     out.close();     in.close(); } </code></pre>  <p>However, it always throws </p>  <pre><code>Exception in thread "AWT-EventQueue-0" java.lang.IllegalArgumentException: Input byte array has wrong 4-byte ending unit     at java.util.Base64$Decoder.decode0(Base64.java:704)     at java.util.Base64$Decoder.decode(Base64.java:526)     at Base64Coder.JavaBase64FileCoder.decodeFile(JavaBase64FileCoder.java:69)     ... </code></pre>  <p>After I changed <code>final int BUFF_SIZE = 1024;</code> into <code>final int BUFF_SIZE = 3*1024;</code>, the code worked. Since "BUFF_SIZE" is also used to encode file, I believe there were something wrong with the file encoded (1024 % 3 = 1, which means paddings are added in the middle of the file). </p>  <p>Also, as @Jon Skeet and @Tagir Valeev mentioned, I should not ignore the return value from <code>InputStream.read()</code>. So, I modified the code as below.</p>  <p>(However, I have to mention that the code does run much faster than using <code>wrap()</code>. I noticed the speed difference because I had coded and intensively used Base64.encodeFile()/decodeFile() long before jdk8 was released. Now, my buffed jdk8 code runs as fast as my original code. So, I do not know what is going on with <code>wrap()</code>... )</p>  <pre><code>public static void decodeFile(String inputFileName,         String outputFileName)         throws FileNotFoundException, IOException {      Base64.Decoder decoder = Base64.getDecoder();     InputStream in = new FileInputStream(inputFileName);     OutputStream out = new FileOutputStream(outputFileName);      byte[] inBuff = new byte[BUFF_SIZE];     byte[] outBuff = null;     int bytesRead = 0;     while (true)     {         bytesRead = in.read(inBuff);         if (bytesRead == BUFF_SIZE)         {             outBuff = decoder.decode(inBuff);         }         else if (bytesRead &gt; 0)         {             byte[] tempBuff = new byte[bytesRead];             System.arraycopy(inBuff, 0, tempBuff, 0, bytesRead);             outBuff = decoder.decode(tempBuff);         }         else         {             out.flush();             out.close();             in.close();             return;         }         out.write(outBuff);     } } </code></pre>  <p>Special thanks to @Jon Skeet and @Tagir Valeev.</p>