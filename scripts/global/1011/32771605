<p>I feel like the answer is obvious but suppose I have the following in C#</p>  <pre><code>using (MemoryStream ms = new MemoryStream()) {     using (BinaryWriter bw = new BinaryWriter(ms))     {         // Write some floats, bytes, and uints         // Convert.ToBase64String this stuff from ms.ToArray     } } </code></pre>  <p>and the following in Java (ok it's Scala but using Java libraries):</p>  <pre><code>val byteStream = new ByteArrayOutputStream() val outStream = new DataOutputStream(byteStream) // Write some floats, bytes, and longs where the uints were using  // writeFloat, writeByte, and writeLong. .NET has an overloaded  // function that takes whatever.  // Base64.getEncoder.encodeToString byteStream.toByteArray </code></pre>  <p>I get completely different base 64 strings. What are they doing different here? I need the Java output to match the .NET output. I assume its some sort of byte ordering issue but I haven't had any luck using <code>ByteBuffer</code> to correct this.</p>  <p>Java: </p>  <blockquote>   <p>PczMzT3MzM0/gAAAPczMzQAAAAAAAAAAAAAAAD3MzM0/gAAAAQAAAABRn8XzAAAAAAAAAAEAAAAAAAAAAQ==</p> </blockquote>  <p>C# (with unknown = signs as we chop them off for reasons) : </p>  <blockquote>   <p>zczMPc3MzD0AAIA/zczMPQAAAAAAAAAAAAAAAM3MzD0AAIA/AfPFn1EBAAAAAQAAAA</p> </blockquote>  <p>I really feel as though it is byte ordering which is why I tried using <code>ByteBuffer</code> in the Java code, order method, to change the ordering but I did not have success. </p>  <p>For further clarity the Java code is running on x86_64 CentOS Java 7 and the .NET is on x86_64 Windows Server 2008 .NET 4.These values are coming from Protobuf objects so they should be pretty cross platform I would think. Numerically the data is identical and consistent regardless of what I put in at least when I write at least these three data types. The only significant difference is the lack of an unsigned type in Java and perhaps there is a binary representation difference which is where I was initially trying to resolve but I do not seem to be able to figure it out. </p>  <p>As I have said. Using another format is not an option. I need the binary data written from java and then base 64 encoded to result in the same results as .NET. Serialization choices are not an option. This has to be it. I need a resource that will aid in bringing this together whether that means binary manipulation of byte data or not. I need some explanation in the datatypes and as I have searched significantly and not found a resource explaining how to do this or what the real differences are so I can implement a solution I decided to ask here.</p>