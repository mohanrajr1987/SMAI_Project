<p>I have a question about Reactive ui, its bindings, and how it handles ui updates. I always assumed that using ReactiveUi would take care of all ui updates on the ui thread. But I recently found out this isn't always the case.</p>  <p>In short the question is: How can I use reactiveui to two-way-model-bind a viewmodel and a view, and assure that updating the ViewModel doesn't crash when run on a different thread than the ui-thread? Without having to manually subscribe to changes and update explicitely on the uiThread, as that defeats the purpose of reactiveui, as well as making it harder to encapsulate all logic in the PCL.</p>  <p>Below I've provided a very simple (Android) project using Xamaring and Reactiveui, to do the following:</p>  <ul> <li>Button with the text 'Hello World'</li> <li>Clicking on it appends 'a' to the button's text.</li> <li>I let the Activity implement IViewFor, and I use a ViewModel deriving from ReactiveObject, containing the text that I want to change.</li> <li>I bind the Activity's button.Text to the ViewModel.Text, to let reactiveui deal with all changes and ui updates.</li> <li>Finally, I add a function to the button's onclick to append 'a' to the ViewModel.</li> </ul>  <p>The issue I have is the following:</p>  <pre><code>button.Click += delegate     {         this.ViewModel.Text += "a";                         // does not crash         Task.Run(() =&gt; { this.ViewModel.Text += "a"; });    // crash     }; </code></pre>  <p>Directly appending 'a' is not an issue. However, adding 'a' on a different thread results in the well-known Java exception: Exception: Only the original thread that created a view hierarchy can touch its views.</p>  <p>I understand the exception and where it's coming from. In fact, if I were to append the 'a' on a different thread, I already had it working with simply not binding the text. But rather by subscribing to changes, and using the RunOnUiThread-method to make changes to the ui. But this scenario kind of defeats the purpose of using ReactiveUi. I really like the clean coding way of the simple statement 'this.Bind(ViewModel, x => x.Text, x => x.button.Text);', but if this <strong>has</strong> to run on the uiThread, I can't see how to make it work.</p>  <p>And naturally this is the bare mininum to show the problem. The actual problem as to why I bring this up is because I want to use the 'GetAndFetchLatest'-method from akavache. It gets data asynchroniously and caches it, and executes a function (being updating the ViewModel). If the data is already in the cache, it will execute the ViewModel-update with the cached result AND do the computationlogic in a different thread, and then call the same function again once it's done (resulting in the crash, because that's on a different thread, updates the ViewModel, which results in the crash).</p>  <p>Note that even though explicitely using RunOnUiThread works, I really don't want (can't even) to call this within the ViewModel. Because I have a more complex piece of code in which a button simply tells the ViewModel to go fetch data and update itself. If I were required to do this on the uiThread (i.e. after I got data back, I update the ViewModel), then I can't bind iOS to the same ViewModel anymore.</p>  <p>And lastly, here's the entire code to make it crash. I've seen the Task.Run-part sometimes work, but if you add some more tasks and keep updating the ViewModel in them, it's bound to crash eventually on the UI-thread.</p>  <pre><code>public class MainActivity : Activity, IViewFor&lt;MainActivity.RandomViewModel&gt; {     public RandomViewModel ViewModel { get; set; }     private Button button;      protected override void OnCreate(Bundle bundle)     {         base.OnCreate(bundle);          SetContentView(Resource.Layout.Main);          this.button = FindViewById&lt;Button&gt;(Resource.Id.MyButton);          this.ViewModel = new RandomViewModel { Text = "hello world" };         this.Bind(ViewModel, x =&gt; x.Text, x =&gt; x.button.Text);          button.Click += delegate             {                 this.ViewModel.Text += "a";                         // does not crash                 Task.Run(() =&gt; { this.ViewModel.Text += "a"; });    // crash             };     }      public class RandomViewModel : ReactiveObject     {         private string text;          public string Text         {             get             {                 return text;             }             set             {                 this.RaiseAndSetIfChanged(ref text, value);             }         }     }      object IViewFor.ViewModel     {         get         {             return ViewModel;         }         set         {             ViewModel = value as RandomViewModel;         }     } } </code></pre>