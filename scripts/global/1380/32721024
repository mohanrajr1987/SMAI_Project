<p>I have an application which is built on top of another framework. Said framework has a number of value objects, which I need to extend in various ways using the decorator pattern. Lets call the base object Entity and the decorator classes Wrappers. Entities of the same class can have different "types", and a different Wrapper class is required for each of these types to expose functionality specific to that type. This application is not the final layer and does not control what types exist or which classes to use for them (done higher up the chain), so assignment needs to be dynamic.</p>  <p>I have created a factory class that receives an entity and determines the correct wrapper for it. The factory can be assigned a Wrapper class to be used when the entity is of a given type.</p>  <pre><code>&lt;?php  class WrapperFactory {     protected $default_wrapper = null;     protected $typed_wrappers = [];      public function __construct($default){         $this-&gt;setDefaultWrapper($default);     }      public function setDefaultWrapper($class){         if ($this-&gt;validateWrapperClass($class)){             $default_wrapper = $class;         }     }      public function getDefaultWrapper(){         return $this-&gt;$default_wrapper;     }      public function setWrapperForType($class, $type){         if($this-&gt;validateWrapperClass($class)){             $this-&gt;$typed_wrappers[$type] = $class;         }     }      public function hasWrapperForType($type){         return array_key_exists($type, $this-&gt;typed_wrappers);     }      public function getWrapperForType($type){         if($this-&gt;hasWrapperForType($type)){             return $this-&gt;typed_wrappers[$type];         }         else{             return $this-&gt;getDefaultWrapper();         }     }      public function wrap($entity)     {         $class = $this-&gt;getWrapperForType($entity-&gt;type);         return new $class($entity);     }      protected function validateWrapperClass($class){         if(class_exists($class) &amp;&amp; class_implements($class, WrapperInterface::class)){             return true;         }else{             throw new BadMethodCallException("Wrapper must implement ". WrapperInterface::class . ".");         }     } } </code></pre>  <p>I'm not entirely sure how to properly Unit Test this class. Is there a way I can mock a <em>class</em> that implements the interface, rather than an object? how can I test that an class assigned to a type is working properly? Do I need to explicitly declare a dummy class or two in my test files or is there a way to mock them?</p>