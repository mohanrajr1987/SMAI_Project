<p>This is my first question so I'll do my best.</p>  <p>I'm trying to get a simple WPF DataGrid control to be "refreshed" using ObservableCollection and MVVM as the numerous tutorials on the web explain.</p>  <p>In context, these are my model clases:</p>  <p>(PersonViewModel.cs)</p>  <pre><code>public class PersonViewModel : INotifyPropertyChanged {     public event PropertyChangedEventHandler PropertyChanged;      private int _id;     private int _idAddress;     private string _name;     private int _age;     private string _address;      public int Id     {         get { return this._id; }         set         {             if (value != this._id)             {                 this._id = value;                 OnPropertyChanged();             }         }     }     public int IdAddress     {         get { return this._idAddress; }         set         {             if (value != this._idAddress)             {                 this._idAddress = value;                 OnPropertyChanged();             }         }     }     public string Name     {         get { return this._name; }         set         {             if (value != this._name)             {                 this._name = value;                 OnPropertyChanged();             }         }     }     public int Age     {         get { return this._age; }         set         {             if (value != this._age)             {                 this._age = value;                 OnPropertyChanged();             }         }     }     public string Address     {         get { return this._address; }         set         {             if (value != this._address)             {                 this._address = value;                 OnPropertyChanged();             }         }     }      private void OnPropertyChanged([CallerMemberName]String caller = null)     {         var handler = PropertyChanged;         if (handler != null)         {             handler(this, new PropertyChangedEventArgs(caller));         }     } } </code></pre>  <p>(AddressViewModel.cs)</p>  <pre><code>public class AddressViewModel : INotifyPropertyChanged {     public event PropertyChangedEventHandler PropertyChanged;      private int _id;     private string _street;     private int _number;      public int Id     {         get { return this._id; }         set         {             if (value != this._id)             {                 this._id = value;                 OnPropertyChanged();             }         }     }     public string Street     {         get { return this._street; }         set         {             if (value != this._street)             {                 this._street = value;                 OnPropertyChanged();             }         }     }     public int Number     {         get { return this._number; }         set         {             if (value != this._number)             {                 this._number = value;                 OnPropertyChanged();             }         }     }      private void OnPropertyChanged([CallerMemberName]String caller = null)     {         var handler = PropertyChanged;         if (handler != null)         {             handler(this, new PropertyChangedEventArgs(caller));         }     } } </code></pre>  <p>And here's a representation of the database model (cannot upload pic &lt; 10 posts)</p>  <h2>Address</h2>  <p>Id<br> Street<br> Number</p>  <h2>Person</h2>  <p>Id<br> IdAddress<br> Name<br> Age<br> Address ---> this property concatenates Street and Number of Address entity.</p>  <p>So, as you can see, it's a very simple example. Just a proof-of-concept. Problem is, whenever I try to add a new entity to the database (through Entity Framework 6 and LINQ) I must inevitably add that ViewModel entity to the DataGrid's data context.</p>  <p>This is the code working as of today:</p>  <pre><code>public static Person CreatePerson(PersonViewModel personVM) {     var person = new Person     {         IdAddress = personVM.IdAddress,         Name = personVM.Name,         Age = personVM.Age     };      try     {         using (var context = new OCDemoContext())         {             context.Database.Connection.Open();             context.Person.Add(person);             context.SaveChanges();             context.Database.Connection.Close();         }     }     catch     {         throw;     }      return person; } </code></pre>  <p>As you can see, the need here is to show in DataGrid a column that concatenates two properties of Address database entity: Street and Number, and giving that value to Address property of PersonViewModel class to show as a column in the DataGrid.</p>  <p>The code that adds the entity to the DataGrid itemssource collection after the insert to the database:</p>  <pre><code>        // Add to the database         PersonsGateway.CreatePerson(personVM);          // Update view on DataGrid's itemssource collection         ViewModel model = this.xGrid.DataContext as ViewModel;          model.Persons.Insert(0, personVM); </code></pre>  <p>XAML as:</p>  <pre><code>&lt;Window x:Class="OCDemo.MainWindow"     xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"     xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"     Title="MainWindow" Height="350" Width="525" xmlns:local="clr-namespace:OCDemo"&gt; &lt;Window.Resources&gt;     &lt;local:ViewModel x:Key="xViewModel" /&gt; &lt;/Window.Resources&gt; &lt;Grid x:Name="xGrid" DataContext="{StaticResource xViewModel}"&gt;     &lt;DataGrid x:Name="xDataGrid" Grid.Row="0" ItemsSource="{Binding Persons}" AutoGenerateColumns="False"&gt;         &lt;DataGrid.Columns&gt;             &lt;DataGridTextColumn Binding="{Binding Path=Name}" Header="Name"/&gt;             &lt;DataGridTextColumn Binding="{Binding Path=Age}" Header="Age"/&gt;             &lt;DataGridTextColumn Binding="{Binding Path=Address}" Header="Address"/&gt;         &lt;/DataGrid.Columns&gt;     &lt;/DataGrid&gt; &lt;/Grid&gt; </code></pre>  <p></p>  <p>And ViewModel.cs</p>  <pre><code>public class ViewModel {     public ObservableCollection&lt;PersonViewModel&gt; Persons { get; set; }      public ViewModel()     {         this.Persons = PersonsGateway.RetrievePersons();     } } </code></pre>  <p>And T4 .tt file updated as <a href="https://msdn.microsoft.com/es-es/data/jj574514" rel="nofollow">MSDN - Updating code generation for data binding</a> explains.</p>  <p>So, it is possible to depend only on adding the entity to the database and not to always add the entity to the itemssource collection after that on a ObservableCollection scenario?</p>