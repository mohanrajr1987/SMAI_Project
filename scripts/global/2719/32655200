<p>With algorithms such as <code>copy_if</code>, <code>count_if</code>, and many others, I can use either  a function or a functor interchangeably where a predicate is required.</p>  <p>However with <code>std::set</code>, I cannot pass a function in place of the comparison function parameter it takes. I have to pass a functor in this case. Why doesn't it accept a function?</p>  <pre><code>bool myfunction (int lhs, int rhs) {     cout &lt;&lt; "myfunction\n";     return true; }  struct myfunctor {     bool operator() (const int&amp; lhs, const int&amp; rhs) const {         cout &lt;&lt; "myfunctor\n";         return true;     } };  std::set&lt;int,myfunctor&gt; first;   std::set&lt;int,myfunction&gt; second;  // this does not compile. </code></pre>