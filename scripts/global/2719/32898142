<p>That is, providing that <code>container</code> is not empty, can I safely do this:</p>  <pre><code>std::vector&lt;int&gt; container; container.push_back( 0xFACE8D ); auto last = container.end() - 1; </code></pre>  <p>and this:</p>  <p>EDIT: replaced <code>-1</code> with <code>--</code> here: </p>  <pre><code>std::list&lt;int&gt; container; container.insert( 0xFACE8D ); auto last = container.end(); --last; </code></pre>  <p>and again for arbitrary non-empty container?</p>  <p>EDIT: let me clarify the question. </p>  <p>Sometimes perfectly legal code behaves incorrectly. The question is: assuming that the above code compiles, is it safe to do something like that?</p>  <p>It should be safe for ordinary C-style arrays because the corresponding iterators are just pointers. But is it safe for more complicated containers?</p>  <p>Suppose that one implements list with iterators like this one:</p>  <pre><code>class MyListIterator {     MyListIterator *prev, *next;     MyListIterator * operator--() { return prev; }     ... };  class MyList {     MyListIterator *end() { return NULL; }     ... };  </code></pre>  <p>Then an attempt to decrement <code>container::end()</code>, despite being perfectly legal syntactically, would cause a segfault. </p>  <p>I hope, though, that <code>stl</code> containers are much smarter than that. Thus the question on the guarantees on the above <code>stl::list</code> code behavior, if any.</p>