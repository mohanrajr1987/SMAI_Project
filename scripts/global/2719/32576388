<p>I'm trying to write a container class for vector arithmetic. The objects are static in size:</p>  <pre><code>template&lt;typename T, unsigned N&gt; class vec{     T data[N] = {0}; public:     vec(std::initializer_list&lt;T&gt; ini){         std::copy(ini.begin(), ini.end(), data);     } } </code></pre>  <p>This is how far I got.</p>  <p>But than I tested the std::array class for comparison and I noticed that it somehow could make a static assertion if the initializer list was to long or to short.</p>  <pre><code>std::array&lt;float, 2&gt; a = {1, 2, 3, 4} &lt;- instant error message from the visual studio ide </code></pre>  <p>In my class I would have to check the length of the initializer list at run-time.</p>  <p>I assume, that the std::array class somehow manages it to directly initialize the data with the initializer list notation without the std::initializer_list class.</p>  <p>Is it possible to initialize my class in the same way as std::array?</p>