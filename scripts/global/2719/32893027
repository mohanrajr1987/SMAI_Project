<p>I'm trying to construct an object that takes a <code>std::map</code> as a parameter, by passing it the map contents using boost <code>map_list_of</code>. </p>  <p>This gives a compile error, however, when I try to do the same with a regular function that takes a <code>std::map</code>, it compiles fine!</p>  <pre><code>#include &lt;map&gt; #include &lt;boost/assign.hpp&gt;  struct Blah {     Blah(std::map&lt;int, int&gt; data) {} };  void makeBlah(std::map&lt;int, int&gt; data) {}  int main() {     Blah b(boost::assign::map_list_of(1, 2)(3, 4));    // Doesn't compile.      makeBlah(boost::assign::map_list_of(1, 2)(3, 4));  // Compiles fine! } </code></pre>  <p>The compile error I get is:</p>  <pre><code>error: call of overloaded ‘Blah(boost::assign_detail::generic_list&lt;std::pair&lt;int, int&gt; &gt;&amp;)’ is ambiguous note: candidates are: Blah::Blah(std::map&lt;int, int, std::less&lt;int&gt;, std::allocator&lt;std::pair&lt;const int, int&gt; &gt; &gt;) note:                 Blah::Blah(const Blah&amp;) </code></pre>  <p>What is the ambiguity, and how come it doesn't affect the regular functoin makeBlah, which as far as I can see, has the same signature as the Blah constructor?</p>  <p>And is there a better way of achieving this, short of making a <code>makeBlah</code> function that will constructor an object of <code>Blah</code>, as it looks like I will have to do?</p>  <p>(As an aside, I am doing this in a unit test using <code>map_list_of</code> to make the test input data creation more readable)</p>