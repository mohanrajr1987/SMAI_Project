<p>I have a functor which operates on a container of type <code>U</code> of elements of type <code>T</code> like so</p>  <pre><code>template&lt;typename T, template&lt;typename...&gt; class U&gt; class asserter  { public:     asserter(U&lt;T&gt; &amp;c) : container(c) { };     void operator()(T lhs)      {         CU_ASSERT(container.find(lhs) != container.end());     }; private:     U&lt;T&gt;    &amp;container; }; </code></pre>  <p>which I might use as </p>  <pre><code>std::set&lt;std::string&gt; a, c; ... asserter&lt;std::string, std::set&gt; ass(c); for_each(a.begin(), a.end(), ass); </code></pre>  <p>Where we are ignoring <code>std::includes()</code> for the moment. </p>  <p>This works great if the container is one where <code>U::find()</code> is defined. If it's not I'd like to fall back to <code>std::find()</code>. On the other hand I'd rather use <code>U::find()</code> over <code>std::find()</code> if it's available. </p>  <p>In C++11 (or 17 if necessary) can I determine if <code>U::find()</code> is available (possibly restricting to the STL) for U and if so use it, otherwise use <code>std::find()</code>? </p>