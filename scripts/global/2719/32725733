<p>I have encountered (and written) code where the natural use of the standard template library in Boolean relational expressions results in (potentially) wasted effort. </p>  <p>For example,</p>  <pre><code>if (std::distance(begin, end) &lt;= 2) { ... } </code></pre>  <p>Or:</p>  <pre><code>if (std::count(begin,end,val) &gt;= 3) { ... } </code></pre>  <p>In both these cases, it is possible to write a custom algorithm to avoid unnecessary iteration/evaluation when the answer is known after a partial evaluation of the range.</p>  <p>Is there a generic approach that can be used to prevent wasted effort in these situations?</p>  <p><strong>EDIT:</strong> Trying to address the "close" votes.</p>  <p>For example, I could implement <code>bool distance_at_least(begin, end, 3)</code> <em>and</em> <code>bool distance_at_most(begin, end, 2)</code> <em>and</em> <code>bool count_at_least(begin, end, val, 5)</code>, etc.</p>  <p>I am asking for a single (generic) approach that can be used for all these types of queries.</p>  <p><strong>EDIT:</strong> Here is a mock-up of a solution for one variant, which tries to convey why I am not keen to write many variants.</p>  <pre><code>#include &lt;vector&gt; #include &lt;list&gt;  namespace DETAIL {      template &lt;class ITER, class CAT&gt;     bool distance_at_least_dispatch(ITER begin, ITER end, typename std::iterator_traits&lt;ITER&gt;::difference_type n, CAT)     {         while (begin != end &amp;&amp; n &gt; 0) {             ++begin;             --n;         }         return n == 0;     }      template &lt;class ITER&gt;     bool distance_at_least_dispatch(ITER begin, ITER end, typename std::iterator_traits&lt;ITER&gt;::difference_type n, std::random_access_iterator_tag)     {         return std::distance(begin, end) &gt;= n;     } }  template &lt;class ITER&gt; bool distance_at_least(ITER begin, ITER end, typename std::iterator_traits&lt;ITER&gt;::difference_type n) {     using CAT = typename std::iterator_traits&lt;ITER&gt;::iterator_category;     return DETAIL::distance_at_least_dispatch(begin, end, n, CAT()); }  int main(int argv, char* argc[]) {     std::vector&lt;int&gt; v;     std::list&lt;int&gt; l;     std::generate_n(std::back_inserter(v), 5, std::rand);     std::generate_n(std::back_inserter(l), 5, std::rand);      std::cout &lt;&lt; distance_at_least(v.begin(), v.end(), 3) &lt;&lt; std::endl;     std::cout &lt;&lt; distance_at_least(v.begin(), v.end(), 5) &lt;&lt; std::endl;     std::cout &lt;&lt; distance_at_least(v.begin(), v.end(), 6) &lt;&lt; std::endl;     std::cout &lt;&lt; distance_at_least(l.begin(), l.end(), 3) &lt;&lt; std::endl;     std::cout &lt;&lt; distance_at_least(l.begin(), l.end(), 5) &lt;&lt; std::endl;     std::cout &lt;&lt; distance_at_least(l.begin(), l.end(), 6) &lt;&lt; std::endl;      return 0; } </code></pre>