<p>I thought I liked the idea of std::array from C++11, but it looks like it has some quarks. I found this out because the following code gives a segmentation fault:</p>  <pre><code>#include&lt;array&gt; #include&lt;iostream&gt;  int main() {         std::array&lt;std::array&lt;int*, 5&gt;, 4&gt; sum;          //Initialize sum array         std::cout &lt;&lt; sum.size() &lt;&lt; " " &lt;&lt; sum[0].size() &lt;&lt; "\n";         for (size_t i = 0; i &lt; sum.size(); i++) {                 for (size_t j = 0; j &lt; sum[0].size(); j++) {                         if (i == 0 || j == 0)                                 *(sum[i][j]) = 0;                         else                                 sum[i][j] = nullptr;                 }         }      return 0; } </code></pre>  <p>This outputs:</p>  <pre><code>4 5 Segmentation fault (core dumped) </code></pre>  <p><code>sum.size()</code> returns 4, as expected, and <code>sum[0].size()</code> returns <code>5</code>, as expected; IE it seems like we have an array with 4 rows and 5 columns. However, I get a segmentation fault when I try to execute this program (as shown above). <a href="http://cpptruths.blogspot.com/2011/10/multi-dimensional-arrays-in-c11.html" rel="nofollow" title="Hello, I&#39;m frustrated!">This link</a> suggests that reversing the order of the way I access my array (as in change <code>sum[i][j]</code> to <code>sum[j][i]</code>) should work, but I also get a seg-fault then too. This made me think I might have been doing something wrong with my pointers (I'm a little rusty with my C++), so I changed sum to be an array of integers, so it read as follows:</p>  <pre><code>#include&lt;array&gt; #include&lt;iostream&gt;  int main() {         std::array&lt;std::array&lt;int, 5&gt;, 4&gt; sum;          //Initialize sum array         std::cout &lt;&lt; sum.size() &lt;&lt; " " &lt;&lt; sum[0].size() &lt;&lt; "\n";         for (size_t i = 0; i &lt; sum.size(); i++) {                 for (size_t j = 0; j &lt; sum[0].size(); j++) {                         if (i == 0 || j == 0)                                 sum[i][j] = 0; //works as sum[j][i] too!!!                         else                                 sum[i][j] = 1;          std::cout &lt;&lt; sum[i][j];                 }      std::cout &lt;&lt; "\n";         }          std::cout &lt;&lt; "here\n";     return 0; } </code></pre>  <p>Which works, and outputs:</p>  <pre><code>4 5 00000 01111 01111 01111 here </code></pre>  <p>However, I'm confused, because if I switch the <code>sum[i][j]</code>'s to <code>sum[j][i]</code>'s, it also works and outputs the same thing! I would expect to get a seg-fault when I try <code>sum[5][0]</code> during the final iteration of the inner loop the first time that it is run! I am now willing to call myself hella confused. What is going on?</p>  <p><strong>Extra info:</strong> I am using g++ 4.8.4 with the -std=c++11 flag set.</p>