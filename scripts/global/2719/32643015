<p>With <code>std::atomic</code>, there seems to be no standards-compliant way to sometimes read/write without atomicity. Boost has interlocked operations, but they are in the <code>details</code> namespace so I don't think I'm supposed to use it. But I don't know all of boost. Is there something in boost or stl that I could use? Or perhaps a proposal which would address this, like maybe adding a <code>std::memory_order_no_synchronization</code>? Or access an abstraction of the interlocked machinery?</p>  <p>It seems like the need for this would appear in many designs. Objects that require thread-safety might be held temporarily in a single-threaded context, making atomic access superfluous. For example, when first constructing an object, it would usually be visible only on the thread creating it, until placed somewhere accessible to multiple threads. So long as your object is only reachable by a single thread, you wouldn't need <code>std::atomic</code>'s safety at all. But then once ready, you'd publish it to other threads, and suddenly you need locking and enforced atomic access.</p>  <p>In this particular application, I'm building large lockless trees. During construction, there is just zero need for interlocked, so the existing design (which calls os-provided interlocked functions) does not use interlocked until it becomes necessary. After it becomes visible to other threads, all threads should be using an interlocked view. I can't port to <code>std::atomic</code> without introducing a bunch of pointless synchronization.</p>  <p>The best I can even think of now is to use <code>std::memory_order_relaxed</code>, but on ARM, this is still not the same as non-atomic access. On x86/amd64 it is though. Another hack is placement new on <code>std::atomic</code>, which writes a new value without atomicity, but that doesn't provide any way to read back the value non-atomically.</p>