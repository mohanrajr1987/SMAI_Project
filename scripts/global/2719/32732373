<p>Here is exerpt from <a href="http://en.cppreference.com/" rel="nofollow">en.cppreference.com</a></p>  <blockquote>   <p>If the std::future obtained from std::async has temporary object   lifetime (not moved or bound to a variable), the destructor of the   std::future will block at the end of the full expression until the   asynchronous operation completes, essentially code such as the   following synchronous:</p> </blockquote>  <pre><code>std::async(std::launch::async, []{ f(); }); // temporary's dtor waits for f() std::async(std::launch::async, []{ g(); }); // does not start until f() completes </code></pre>  <p>But when i tried with VC++:</p>  <pre><code>void fasync(char ch) {     for (int i = 0; i &lt; 10; ++i)     {         this_thread::sleep_for(chrono::milliseconds(100));         cout &lt;&lt; ch &lt;&lt; endl;     } }  int _tmain(int argc, _TCHAR* argv[]) {     async(launch::async, [] { fasync('+'); });     async(launch::async, [] { fasync('*'); });      this_thread::sleep_for(chrono::milliseconds(2000));      return 0; } </code></pre>  <p>i got something like this</p>  <blockquote>   <p>+   *   +*</p>      <p>*+</p>      <p>*+</p>      <p>*   +   *+</p>      <p>+*</p>      <p>+*</p>      <p>+*</p>      <p>+*</p> </blockquote>  <p>Looks like nobody waits for fasync('+')?</p>  <p>First i thought that it is because of sleep and changed fasync to</p>  <pre><code>for (int i = 0; i &lt; 10; ++i) {     cout &lt;&lt; ch &lt;&lt; endl; } cin.get(); </code></pre>  <p>but output interleaving again.</p>  <p><strong>EDIT: According to the link provided by T.C. it is a known bug of VS 2013.</strong></p>