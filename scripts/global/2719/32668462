<p>What I want is to copy an <code>std::vector&lt;int&gt;</code> to another <code>std::vector&lt;myStruct&gt;</code> with assignment operator in which <code>myStruct</code> can be assigned an <code>int</code>. So I wrote this piece of code:</p>  <pre><code>#include &lt;vector&gt; #include &lt;iostream&gt;  using namespace std;  struct myStruct {    myStruct(int&amp; a) : _val(a) { }    myStruct(int&amp;&amp; a) : _val(a) { }     myStruct&amp; operator=(int&amp; a)    {       _val = a;       return *this;    }     int _val; };  int main() {    vector&lt;int&gt; ivec;    ivec.push_back(1);    vector&lt;myStruct&gt; svec = ivec;     return 0; } </code></pre>  <p>And it gives me error as it cannot find a valid conversion between <code>std::vector&lt;myStruct&gt;</code> and <code>std::vector&lt;int&gt;</code> although <code>int</code> can implicitly be converted to <code>myStruct</code>. On the other hand, assign operator cannot be declared outside the class so I deduce writing an operator manually is not an option. So what should I do in this situation?</p>  <p>*** UPDATE: As <code>Blastfurnace</code> and others said this can be solved using this code instead of assignment:</p>  <pre><code>vector&lt;myStruct&gt; svec(ivec.begin(), ivec.end()); </code></pre>  <p>But imagine the situation in which I want to write a library and want to handle this in the library itself so the user can just write <code>std::vector&lt;myStruct&gt; svec = someFunction()</code> in which <code>someFunction</code> returns <code>std::vector&lt;int&gt;</code>. Isn't there any solution for this?</p>