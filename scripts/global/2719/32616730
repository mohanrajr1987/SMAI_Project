<p>I asked a rather poorly formulated (and duly poorly received, whoops) question similar to this yesterday that I've had time to think about and better explain (and I also made some progress in attempting to figure out the issue), so here goes:</p>  <p>I have a class <code>State</code> and a class <code>Node</code>. <code>Node</code> contains a pointer to a <code>State</code> as a member:</p>  <pre><code>class State{ public:     int a;     int b;     State(int a1, int b1){         a = a1;         b = b1;     } };  class Node{ public:     State *s;     Node(State *s1){         s = s1;     }     Node(){         s = NULL;     } };  int main() {     State *s = new State(5, 6);     State *z = new State(5, 6);     Node *n = new Node(s);     set&lt;State*&gt; states;     states.insert(s);     cout&lt;&lt;states.count(z);     return 0; } </code></pre>  <p>You can see in <code>main</code> that I'm creating two identical pointers to <code>State</code>, inserting one into the set, and then using <code>state::count</code> (returns 1 for found, 0 for not found) to look for a <code>State</code> identical to <code>z</code> in <code>states</code>. This should return 1, but it returns 0. I thought at first this was because I needed to overload the comparator between <code>States</code>, but even after writing this function:</p>  <pre><code>bool operator==(const State &amp;s1, const State &amp;s2){     if(s1.a == s2.a &amp;&amp; s1.b == s2.b)         return true;     else         return false; } </code></pre>  <p>I'm returning 0. My next idea was because this was a set of pointers to <code>State</code> rather than the actual objects, and because of that my == overload was being bypassed. So I tried this:</p>  <pre><code>int main() {     State *s = new State(5, 6);     State *z = new State(5, 6);     Node *n = new Node(s);     set&lt;State&gt; states;     states.insert(*s);     cout&lt;&lt;states.count(*z);     return 0; } </code></pre>  <p>There's a running example of this here: <a href="http://ideone.com/iYQyBK" rel="nofollow">http://ideone.com/iYQyBK</a></p>  <p>My idea was to have a set of <code>State</code> rather than pointers to <code>State</code> and then dereference the pointers to pass in, but unfortunately this new code gives me all sorts of ugly compilation errors which are very obscure and seem to have something to do with a failure during comparison, but I can't really tell what they mean. What's my best move here to get <code>set::count</code> to work properly (or to find some other way to check if a <code>State</code> is in my <code>set</code>)?</p>