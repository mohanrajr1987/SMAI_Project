<p>I'm trying to create a single AMD library (module) file which is build out of many small files (TypeScript files compiled to JavaScript-AMD modules).</p>  <p>The problem is:</p>  <ol> <li>I have cyclic dependencies between classes. (Parent needs to know child and child needs to know parent)</li> <li>I want to get rid of all the define() and require() calls, except for the main define for <em>"myLibrary"</em></li> </ol>  <p>The main reasons to create a single file:</p>  <ol> <li>Load times (requirejs should not be used to reference all the small files)</li> <li>Cyclic dependencies that can't(?) be resovled by AMD modules</li> </ol>  <p>My main questions is: </p>  <ul> <li><em>Is there a tool to do this?</em> r.js (grunt-contrib-requirejs) failed me by leaving all the interior calls to define() inside.</li> </ul>  <p>My current project layout is similar to the following example:</p>  <pre><code>root |-- myLibrary |   |-- packageA |   |   |-- ClassA1.ts |   |   +-- ClassA2.ts |   |-- packageB |   |   |-- ClassB1.ts |   |   +-- ClassB2.ts |   |-- packageA.ts |   +-- packageB.ts +-- myLibrary.ts </code></pre>  <p>The code of <em>myLibrary.ts</em> is simply:</p>  <pre class="lang-js prettyprint-override"><code>export import packageA = require("./packageA"); export import packageB = require("./packageB"); </code></pre>  <p>Which simply compiles to an AMD module like this:</p>  <pre class="lang-js prettyprint-override"><code>define(["require", "exports", "./myLibrary/packageA", "./myLibrary/packageB"], function (require, exports, packageA, packageB) {     exports.packageA = packageA;     exports.packageB = packageB; }); </code></pre>  <p>The package files are structured in the same manner. For example packageA.ts looks like this:</p>  <pre class="lang-js prettyprint-override"><code>// Typescript source: export * from "./packageA/ClassA1"; export * from "./packageA/ClassA2";  // Compiled as Javascript: define(["require", "exports", "./packageA/ClassA1", "./packageA/ClassA2"], function (require, exports, ClassA1_1, ClassA2_1) {     function __export(m) {         for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];     }     __export(ClassA1_1);     __export(ClassA1_2); }); </code></pre>  <p>What is currently get:</p>  <pre class="lang-js prettyprint-override"><code>define("myLibrary/packageA/ClassA1",["require", "exports"], function(require, exports) {     var MyClassA1 = (function() {         // The content of the class ...     })();     exports.MyClassA1 = MyClassA1; }); define("myLibrary/packageA/ClassA2", ...  // The other stuff ...      define(["require", "exports", "./myLibrary/packageA", "./myLibrary/packageB"], function (require, exports, packageA, packageB) {     exports.packageA = packageA;     exports.packageB = packageB; }); </code></pre>  <p>What I desire:</p>  <pre class="lang-js prettyprint-override"><code>define(["require", "exports"], function(require, exports) {     //... The entire code of packageA without define or require.     var packageA = ...;     //...     export.packageA = packageA;     export.packageB = packageB; }); </code></pre>