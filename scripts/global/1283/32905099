<p>when i try to run client program after first scanf statement program exit automatically.please help.. error:wsarecv: An existing connection was forcibly closed by the remote host. following is part of code</p>  <p><strong>client.go</strong></p>  <pre><code>package main  import (     "fmt"     "log"     "net"     //"strconv"     "net/rpc/jsonrpc" )  type Request struct {     NameandPercentage string     Budget            float64 } type Stockprice struct {     stockprice  []float64     stockamount []float64     noofstocks  []float64 } type Response struct {     TradeId  int     Stocks   Stockprice     Unvested float64 }  func main() {      client, err := net.Dial("tcp", "127.0.0.1:1234")     if err != nil {         log.Fatal("dialing:", err)     }     // Synchronous call     var ss string     var b float64     fmt.Println("please enter info as following format :      StockSymbol:Percentage")     fmt.Scanf("%s", &amp;ss)     fmt.Scanf("%f", &amp;b)     fmt.Println("enter budget amount:")      request := Request{         NameandPercentage: ss,         Budget:            b,     }     var reply Response     c := jsonrpc.NewClient(client)     err = c.Call("Responses.BuyStock", request, &amp;reply)     if err != nil {         log.Fatal("arith error:", err)     } else {         fmt.Println(reply)     } } </code></pre>  <p><strong>server.go</strong></p>  <pre><code>package main  import (     "encoding/json"     "fmt"     "io/ioutil"     "log"     "math"     "net"     "net/http"     "net/rpc"     "net/rpc/jsonrpc"     "strconv"     "strings"     "time" )  type Request struct {     NameandPercentage string     Budget            float64 } type Stockprice struct {     stockprice  []float64     stockamount []float64     noofstocks  []float64 } type Responses struct{} type Response struct {     TradeId  int     Stocks   Stockprice     Unvested float64 } type Stock struct {     List struct {         Resources []struct {             Resource struct {                 Fields struct {                     Name    string `json:"name"`                     Price   string `json:"price"`                     Symbol  string `json:"symbol"`                     Ts      string `json:"ts"`                     Type    string `json:"type"`                     UTCTime string `json:"utctime"`                     Volume  string `json:"volume"`                 } `json:"fields"`             } `json:"resource"`         } `json:"resources"`     } `json:"list"` }  const (     timeout = time.Duration(time.Second * 100) )  func (t *Responses) BuyStock(req *Request, reply *Response) error {      client := http.Client{Timeout: timeout}     w := strings.FieldsFunc(req.NameandPercentage, func(r rune) bool {         switch r {         case ',', ':', '%':             return true         }         return false     })     names := []string{}     for i := 0; i &lt; len(w); i = i + 2 {         names = append(names, w[i])     }     s := names     str := strings.Join(s, ",")     url := fmt.Sprintf("http://finance.yahoo.com/webservice/v1/symbols/%s/quote?format=json", str)     fmt.Printf(url)     res, err := client.Get(url)     if err != nil {         fmt.Errorf("Stocks cannot access yahoo finance API: %v", err)     }     defer res.Body.Close()     content, err := ioutil.ReadAll(res.Body)     if err != nil {         fmt.Errorf("Stocks cannot read json body: %v", err)     }     var stock Stock     err = json.Unmarshal(content, &amp;stock)     if err != nil {         fmt.Errorf("Stocks cannot parse json data: %v", err)     }     var sp []float64     var sa []float64     var nos []float64     for i := 0; i &lt; len(stock.List.Resources); i++ {          sp[i], err = strconv.ParseFloat(stock.List.Resources[i].Resource.Fields.Price, 64)         if err != nil {             fmt.Println("error:%v", err)         }         nos[i] = math.Floor(req.Budget / sp[i])         sa[i] = sp[i] * nos[i]     }     //Stock2price1 := stock.List.Resources[1].Resource.Fields.Price     var total float64 = 0     for _, value := range sa {         total += value     }     rem := (req.Budget) - total     id := 1     result := Response{         TradeId: id,         Stocks: Stockprice{             stockprice:  sp,             stockamount: sa,             noofstocks:  nos,         },         Unvested: rem,     }     *reply = result     return nil }  func main() {     st := new(Responses)     server := rpc.NewServer()     server.Register(st)     server.HandleHTTP(rpc.DefaultRPCPath, rpc.DefaultDebugPath)     listener, e := net.Listen("tcp", ":1234")     if e != nil {         log.Fatal("listen error:", e)     }     for {         if conn, err := listener.Accept(); err != nil {             log.Fatal("accept error: " + err.Error())         } else {             log.Printf("new connection established\n")             go server.ServeCodec(jsonrpc.NewServerCodec(conn))          }     } } </code></pre>