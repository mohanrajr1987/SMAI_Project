<p>I'm trying to adapt a client/server messaging application to use SSL in Java. I have no trouble doing this with the next pieces of code:</p>  <p>Client:</p>  <pre><code>SSLSocketFactory sslsocketfactory = (SSLSocketFactory)SSLSocketFactory.getDefault(); logger.trace("SSL Socket factory created"); javax.net.ssl.SSLSocket sslsocket = (javax.net.ssl.SSLSocket)sslsocketfactory.createSocket(url, port); logger.trace("SSL Socket created"); outputStream = sslsocket.getOutputStream(); OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream); BufferedWriter bufferedwriter = new BufferedWriter(outputStreamWriter); logger.trace("Input and output created");  inputStream=sslsocket.getInputStream(); InputStreamReader inputStreamReader=new InputStreamReader(inputStream); BufferedReader bufferedReader=new BufferedReader(inputStreamReader); logger.trace("Socket input created");  int readValue=0; bufferedwriter.write(frame + '\n'); bufferedwriter.flush(); logger.trace("Message sent");  while((readValue=bufferedReader.read())!=-1){     response+=(char)readValue;     if(!bufferedReader.ready()){         break;     } }                logger.trace(response); </code></pre>  <p>Server:</p>  <pre><code>SSLServerSocketFactory sslserversocketfactory = (SSLServerSocketFactory)SSLServerSocketFactory.getDefault(); logger.trace("Server socket factory created"); SSLServerSocket sslserversocket = (SSLServerSocket)sslserversocketfactory.createServerSocket(port); logger.info("Waiting to accept a new client socket");  System.setProperty(Context.SECURITY_PROTOCOL, "ssl"); clientSocket = (SSLSocket) serverSocket.accept(); logger.info("Socket accepted successfully");  InputStream inputstream = clientSocket.getInputStream(); InputStreamReader inputstreamreader = new InputStreamReader(inputstream); BufferedReader bufferedreader = new BufferedReader(inputstreamreader);  OutputStream outputstream=clientSocket.getOutputStream(); OutputStreamWriter outputstreamwriter=new OutputStreamWriter(outputstream); BufferedWriter bufferedwriter=new BufferedWriter(outputstreamwriter);  String string = null; logger.trace("Socket going to read"); String response="some response"; while ((string = bufferedreader.readLine()) != null) {     logger.trace(string);         System.out.println(string);         System.out.flush();     logger.trace("Writing response");     bufferedwriter.write(string.toCharArray());     bufferedwriter.flush(); } logger.trace("Message sent"); </code></pre>  <p>But my server structure is more complex than this, and it doesn't use buffered readers/writers, but data output/input. I tried it at first without modifying the client, but it didn't worked. I modified the client to use data output/input, but it continues to not send the message.</p>  <p>My current client code is this:</p>  <pre><code>SSLSocketFactory sslsocketfactory = (SSLSocketFactory)SSLSocketFactory.getDefault(); logger.trace("SSL Socket factory created"); javax.net.ssl.SSLSocket sslsocket = (javax.net.ssl.SSLSocket)sslsocketfactory.createSocket(url, port); logger.trace("SSL Socket created");  outputStream = sslsocket.getOutputStream(); inputStream=sslsocket.getInputStream();  DataOutputStream dataOutputStream=new DataOutputStream(outputStream); DataInputStream dataInputStream=new DataInputStream(inputStream); logger.trace("Input and output created");  dataOutputStream.writeBytes(frame); dataOutputStream.flush(); logger.trace("Frame {} sent",frame);  int data=dataInputStream.available();  if(data&gt;0){     byte[] messageRead = new byte[data];     dataInputStream.readFully(messageRead);     response=byteArrayToHexadecimal(messageRead); } logger.trace("Response frame received"); </code></pre>  <p>My server read and write:</p>  <pre><code>//READER int data = input.available(); if(data&gt;0){     byte[] messageRead = new byte[data];     input.readFully(messageRead);      responsesByte.add(messageRead);      String message=byteArrayToHexadecimal(messageRead);     connection.responses.add(message);                           logger.trace("Arrived through connection with id {}: {}",connection.id,message);     logger.trace("Arrived through connection with id {}: {}",connection.id,messageRead);     connection.messageReceivedBeforeTimeout=true; }  //WRITER next = random.nextInt(connection.responses.size()); byte[] byteFrame=connection.responsesByte.get(next);  String stringFrame=byteArrayToHexadecimal(byteFrame); stringFrame=stringFrame.substring(4);  //THE READER STORES THE MESSAGES IN AN ARRAY AND THE WRITER PROCESS THEM IN A RANDOM ORDER connection.responses.remove(next); connection.responsesByte.remove(next); try{     IsoMessage isoResponse=writerFactory.parseMessage(stringFrame.getBytes(),10);     isoResponse=addResponseInfo(isoResponse);     String isoResponseWithLength=addLengthToIsoMessage(isoResponse);     logger.trace("Response: {}",isoResponseWithLength);     byteFrame=hexadecimalToByteArray(isoResponseWithLength);     logger.trace("Data leaving through connection {}: {}",connection.id,isoResponseWithLength);     logger.trace("Data leaving through connection {}: {}",connection.id,byteFrame); }catch(Throwable throwable){     logger.warn("Error while adding new values to the response message. Returning original message",throwable); }                        output.write(byteFrame); output.flush(); </code></pre>  <p>I have another message that doesn't uses SSL and works perfectly fine with this server. That message uses data input/output too, so I'm not sure that's actually the problem here. My only suspicion is with the handshake, but it worked fine in the first version. Any ideas or points to delve in?</p>  <p><strong>EDIT:</strong> After some debugging, I've found that the application kind of stucks during the handshake. Still don't know why, though.</p>  <p><strong>EDIT 2:</strong> Tried starting the handshake manually from both sides. Doing it at the server side made the connection react, although the message didn't really got sent, nor the response happened.</p>