<p>So there's a piece of functionality with which I've been struggling for a while now. I'm using .where() method in order to retrieve an array of objects from the Collection and then I reset this Collection with this array.</p>  <pre><code>    # Fetch the collection     collection = App.request(collection:entites)     console.log collection     &gt;collection {length: 25, models: Array[25] ... } </code></pre>  <p>When the event fires it passes options for .where() method and starts reset process:</p>  <pre><code>    # Get new models     new_models = collection.where(options)      # Reset collection with the new models     collection.on 'reset', (model, options) -&gt;         console.log options.previousModels         return      collection.reset(new_models)     console.log collection     &gt;collection {length: 5, models: Array[5] ... } </code></pre>  <p>In the View responsible of rendering this collection I listen to the 'reset' event and render the View accordingly.</p>  <pre><code>    initialize: -&gt;         @listenTo(@collection, 'reset', @render) </code></pre>  <p>It works just as expected: event fires, collections undergoes reset and the View re-renders reseted collection. But when the event fires second time the collection doesn't sync with the server and <code>new_models = collection.where(options)</code> receives a collection that was already reseted in  a previous event run and returns an empty array.</p>  <p>What are my options here? Each event run I need an initial collection of all models to work with. Should I just request new instance of the collection on the each run or can I make it in a more cleaner manner, i.e. save original state somewhere and pass it for the event run instead of fetching new collection from the server? Please advise.</p>