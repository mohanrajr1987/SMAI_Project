<p>The following code runs without problems:</p>  <pre><code>prepare_query(QueryFile, Q_Name, Statement) :-   load_structure(QueryFile, QueryXML, [dialect(xml), space(remove)]),   getDNS( QueryXML, Q_Name, DNS),   getSelect(QueryXML, Q_Name, Select),   getParameter(QueryXML, Q_Name, Parameters),   =&gt; getResultNames(QueryXML, Q_Name, ResultNames),   odbc_prepare(DNS, Select, Parameters, Statement,      [ findall((Apl_id_n, Apl_id_b), row(Apl_id_n, Apl_id_b)) ]). </code></pre>  <p>The predicate <code>getResultNames</code> returns the <strong>atom</strong> <code>Apl_id_n, Apl_id_b</code> so I understand why the following code </p>  <pre><code>FindAllOption =.. [findall,(ResultNames),row(ResultNames)], writeln(FindAllOption) </code></pre>  <p>returns:</p>  <pre><code>findall(Apl_id_n, Apl_id_b,row(Apl_id_n, Apl_id_b)) </code></pre>  <p>Is it possible to split up <code>ResultNames</code> in the separated terms so <code>FindAllOption</code> is created as:</p>  <pre><code>findall((Apl_id_n, Apl_id_b),row(Apl_id_n, Apl_id_b)) </code></pre>  <p>Is there another way to make the <code>findall-option</code> more flexible?</p>  <p>Ben</p>