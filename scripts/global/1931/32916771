<p>How to setup view engine in <code>ASP.NET MVC 6</code> to work with test host created by <code>TestServer</code>. I've tried to implement the <a href="https://github.com/aspnet/Mvc/blob/538cd9c19121f8d3171cbfddd5d842cbb756df3e/test/Microsoft.AspNet.Mvc.FunctionalTests/MvcTestFixture.cs#L104-L126" rel="nofollow">trick</a> from <code>MVC 6</code> repo:</p>  <pre><code>[Fact] public async Task CallMvc() {     var client = GetTestHttpClient();      //call to HomeController.Index to get Home/Index.cshtml content     HttpRequestMessage request = new HttpRequestMessage(HttpMethod.Get, "/");      var response = await client.SendAsync(request);     var content = await response.Content.ReadAsStringAsync();     PAssert.IsTrue(() =&gt; content != null); }  private HttpClient GetTestHttpClient(Action&lt;IServiceCollection&gt; configureServices = null) {     var applicationServices = CallContextServiceLocator.Locator.ServiceProvider;     var applicationEnvironment = applicationServices.GetRequiredService&lt;IApplicationEnvironment&gt;();     var libraryManager = applicationServices.GetRequiredService&lt;ILibraryManager&gt;();     var startupAssembly = typeof(Startup).Assembly;      var applicationName = startupAssembly.GetName().Name;     var library = libraryManager.GetLibraryInformation(applicationName);     var applicationRoot = Path.GetDirectoryName(library.Path);      var hostingEnvironment = new HostingEnvironment()     {         WebRootPath = applicationRoot     };      var loggerFactory = new LoggerFactory();      var startup = new Startup();      Action&lt;IServiceCollection&gt; configureServicesAction = services =&gt;     {         services.AddInstance(applicationEnvironment);         services.AddInstance&lt;IHostingEnvironment&gt;(hostingEnvironment);          // Inject a custom assembly provider. Overrides AddMvc() because that uses TryAdd().         var assemblyProvider = new FixedSetAssemblyProvider();         assemblyProvider.CandidateAssemblies.Add(startupAssembly);         services.AddInstance&lt;IAssemblyProvider&gt;(assemblyProvider);          startup.ConfigureServices(services);     };      Action&lt;IApplicationBuilder&gt; configureApp = _ =&gt; startup.Configure(_, hostingEnvironment, loggerFactory);     var server = TestServer.Create(configureApp, configureServicesAction);     var httpClient = server.CreateClient();      return httpClient; } </code></pre>  <p>Startup class is just the simplest setup for MVC:</p>  <pre><code>public class Startup {     // This method gets called by the runtime. Use this method to add services to the container.     public void ConfigureServices(IServiceCollection services)     {         // Add MVC services to the services container.         services.AddMvc();     }      // Configure is called after ConfigureServices is called.     public void Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory)     {                // Add MVC to the request pipeline.         app.UseMvc(routes =&gt;         {             routes.MapRoute("default", "{controller=Home}/{action=Index}/{id?}");         });     } } </code></pre>  <p>I'm getting <code>Response status code does not indicate success: 500 (Internal Server Error)</code> and internally it's not able to locate Index.cshtml view. All paths  below are following Unit Tests library path or dnx path:</p>  <pre><code>var applicationBasePath = _appEnvironment.ApplicationBasePath; var webRootPath = _env.WebRootPath; var baseDirectory = AppDomain.CurrentDomain.BaseDirectory;  </code></pre>  <p>What is the way to setup view engine and environment to work from UnitTests using <code>TestServer</code>?</p>