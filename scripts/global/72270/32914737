<p><a href="http://plnkr.co/edit/ZKz74fDoWY8VmYWR8cgI?p=preview" rel="nofollow">Plunk</a> with examples.</p>  <p>In Angular 1.4 a <a href="https://github.com/angular/angular.js/issues/9992" rel="nofollow">change has been introduced</a> for <code>$filter('filter')</code> to throw an error when it doesn't operate on an array.  </p>  <p>The problem with this is that <a href="https://angular-ui.github.io/bootstrap/#/typeahead" rel="nofollow">UI Bootstrap's typeahead</a> used this to query and filter async results.</p>  <pre><code>// controller $scope.getActors = function(val) {     var deferred = $q.defer();     var promise = deferred.promise;      var values = [       {label: 'Jeff Goldblum', value: 1},       {label: 'Casey Affleck', value: 2},       {label: 'Tom Cruise', value: 3}     ];      // fake an async call     $timeout(function() {       deferred.resolve(values);     }, 1500)      return promise; }  // directive typeahead="actor as actor.label for actor in getActors($viewValue) | filter:{label:$viewValue}" </code></pre>  <p>However, this now throws an error because what is returned before any results is a <code>$promise</code> object, causing <code>$filter('filter')</code> to fail.  </p>  <p>I thought maybe I could wrap <code>filter</code> in another filter to return an empty array before the promise was resolved, but no such luck.</p>  <pre><code>// filter .filter('asyncFilter', function($filter) {   return function(val) {     return angular.isArray(val) ? $filter('filter')(val) : [];   }; })  // directive typeahead="actor as actor.label for actor in getActors($viewValue) | asyncFilter:{label:$viewValue}" </code></pre>