<p>I've a rotation represented as a quaternion and am trying to constrain the pitch, yaw, &amp; roll axes. I tried doing so thusly:</p>  <pre><code>public struct Orientation {     public Vector3 up, forward;      public Orientation(Vector3 up, Vector3 forward)     {         this.up = up;         this.forward = forward;     } }  public static Orientation[] orientations = new Orientation[3] {     new Orientation(Vector3.right, Vector3.up),     new Orientation(Vector3.up, Vector3.forward),     new Orientation(Vector3.forward, Vector3.right) };  public enum Axis {     Pitch,     Yaw,     Roll };  private Vector3 ConstrainAxis(Vector3 vector, Axis axis, float from, float to) {     Orientation orientation = orientations[(int)axis];      float theta = (to - from) * 0.5F;      Vector3 cons = Quaternion.AngleAxis(from + theta, orientation.up) * orientation.forward;     Vector3 proj = Vector3.ProjectOnPlane(vector, orientation.up);      return ConstrainVector(cons.normalized, proj.normalized, theta); }  private Vector3 ConstrainVector(Vector3 from, Vector3 to, float angle) {     float theta = Mathf.Abs(angle / Vector3.Angle(from, to));      if(theta &lt; 1.0F)     {         return Vector3.Slerp(from, to, theta);     }      return to; } </code></pre>  <p>Which turned out to be nothing more than an over-complicated way of constraining the individual components of an euler angle representation, of which both are subject to a strange jittering issue (gimbal lock related?). </p>  <p>What is the best approach to constraining these axes?</p>