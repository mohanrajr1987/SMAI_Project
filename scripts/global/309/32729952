<p>I am trying to write some position/orientation methods for my small &amp; simple 3d-space calculation library. But I'm stuck on the following problem.</p>  <p>I store 3d line as <code>start</code> and <code>end</code> points. However it should be possible to store it as <code>start</code> point and line's <code>length</code> + <code>orientation</code> as well (it's just a good example to test if orientation calculations works). </p>  <p>By <code>orientation</code> I mean rotation from the initial "0" orientation (which places the <code>end</code> at <code>start + [0,legth,0]</code>). So I first rotate the <code>[0,length,0]</code> by orientation and then add <code>start</code> to it to get <code>end</code> point.</p>  <p>The problem is, my orientation calculations fails somewhere. After calculating the orientation I get different ending point.</p>  <p>I use <strong>left-handed coordinate system with Y-axis pointing up</strong>, but I don't think it's important here.</p>  <p>Here's the code (I've tried to name the methods in the way you can check if the steps are ok; here's the <a href="http://pastebin.com/SH3Rfuis" rel="nofollow">full source code</a> if you want to compile it yourself):</p>  <pre><code>Point3D start = { 5.0f, 4.0f, 7.0f }; Point3D end = { 15.0f, 6.0f, 14.0f };  Point3D direction = (end - start); std::wcout &lt;&lt; L"Direction: "; direction.output();  float angle = Point3D(0.0f, 1.0f, 0.0f).getAngleToAnotherVectorInRadians(direction); Point3D axis = direction.getCrossProduct(Point3D(0.0f, 1.0f, 0.0f)).getNormalized(); Quaternion o = Quaternion(AxisAngle(axis, angle));  std::wcout &lt;&lt; L"\nAxisAngle: ";  AxisAngle(axis, angle).output(); std::wcout &lt;&lt; L"\nOrientation: "; o.output();  //test - end2 should be equal to end Point3D offset(0.0f, (end - start).getLengthAsVector(), 0.0f); offset = o.rotatePoint(offset); std::wcout &lt;&lt; L"\nOffset: "; offset.output(); Point3D end2 = start + offset; std::wcout &lt;&lt; L"\nEnd2: "; end2.output(); </code></pre>  <p>The code produces such output (without a comments, of course):</p>  <pre><code>Direction: {10, 2, 7} //looks ok AxisAngle: {{-0.573462, 0, 0.819232}, 1.40839} Orientation: {-0.371272, 0, 0.530388, 0.762132} Offset: {-10, 2, -7} //Almost! It should be {10, 2, 7} End2: {-5, 6, -9.53674e-07} //Wrong! It should be { 15, 6, 14 } </code></pre>  <p>In case that all steps are ok but there are some mistakes in methods' implementations I post here the important code for classes (so you can reproduce the problem): <code>Point3D, AxisAngle, Quaternion</code>.</p>  <p><strong>I highly believe that problem(s) lay(s) in my main steps or in <code>AxisAngle</code> calculations.</strong> I think that <code>AxisAngle</code> to <code>Quaternion</code> transformation is ok (but I pass the wrong <code>AxisAngle</code> to <code>Quaternion</code> constructor).</p>  <p>The <code>Point3D</code>:</p>  <pre><code>struct Point3D { protected:     float x, y, z;  public:     Point3D() : x(0.0f), y(0.0f), z(0.0f) {}     Point3D(float x, float y, float z) : x(x), y(y), z(z) {}     void output() { std::wcout &lt;&lt; L"{" &lt;&lt; x &lt;&lt; L", " &lt;&lt; y &lt;&lt; L", " &lt;&lt; z &lt;&lt; L"}"; }     Point3D operator-(const Point3D &amp;point) const {         Point3D temp;         temp.setX(getX() - point.getX());         temp.setY(getY() - point.getY());         temp.setZ(getZ() - point.getZ());         return temp;     }     Point3D operator+ (const Point3D &amp;value) const {         Point3D temp;         temp.setX(getX() + value.getX());         temp.setY(getY() + value.getY());         temp.setZ(getZ() + value.getZ());         return temp;     }     inline float getX() const { return x; } inline float getY() const { return y; } inline float getZ() const { return z; }     inline void setX(float x) { this-&gt;x = x; } inline void setY(float y) { this-&gt;y = y; } inline void setZ(float z) { this-&gt;z = z; }      inline float getLengthAsVector() const {         return sqrt(x*x + y*y + z*z);     }     inline Point3D getCrossProduct(const Point3D &amp;anotherVector) const {         //based on: http://www.sciencehq.com/physics/vector-product-multiplying-vectors.html         return Point3D(             y * anotherVector.z - anotherVector.y * z,             z * anotherVector.x - anotherVector.z * x,             x * anotherVector.y - anotherVector.x * y             );     }     inline float getDotProduct(const Point3D &amp;anotherVector) const {         //based on: https://www.ltcconline.net/greenl/courses/107/Vectors/DOTCROS.HTM         return x * anotherVector.x + y * anotherVector.y + z * anotherVector.z;     }     inline float getAngleToAnotherVectorInRadians(const Point3D &amp;anotherVector) const {         //based on: http://math.stackexchange.com/questions/974178/how-to-calculate-the-angle-between-2-vectors-in-3d-space-given-a-preset-function         return acos(getDotProduct(anotherVector) / (getLengthAsVector() * anotherVector.getLengthAsVector()));     }     Point3D getNormalized() const {         float length = std::abs(sqrt(x*x + y*y + z*z));         Point3D result(x / length, y / length, z / length);         return result;     } }; </code></pre>  <p>The <code>AxisAngle</code>:</p>  <pre><code>class AxisAngle { protected:     Point3D axis;     float angleInRadians;  public:     AxisAngle(const AxisAngle &amp;other) { axis = other.axis; angleInRadians = other.angleInRadians; }     AxisAngle::AxisAngle(float x, float y, float z, float angleInRadians) {         this-&gt;axis = Point3D(x, y, z);         this-&gt;angleInRadians = angleInRadians;     }     AxisAngle::AxisAngle(const Point3D &amp;axis, float angleInRadians) {         this-&gt;axis = axis;         this-&gt;angleInRadians = angleInRadians;     }      Point3D getAxis() const { return axis; }     float getAngleInRadians() const { return angleInRadians; }      void output() { std::wcout &lt;&lt; L"{";  axis.output(); std::wcout &lt;&lt; L", " &lt;&lt; angleInRadians &lt;&lt; L"}"; }  }; </code></pre>  <p>And last but not least, <code>Quaternion</code>:</p>  <pre><code>class Quaternion { protected:     float x; float y; float z; float w;  public:     Quaternion() { x = 0.0f; y = 0.0f; z = 0.0f; w = 1.0f; }     Quaternion(const Quaternion &amp;other) { x = other.x; y = other.y; z = other.z; w = other.w; }     Quaternion(float x, float y, float z, float w) { this-&gt;x = x; this-&gt;y = y; this-&gt;z = z; this-&gt;w = w; }     Quaternion(const AxisAngle &amp;axisAngle) {         Point3D axis = axisAngle.getAxis();         float angleInRadians = axisAngle.getAngleInRadians();         x = sin(angleInRadians / 2) * axis.getX();         y = sin(angleInRadians / 2) * axis.getY();         z = sin(angleInRadians / 2) * axis.getZ();         w = cos(angleInRadians / 2);         normalizeIt();     }      float getLength() const {         return sqrt(x*x + y*y + z*z + w*w);     }      void normalizeIt() {         float length = getLength();         x = x / length;         y = y / length;         z = z / length;         w = w / length;     }      Quaternion getConjugated() const {         return Quaternion(-x, -y, -z, w);     }      Quaternion multiply(Quaternion by) {         //"R" for result         float wR = w * by.getW() - x * by.getX() - y * by.getY() - z * by.getZ();         float xR = x * by.getW() + w * by.getX() + y * by.getZ() - z * by.getY();         float yR = y * by.getW() + w * by.getY() + z * by.getX() - x * by.getZ();         float zR = z * by.getW() + w * by.getZ() + x * by.getY() - y * by.getX();         return Quaternion(xR, yR, zR, wR);     }      //rotate Point3D p around [0,0,0] with this Quaternion     Point3D rotatePoint(Point3D p) const {         Quaternion temp = multiply(p).multiply(getConjugated());         return Point3D(temp.getX(), temp.getY(), temp.getZ());          //G: P' = Q(P-G)Q' + G &lt;- to rotate P around G with Quaternion     }      Quaternion multiply(Point3D r) const {         float wR = -x * r.getX() - y * r.getY() - z * r.getZ();         float xR = w * r.getX() + y * r.getZ() - z * r.getY();         float yR = w * r.getY() + z * r.getX() - x * r.getZ();         float zR = w * r.getZ() + x * r.getY() - y * r.getX();         return Quaternion(xR, yR, zR, wR);     }      inline float getX() const { return x; } inline void setX(float x) { this-&gt;x = x; }     inline float getY() const { return y; } inline void setY(float y) { this-&gt;y = y; }     inline float getZ() const { return z; } inline void setZ(float z) { this-&gt;z = z; }     inline float getW() const { return w; } inline void setW(float w) { this-&gt;w = w; }      void output() { std::wcout &lt;&lt; L"{" &lt;&lt; x &lt;&lt; L", " &lt;&lt; y &lt;&lt; L", " &lt;&lt; z &lt;&lt; L", " &lt;&lt; w &lt;&lt; L"}"; } }; </code></pre>  <p>In case somebody would ask: <strong>I do want to use quaternions.</strong> They may not look 100% needed here, but storing 3d object's orientation as quaternion has many benefits in more complex computations (and most game engines / 3d software use it as well "under the mask").</p>