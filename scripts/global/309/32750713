<p>In iOS 8 there was a problem with the division of floats in Metal preventing proper texture projection, <a href="http://stackoverflow.com/questions/31925583/how-to-use-a-3x3-2d-transformation-in-a-vertex-fragment-shader-metal">which I solved</a>.</p>  <p>Today I discovered that the texture projection on iOS 9 is broken again, although I'm not sure why.</p>  <p>The result of warping a texture on CPU (with OpenCV) and on GPU are not the same. You can see on your iPhone if you run <a href="https://github.com/aledalgrande/warpExample" rel="nofollow">this example app</a> (already includes the fix for iOS 8) from iOS 9.</p>  <p>The <em>expected</em> CPU warp is colored red, while the GPU warp done by Metal is colored green, so where they overlap they are yellow. Ideally you should not see green or red, but only shades of yellow.</p>  <p>Can you:</p>  <ul> <li>confirm the problem exists on your end;</li> <li>give any advice on anything that might be wrong?</li> </ul>  <p>The shader code is:</p>  <pre><code>struct VertexInOut {   float4 position [[ position ]];   float3 warpedTexCoords;   float3 originalTexCoords; };  vertex VertexInOut warpVertex(uint vid [[ vertex_id ]],                               device float4 *positions [[ buffer(0) ]],                               device float3 *texCoords [[ buffer(1) ]]) {   VertexInOut v;   v.position = positions[vid];    // example homography   simd::float3x3 h = {     {1.03140473, 0.0778113901, 0.000169219566},     {0.0342947133, 1.06025684, 0.000459250761},     {-0.0364957005, -38.3375587, 0.818259298}   };    v.warpedTexCoords = h * texCoords[vid];   v.originalTexCoords = texCoords[vid];    return v; }  fragment half4 warpFragment(VertexInOut inFrag [[ stage_in ]],                             texture2d&lt;half, access::sample&gt; original [[ texture(0) ]],                             texture2d&lt;half, access::sample&gt; cpuWarped [[ texture(1) ]]) {   constexpr sampler s(coord::pixel, filter::linear, address::clamp_to_zero);   half4 gpuWarpedPixel = half4(original.sample(s, inFrag.warpedTexCoords.xy * (1.0 / inFrag.warpedTexCoords.z)).r, 0, 0, 255);   half4 cpuWarpedPixel = half4(0, cpuWarped.sample(s, inFrag.originalTexCoords.xy).r, 0, 255);    return (gpuWarpedPixel + cpuWarpedPixel) * 0.5; } </code></pre>