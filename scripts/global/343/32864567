<p>I often have to project one collection into another. That would be very easy using Select operator from linq to objects:</p>  <pre><code>var targetCollection = sourceCollection.Select(source =&gt; new Target {     Source = source,    //some other stuff here } </code></pre>  <p>But I have to keep the collections eventually synchronized. When new items are added or removed from the sourceCollection, the changes has to be reflected in targetCollection. I have to do something like this:</p>  <pre><code>void OnSourceCollectionChanged(){    SyncCollections(sourceCollection, targetCollection) }  void SyncCollections(ICollection&lt;Source&gt; sourceCollection, ICollection&lt;Target&gt; targetCollection) {    //find items that are no longer present    var newItems = sourceCollection.Where(s =&gt; !targetCollection.Any(t =&gt; t.Source == s));    //find items that were added    var oldItems = targetCollection.Where(t =&gt; !sourceCollection.Any(s =&gt; t.Source == s));     foreach(var oldItem in oldItems)  targetCollection.Remove(oldItem);     foreach(var source in newItems){        var target = new Target{ Source = source };        targetCollection.Add(target);    } } </code></pre>  <p>I believe there are already good libraries to deal with such scenarios. Can you recommend me some?</p>  <p>I think of API where I just specify the projection and maybe 'equality comparer' to compare source and target item:</p>  <pre><code>var synchronizer = new CollectionSynchronizer&lt;Source, Target&gt;(     source =&gt; new Target     {         Source = source     });  synchronizer.Sync(sourceCollection, targetCollection);  //or specify filter as well: synchronizer.Sync(     sourceCollection.Where(s =&gt; s.Created &gt; DatTime.Now.AddMinutes(-5)),     targetCollection); </code></pre>