<p>I am facing a problem in my program when multiple threads access the same server over RMI. The server contains a list as a cache and performs some expensive computation sometimes changing that list. After the computation finished the list will be serialized and sent to the client.</p>  <p><strong>First Problem:</strong> if the list is changed while being serialized (e.g. by a different client requesting some data) a <code>ConcurrentModificationException</code> is (probably) thrown, resulting in a <code>EOFException</code> for the RMI call / the deserialization on the client-side.</p>  <p>Therefore I need a some kind of list-structure which is "stable" for serialization while possibly being changed by a different thread.</p>  <p><strong>Solutions we tried</strong>: </p>  <ul> <li>regular ArrayList / Set - not working because of concurrency</li> <li>deep-copying the entire structure before every serialization - faaar too expensive</li> <li><code>CopyOnWriteArrayList</code> - expensive as well since it copies the list <strong>and</strong></li> </ul>  <p>revealing the <strong>Second Problem</strong>: we need to be able to atomically replace any element in the list which is currently not thread-safe (first delete, then add (which is even more expensive)) or only doable by locking the list and therefore only doing the different threads in sequence.</p>  <p>Therefore my <strong>question</strong> is:</p>  <blockquote>   <p>Do you know of a <code>Collection</code> implementation which allows us to <code>serialize</code> the Collection thread-safe while other Threads modify it <code>and</code> which contains some way of <code>atomically replacing</code> elements? </p>      <p>A bonus would be if the list would <code>not</code> need to be <code>copied</code> before serialization! Creating a snapshot for every serialization would be okay, but still meh :/</p> </blockquote>  <p>Illustration of the problem (C=compute, A=add to list, R=remove from list, S=serialize)</p>  <pre><code>Thread1 Thread2       C        A       A C       C A       S C       S R &lt;---- Remove and add have to be performed without Thread1 serializing        S A &lt;---- anything in between (atomically) - and it has to be done without        S S       blocking other threads computations and serializations for long         S       and not third thread must be allowed to start serializing in this         S       in-between state         S </code></pre>