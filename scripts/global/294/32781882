<p>First of all, I create the virtual interface tuntap using commands:</p>  <pre><code>#ip tuntap add inter_virt1 mode tap #ip link set inter_virt1 up #ifconfig inter_virt1 172.16.2.40/24 </code></pre>  <p>If I do ping over 172.16.2.40, I get response:</p>  <pre><code>root@enri-VirtualBox:/home/enri# ping 172.16.2.40 PING 172.16.2.40 (172.16.2.40) 56(84) bytes of data. 64 bytes from 172.16.2.40: icmp_seq=1 ttl=64 time=0.091 ms 64 bytes from 172.16.2.40: icmp_seq=2 ttl=64 time=0.108 ms 64 bytes from 172.16.2.40: icmp_seq=3 ttl=64 time=0.110 ms ^C --- 172.16.2.40 ping statistics --- 3 packets transmitted, 3 received, 0% packet loss, time 2003ms rtt min/avg/max/mdev = 0.091/0.103/0.110/0.008 ms </code></pre>  <p>However using the following code, I get not receive anything:</p>  <pre><code>#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;sys/types.h&gt;           #include &lt;sys/socket.h&gt; #include &lt;netpacket/packet.h&gt; #include &lt;net/ethernet.h&gt;  #include &lt;errno.h&gt; #include &lt;unistd.h&gt; #include &lt;string.h&gt; #include &lt;sys/ioctl.h&gt; #include &lt;net/if.h&gt;  int main(int argc, char *argv[]){     int fd, ret, j;     struct sockaddr_ll interfaz;     struct ifreq ifr;     char *nameInterfaz = "inter_virt1";     char buffer[5000];      if((fd = socket(AF_PACKET, SOCK_DGRAM, htons(ETH_P_IP))) == -1){          perror("socket");         exit(1);         }      strcpy(ifr.ifr_name, nameInterfaz);      if((ret = ioctl(fd, SIOCGIFINDEX, &amp;ifr)) == -1){         perror("ioctl");         exit(1);     }      memset(&amp;interfaz, 0, sizeof(interfaz));     interfaz.sll_family = AF_PACKET;     interfaz.sll_protocol = htons(ETH_P_IP);     interfaz.sll_ifindex = ifr.ifr_ifindex;      if((ret = bind(fd, (struct sockaddr *)&amp;interfaz, sizeof(interfaz))) == -1){         perror("bind");         exit(1);     }      while(1){         if((ret = recvfrom(fd, buffer, 5000, 0, NULL, NULL)) == -1){             perror("recvfrom");             exit(1);         }         printf("%d bytes received\n", ret);         for(j=0; j&lt;ret; j++){             printf("%d] %d, ", j, (unsigned char)buffer[j]);         }         printf("\n\n");     }      return 0; } </code></pre>  <p>I have also tried to send datagrams (UDP) to 172.16.2.40 using socket</p>  <pre><code>#include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt; #include &lt;stdio.h&gt; #include &lt;errno.h&gt; #include &lt;unistd.h&gt; #include &lt;stdlib.h&gt; #include &lt;netinet/in.h&gt; #include &lt;string.h&gt; #include &lt;arpa/inet.h&gt;  int main(int argc, char *argv[]){         int sd;         struct sockaddr_in dir_serv, dir_propia;         char *dir_ip_serv = "172.16.2.40", dir_propia = "192.168.1.2";         char buffer[2000];          if((sd = socket(AF_INET, SOCK_DGRAM, 0)) == -1){                 perror("socket");                 exit(1);         }          memset((char *)&amp;dir_serv, 0, sizeof(dir_serv));         dir_serv.sin_family = AF_INET;         dir_serv.sin_port = htons(7012);         dir_serv.sin_addr.s_addr = inet_addr(dir_ip_serv);          memset((char *)&amp;dir_propia, 0, sizeof(dir_propia));         dir_propia.sin_family = AF_INET;         dir_propia.sin_port = htons(7011);         dir_propia.sin_addr.s_addr = inet_addr(dir_ip_propia);          if(bind(sd, (struct sockaddr *)&amp;dir_propia, sizeof(struct sockaddr_in)) == -1){                 perror("bind");                 exit(1);         }          printf("Introduce text\n");         scanf("%s", buffer);          if(sendto(sd, buffer, strlen(buffer), 0, (struct sockaddr *)&amp;dir_serv, sizeof(struct sockaddr_in)) == -1){                 perror("sendto");                 exit(1);         }          return 0; } </code></pre>  <p>But I do not get anything. My ultimate goal is to receive packets addressed to the virtual interface when the destination IP address is or is not the IP address assigned to the virtual interface.</p>