<p>I have a consumer that reads from RabbitMQ and writes to my database. The Consumer class that I use, is user defined, and it implements Callable.</p>  <p>Manual Consumer Method:</p>  <pre><code>public static void consume(Queue queue, String consumerName, int threadCount, int prefetchCount) throws Exception {     DbUtil.initializeConnectionPool();      Connection connection = RabbitMqUtils.getConnection();     Channel channel = connection.createChannel();     QueueingConsumer consumer = new QueueingConsumer(channel);      channel.basicQos(threadCount * prefetchCount);     queue.initiateConsumer(channel, consumer);      System.out.println("MQ Server: " + connection.getAddress() + ":" + connection.getPort());     System.out.println("Queue: " + queue.name);      // Multi-threading code.     threadPool = Executors.newFixedThreadPool(threadCount);     Class c = Class.forName(consumerName);      while (true) {         Consumer consumerInstance = (Consumer) c.newInstance();         java.sql.Connection dbConnection = null;         QueueingConsumer.Delivery delivery = null;          try {             delivery = consumer.nextDelivery();             dbConnection = DbUtil.getConnectionFromPool();             consumerInstance.setConsumerDetails(new String(delivery.getBody()), dbConnection, channel, queue, delivery);             threadPool.submit(consumerInstance);         } catch (Exception e) {             if (delivery != null) {                 Consumer.reQueueMessage(delivery, new String(delivery.getBody()), channel, queue, e);             }             if (dbConnection != null) {                 dbConnection.close();             }          }     } } </code></pre>  <p>Call Method:</p>  <pre><code>@Override public Object call() throws Exception {     try {         doWork(this.message, this.dbConnection);         channel.basicAck(this.delivery.getEnvelope().getDeliveryTag(), false);     } catch (Exception e) {         Consumer.dumpMsg(e.getMessage(), "Error Msg");         Consumer.reQueueMessage(this.delivery, new String(this.delivery.getBody()), this.channel, this.queue, e);     } finally {         java.sql.Connection dbConnection = this.dbConnection;         if (dbConnection != null) {             dbConnection.close();         }     }      return null; } </code></pre>  <p>The <code>doWork</code> is my method which is overridden in the children of the <code>Consumer</code> class. The issue is that 1 in about a 1000 messages get stuck in the queue in the <code>unacked</code> state. I can only get them out of the <code>unacked</code> state by stopping and then starting the consumer. My guess is that the acknowledgement gets lost in the network traffic. I want to know if there is a way to cause the messages to only remain in the <code>unacked</code> state for sometime, before going back to the queue, to be re-consumed.</p>