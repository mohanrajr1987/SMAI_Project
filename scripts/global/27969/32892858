<p>I'm trying to listen to the error queue to process failed messages but I can't seem to get MassTransit not to set bindings on message that i want it to listen to within the configuration. The configuration is below and is using v3 of MassTransit:</p>    <pre><code>var hostAddress = new Uri("rabbitmq://localhost/"); var username = "guest"; var password = "guest";  _busControl = MassTransit.Bus.Factory.CreateUsingRabbitMq(configurator =&gt; {   var host = configurator.Host(hostAddress, h =&gt;   {     h.Username(username);     h.Password(password);   });    configurator.ReceiveEndpoint(host, "myqueue_error",   endpointConfigurator =&gt;   {     endpointConfigurator.Handler&lt;SomeMessage&gt;(context =&gt;     {       return Console.Out.WriteLineAsync("Woop");     });   }); }); </code></pre>    <p>In the above example it will set bindings up for anything that publishes <code>SomeMessage</code> and direct them in to the <code>myqueue_error</code> which I only want messages going in to this queue which has been forward from the service that are failing. Is there anyway to consume messages from a queue but tell MassTransit not to get bindings up for them?</p>  <blockquote>   <p>Update - Potential Solution</p> </blockquote>  <p>It seems that I don't need to setup a ReceiveEndpoint but I can just rename the controlbus to accept the message that I care about, This will then be able to process these messages without creating exchange bindings to the messages.</p>  <p>Below is the altered code, not sure if this is an ideal way but it <em>works</em></p>  <pre class="lang-cs prettyprint-override"><code>var hostAddress = new Uri("rabbitmq://localhost/"); var username = "guest"; var password = "guest";  _busControl = MassTransit.Bus.Factory.CreateUsingRabbitMq(configurator =&gt; {   configurator.Host(hostAddress, h =&gt;   {     h.Username(username);     h.Password(password);   });    // We need to make the queue look like the error queue   configurator.BusQueueName = $"{_queue}_error";   configurator.Durable = true;   configurator.AutoDelete = false;   configurator.SetQueueArgument("x-expires", null); });  var connectHandle = _busControl.ConnectHandler&lt;SomeMessage&gt;(context =&gt; Console.Out.WriteLineAsync("Woop"));  _busHandle = _busControl.Start();  _busHandle.Ready.Wait();  // Wait  // Clean up  connectHandle.Disconnect(); _busHandle.Stop </code></pre>