<p>Working on a C# project that uses Rabbit. I've found what appears to me as conflicting information in the documentation regarding when a message is redelivered as a result of either a connection or channel dying (which one is it?)</p>  <p>The docs here: <a href="http://www.rabbitmq.com/semantics.html" rel="nofollow">http://www.rabbitmq.com/semantics.html</a></p>  <p>State that it is requeued for delivery when a channel closes</p>  <blockquote>   <p>Messages can be returned to the queue using AMQP methods that feature   a requeue parameter (basic.recover, basic.reject and basic.nack), <strong>or   due to a channel closing</strong> while holding unacknowledged messages. Any of   these scenarios caused messages to be requeued at the back of the   queue for RabbitMQ releases earlier than 2.7.0. From RabbitMQ release   2.7.0, messages are always held in the queue in publication order, even in the presence of requeueing or channel closure.</p> </blockquote>  <p>But here: <a href="http://www.rabbitmq.com/tutorials/tutorial-two-dotnet.html" rel="nofollow">http://www.rabbitmq.com/tutorials/tutorial-two-dotnet.html</a></p>  <p>States: Only when the worker connection dies</p>  <blockquote>   <p>If a consumer dies without sending an ack, RabbitMQ will understand   that a message wasn't processed fully and will redeliver it to another   consumer. That way you can be sure that no message is lost, even if   the workers occasionally die.</p>      <p>There aren't any message timeouts; RabbitMQ will redeliver the message   <strong>only when the worker connection dies</strong>. It's fine even if processing a   message takes a very, very long time.</p> </blockquote>  <p>So when does redelivery actually happen? When the worker or the channel dies? Can I <strong>Consume</strong> on one channel but <strong>ACK</strong> on another channel?</p>  <p>Currently I created a ChannelManager class that opens N channels and stores them in a ConcurrentQueue and Queues / Dequeues Channels as they are needed, and also ensures we never fall below the 'minimum' available channel count. With this method there is no way for me to ensure the Consume and Ack happen on the same channel...</p>