<p>I've hit a complete brick wall in my attempt to use NVEnc to stream OpenGL frames as H264. I've been at this particular issue for close to 8 hours without any progress.</p>  <p>The problem is the call to <code>nvEncRegisterResource()</code>, which invariably fails with code -23 (enum value NV_ENC_ERR_RESOURCE_REGISTER_FAILED, documented as "failed to register the resource" - thanks NVidia).</p>  <p>I'm trying to follow a procedure outlined in <a href="http://heim.ifi.uio.no/paalh/students/MartinAlexanderWilhelmsen.pdf" rel="nofollow">this document</a> from the University of Oslo (page 54, "OpenGL interop"), so I know for a fact that this is supposed to work, though unfortunately said document does not provide the code itself.</p>  <p>The idea is fairly straightforward:</p>  <ol> <li>map the texture produced by the OpenGL frame buffer object into CUDA;</li> <li>copy the texture into a (previously allocated) CUDA buffer; </li> <li>map that buffer as an NVEnc input resource</li> <li>use that input resource as the source for the encoding</li> </ol>  <p>As I said, the problem is step (3). Here are the relevant code snippets (I'm omitting error handling for brevity.)</p>  <pre><code>// Round up width and height priv-&gt;encWidth = (_resolution.w + 31) &amp; ~31, priv-&gt;encHeight = (_resolution.h + 31) &amp; ~31;  // Allocate CUDA "pitched" memory to match the input texture (YUV, one byte per component) cuErr = cudaMallocPitch(&amp;priv-&gt;cudaMemPtr, &amp;priv-&gt;cudaMemPitch, 3 * priv-&gt;encWidth, priv-&gt;encHeight); </code></pre>  <p>This should allocate on-device CUDA memory (the "pitched" variety, though I've tried non-pitched too, without any change in the outcome.)</p>  <pre><code>// Register the CUDA buffer as an input resource NV_ENC_REGISTER_RESOURCE regResParams = { 0 }; regResParams.version = NV_ENC_REGISTER_RESOURCE_VER; regResParams.resourceType = NV_ENC_INPUT_RESOURCE_TYPE_CUDADEVICEPTR; regResParams.width  = priv-&gt;encWidth; regResParams.height = priv-&gt;encHeight; regResParams.bufferFormat = NV_ENC_BUFFER_FORMAT_YUV444_PL; regResParams.resourceToRegister = priv-&gt;cudaMemPtr; regResParams.pitch = priv-&gt;cudaMemPitch; encStat = nvEncApi.nvEncRegisterResource(priv-&gt;nvEncoder, &amp;regResParams); //                 ^^^ FAILS priv-&gt;nvEncInpRes = regResParams.registeredResource; </code></pre>  <p>This is the brick wall. No matter what I try, <code>nvEncRegisterResource()</code> fails. </p>  <p>I should note that I rather think (though I may be wrong) that I've done all the required initializations. Here is the code that creates and activates the CUDA context:</p>  <pre><code>// Pop the current context cuRes = cuCtxPopCurrent(&amp;priv-&gt;cuOldCtx);  // Create a context for the device priv-&gt;cuCtx = nullptr; cuRes = cuCtxCreate(&amp;priv-&gt;cuCtx, CU_CTX_SCHED_BLOCKING_SYNC, priv-&gt;cudaDevice);  // Push our context cuRes = cuCtxPushCurrent(priv-&gt;cuCtx); </code></pre>  <p>.. followed by the creation of the encoding session:</p>  <pre><code>// Create an NV Encoder session NV_ENC_OPEN_ENCODE_SESSION_EX_PARAMS nvEncSessParams = { 0 }; nvEncSessParams.apiVersion = NVENCAPI_VERSION; nvEncSessParams.version = NV_ENC_OPEN_ENCODE_SESSION_EX_PARAMS_VER; nvEncSessParams.deviceType = NV_ENC_DEVICE_TYPE_CUDA; nvEncSessParams.device = priv-&gt;cuCtx; // nullptr auto encStat = nvEncApi.nvEncOpenEncodeSessionEx(&amp;nvEncSessParams, &amp;priv-&gt;nvEncoder); </code></pre>  <p>And finally, the code initializing the encoder:</p>  <pre><code>// Configure the encoder via preset  NV_ENC_PRESET_CONFIG presetConfig = { 0 }; GUID codecGUID = NV_ENC_CODEC_H264_GUID; GUID presetGUID = NV_ENC_PRESET_LOW_LATENCY_DEFAULT_GUID; presetConfig.version = NV_ENC_PRESET_CONFIG_VER; presetConfig.presetCfg.version = NV_ENC_CONFIG_VER; encStat = nvEncApi.nvEncGetEncodePresetConfig(priv-&gt;nvEncoder, codecGUID, presetGUID, &amp;presetConfig);  NV_ENC_INITIALIZE_PARAMS initParams = { 0 }; initParams.version = NV_ENC_INITIALIZE_PARAMS_VER; initParams.encodeGUID = codecGUID; initParams.encodeWidth  = priv-&gt;encWidth; initParams.encodeHeight = priv-&gt;encHeight; initParams.darWidth  = 1; initParams.darHeight = 1; initParams.frameRateNum = 25;   // TODO: make this configurable initParams.frameRateDen = 1;    // ditto //   .max_surface_count = (num_mbs &gt;= 8160) ? 32 : 48; //   .buffer_delay ? necessary initParams.enableEncodeAsync = 0; initParams.enablePTD = 1; initParams.presetGUID = presetGUID; memcpy(&amp;priv-&gt;nvEncConfig, &amp;presetConfig.presetCfg, sizeof(priv-&gt;nvEncConfig)); initParams.encodeConfig = &amp;priv-&gt;nvEncConfig; encStat = nvEncApi.nvEncInitializeEncoder(priv-&gt;nvEncoder, &amp;initParams); </code></pre>  <p>All the above initializations report success.</p>  <p>I'd be extremely grateful to anyone who can get me past this hurdle.</p>  <hr>  <p>EDIT: here is the complete code to reproduce the problem. The only observable difference to the original code is that <code>cuPopContext()</code> returns an error (which can be ignored) here - probably my original program creates such a context as a side effect of using OpenGL. Otherwise, the code behaves exactly as the original does. I've built the code with Visual Studio 2013. You must link the following library file (adapt path if not on C:): <code>C:\Program Files (x86)\NVIDIA GPU Computing Toolkit\CUDA\v7.5\lib\Win32\cuda.lib</code></p>  <p>You must also make sure that <code>C:\Program Files (x86)\NVIDIA GPU Computing Toolkit\CUDA\v7.5\include\</code> (or similar) is in the include path.</p>  <p>NEW EDIT: modified the code to only use the CUDA driver interface, instead of mixing with the runtime API. Still the same error code.</p>  <pre><code>#ifdef _WIN32 #include &lt;Windows.h&gt; #endif #include &lt;cassert&gt; #include &lt;GL/gl.h&gt; #include &lt;iostream&gt; #include &lt;string&gt;  #include &lt;stdexcept&gt; #include &lt;string&gt;  #include &lt;cuda.h&gt; //#include &lt;cuda_runtime.h&gt; #include &lt;cuda_gl_interop.h&gt; #include &lt;nvEncodeAPI.h&gt;  // NV Encoder API ---------------------------------------------------  #if defined(_WIN32) #define LOAD_FUNC(l, s) GetProcAddress(l, s) #define DL_CLOSE_FUNC(l) FreeLibrary(l) #else #define LOAD_FUNC(l, s) dlsym(l, s) #define DL_CLOSE_FUNC(l) dlclose(l) #endif  typedef NVENCSTATUS(NVENCAPI* PNVENCODEAPICREATEINSTANCE)(NV_ENCODE_API_FUNCTION_LIST *functionList);  struct NVEncAPI : public NV_ENCODE_API_FUNCTION_LIST { public:     // ~NVEncAPI() { cleanup(); }      void init() { #if defined(_WIN32)         if (sizeof(void*) == 8) {             nvEncLib = LoadLibrary(TEXT("nvEncodeAPI64.dll"));         }         else {             nvEncLib = LoadLibrary(TEXT("nvEncodeAPI.dll"));         }         if (nvEncLib == NULL) throw std::runtime_error("Failed to load NVidia Encoder library: " + std::to_string(GetLastError())); #else         nvEncLib = dlopen("libnvidia-encode.so.1", RTLD_LAZY);         if (nvEncLib == nullptr)             throw std::runtime_error("Failed to load NVidia Encoder library: " + std::string(dlerror())); #endif         auto nvEncodeAPICreateInstance = (PNVENCODEAPICREATEINSTANCE) LOAD_FUNC(nvEncLib, "NvEncodeAPICreateInstance");          version = NV_ENCODE_API_FUNCTION_LIST_VER;         NVENCSTATUS encStat = nvEncodeAPICreateInstance(static_cast&lt;NV_ENCODE_API_FUNCTION_LIST *&gt;(this));     }      void cleanup() { #if defined(_WIN32)         if (nvEncLib != NULL) {             FreeLibrary(nvEncLib);             nvEncLib = NULL;         } #else         if (nvEncLib != nullptr) {             dlclose(nvEncLib);             nvEncLib = nullptr;         } #endif     }  private:  #if defined(_WIN32)     HMODULE nvEncLib; #else     void* nvEncLib; #endif     bool init_done; };  static NVEncAPI nvEncApi;  // Encoder class ----------------------------------------------------  class Encoder { public:     typedef unsigned int uint_t;     struct Size { uint_t w, h; };      Encoder() {          CUresult cuRes = cuInit(0);         nvEncApi.init();      }      void init(const Size &amp; resolution, uint_t texture) {          NVENCSTATUS encStat;         CUresult cuRes;          texSize = resolution;         yuvTex = texture;          // Purely for information         int devCount = 0;         cuRes = cuDeviceGetCount(&amp;devCount);          // Initialize NVEnc         initEncodeSession();            // start an encoding session         initEncoder();          // Register the YUV texture as a CUDA graphics resource         // CODE COMMENTED OUT AS THE INPUT TEXTURE IS NOT NEEDED YET (TO MY UNDERSTANDING) AT SETUP TIME         //cudaGraphicsGLRegisterImage(&amp;priv-&gt;cudaInpTexRes, priv-&gt;yuvTex, GL_TEXTURE_2D, cudaGraphicsRegisterFlagsReadOnly);          // Allocate CUDA "pitched" memory to match the input texture (YUV, one byte per component)         encWidth = (texSize.w + 31) &amp; ~31, encHeight = (texSize.h + 31) &amp; ~31;         cuRes = cuMemAllocPitch(&amp;cuDevPtr, &amp;cuMemPitch, 4 * encWidth, encHeight, 16);          // Register the CUDA buffer as an input resource         NV_ENC_REGISTER_RESOURCE regResParams = { 0 };         regResParams.version = NV_ENC_REGISTER_RESOURCE_VER;         regResParams.resourceType = NV_ENC_INPUT_RESOURCE_TYPE_CUDADEVICEPTR;         regResParams.width = encWidth;         regResParams.height = encHeight;         regResParams.bufferFormat = NV_ENC_BUFFER_FORMAT_YUV444_PL;         regResParams.resourceToRegister = (void*) cuDevPtr;         regResParams.pitch = cuMemPitch;         encStat = nvEncApi.nvEncRegisterResource(nvEncoder, &amp;regResParams);         assert(encStat == NV_ENC_SUCCESS); // THIS IS THE POINT OF FAILURE         nvEncInpRes = regResParams.registeredResource;     }      void cleanup() { /* OMITTED */ }      void encode() {         // THE FOLLOWING CODE WAS NEVER REACHED YET BECAUSE OF THE ISSUE.         // INCLUDED HERE FOR REFERENCE.          CUresult cuRes;         NVENCSTATUS encStat;          cuRes = cuGraphicsResourceSetMapFlags(cuInpTexRes, CU_GRAPHICS_MAP_RESOURCE_FLAGS_READ_ONLY);          cuRes = cuGraphicsMapResources(1, &amp;cuInpTexRes, 0);          CUarray mappedArray;         cuRes = cuGraphicsSubResourceGetMappedArray(&amp;mappedArray, cuInpTexRes, 0, 0);          cuRes = cuMemcpyDtoA(mappedArray, 0, cuDevPtr, 4 * encWidth * encHeight);          NV_ENC_MAP_INPUT_RESOURCE mapInputResParams = { 0 };         mapInputResParams.version = NV_ENC_MAP_INPUT_RESOURCE_VER;         mapInputResParams.registeredResource = nvEncInpRes;         encStat = nvEncApi.nvEncMapInputResource(nvEncoder, &amp;mapInputResParams);          // TODO: encode...          cuRes = cuGraphicsUnmapResources(1, &amp;cuInpTexRes, 0);     }  private:     struct PrivateData;      void initEncodeSession() {          CUresult cuRes;         NVENCSTATUS encStat;          // Pop the current context         cuRes = cuCtxPopCurrent(&amp;cuOldCtx); // THIS IS ALLOWED TO FAIL (it doesn't          // Create a context for the device         cuCtx = nullptr;         cuRes = cuCtxCreate(&amp;cuCtx, CU_CTX_SCHED_BLOCKING_SYNC, 0);          // Push our context         cuRes = cuCtxPushCurrent(cuCtx);          // Create an NV Encoder session         NV_ENC_OPEN_ENCODE_SESSION_EX_PARAMS nvEncSessParams = { 0 };         nvEncSessParams.apiVersion = NVENCAPI_VERSION;         nvEncSessParams.version = NV_ENC_OPEN_ENCODE_SESSION_EX_PARAMS_VER;         nvEncSessParams.deviceType = NV_ENC_DEVICE_TYPE_CUDA;         nvEncSessParams.device = cuCtx;         encStat = nvEncApi.nvEncOpenEncodeSessionEx(&amp;nvEncSessParams, &amp;nvEncoder);     }      void Encoder::initEncoder()     {         NVENCSTATUS encStat;          // Configure the encoder via preset          NV_ENC_PRESET_CONFIG presetConfig = { 0 };         GUID codecGUID = NV_ENC_CODEC_H264_GUID;         GUID presetGUID = NV_ENC_PRESET_LOW_LATENCY_DEFAULT_GUID;         presetConfig.version = NV_ENC_PRESET_CONFIG_VER;         presetConfig.presetCfg.version = NV_ENC_CONFIG_VER;         encStat = nvEncApi.nvEncGetEncodePresetConfig(nvEncoder, codecGUID, presetGUID, &amp;presetConfig);          NV_ENC_INITIALIZE_PARAMS initParams = { 0 };         initParams.version = NV_ENC_INITIALIZE_PARAMS_VER;         initParams.encodeGUID = codecGUID;         initParams.encodeWidth = texSize.w;         initParams.encodeHeight = texSize.h;         initParams.darWidth = texSize.w;         initParams.darHeight = texSize.h;         initParams.frameRateNum = 25;         initParams.frameRateDen = 1;         initParams.enableEncodeAsync = 0;         initParams.enablePTD = 1;         initParams.presetGUID = presetGUID;         memcpy(&amp;nvEncConfig, &amp;presetConfig.presetCfg, sizeof(nvEncConfig));         initParams.encodeConfig = &amp;nvEncConfig;         encStat = nvEncApi.nvEncInitializeEncoder(nvEncoder, &amp;initParams);     }      //void cleanupEncodeSession();     //void cleanupEncoder;      Size                    texSize;      GLuint                  yuvTex;     uint_t                  encWidth, encHeight;     CUdeviceptr             cuDevPtr;     size_t                  cuMemPitch;     NV_ENC_CONFIG           nvEncConfig;     NV_ENC_INPUT_PTR        nvEncInpBuf;     NV_ENC_REGISTERED_PTR   nvEncInpRes;     CUdevice                cuDevice;     CUcontext               cuCtx, cuOldCtx;     void                    *nvEncoder;     CUgraphicsResource      cuInpTexRes; };   int main(int argc, char *argv[]) {     Encoder encoder;      encoder.init({1920, 1080}, 0); // OMITTED THE TEXTURE AS IT IS NOT NEEDED TO REPRODUCE THE ISSUE      return 0; } </code></pre>