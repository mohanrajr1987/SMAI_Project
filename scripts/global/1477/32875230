<p>I'm working with a C++ class which I CANNOT modify that declares an extern "C" function from within a cpp file (not a .h).</p>  <p>How do I call that function from another cpp file?  </p>  <p>To further complicate matters, the function is declared with the "weak" attribute, and as such I can overwrite it.  What I'm really trying to do is call that weak function from my strong function in a manner analogous to calling a base class function from a derived class which is overriding the function. </p>  <ul> <li>MORE -</li> </ul>  <p>Alright let's get really specific since ppl are asking for more info...</p>  <p>I'm creating a Qt 5.5 project for an iOS App.  I found a bug where Qt will crash if you load the app face up.  See thread: <a href="http://stackoverflow.com/questions/32763586/qt-for-ios-locks-up-when-app-is-launched-face-up-qiosscreen-mm-assertion">Qt for iOS locks up when app is launched face up. (qiosscreen.mm assertion)</a></p>  <p>I am NOT building from the Qt source.  I am using it out of the box.  I can see the cpp source, but I cannot actually modify or include it.</p>  <p>I figured out a way with a static class to detect that my problem will occur before it does.  Since I don't actually know how to fix it, I want to display an error message at least rather than just having the app go to a black screen when you launch it.  </p>  <p>Qt iOS apps load using the class "qioseventdispatcher".  The cpp (which I can't change or include) declares a weak main function and another weak function called qtmn.  You are suppose to override qtmn as your "main" function - which this qt class calls.  You can, however, override the "real" main too and create your own native app without the qt underlying layers.  </p>  <p>I want to determine at RUNTIME (I can do this at compile time now) if I'm going to have the qt functions called or my own to load a simple native app that will display an error message.  </p>  <p>Here's some of the qt cpp:</p>  <pre><code>    extern "C" int __attribute__((weak)) main(int argc, char *argv[])     {         @autoreleasepool {   ...             qEventDispatcherDebug() &lt;&lt; "Running UIApplicationMain"; qIndent();             return UIApplicationMain(argc, argv, nil, NSStringFromClass([QIOSApplicationDelegate class]));         }     }    ...      // We define qtmn so that user_main_trampoline() will not cause     // missing symbols in the case of hybrid applications that don't     // use our main wrapper. Since the symbol is weak, it will not     // get used or cause a clash in the normal Qt application usecase,     // where we rename main to qtmn before linking.     extern "C" int __attribute__((weak)) qtmn(int argc, char *argv[])     {         Q_UNUSED(argc);         Q_UNUSED(argv);          Q_UNREACHABLE();     } </code></pre>  <p>qtmn() goes on the get called by the UIApplication selector (void) applicationDidFinishLaunching.</p>  <p>I want to provide a "strong" copy of main, and a strong copy of qtmn().  My copy of main will decide to load my native app, or call the qt weak main function somehow, which will then call my qtmn() function in the standar Qt for iOS manner.</p>