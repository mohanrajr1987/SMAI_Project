<p>I tried to use <code>abi::__cxa_demangle</code> to demangle user-defined types:</p>  <pre><code>#include &lt;iostream&gt; #include &lt;mutex&gt; #include &lt;memory&gt; #include &lt;string&gt; #include &lt;typeinfo&gt;  #include &lt;cassert&gt; #include &lt;cstdlib&gt;  #include &lt;cxxabi.h&gt;  namespace {  #pragma clang diagnostic push #pragma clang diagnostic ignored "-Wglobal-constructors" #pragma clang diagnostic ignored "-Wexit-time-destructors" std::mutex m; std::unique_ptr&lt; char, decltype(std::free) &amp; &gt; demangled_name{nullptr, std::free}; #pragma clang diagnostic pop  }  inline std::string get_demangled_name(char const * const symbol) noexcept {     if (!symbol) {         return "&lt;null&gt;";     }     std::lock_guard&lt; std::mutex &gt; lock(m);     int status = -4;     demangled_name.reset(abi::__cxa_demangle(symbol, demangled_name.release(), nullptr, &amp;status));     return ((status == 0) ? demangled_name.get() : symbol); }  template&lt; typename ...types &gt; void f(std::size_t const i) {     using F = void (*)();     assert(i &lt; sizeof...(types));     static F const a[sizeof...(types)] = {static_cast&lt; F &gt;([] () { std::cout &lt;&lt; get_demangled_name(typeid(types).name()) &lt;&lt; std::endl; })...};     return a[i](); };  struct A {}; struct B {}; struct X {}; struct Y {}; struct Z {};  int main() {     for (std::size_t i = 0; i &lt; 5; ++i) {        f&lt; A, B, X, Y, Z &gt;(i);     }     return EXIT_SUCCESS; } </code></pre>  <p>But <code>abi::__cxa_demangle</code> returns <code>status</code> <a href="https://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-4.3/a01696.html" rel="nofollow"><em>"-3: One of the arguments is invalid."</em></a> every second time.</p>  <p>At the first call (for <code>A</code>) smart pointer contains <code>nullptr</code> and <code>abi::__cxa_demangle</code> returns zero <code>status</code> <a href="https://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-4.3/a01696.html" rel="nofollow"><em>"0: The demangling operation succeeded."</em></a>. But documentation said:</p>  <blockquote>   <p>output_buffer: A region of memory, allocated with malloc, of *length bytes, into which the demangled name is stored. If output_buffer is not long enough, it is expanded using realloc. output_buffer may instead be NULL; in that case, the demangled name is placed in a region of memory allocated with malloc.</p> </blockquote>  <p>Hence, I conclude the function can't reuse memory consistently allocated by itself. Is it bug or just my misunderstanding of the documentation?</p>