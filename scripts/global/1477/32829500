<p>I am writing code that will be compiled (using gcc, targeting Android x86) and then processed by another program. that program has limits on its input such as that the code cannot make indirect calls or reference globals. To enforce this in PIC/PIE code the tool errors on calls to get_pc_thunk (or any function that just reads the top of the stack and returns)</p>  <p>I have my code in a state where it should meet these requirements. All functions are linked in and can be called by offset after linking. but GCC leaves a call to get_pc_thunk in my function even though it is not used.</p>  <p>my code is (test.c):</p>  <pre><code>unsigned long long API test(unsigned long long a, unsigned long long b) {    return a / b; } </code></pre>  <p>to build this I use:</p>  <pre><code>gcc.exe -o test.o -fno-stack-protector test.c -c -O0  gcc.exe -o libtest.so -m32 -static -static-libgcc -nostartfiles -shared test.o </code></pre>  <p>I get out:</p>  <pre><code>000001d8 &lt;test&gt;:  1d8:   55                      push   ebp  1d9:   89 e5                   mov    ebp,esp  1db:   53                      push   ebx  1dc:   8d 64 24 dc             lea    esp,[esp-0x24]  1e0:   e8 45 00 00 00          call   22a &lt;__x86.get_pc_thunk.bx&gt;  1e5:   81 c3 0f 1e 00 00       add    ebx,0x1e0f  1eb:   8b 45 08                mov    eax,DWORD PTR [ebp+0x8]  1ee:   89 45 f0                mov    DWORD PTR [ebp-0x10],eax  1f1:   8b 45 0c                mov    eax,DWORD PTR [ebp+0xc]  1f4:   89 45 f4                mov    DWORD PTR [ebp-0xc],eax  1f7:   8b 45 10                mov    eax,DWORD PTR [ebp+0x10]  1fa:   89 45 e8                mov    DWORD PTR [ebp-0x18],eax  1fd:   8b 45 14                mov    eax,DWORD PTR [ebp+0x14]  200:   89 45 ec                mov    DWORD PTR [ebp-0x14],eax  203:   8b 45 e8                mov    eax,DWORD PTR [ebp-0x18]  206:   8b 55 ec                mov    edx,DWORD PTR [ebp-0x14]  209:   89 44 24 08             mov    DWORD PTR [esp+0x8],eax  20d:   89 54 24 0c             mov    DWORD PTR [esp+0xc],edx  211:   8b 45 f0                mov    eax,DWORD PTR [ebp-0x10]  214:   8b 55 f4                mov    edx,DWORD PTR [ebp-0xc]  217:   89 04 24                mov    DWORD PTR [esp],eax  21a:   89 54 24 04             mov    DWORD PTR [esp+0x4],edx  21e:   e8 0b 00 00 00          call   22e &lt;__udivdi3&gt;  223:   8d 64 24 24             lea    esp,[esp+0x24]  227:   5b                      pop    ebx  228:   5d                      pop    ebp  229:   c3                      ret      0000022a &lt;__x86.get_pc_thunk.bx&gt;:  22a:   8b 1c 24                mov    ebx,DWORD PTR [esp]  22d:   c3                      ret      0000022e &lt;__udivdi3&gt;:  ... </code></pre>  <p>having worked through what is happening I understand that at compile time gcc adds placeholders for the call to get_pc_thunk and __udivdi3 since it does not know at that point where __udivdi3 will be, and it might need to be called via a lookup table. However after linking the get_pc_thunk is no longer needed. I have looked through the linker options and cannot find one that will optimize this call out.</p>  <p>Is there an option to remove this unneeded call in this case?</p>