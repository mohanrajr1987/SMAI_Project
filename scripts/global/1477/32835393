<p>I expected to see  "initializer-string for array of chars is too long" warning for both of the variables in the following program using gcc.</p>  <p>Program:</p>  <pre><code>int main() {    char str1[4]="1234";    char str2[3]="1234";     (void)str1; // Remove unused variable warning.    (void)str2; // Remove unused variable warning.    return 0; } </code></pre>  <p>However, I got a warning only for <code>str2</code>. </p>  <p>Since </p>  <pre><code>char str1[4]="1234"; </code></pre>  <p>is equivalent to</p>  <pre><code>char str1[4]= {'1', '2', '3', '4', '\0'}; </code></pre>  <p>shouldn't we get the same warning for <code>str1</code> also?</p>  <p>Is this a defect in gcc?</p>  <p>Compiler command:</p>  <blockquote>   <p>gcc -Wall -std=c99     soc.c   -o soc</p> </blockquote>  <p><code>gcc</code> version is 4.8.4.</p>  <p><strong>Update</strong></p>  <p>Learned just now that </p>  <pre><code>char str1[4]="1234"; </code></pre>  <p><strong>is not</strong> equivalent to</p>  <pre><code>char str1[4]= {'1', '2', '3', '4', '\0'}; </code></pre>  <p><strong>Update 2</strong></p>  <pre><code>char str1[4]="1234"; </code></pre>  <p>is ill-formed in C++11 (Section 8.5.2/2). I didn't think C99 and C++11 would treat them differently.</p>