<p>The GCC <code>__atomic</code> API has multiple functions ending in <code>_n</code>, e.g. </p>  <pre><code>__atomic_load_n  __atomic_store_n </code></pre>  <p>The compiler also supports intrinsitcs with <code>n</code> replaced by 1, 2, 4, 8 or 16 (which you have to infer exist from the docs - IMO the docs are pretty hazy for <code>__atomic</code>s and should be improved!).  When an explicit number is used this tells the compiler the width of the data the atomic operation should operate on. When <code>_n</code> is used I'm presuming the compiler infers the width from the type passed if it can, or errors otherwise.</p>  <p>I checked this last statement by passing a <code>void*</code> to <code>__atomic_load_n</code> and it complained, which wasn't a big surprise.</p>  <p>So my questions are: </p>  <ul> <li>Is what I have said correct? </li> <li>Is there any reason not to use the <code>_n</code> version except in the case that you have some opaque pointer and need to explicitly tell the compiler how wide it's pointee is? </li> <li>Are there any other subtleties I'm missing with this stuff?</li> </ul>  <p>Thanks</p>