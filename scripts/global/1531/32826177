<p>An example from the stairway book:</p>  <pre><code>package ky.example  object Example {   abstract class MyList[+T] {     def isEmpty: Boolean     def head: T     def tail: MyList[T]      def length: Int = if(isEmpty) 0 else 1 + tail.length     def drop(n: Int): MyList[T] = {       if(isEmpty) MyNil       else tail.drop(n - 1)     }     def map[U](func: T =&gt; U): MyList[U] = {       if(isEmpty) MyNil //      else new ::(func(head), tail.map(func))       else func(head) :: tail.map(func) // cannot resolve symbol ::     }   }    case object MyNil extends MyList[Nothing] {     override def isEmpty: Boolean = true      override def tail: MyList[Nothing] = throw new NoSuchElementException("tail of MyNil")      override def head: Nothing = throw new NoSuchElementException("head of MyNil")   }    final case class ::[T](val head: T, val tail: MyList[T]) extends MyList[T] {     override def isEmpty: Boolean = false   }   object :: {     def apply[T](h: T, t: MyList[T]) = {       new ::(h, t)     }   }  } </code></pre>  <p>The compiler says it cannot resolve the symbol <code>::</code>.  If I use the prefix version instead of the infix version (the line is commented out), there is no error.</p>  <p>How can I solve this?</p>