<p>I have some classes <code>Daughter1</code> and <code>Daughter2</code> inherited from <code>Mother</code>:</p>  <pre><code>class   Mother { public:     Mother(); // Empty constructor.     virtual ~Mother(); // Delete common daughter's stuff.  protected:     // Common stuff of each daughter. }; </code></pre>  <p>The common stuff of every daughter class has the same deletion method, so the mother is in charge. However, their initialization is not the same, so they are in respective daughter's constructors:</p>  <pre><code>class   Daughter1 : public Mother { public:     Daughter1(); // Initialize mother's stuff     ~Daughter1(); };  class   Daughter2 : public Mother { public:     Daughter2(); // Initialize mother's stuff in a different way than Daughter1     ~Daughter2(); }; </code></pre>  <p>The problem is: sometimes, a daughter constructor can fail to load its stuff and throws an exception. And when I declare a Daughter like this:</p>  <pre><code>Daughter1   daughter; </code></pre>  <p>And the constructor throws an exception, it calls the mother's destructor, which try to delete its stuff without an initialization, that lead inevitably to a segmentation fault.</p>  <p>What is the best way to avoid this kind of trouble?</p>  <hr>  <p>Most of my stuff is composed of pointers, so I know I could simply initialize them to <code>nullptr</code> in the mother constructor and check them before trying a deletion in the destructor, but it only works with pointer and I'm looking for a global solution.</p>