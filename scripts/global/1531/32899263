<p>I'm taking a C++ class, and we're learning outdated C++ unfortunately. This question is specific and I couldn't just Google it. Thank you for answering.</p>  <p>How do I / can I access base privates from a derived ctor init-list? How do I / can I call a function from a derived ctor execution block?</p>  <p>point.h</p>  <pre><code>class Point {     const double x;     const double y; public:     Point () = delete;     Point ( Point &amp;&amp; other ) : x { other.x }, y { other.y } {}     explicit Point ( double xx, double yy) : x { xx }, y { yy }, {} </code></pre>  <p>city.h</p>  <pre><code>class City : public Point {     const std::string name; public:     City () = delete;     City ( City &amp;&amp; other )       : Point ( std::forward &lt; City &gt; ( other ) ) { name = other.name; }     // is other scrapped by the time I try to get the name?     explicit City ( double xx, double yy, std::string nname )       : Point ( xx, yy ) { name = nname; } </code></pre>  <p>(<code>explicit ctor</code> for ease of reference; it's the only explicit ctor I have)</p>  <p>In <code>City's explicit ctor</code> and <code>City's move ctor</code>, I get the same error: <strong>no overload found for <code>operator=</code></strong>. Ditto with <code>string::assign</code>, and every other string method. What's going on? <code>string</code> is included.</p>  <p>If I stick <code>protected:</code> in front of <code>Point's</code> privates and then try to initialize them in the <code>explicit City ctor</code> initialization list <code>x { xx }, .. name { nname } {}</code>, the error says <strong>x is not a member or base class</strong></p>