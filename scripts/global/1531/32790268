<p>I have a header file with a class called 'list' and a struct called 'node' within the private part of that class. Together, this class and struct will make up a doubly threaded list of winery objects (winery being it's own class). What I'm wondering is if it would be best to implement and de-implement the node struct's variables within the list constructor and deconstructor (like this):</p>  <pre><code>list::list() {     struct node     {         item = winery::winery()         nextByName = nullptr;         nextByRating = nullptr;     };     headByName = nullptr;     headByRating = nullptr; } list::~list() {     struct node     {         delete item;         delete nextByName;         delete nextByRating;     };     delete headByName;     delete headByRating; } </code></pre>  <p>if it would be better to implement and de-implement them separately (like this):</p>  <pre><code>list::node::node() {     item = winery::winery()     nextByName = nullptr;     nextByRating = nullptr; } list::node::~node() {     delete item;     delete nextByName;     delete nextByRating; } </code></pre>  <p>or if I should something else? I've looked online, and in my textbooks, but there really is no clear answer on this. I would really appreciate your guys help, and if you could explain why your solution is the best (if it is the best), I would be extremely grateful. I just started learning C++ a few months ago after all.</p>  <p>By the way, this is what my list.h file looks like:</p>  <pre><code>#include "winery.h"  class list { public:     list();     ~list();     void addWinery();     void removeWinery();     void displayByRating() const;     void displayByName() const;     void searchByName() const; private:     struct node     {         winery item;         node * nextByName;         node * nextByRating;     };      node * headByName;     node * headByRating; };  </code></pre>