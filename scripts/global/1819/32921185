<p>I'm currently developing an Android app that can track position. There are two parts of my app:</p>  <ol> <li>update data (longitude,latitude) to the server</li> <li>receive data from the server every 10 seconds and show it on <strong>googlemap(marker)</strong></li> </ol>  <p>My first part is done and in the second part I am getting a value from the server. But problem arises when I <code>sync</code> my map with new values â€“ every time it refreshes the whole map.</p>  <p>If anyone has any insight on how to achieve this effect of being able to run the android app and see the marker dynamically change, it would be much appreciated!</p>  <pre><code>public class user_page extends FragmentActivity implements OnMapReadyCallback { double longi=0,lati=0; int id=0; MapFragment mapFragment; public void onCreate(Bundle savedInstanceState) {     super.onCreate(savedInstanceState);      setContentView(R.layout.tim);      try     {        mapFragment = (MapFragment) getFragmentManager()                 .findFragmentById(R.id.map);      }     catch(Exception e)     {         Log.d("error",e.toString());     }     final Handler h = new Handler();     h.postDelayed(new Runnable() {          @Override         public void run() {             // TODO Auto-generated method stub              new logincheck().execute();                  Toast.makeText(getApplicationContext(),"longi = " + longi + "latii = " +lati,Toast.LENGTH_SHORT).show();             h.postDelayed(this, 10000);         }     }, 10000);   }   @Override public void onMapReady(GoogleMap googleMap) {       LatLng current = new LatLng(longi, lati);      googleMap.moveCamera(CameraUpdateFactory.newLatLngZoom(current, 13));      googleMap.addMarker(new MarkerOptions()             .title(""+id)             .position(current));    } // end of class user_page  public class logincheck extends AsyncTask&lt;String, Void, String&gt;  {       HashMap&lt;String, String&gt; data;     ArrayList&lt;HashMap&lt;String, String&gt;&gt; dataFromdb;      public logincheck()     {         dataFromdb = new ArrayList&lt;HashMap&lt;String, String&gt;&gt;();     }       @Override     protected String doInBackground(String... params) {         id = getIntent().getIntExtra("id",0);         StringBuilder result = new StringBuilder("");         String line ="";          HttpClient client = new DefaultHttpClient();         HttpGet httpget = new HttpGet("mylink?id=" +id);          try         {             HttpResponse responce = client.execute(httpget);             BufferedReader in = new BufferedReader(new InputStreamReader(responce.getEntity().getContent()));             while((line= in.readLine()) != null)             {                 result.append(line);             }             in.close();         }         catch(Exception e)         {             Log.e("error in do in background", e.getMessage());         }          return result.toString();     }       protected void onPostExecute(String result) {         ArrayList&lt;HashMap&lt;String, String&gt;&gt; mydata = parseJson(result);         for(int i=0;i &lt; mydata.size();i++)         {             longi = Double.parseDouble(mydata.get(i).get("logi"));             lati = Double.parseDouble(mydata.get(i).get("lati"));          }         try {             mapFragment.getMapAsync(user_page.this);         }         catch(Exception e)         {             Log.d("error",e.toString());         }      }      private ArrayList&lt;HashMap&lt;String, String&gt;&gt; parseJson(String stringdata)     {         dataFromdb.clear();         try         {               JSONArray jsonarray = new JSONArray(stringdata);             JSONObject jsondata = null;              for(int i=0;i&lt;jsonarray.length();i++)             {                 NumberFormat n = NumberFormat.getInstance();                 data = new HashMap&lt;String, String&gt;();                 jsondata = jsonarray.getJSONObject(i);                 data.put("logi",jsondata.getString("logi"));                 data.put("lati",jsondata.getString("lati"));                  dataFromdb.add(data);             }          }         catch(JSONException e)         {             Log.e("error in parsing ",e.getMessage());         }          return dataFromdb;     }   } } </code></pre>