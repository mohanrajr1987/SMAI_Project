<p>I'm trying to create a Delegate class that will act similarly to the C# one.</p>  <p>My goal is the following.</p>  <pre class="lang-cpp prettyprint-override"><code>void say() { std::cout &lt;&lt; "Hello, World!\n" &lt;&lt; std::endl; } int add(int n) { return n + 1; }  [...]  Delegate&lt;void&gt; s(say); s(); Delegate&lt;int, int&gt; * a = new Delegate&lt;int, int&gt;(add); </code></pre>  <p>I'm pretty close to a result that can handle both normal C function functions and C++ methods (by the way, I'm assuming C++11 standard). Here's what I've came to.</p>  <pre class="lang-cpp prettyprint-override"><code>template &lt;class R, class ...P&gt; class Delegate {     public:         template &lt;class F, class T&gt; Delegate(F method, T&amp; object)             : handler(MethodDelegate&lt;T, R, P...&gt;(method, object))         {}          template &lt;class T&gt; Delegate(T function)             : handler(FunctionDelegate&lt;R, P...&gt;(function))         {}          virtual ~Delegate() noexcept {}          virtual R run(P... args) const = 0;         inline R operator()(P... args) const         {             return this-&gt;run(args...);         }      private:         template &lt;class _T, class _R, class ..._P&gt; class MethodDelegate : public Delegate&lt;_R, _P...&gt;         {             public:                 MethodDelegate(_R (_T::*method) (_P...), _T&amp; object)                     : object(object), method(method)                 {}                 virtual ~MethodDelegate() noexcept {}                  _R run(_P... args) const                 {                     return (object.*method)(args...);                 }              private:                 _T&amp; object;                 _R (_T::*method) (_P...);         };          template &lt;class _R, class ..._P&gt; class FunctionDelegate : public Delegate&lt;_R, _P...&gt;         {             public:                 FunctionDelegate(_R (*function) (_P...))                     : function(function)                 {}                 virtual ~FunctionDelegate() noexcept {}                  _R run(_P... args) const                 {                     return (*function)(args...);                 }              private:                 _R (*function) (_P...);         };          Delegate&lt;R, P...&gt; handler; }; </code></pre>  <p>It compiles with <code>clang++ delegate.cpp --std=c++11</code> and <code>g++ delegate.cpp --std=c++11</code> but the problem comes when I try to edit the <code>main</code>:</p>  <pre class="lang-cpp prettyprint-override"><code>int main(int argc, char *argv[]) {     Delegate&lt;void&gt; s(say);     s(); } </code></pre>  <p>Clang++ says:</p>  <pre><code>delegate4.cpp:73:21: error: field has incomplete type 'Delegate&lt;void&gt;'             Delegate&lt;R, P...&gt; handler;                               ^ delegate4.cpp:109:17: note: in instantiation of template class 'Delegate&lt;void&gt;' requested here     Delegate&lt;void&gt; s(say);                    ^ delegate4.cpp:18:38: note: definition of 'Delegate&lt;void&gt;' is not complete until the closing '}' template &lt;class R, class ...P&gt; class Delegate : public Object                                      ^ 1 error generated. </code></pre>  <p>I guess I need to move the implementation of <code>FunctionMethod</code> and <code>DelegateMethod</code> classes outside (like I'd do with normal methods when splitting <code>.h</code> headers and <code>.cpp</code> codes) but I might be wrong.</p>  <p>Can someone help me please? If possible, I'd like not to modify the desing/inheritance pattern and with no external functions (that's why I used the constructors trick base on C++ template function "auto-guessing").</p>  <p>Thank for your patience and help and sorry for the long post.</p>  <h1>Edit</h1>  <p>As @chris pointed out in the comments, I'm trying to use a "raw object" of the same type of the class. A possible solution would be to use pointers, but this would require dynamic allocation I guess. Is there a way to do so <em>without</em> dynamic allocation? Moreover, does anyone knows how to do a third class called <code>LambdaDelegate</code> that keeps the sape hierarchy? Thank you :)</p>