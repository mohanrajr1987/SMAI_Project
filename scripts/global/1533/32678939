<p>I am stuck at an error that I can understand but cannot fix, it's a CS0123 error where parameters between a method and a delegate do not match. But I looked at my code and it seems to be the right type so I'm confused and ask for your help since I'm learning more advanced C# with this project. This project is about to generate an hex grid and then process an A* pathfinding on it between two hex tiles. I used <a href="https://tbswithunity3d.wordpress.com/" rel="nofollow">this serie of written tutorials</a> even if it's an old one and had to refresh a bit the code to make it work on Unity 5 and more recent version of C# .NET (I guess).</p>  <p>Here are the errors :</p>  <p><strong>Assets/Scripts/GridManager.cs(151,39): error CS0123: A method or delegate 'GridManager.calcDistance(Tile)' parameters do not match delegate 'System.Func()' parameters</strong></p>  <p><strong>Assets/Scripts/GridManager.cs(153,17): error CS1502: The best overloaded method match for 'GridManager.DrawPath(System.Collections.Generic.IEnumerable)' has some invalid arguments</strong></p>  <p><strong>Assets/Scripts/GridManager.cs(153,17): error CS1503: Argument '#1' cannot convert 'object' expression to type 'System.Collections.Generic.IEnumerable'</strong></p>  <p>I'm pretty sure that the two lasts are there only because of the first because it does not recognize the right var type that should be a Tile.</p>  <p>I hope you'll be able to help me and explain me what I did wrong. I think I do not entirely what's going on there.</p>  <p>Thank you in advance !</p>  <p>Here is some of my modified code but it's basically the same as the tutorial :</p>  <p>GridManager.cs :</p>  <pre><code>    double calcDistance(Tile tile)     {             Tile destTile = destTileTB.tile;             float deltaX = Mathf.Abs(destTile.X - tile.X);             float deltaY = Mathf.Abs(destTile.Y - tile.Y);             int z1 = -(tile.X + tile.Y);             int z2 = -(destTile.X + destTile.Y);             float deltaZ = Mathf.Abs(z2 - z1);              return Mathf.Max(deltaX, deltaY, deltaZ);     }      private void DrawPath(IEnumerable&lt;Tile&gt; path)     {             if (this.path == null)                     this.path = new List&lt;GameObject&gt;();             this.path.ForEach(Destroy);             this.path.Clear();              GameObject lines = GameObject.Find("Lines");             if (lines == null)                     lines = new GameObject("Lines");             foreach (Tile tile in path)             {                     var line = (GameObject)Instantiate(Line);                     Vector2 gridPos = new Vector2(tile.X + tile.Y / 2, tile.Y);                     line.transform.position = calcWorldCoord(gridPos);                     this.path.Add(line);                     line.transform.parent = lines.transform;             }     }      public void generateAndShowPath()     {             if (originTileTB == null || destTileTB == null)             {                     DrawPath(new List&lt;Tile&gt;());                     return;             }             Func&lt;Tile, Tile, double&gt; distance = (node1, node2) =&gt; 1;              var path = PathFinder.FindPath(originTileTB.tile, destTileTB.tile,                                            distance, calcDistance); //error is here             DrawPath(path);     } </code></pre>  <p>PathFinder.cs:</p>  <pre><code>    using System;     using System.Collections;     using System.Collections.Generic;     using System.Linq;      public static class PathFinder     {     public static Path&lt;Node&gt; FindPath&lt;Node&gt;(             Node start,             Node destination,             Func&lt;Node, Node, double&gt; distance,             Func&lt;Node&gt; estimate)             where Node : IHasNeighbours&lt;Tile&gt;     {             var closed = new HashSet&lt;Node&gt;();             var queue = new PriorityQueue&lt;double, Path&lt;Node&gt;&gt;();             queue.Enqueue(0, new Path&lt;Node&gt;(start));              while (!queue.IsEmpty)             {                     var path = queue.Dequeue();                      if (closed.Contains(path.LastStep))                             continue;                     if (path.LastStep.Equals(destination))                             return path;                      closed.Add(path.LastStep);                      foreach (Node n in path.LastStep.Neighbours)                     {                             double d = distance(path.LastStep, n);                             var newPath = path.AddStep(n, d);                             queue.Enqueue(newPath.TotalCost + estimate(n), newPath);                     }             }              return null;     }     } </code></pre>