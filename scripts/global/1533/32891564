<p>Say I have a method that calls another method that accepts a string and returns a string, over and over until a condition is met:</p>  <pre><code>public string RetryUntil(     Func&lt;string, string&gt; method,     string input,     Func&lt;string, bool&gt; condition,     TimeSpan timeSpan) {     Stopwatch stopwatch = new Stopwatch();     stopwatch.Start();      string response = string.Empty;     bool conditionResult = false;      while (stopwatch.Elapsed &lt; timeSpan &amp;&amp; conditionResult != true)     {         result = method(input);         conditionResult = condition(result);         Thread.Sleep(TimeSpan.FromSeconds(0.5));     }      return response; } </code></pre>  <p>It really feels like I should be able to specify the 'method' and 'input' parameters as one parameter. So, I want to refactor it so I am able to call it like this, for example:</p>  <pre><code>RetryUntil(     ConvertString("hello World"),     (str) =&gt; { return str == "whatever"; },     TimeSpan.FromSeconds(10)); </code></pre>  <p>But obviously, this would pass the result of calling the ConvertString method, (rather than just a delegate to that method) into the Retry method. Is there a way to pass both delegates and specific parameters for those delegates as one? Am I thinking about the entire problem backwards? It just feels a bit inelegant the way I'm doing it now.</p>