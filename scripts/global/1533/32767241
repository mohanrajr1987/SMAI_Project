<p>C# delegates are immutable, so when you add or remove a function from the delegate, it is replaced by a new object.</p>  <p>Considering the following piece of code:</p>  <pre><code>lock(shared_instance.my_delegate){   shared_instance.my_delegate+=Foo; } </code></pre>  <p>Consider the following situation:</p>  <p>Threads 1 and 2 arrive at the lock, thread 2 blocks on the delegate instance, let's call it <code>A</code>.</p>  <p>Thread 1 replaces <code>A</code> with a new instance, <code>B</code>, and exits the lock.</p>  <p>Does thread 2 acquire lock on <code>B</code> or on <code>A</code>? If it's on <code>A</code>, then it seems to me that thread 3 could come along, acquire a lock on <code>B</code> at the same time when thread 2 acquires a lock on <code>A</code>, and they could simultaneously try to overwrite the deleage and a race would occur, correct?</p>  <p>EDIT:</p>  <p>I now realize that the question could be generalized to any reference type:</p>  <pre><code>lock(shared_ref){   shared_ref=different_ref; } </code></pre>  <p>Basically what I want to know is: If this happens, waiting threads will still lock on the old reference, yes?</p>