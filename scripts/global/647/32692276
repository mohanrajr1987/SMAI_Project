<p>In my project, users are able to upload documents. I would like to create a query, which would give me details about documents for a specific user, or rather each user. I would like to use projections to get a list of transport objects "ContractorDocumentSummary"</p>  <p>Here is the ContractorDocument entity:</p>  <pre><code>@Entity public class ContractorDocument extends BaseVersionedAuditableEntity {      @Id     @GeneratedValue     private Long id;      private Boolean defaultDocument;      private Boolean fileDocument;      private String name;      private String description;      @OneToMany(mappedBy = "contractorDocument")     private List&lt;ContractorDocumentFile&gt; documentFiles;      // klucz obcy do ContractorProfile na potrzeby odczytu     @Column(insertable = false, updatable = false, name = "contractorProfile_id")     private Long contractorProfileId;      @ManyToOne(fetch = FetchType.LAZY)     private ContractorProfile contractorProfile;      @ManyToOne(fetch = FetchType.EAGER)     private ContractorDocumentType documentType;      public Long getId() {         return id;     }      public void setId(Long id) {         this.id = id;     }      public Boolean getDefaultDocument() {         return defaultDocument;     }      public void setDefaultDocument(Boolean defaultDocument) {         this.defaultDocument = defaultDocument;     }      public Boolean getFileDocument() {         return fileDocument;     }      public void setFileDocument(Boolean fileDocument) {         this.fileDocument = fileDocument;     }      public String getName() {         return name;     }      public void setName(String name) {         this.name = name;     }      public String getDescription() {         return description;     }      public void setDescription(String description) {         this.description = description;     }      public List&lt;ContractorDocumentFile&gt; getDocumentFiles() {         return documentFiles;     }      public void setDocumentFiles(List&lt;ContractorDocumentFile&gt; documentFiles) {         this.documentFiles = documentFiles;     }      private List&lt;ContractorDocumentFile&gt; getNonNullDocumentFiles() {         List&lt;ContractorDocumentFile&gt; files = this.getDocumentFiles();         if (files == null) {             files = new ArrayList&lt;&gt;();             this.documentFiles = files;         }         return files;     }      /**      * Dodanie dokumentu do profilu kontraktora.      * @param documentFile dokument kt√≥ry dodajemy      */     public void addDocumentFile(ContractorDocumentFile documentFile) {         getNonNullDocumentFiles().add(documentFile);         ContractorDocument prevDoc = documentFile.getContractorDocument();         if (prevDoc != this) {             documentFile.setContractorDocument(this);         }     }      public Long getContractorProfileId() {         return contractorProfileId;     }      public void setContractorProfileId(Long contractorProfileId) {         this.contractorProfileId = contractorProfileId;     }      public ContractorProfile getContractorProfile() {         return contractorProfile;     }      public void setContractorProfile(ContractorProfile contractorProfile) {         this.contractorProfile = contractorProfile;     }      public ContractorDocumentType getDocumentType() {         return documentType;     }      public void setDocumentType(ContractorDocumentType documentType) {         this.documentType = documentType;     } } </code></pre>  <p>and the transport object:</p>  <pre><code>    public class ContractorDocumentsSummary {  private Long idAvg; private Long idSum; private int count; private Long contractorProfileId;      public ContractorDocumentsSummary(Long idAvg, Long idSum, int count, Long contractorProfileId) {         this.idAvg = idAvg;         this.idSum = idSum;         this.count = count;         this.contractorProfileId = contractorProfileId;     }      public Long getIdAvg() {         return idAvg;     }      public void setIdAvg(Long idAvg) {         this.idAvg = idAvg;     }      public Long getIdSum() {         return idSum;     }      public void setIdSum(Long idSum) {         this.idSum = idSum;     }      public int getCount() {         return count;     }      public void setCount(int count) {         this.count = count;     }      public Long getContractorProfileId() {         return contractorProfileId;     }      public void setContractorProfileId(Long contractorProfileId) {         this.contractorProfileId = contractorProfileId;     } } </code></pre>  <p>and now goes the query:</p>  <pre><code>public interface ContractorDocumentRepository extends JpaRepository&lt;ContractorDocument, Long&gt; {       @Query("SELECT new ContractorDocumentsSummary(avg(p.id), sum(p.id), count(p.id), "             + "p.contractorProfileId) FROM ContractorDocument p GROUP BY p.contractorProfileId")     List&lt;ContractorDocumentsSummary&gt; findDocsSummaryForContractors();      //JOIN ContractorProfile prof WHERE (p.contractorProfileId = prof.id) } </code></pre>  <p>the JOIN clause is commented and pasted below, because I thought it might be the problem, but apparently it is not. The ContractorDocument entity has no direct relation to ContractorProfile, only the id is kept.</p>  <p>Obviously the query is not what I want it to be, but I started with something simple, and even that does not work. In later version I will want to add at least 2 JOIN clauses- one for ContractorProfile (I will want to use it to limit the number/size of documents per user) and the other one for FileEntryInfo, which is another entity, which keeps some file info like size, type etc.</p>  <p>My problem is, I obviously have some syntax error, as I keep getting exceptions like </p>  <pre><code>java.lang.IllegalArgumentException: Validation failed for query for method public abstract java.util.List myprojectpath.ContractorDocumentRepository.findDocsSummaryForContractors()! </code></pre>  <p>It is the first time that I try to use aggregate functions with JPQL. JPQL gives me a headache in general, but this I've been fighting for hours and can't find a solution. I bet it's something simple, any help appreciated ;)</p>  <p><strong>edit:</strong> </p>  <p>please excuse the comments in Polish, they are irrelevant.</p>  <p><strong>next edit:</strong></p>  <p>I managed to get it working. There were 2 problems needed solving. One was the use of constructor in the query. You need to use it like so: </p>  <pre><code>"SELECT new org.foo.userprofile.domain.ContractorDocumentsSummary(avg(p.id), sum(p.id), count(p.id), "         + "p.contractorProfileId) FROM ContractorDocument p GROUP BY p.contractorProfileId"  </code></pre>  <p>the full package path is needed for this to work.</p>  <p>Second thing was the the Transport object itself. After I changed the usage of constructor to the proper one, I got a new exception which said that "no constructor with valid arguments was found (double, long, long, long)".</p>  <p>The tricky part was, that it actually expected (Double, Long, Long, Long), which is obviously not the same.</p>  <p>Anyways, after I got it working, or rather not throwing compilation errors, it works different than expected. With the query being:</p>  <p>@Query("SELECT new org.foo.userprofile.domain.ContractorDocumentsSummary(avg(p.id), sum(p.id), count(p.id), "             + "p.contractorProfileId) FROM ContractorDocument p GROUP BY p.contractorProfileId")     List findDocsSummaryForContractors();</p>  <p>and the testing code:</p>  <pre><code>        for (int i=0; i&lt;1000; i++) {         ContractorDocument document = new ContractorDocument();         int n = i/20;         document.setContractorProfileId(new Long(n));         contractorDocumentRepositoryTestService.save(document);     }         List&lt;ContractorDocumentsSummary&gt; docList = contractorDocumentRepositoryTestService.findDocsSummaryForContractors();     Assert.assertEquals(50, docList.size()); </code></pre>  <p>The problem being, docList.size() equals 1 instead of 50 as expected. I don't know why that is so, but apparently I get only 1 object instead of 50. Any ideas?</p>