<p>Simple grails app works wrong with following entity structure</p>  <pre><code>abstract class EntityBase { .... static mapping = {     table 'test'     discriminator value: '0', type: 'byte', column:'class_type'   } }   class EntityA extends EntityBase {   static mapping = {     cache 'nonstrict-read-write'     discriminator value: '1', type: 'byte', column:'class_type'   } }  class EntityB extends EntityBase {   static mapping = {     cache 'nonstrict-read-write'     discriminator value: '2', type: 'byte', column:'class_type'   } }  class HolderEntity {   EntityBase holdedEntity    static mapping = {     cache 'nonstrict-read-write'   } } </code></pre>  <p>For first load or without cache everything works well</p>  <p>After loading of HolderEntity instance from cache, holdedEntity field initialised by object with type EntityBase (abstract class). </p>  <p><strong>Pseudocode:</strong></p>  <pre><code>def a = HolderEntity.get(1) assert a.holdedEntity.class!=EntityBase //ok a = HolderEntity.get(1) // load from cache assert a.holdedEntity.class!=EntityBase //fails </code></pre>  <p>During loading from cache hibernate construct entity using special logic: for field it detect class type by variable type (it's EntityBase class) instead of discriminator (<em>final Type[] types = subclassPersister.getPropertyTypes();</em> in <strong>DefaultLoadEventListener</strong>) and call method<br> <strong>SessionImpl.internalLoad(String entityName, Serializable id, boolean eager, boolean nullable)</strong> witch "instantiate" abstract class and init fields by data from hibernate cache  </p>  <p>It works same for lazy &amp; eager loading of holdedEntity Class type stored in <strong>AbstractEntityPersister.EntityMetamodel</strong>. It looks like, field type for cache is static, but it's should depend on instance of field</p>  <p>How to solve it without disabling of hibernate L2 cache?</p>  <p>Hibernate 4.3.8 (4.3.6 &amp; 4.3.11 tested also)</p>  <p>Grails 2.4.5</p>