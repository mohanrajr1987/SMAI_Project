<p>Our Django app has a custom user model that looks like this:</p>  <pre><code>class OurCustomUser(AbstractBaseUser, PermissionsMixin):     id = models.CharField(max_length=11, unique=True, db_index=True)     # This will be populated using a database function which selects a sequential number using the common_counter table     primary_key = models.IntegerField(primary_key=True)     username = models.EmailField(max_length=254, unique=True, db_index=True)     ... </code></pre>  <p>and we have a <code>Student</code> model that attaches profile information to a user that looks like this:</p>  <pre><code>class Student(DirtyFieldsMixin, UploadPhotoMixin, models.Model):     id = models.CharField(verbose_name='ID', serialize=False, max_length=255, primary_key=True)     user = models.OneToOneField(OurCustomUser)     ... </code></pre>  <p>We are seeing a number of n+1 query cases. We can usually solve them by using <code>.values_list('field', 'field2', 'etc')</code> but we aren't clear how to fix this inside the models so we don't have to worry about these problems cropping up again. There's a fair bit of non-standard stuff going on with the second <code>primary_key</code> field and the <code>serialize=False</code> which may be affecting us when converting to JSON (most of our content is served out via a REST API). Is there an obvious problem with the current structure? Putting a breakpoint in when these issues happen, we see when that method attempts to match <code>student.User</code> key with its value it makes that extra query because value is <code>user_id</code> not an <code>User</code> object.</p>