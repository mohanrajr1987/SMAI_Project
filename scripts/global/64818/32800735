<p>In my game I have currently two screens. The <code>MenuScreen</code> and the <code>GameScreen</code>. Through the Play option in the menu the player can switch to the GameScreen and start the Gameplay and with Escape he can get back to the MenuScreen. I dispose the used Assets when I switch to the other Screen in the <code>hide()</code> method and load the needed Assets for the new Screen in the constructor of the Screen I switch to. The problem is that the Textures and Sound Effects aren't rendered/played when I switch back.  For example when I start the game in the <code>MenuScreen</code>, then switch to the <code>GameScreen</code> everything is fine. But when I switch back to the <code>MenuScreen</code> the <code>MenuScreen</code> is just a black window. When I then switch to the <code>GameScreen</code> again it's black too except for the BitmapFont. Maybe there is a fundemental flaw in the way I handle this. I tried to leave out as much unnecessary things as I can from the code I post here, but I fear that it's still too much.</p>  <p>RessourceLoader Class:</p>  <pre><code>public class RessourceLoader {      public static AssetManager manager;       public static void create() {         manager = new AssetManager();     }      public static void loadMenuScreen() {         manager.load("gfx/menuBackground.png", Texture.class);     }      public static void getMenuScreen() {         menuBackground = manager.get("gfx/menuBackground.png", Texture.class);     }      public static void disposeMenuScreen() {         menuBackground.dispose();     }      public static void loadGameScreen() {         // load GameScreen Assets through AssetManager     }      public static void getGameScreen() {         // get GameScreen Assets through AssetManager     }      public static void disposeGameScreen() {         // dispose all GameScreen Assets     }      public static void dispose() {         manager.dispose();     } } </code></pre>  <p>MenuScreen Class:</p>  <pre><code>public class MenuScreen implements Screen {      // Game starts in the MenuScreen      // Instance of game     private PHGame game;     // Orthographic camera     private OrthographicCamera cam;      public MenuScreen(PHGame phGame) {         game = phGame;               RessourceLoader.loadMenuScreen();         RessourceLoader.manager.finishLoading();         RessourceLoader.getMenuScreen();          cam = new OrthographicCamera();         cam.setToOrtho(true, 640, 480);          game.batcher.setProjectionMatrix(cam.combined);     }      @Override     public void render(float delta) {          // Fills background with black to avoid flickering         Gdx.gl.glClearColor(0, 0, 0, 1);         Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);          // Begin Drawing         game.batcher.begin();                // Draw Menu          // Stop drawing         game.batcher.end();          // Pressing Space confirms currently selected menu item         if (GameKeys.isPressed(GameKeys.SPACE)) {             game.setScreen(new GameScreen(game));         }          // Update Key Presses         GameKeys.update();     }      @Override     public void hide() {         dispose();     }      @Override     public void dispose() {         RessourceLoader.disposeMenuScreen();     } } </code></pre>  <p>GameScreen Class:</p>  <pre><code>public class GameScreen implements Screen {      // Instance of game     private PHGame game;      private GameWorld world;     private GameRenderer renderer;     private float runTime;       public GameScreen(PHGame phGame) {         game = phGame;         RessourceLoader.loadGameScreen();         RessourceLoader.manager.finishLoading();         RessourceLoader.getGameScreen();         world = new GameWorld(game, this);         renderer = new GameRenderer(world, game);     }      @Override     public void render(float delta) {         // runTime is the amount of time the game is running         runTime += delta;         // Updates the Game World         world.update(delta);         // Renders everything         renderer.render(runTime);         // Update Key Presses         GameKeys.update();     }      @Override     public void hide() {         dispose();     }      @Override     public void dispose() {         RessourceLoader.disposeGameScreen();     } } </code></pre>  <p>GameRenderer Class:</p>  <pre><code>public class GameRenderer {      // Instance of PHGame     PHGame game;     // Instance of Game World     private GameWorld world;     // Orthographic Camera     private OrthographicCamera cam;      // If true hitbox's will be shown     private boolean showHitbox;      // Game Objects     private Player player;      public GameRenderer(GameWorld world, PHGame game) {         this.game = game;         this.world = world;         player = world.getPlayer();         cam = new OrthographicCamera();         cam.setToOrtho(true, 640, 480);         showHitbox = false;          game.batcher.setProjectionMatrix(cam.combined);     }      public void render(float runTime) {         // draw objects and hud           } } </code></pre>  <p>If there are any questions regarding my problem I'll try to answer then as good as I can.</p>