<p>here the situation:</p>  <p>i got some beans (called Systems). These beans work with external system to gather data and do more (like analyze them, or store them in database etc.). These systems also got some beans to do the work (the work called before, gather / read, analyze, store, etc).</p>  <p>I got a spring context xml where these beans (systems) are defined like:</p>  <pre><code>&lt;bean id="SomeSystem" class"..."/&gt; </code></pre>  <p>All these systems have the same Interface...let's call it "MommyInterfaceSystem"... And i got also a simple util:list config, like this:</p>  <pre><code>&lt;util:list id="MyAwesomeSystemsList"&gt;   &lt;ref bean="SomeSystem"/&gt;   &lt;ref bean="AnotherSystem"/&gt;   ... &lt;/util:list&gt; </code></pre>  <p>As you can see i got some "Systems" like "SomeSystem" and "AnotherSystem" - both implementing "MommyInterfaceSystem"...whatever...</p>  <p>These systems are get called over another Class. Let's call it "GatherInformationFromSystems".</p>  <p>This class has this structure:</p>  <pre><code>public class GatherInformationFormSystems {   @Resource(name "MyAwesomeSystemsList")   private final List&lt;MommyInterfaceSystem&gt; informationSystems = new ArrayList&lt;MommyInterfaceSystem&gt;();    public void execute() {     ...     for(MommyInterfaceSystem s : informationSystems) {       ...       s.gatherInformation();       ...     }     ...   } } </code></pre>  <p>And now i want to test the results of this process! And here we arrive the my problem.</p>  <p>I wrote a simple unit test to execute the process of gathering information. This process works and it is fine. I wrote many test for this process and it works greats but if i want to mock an external system (because i want to predefine the return value) it fails...</p>  <p>If i call the gather bean directly (not over the util:list...it works...but then the other actions like analyze or store won't get called...).</p>  <p>I have to do something like this:</p>  <p>If AnotherSystem of informationSystems is calling the "gatherInformation" method of - it is gonna call another method (let's call it "doCall").</p>  <p>And i want to mock this method. The method <code>doCall</code>.</p>  <p>All should be the same, except this method (<code>doCall</code>). Here i want to return a predefined Object. </p>  <p>Sry for this bad explanation, my english is damn bad...but i hope you will understand my problem :/</p>  <hr>  <p>here i can list what i tried...</p>  <ol> <li><p>i tried to get the system from the list with reflections and replaced it with a mock...the result is a nullpointer exception because of missing autowired beans...</p></li> <li><p>I autowired the bean directly and tried to mock it:</p>  <pre><code>Mockito.when(anotherSystem.doCall(Mockito.anyString()).thenReturn(data); </code></pre></li> <li><p>I tried to create the object with EasyMock.mock...also failed</p></li> </ol>  <hr>  <p>I didn't try to create a xml context to override the bean definition with own bean, because the system contains many other method which get called...and...yeah...pity...</p>