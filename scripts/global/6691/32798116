<p>Consider the following sample <code>MockUp</code> of a class <code>Foo</code> that intercepts <code>Bar</code> in the constructor and then implements <code>toString()</code> in terms of <code>Bar</code>;</p>  <pre class="lang-java prettyprint-override"><code>public class FooStub extends MockUp&lt;Foo&gt; {      private Bar bar;      @Mock     public void $init(Bar bar) {         this.bar = bar;     }      @Mock     public String toString() {         return bar.toString();     } } </code></pre>  <p>If <code>Foo</code> happens to override <code>toString()</code> all works fine. Otherwise though, you get a <code>IllegalArgumentException</code> : "Matching real methods not found for the following mocks". I understand from here that JMockit does not look in base classes and therefore cannot find a <code>toString()</code> method to mock.</p>  <p>Assuming I can't modify the Foo class (in reality I can, but just for the sake of argument), is there any way to mock <code>toString()</code> just for this <code>Foo</code> class? </p>  <p>To be clear, I want to mock all instances of this class, not just one instance (that has easy solutions that do no require a <code>MockUp</code>).</p>