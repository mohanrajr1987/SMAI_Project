<p>I'm using the <code>retry</code> decorator in some code in python. But I want to speed up my tests by removing its effect.</p>  <p>My code is:</p>  <pre><code>@retry(subprocess.CalledProcessError, tries=5, delay=1, backoff=2, logger=logger) def _sftp_command_with_retries(command, pem_path, user_at_host):     # connect to sftp, blah blah blah     pass </code></pre>  <p>How can I remove the effect of the decorator while testing? I can't create an undecorated version because I'm testing higher-level functions that use this.</p>  <p>Since <code>retry</code> uses <code>time.sleep</code> to back off, ideally I'd be able to patch <code>time.sleep</code> but since this is in a decorator I don't think that's possible.</p>  <p>Is there any way I can speed up testing code that uses this function?</p>  <p><strong>Update</strong></p>  <p>I'm basically trying to test my higher-level functions that use this to make sure that they catch any exceptions thrown by <code>_sftp_command_with_retries</code>. Since the <code>retry</code> decorator will propagate them I need a more complicated mock.</p>  <p>So from <a href="http://stackoverflow.com/questions/7667567/can-i-patch-a-python-decorator-before-it-wraps-a-function">here</a> I can see how to mock a decorator. But now I need to know how to write a mock that is itself a decorator. It needs to call <code>_sftp_command_with_retries</code> and if it raises an exception, propagate it, otherwise return the return value.</p>  <p>Adding this after importing my function didn't work:</p>  <pre><code>_sftp_command_with_retries = _sftp_command_with_retries.__wrapped__  </code></pre>