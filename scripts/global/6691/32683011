<p>I am pretty familiar with unit testing and do understand the difference between mocks and stubs. The simplest explanation from Roy Osherove is that all fakes start out as stubs until you assert against them, then they are mocks.</p>  <p>Again, I get all that. My question is "Is it wrong to use a single fake instance as both a mock and a stub? Take the following example from the Rhino Mocks documentation (<a href="http://ayende.com/wiki/Rhino+Mocks+3.5.ashx" rel="nofollow">http://ayende.com/wiki/Rhino+Mocks+3.5.ashx</a>)</p>  <pre><code>public void When_user_forgot_password_should_save_user() {   var mockUserRepository = MockRepository.GenerateMock&lt;IUserRepository&gt;();   var stubbedSmsSender = MockRepository.GenerateStub&lt;ISmsSender&gt;();    var theUser = new User{HashedPassword = "this is not hashed password"};        mockUserRepository.Stub(x =&gt; x.GetUserByName("ayende")).Return(theUser);    mockUserRepository.Expect( x =&gt; x.Save(theUser) );    var controllerUnderTest = new LoginController(mockUserRepository, stubbedSmsSender);    controllerUnderTest.ForgotMyPassword("ayende");    mockUserRepository.VerifyAllExpectations(); } </code></pre>  <p>You'll notice that the mockUserRepository is named with the word mock and is calling the GenerateMock factory because further down in the code the mockUserRepository has a behavioral expectation established for it and eventually that expectation of behavior is being verified. Great, but along the way the mockUserRepository is calling its Stub() method to "can" the data returned by calls to GetUserByName() on the same object.</p>  <p>Clearly, this example shows using an explicitly named and declared mock as both a mock and a stub.  Going back to Roy Osherove's definition that all fakes are stubs until you assert against them, I am forced to believe that using a fake as both a mock and a stub (while certainly works) is bad practice.</p>  <p>Does anyone know if there is a verdict on doing this?</p>