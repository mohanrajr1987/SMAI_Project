<p>I am having trouble getting my head around unit testing with Mock in Python.  I have a method <code>start_thing()</code> in a class I'd like to test: </p>  <pre><code>class ComplexClass:    def __init__(self, lots, of, args):        self.lots = lots        ..     def start_thing(self):         import pdb; pdb.set_trace()         print "some error!!"         assert False </code></pre>  <p>The class this belongs to is quite complex and a pain to try and mock manually. That is why I started to look at using Mock.</p>  <p>I would like to setup a mock that Mocks an instance of this class to make it easy to run a unittest, but not mock the method <code>start_thing()</code> so that the real <code>start_thing()</code> implementation is tested, not a mocked version .. so I created this:</p>  <pre><code>class TestComplexClass(TestCase):      @patch.object(module.ComplexClass, 'start_thing')      def test_start_thing(self, mock_method):         ComplexClass.start_thing() </code></pre>  <p>When running my test the debug trace, assert or print are not hit in my real method <code>start_thing()</code>, which suggests I have mocked the class and the method - where I just want to mock the object and test the real methods. What am I doing wrong here? Is that possible?</p>  <p>I have found lots of examples with Mock showing how to create a mock version of the method I want to test, which I think is kind of pointless since I don't want to check if it's being called correctly, rather I want to test the implementation in the real code, and mock the class it belongs to so it's easier to create.</p>  <p>Perhaps there's something I don't understand about the Mock testing idea as a whole?</p>