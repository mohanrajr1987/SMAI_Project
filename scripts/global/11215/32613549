<p>I'm implementing an event aggregator similar to these:</p>  <p><a href="http://udidahan.com/2009/06/14/domain-events-salvation/" rel="nofollow">http://udidahan.com/2009/06/14/domain-events-salvation/</a> <a href="http://www.bjoernrochel.de/2009/07/20/diving-into-the-storyteller-trunk-part-5-the-eventaggregator/" rel="nofollow">http://www.bjoernrochel.de/2009/07/20/diving-into-the-storyteller-trunk-part-5-the-eventaggregator/</a></p>  <p>The gist of it is, I have an Open generic interface IHandles where T is EventArgs.  </p>  <pre><code>public interface IHandles&lt;T&gt; where T : EventArgs {     void Handle(T args); } </code></pre>  <p>I have an EventDispatcher:</p>  <pre><code>public class StructureMapEventDispatcher : IEventDispatcher {     private readonly IContainer _container;      public StructureMapEventDispatcher(IContainer container)     {         _container = container;     }      public void Dispatch&lt;TEvent&gt;(TEvent eventToDispatch) where TEvent : EventArgs     {         foreach (var handler in _container.GetAllInstances&lt;IHandles&lt;TEvent&gt;&gt;())         {             handler.Handle(eventToDispatch);         }     } } </code></pre>  <p>Any time I call </p>  <pre><code>eventDispatcher.Dispatch&lt;MyEventType&gt;(eventArgsInstance) </code></pre>  <p>StructureMap looks in the container and gets me types that Implement IHandler and calls the handle method on them.</p>  <p>Works great.... Except for one of my events, (which has multiple subscribers) one of the subscribers needs to maintain internal state as it is aggregating data from multiple publishers, and therefore this aggregator needs to be a singleton.</p>  <p>Presently my registry looks like this:</p>  <pre><code>        Scan(scanner =&gt;             {                 scanner.AssemblyContainingType&lt;SupplyAndDemandZoneScanner&gt;();                 scanner.WithDefaultConventions();                 scanner.ConnectImplementationsToTypesClosing(typeof(IHandles&lt;&gt;));             });             For&lt;ZoneAggregator&gt;().Singleton().Use&lt;ZoneAggregator&gt;(); </code></pre>  <p>ZoneAggregator Implements <code>IHandle&lt;ZoneSectorFound&gt;</code> as do a couple of other classes.</p>  <p>Every time I'm calling eventDispatcher.Dispatch(myArgs) its making a new ZoneAggregator - even upon repeated requests, debugging from within the constructor shows a new object being created every time.  Not only is this breaking my application due to the inability for the ZoneAggregator class to maintain state between events.  But it would also indicate that every event that gets raised by this method is producing a new object, which seems completely wasteful.</p>  <p>How can I configure StructureMap to re-use objects when requested by open generic types - yet with multiple concrete types per open generic?  I'm writing in .net 3.5 and am therefore using Structuremap 2.6.3</p>