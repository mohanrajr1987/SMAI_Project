<p><strong>Introduction</strong></p>  <p>I'm working on an application using an entity component system.  The system relies heavily on two abstract classes, Component and Processor, which share a one to one relationship.  Each Processor implements a basic Subscriber interface allowing the EventManager class to notify them when a new Event is created.</p>  <p><strong>Events</strong></p>  <p>I have an Event abstract class which stores event type ID, like so:</p>  <pre><code>public abstract class Event {      public static final int NONE = 0;      private final int eventID;      public Event(int eventID) {         this.eventID = eventID;     }      public int getEventID() {         return eventID;     } } </code></pre>  <p>Then I have a Factory type class that extends Event, like so:</p>  <pre><code>public abstract class BaseEvents extends Event {      public static final int TRANSFORM = 1;      public BaseEvents(int eventID) {         super(eventID);     }      public static class Transform extends BaseEvents {          private final float rotation,                 tx,                 ty;          public Transform(float rotation, float tx, float ty) {             super(TRANSFORM);             this.rotation = rotation;             this.tx = tx;             this.ty = ty;         }          public float getRotation() {             return rotation;         }          public float getTx() {             return tx;         }          public float getTy() {         return ty;         }     } } </code></pre>  <p>I'm trying to allow the ability to create new events simply by further extending BaseEvents.  I'm using static inner classes mostly for organization. I don't want to create a separate class for every event.</p>  <p><strong>Event Handlers</strong></p>  <p>To avoid hard-coding handling of each Event in a given Processor I'm using an EventHandler class.  My plan was to have one EventHandler class per Event.  Again I'm using static inner classes for organization.</p>  <p>Here's the EventHandler abstract class:</p>  <pre><code>public abstract class EventHandler {      public void handle(Event event, Component component) {     } } </code></pre>  <p>Here's the BaseEventHandlers "Factory" class:</p>  <pre><code>public class BaseEventHandlers extends EventHandler {      public static class Transform extends BaseEventHandlers {          @Override         public void handle(Event event, Component component) {             BaseEvents.Transform e = (BaseEvents.Transform) event;             RenderComponent c = (RenderComponent) component;             c.setRotation(e.getRotation());             c.setTx(e.getTx());             c.setTy(e.getTy());         }     } } </code></pre>  <p>The example code I'm showing is for a RenderComponent / RenderProcessor pairing.  We care about Transform events because they tell us where to repaint an object.</p>  <p>When EventManager notifies RenderProcessor of a new event, we check a Map using the Event ID to obtain the appropriate EventHandler, invoking its handle method. Note, Events are actually stored in a Processor's queue and processed during an update call, like so:</p>  <pre><code>... protected final Map&lt;Integer, EventHandler&gt; eventHandlers = new HashMap&lt;&gt;(); ...     @Override     public void update() {         events.stream()                 .forEach(event -&gt; {                     eventHandlers.get(event.getEventID()).handle(event, components.get(event.getSourceEntityID()));                 });         events.clear();     } ... </code></pre>  <p><strong>My Problem</strong></p>  <p>In the EventHandler, I need to cast both the Event and the Component abstract classes into appropriate concrete classes.  I'm OK with being limited to one type of Event, but I can't limit myself to one type of Component.  What I want is to use Polymorphism and Overloading so that I have something like:</p>  <pre><code>    ...         public void handle(Event event, RenderComponent component) {             BaseEvents.Transform e = (BaseEvents.Transform) event;             component.setRotation(e.getRotation());             component.setTx(e.getTx());             component.setTy(e.getTy());         }          public void handle(Event event, OtherComponent component) {             BaseEvents.Transform e = (BaseEvents.Transform) event;             component.setRotation(e.getRotation());             component.setTx(e.getTx());             component.setTy(e.getTy());         }     ... </code></pre>  <p>This won't work because I only have access to the handle(Event event, Component component) method of the abstract class (overloading doesn't seem to care about the subclass).  One idea was to create an interface like Transformable and have RenderComponent and OtherComponent implement it.  This works when the data contained in the event is applicable to both Components, but it would be very easy for that not to be the case with some Events.  </p>  <p>For example, say I have an event for closing a window called WindowClosed.  I need to play a sound, draw a closing animation, and update the number of open windows.  That's one event three different Components/Processors need to process.  In this example, the only interface that would work would be one that covered all methods needed by each Component, which (in my opinion) leads to messy, messy spaghetti code.</p>  <p>Is there perhaps a clever way to solve this using Generics?</p>