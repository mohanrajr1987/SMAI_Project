<p><a href="https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%_sec_3.3" rel="nofollow">SICP question 3.25</a> states:</p>  <blockquote>   <p>[S]how how to implement a table in which values are stored under an arbitrary number of keys and different values may be stored under different numbers of keys. The lookup and insert! procedures should take as input a list of keys used to access the table.</p> </blockquote>  <p>Here a table is a data structure where an arbitrary amount of keys can be used to retrieve a value. E.g., in</p>  <pre><code>(define t (make-table)) (define get (t 'lookup-proc)) (define put (t 'insert-proc!)) </code></pre>  <p>The following code should put the symbol 'hello after the key 'a 'b 'c:</p>  <pre><code>(put (list 'a 'b 'c) 'hello) (get (list 'a 'b 'c)) ; =&gt; 'hello </code></pre>  <p>Inspired by a <a href="http://community.schemewiki.org/?sicp-ex-3.25" rel="nofollow">solution</a> I am using the following <code>insert-proc</code> procedure:</p>  <pre><code>(define (insert! keys value)  (define (foldl op acc lst)    (if (null? lst)        acc        (foldl op (op acc (car lst)) (cdr lst))))  (define (descend table key)    (let ((record (assoc key (cdr table))))      (if record          record          (let ((new (cons (list key) (cdr table))))            (set-cdr! table new)            (car new)))))  (set-cdr! (foldl descend local-table keys) value)) </code></pre>  <p>(Full code I am using can be found in <a href="https://gist.github.com/anonymous/8c40257842788c464457" rel="nofollow">this gist</a>.)</p>  <p>The code works as in the example above. But when I insert a new value over an existing path I get the following behaviour:</p>  <pre><code>(put (list 'a 'b 'c) 'hello) (put (list 'a 'b) 'hi) ; Or (put (list 'a 'b 'c 'd) 'hi) ; =&gt;  mcar: contract violation ;     expected: mpair? ;     given: 'hello </code></pre>  <p>Does anyone see why it is not possible to insert keys in already existing paths in the table and how it can be made possible?</p>  <p>Thanks.</p>