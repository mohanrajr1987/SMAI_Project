<p>How to define a function in Scheme / Racket that returns functions of particular arities?</p>  <p>Currently I have in my code the following:</p>  <pre><code>(define (get-function n)   (cond     [(= n 1) (lambda (a) a)]     [(= n 2) (lambda (a b) (+ a b))]     [(= n 3) (lambda (a b c) (+ a b c))]     ; and so on     )) </code></pre>  <p>Of course arity of a function it returns is n:</p>  <pre><code>(procedure-arity (get-function 3)) ; returns 3 </code></pre>  <p>Please don't mind "+", in my program it's more complicated than a fold of "+". However, the structure of that function could be defined recursively as well; similar to:</p>  <pre><code>(define (get-function-variadic n)   (lambda arguments     (if (empty? arguments) 0         (+ (car arguments)            (apply (get-function-variadic (sub1 n)) (cdr arguments)))))) </code></pre>  <p>But then it returns variadic functions:</p>  <pre><code>(procedure-arity (get-function-variadic 3)) ; returns #(struct:arity-at-least 0) </code></pre>  <p>so that all of these work just as the normal Scheme's variadic "+":</p>  <pre><code>((get-function-variadic 3) 1 2 3)  ((get-function-variadic 3) 1 2) ((get-function-variadic 3) 1 2 3 4) </code></pre>  <p>In fact I want only the first one to return a result, while others should return an error "wrong number of arguments". Additionally, in other parts of a program I rely on arity of the functions generated. So, a variadic function doesn't suit me (even if it checks the length of "arguments"). I need a set of functions of different integer arities returned by (get-function n). Is it possible to define in Scheme / Racket?</p>