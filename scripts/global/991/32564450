<p>I'd like to write the following ex:</p>  <pre><code>(adjoin-set 2 (adjoin-set 8 (adjoin-set 4 (adjoin-set 3 (adjoin-set 7 (adjoin-set 5 '())))))) </code></pre>  <p>recursively.</p>  <p>My other code is as follows (from Structure and Interpretation of Computer Programs, 2nd ed.)</p>  <pre><code>(define (entry tree) (car tree)) (define (left-branch tree) (cadr tree)) (define (right-branch tree) (caddr tree)) (define (make-tree entry left right)   (list entry left right))   (define (adjoin-set x set)   (cond ((null? set) (make-tree x '() '()))         ((= x (entry set)) set)         ((&lt; x (entry set))          (make-tree (entry set)                     (adjoin-set x (left-branch set))                     (right-branch set)))         ((&gt; x (entry set))          (make-tree (entry set)                     (left-branch set)                     (adjoin-set x (right-branch set)))))) </code></pre>  <p>So far I've tried the following:</p>  <pre><code>(define (bst list)   (if (null? list) '())    (bst (adjoin-set (cdr list) '()))) </code></pre>  <p>This doesn't work. How could I make this work?</p>  <p>I'd like to follow a similar approach as when making the calls manually, i.e., <code>(adjoin-set (car list) (next adjoint-set))</code>.</p>