<p>I'm building in scheme a database using a wiredtiger key/value store. </p>  <p>To query a given table one needs to have a <code>cursor</code> over the table. The library recommends to re-use the <code>cursor</code>. The general behavior can be described by the following pseudo-code:</p>  <pre><code>with db.cursor() as cursor:     cursor.get(key)     ...     do_something(db)    ... </code></pre>  <p>During the extent of the <code>with</code> statment <code>cursor</code> <strong>can only</strong> be used in the current context. If <code>do_something(db)</code> needs a cursor, it must create/retrieve another cursor even if it's to query the same table. Otherwise the <code>cursor</code> loose its position and the continuation of <code>do_something(db)</code> doesn't expect. </p>  <p>You can work around it by <em>always reseting</em> the cursor, that's a waste. Instead it's preferable to keep a set of cursors ready to be used and when one can <em>request</em> via <code>db.cursor()</code> this will remove a cursor from the available cursors and return it. Once the "context" operation is finished, put it back.</p>  <p>The way I solve this in Python is by using a <code>list</code>. <code>db.cursor()</code> looks like:</p>  <pre><code>def cursor(self):     cursor = self.cursors.pop()     yield cursor     self.cursors.append(cursor) </code></pre>  <p>Which means, retrieve a cursor, send it to the current context, once the context is finished, put it back to the list of available cursors.</p>  <p>How can I avoid the mutation and use more functional approach?</p>