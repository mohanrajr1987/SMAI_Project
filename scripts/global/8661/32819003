<p>I have a basic java webserver for persisting payment history of users. I am trying to write a method to return a list of payments by querying a database, but for some reason the client keeps throwing an exception.</p>  <p>Here is my resource method for the server:</p>  <pre><code>@RolesAllowed({"authenticated","administrator","superadministrator"}) @Path("getPaymentHistory/{userId}") @GET public Response getPaymentHistory(@Context SecurityContext sc, @PathParam("userId") String userId){     PaymentListResponse response = paymentService.getUserPaymentHistory(userId);     logger.debug("payment service found " +response.getPayments().size()+ " payments for user: " + userId);     return Response.ok().entity(response).build(); } </code></pre>  <p>This produces the following log :</p>  <blockquote>   <p>DEBUG c.b.s.p.resource.PaymentResource - payment service found 3 payments for user: c832f8c2-f5ff-4e5c-a1b9-7e5a3f26a359</p> </blockquote>  <p>Therefore the list is definitely populated with the 3 payments the user has made previously. I added the list to an XML root element as I thought it may be the cause of the exception:</p>  <pre><code>@XmlRootElement public class PaymentListResponse {      private List&lt;Payment&gt; payments = new ArrayList&lt;Payment&gt;();      public PaymentListResponse(){}      //getter &amp; setter ..  } </code></pre>  <p>Here is my client code:</p>  <pre><code>    DefaultHttpClient httpClient = new DefaultHttpClient();     String responseString = null;     HttpResponse response;     try {         response = httpClient.execute(data);         HttpEntity entity = response.getEntity();         responseString = EntityUtils.toString(entity, "UTF-8");     } catch (HttpException | IOException e) {         e.printStackTrace();     }     return responseString; </code></pre>  <p>This produces the following log:</p>  <blockquote> <pre><code>org.apache.http.MalformedChunkCodingException: Chunked stream ended unexpectedly at org.apache.http.impl.io.ChunkedInputStream.getChunkSize(ChunkedInputStream.java:222) at org.apache.http.impl.io.ChunkedInputStream.nextChunk(ChunkedInputStream.java:183) at org.apache.http.impl.io.ChunkedInputStream.read(ChunkedInputStream.java:155) at org.apache.http.conn.EofSensorInputStream.read(EofSensorInputStream.java:159) at sun.nio.cs.StreamDecoder.readBytes(StreamDecoder.java:284) at sun.nio.cs.StreamDecoder.implRead(StreamDecoder.java:326) at sun.nio.cs.StreamDecoder.read(StreamDecoder.java:178) at java.io.InputStreamReader.read(InputStreamReader.java:184) at java.io.Reader.read(Reader.java:140) at org.apache.http.util.EntityUtils.toString(EntityUtils.java:135) </code></pre> </blockquote>  <p>I cant figure out why my JSON is causing errors, I have responses from the same Resource being sent back without errors. this happens only when i try to send a populated list. If the list is empty the response from the server is </p>  <blockquote>   <p>{"payments":[]}</p> </blockquote>  <hr>  <p><strong>Update</strong> </p>  <p>I used the following code as suggested in the answers:</p>  <pre><code>return Response.ok().entity(response.toArray()).build(); </code></pre>  <p>Class annotations are as follows:</p>  <pre><code>@Produces({MediaType.APPLICATION_JSON}) @Consumes({MediaType.APPLICATION_JSON}) </code></pre>  <p>with the same exception being thrown. For clarity, I have used this type of response before in another part of the server. The response from that is also a JSON list and is handled by the same client code.</p>  <p>Here is another method which works:</p>  <pre><code>@RolesAllowed({"administrator","superadministrator"}) @Path("get_all") @GET public Response getAccounts(@Context SecurityContext sc) {     ExternalUser userMakingRequest = (ExternalUser)sc.getUserPrincipal();     List&lt;Account&gt; accounts = accountService.getAllAccounts(userMakingRequest);     return Response.ok().entity(accounts).build(); } </code></pre>