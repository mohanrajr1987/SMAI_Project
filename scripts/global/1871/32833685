<p>In <a href="https://stackoverflow.com/questions/32809769/how-to-pass-subroutine-names-as-arguments-in-fortran">How to pass subroutine names as arguments in Fortran?</a> we learned how to pass subroutine names as arguments in Fortran. How can we do this inside a class structure? </p>  <p>The ensuing code produces the following compilation error using GNU Fortran (GCC) 5.1.0:</p>  <pre><code>gfortran  -Wall -Wextra -Wconversion -Og -pedantic -fcheck=bounds -fmax-errors=5 class_pass.f08  myClass.f08:44:30:                   class ( test ), target :: me                               1 Error: Derived type ‘test’ at (1) is being used before it is defined myClass.f08:9:21:               procedure, public :: action =&gt; action_sub                      1 Error: Non-polymorphic passed-object dummy argument of ‘action_sub’ at (1) myClass.f08:40:36:           class ( test ), target :: me                                     1 Error: CLASS variable ‘me’ at (1) must be dummy, allocatable or pointer (null):0: confused by earlier errors, bailing out </code></pre>  <p>The main routine follows. It includes a routine <code>check</code> used as a diagnostic.</p>  <pre><code>include 'myClass.f08' program class_pass      use myClass     implicit none      type ( test ) :: myTest          call myTest % check ()         call myTest % action ( square_sub )  end program class_pass </code></pre>  <p>The module:</p>  <pre><code>module myClass      implicit none      type     :: test         real :: x, y         contains             private             procedure, public :: action =&gt; action_sub             procedure, public :: square =&gt; square_sub             procedure, public :: double =&gt; double_sub             procedure, public :: check  =&gt; check_sub     end type test      private :: action_sub     private :: square_sub     private :: double_sub     private :: check_sub  contains      subroutine square_sub ( me )         class ( test ), target :: me             me % y = me % x ** 2     end subroutine square_sub      subroutine double_sub ( me )         class ( test ), target :: me             me % y = me % x * 2     end subroutine double_sub      subroutine check_sub ( me )         class ( test ), target :: me             me % x = 5.0             call double_sub ( me )             print *, 'x = ', me % x, ', y = ', me % y     end subroutine check_sub      subroutine action_sub ( sub )         class ( test ), target :: me          interface mySub             subroutine sub ( me )                 class ( test ), target :: me             end subroutine sub         end interface mySub              call sub ( me )             print *, 'x = ', me % x, ', y = ', me % y      end subroutine action_sub  end module myClass </code></pre>  <p>Many thanks to @Vladimir F for the original solution and tips.</p>