<p>I have two derived types (child1 and child2) that both extend from the same abstract type (<code>type, abstract :: partent</code>). The abstract type has a deferred bound procedure.</p>  <p>I want to call a subroutine that performs some stuff (performance critical) depending on the type of the child handed over as input. I can think of two options:</p>  <ul> <li>The subroutine takes the <code>class(parent), intent(inout) :: type_in</code> as input. Implementations for the children are then done within a <code>select type (type_in)</code> construct.</li> <li>I write two subroutines, one with <code>type(child1), intent(inout) :: type_in</code> and one with <code>type(child2), intent(inout) :: type_in</code> and provide an explicit interface to overload the routine name.</li> </ul>  <p>The first option allows for implementations where the extension of the parent is not known at compile time, but that is not necessary in my case. It also saves some lines of code because only a part of it is different for the children.</p>  <p>My question is: Is there additional overhead in option one because I implemented the input as polymorphic data when the type is known at compile time?</p>