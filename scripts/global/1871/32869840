<p>I would like to assign values to array of pointers in Fortran 2003. Array of pointers is realised by means of a derived data type <code>arrpntr</code>. Please take a look at a simple example below:</p>  <pre><code>  PROGRAM TST_PNTR    real, allocatable, target  :: arr1(:), arr2(:)    ! array of pointers   type :: arrpntr     real, pointer :: arr(:) =&gt; null()   end type    type(arrpntr) :: p(2)    integer :: err    integer, parameter :: M = 10, N = 10    allocate(arr1(M), arr2(N), stat=err)    arr1 = [ (i, i=1, 10) ]   arr2 = arr1**2    ! arr1 = arr1-0.5   ! p(1)%arr =&gt; arr1    p(1)%arr =&gt; arr1-0.5   p(2)%arr =&gt; arr2    write(*,*) p(1)%arr   write(*,*) p(2)%arr    arr1 = arr1**2   arr2 = sqrt(arr2)    write(*,*) p(1)%arr   write(*,*) p(2)%arr    deallocate(arr1, arr2, stat=err)    nullify(p(1)%arr, p(2)%arr)    END PROGRAM TST_PNTR </code></pre>  <p>In its current state compiler throws an error: <code>Pointer assignment target is neither TARGET nor POINTER at (1)</code> complaining about the line <code>p(1)%arr =&gt; arr1-0.5</code>. It works in case I split the operation into two parts as in the commented lines above. However, I would like to achieve the same result without storing an intermediate result in a temporary variable <code>arr1</code>. Operation <code>arr1-0.5</code> is a simple example. In reality I would like to use a much more complex expression on the right hand side of <code>p(1)%arr =&gt;</code>. Is there a better way avoiding the use of an intermediate array?</p>