<p>I was thinking about pointer initialization and tried the following two cases:</p>  <pre><code>#include &lt;stdio.h&gt;  int main(int argc, char **argv) {     int *d;     int f;     int p;      *d = 6;      printf("%d %d %d\n", *d, f, p);      return 0; } </code></pre>  <p>This code segfaults at the line (seen in gdb):</p>  <pre><code>*d = 6; </code></pre>  <p>Which makes sense because I am trying store a value at a random address.</p>  <p>I then tried the following:</p>  <pre><code>#include &lt;stdio.h&gt;  int main(int argc, char **argv) {     int *d;     int f = 10;     int p = 9;      *d = 6;      printf("%d %d %d\n", *d, f, p);      return 0; } </code></pre>  <p>This runs to completion with the output: </p>  <blockquote>   <p>6 10 9</p> </blockquote>  <p>If only <code>f</code> is initialized to 10 (<code>p</code> is not initialized) or vice versa, the program still completes with output </p>  <blockquote>   <p>6 10 0 </p> </blockquote>  <p>or </p>  <blockquote>   <p>6 0 9 </p> </blockquote>  <p>(<code>p</code> initialized).  I do not understand why this works.  My initial guess is that the initialization of either <code>f</code> or <code>p</code> makes space or orients memory to allow for the safe initialization of <code>d</code>.  I also thought about stack allocations, but am still unsure.</p>