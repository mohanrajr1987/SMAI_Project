<p>I stumbled upon this and it caused a problem in an OpenGL-application I'm currently writing, so I have to ask:</p>  <pre><code>abstract class Entity {   protected var modelMatrixLocation: Int = _   protected var modelViewProjectionMatrixLocation: Int = _ }  class ConcreteEntity extends Entity {   modelMatrixLcoation: Int = getUniformLocation(shaderID, "modelMatrix")    println(modelMatrixLocation)   println(modelViewProjectionMatrixLocation) } </code></pre>  <p>Concrete Entity prints out</p>  <blockquote>   <p>0</p>      <p>0</p> </blockquote>  <p>Now obviously the real world example is a bit more complex, but that's exactly what happened. I got two <code>Int</code>s that represent a location of a uniform in a shader and forgot to initialize one.</p>  <p>Then I had to debug quite a bit to find out why my shader was behaving so strangely (while before it worked - which was pure co-incidence as the modelMatrix was never used but the modelViewProjectionMatrix was set, so it all miraculously worked)</p>  <p>So my questions:  1.)  Why is a variable Int that is uninitialized set to 0? (Instead of, for example, -1) I mean, -1 would be more appropriate as it would not collide with SQL-queries, Collection-object-fetching or stuff like that either - in computer science we usually start counting with 0, so -1 would throw us a more obvious error.</p>  <p>2.) How can I avoid this? How can I make sure, that all the variables from the <code>abstract class Entity</code> are really filled?</p>  <p>I mean, I could probably do something like:</p>  <pre><code>protected var modelMatrixLocationName: String = _ protected val modelMatrixLocation: Int = getUniformLocation(shaderID, "modelMatrixLocationName") </code></pre>  <p>with a little bit of tweaking, but that's just ugly.</p>  <p>Another way would be to use <code>Option</code> instead. One the one hand this seems to be a nice(r) way to handle this, but still I'd need to use a var, which I'd like to avoid. <code>val</code>s all the way! ;)</p>  <p>Any better ideas?</p>