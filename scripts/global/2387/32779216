<p>At the moment in C# I'm signing a challenge like this:</p>  <pre class="lang-C# prettyprint-override"><code>RSACryptoServiceProvider rsa; RSAPKCS1SignatureFormatter RSAFormatter = new RSAPKCS1SignatureFormatter(rsa); RSAFormatter.SetHashAlgorithm("SHA1"); byte[] SignedHash = RSAFormatter.CreateSignature(paramDataToSign); </code></pre>  <p>Then I give the <code>SignedHash</code> to Windows, it accepts it and everything is OK. But I need to move this part to Android and there's the problem, that I just can't get the same signed hash value.</p>  <p>In Android I tried to make the signed hash but they differ from the one generated in C#.</p>  <pre class="lang-java prettyprint-override"><code>Signature signer = Signature.getInstance("SHA1withRSA", "BC"); signer.initSign(privateKey); signer.update(paramDataToSign); signer.sign(); </code></pre>  <p>In C# - using the following piece of code - I get the same result as in Android, but it is not an option cause then Windows does not accept the signed hash.</p>  <pre class="lang-C# prettyprint-override"><code>ISigner signer = SignerUtilities.GetSigner("SHA1withRSA"); signer.Init(true, privateKey); signer.BlockUpdate(paramDataToSign, 0, paramDataToSign.Length); signer.GenerateSignature(); </code></pre>  <p>Here's written that C# PKCS1SignatureFormatter and Java Signature should give the same result, but they do not. <a href="http://www.jensign.com/JavaScience/dotnet/VerifySig/" rel="nofollow">http://www.jensign.com/JavaScience/dotnet/VerifySig/</a></p>  <p>What could be the problem?</p>  <hr>  <p>Here are the base 64 (WebSafe) values that I get:</p>  <pre class="lang-none prettyprint-override"><code>Challenge = zHyz12Tk4m151nssYIBWqBCAxhQ  RSAPKCS1SignatureFormatter SignedHash = kmu39keplCAV4Qnu22wdprLz4nGSsrVtHbxQ5YMUG7p-0YwReCG4ROIlFvYs4CGfjCiAGFPw4PLrLx7mrlAA6iuhJMkgm_PMTW9alQYTH612hLEUP4EmK0M2kw8CveLcjI3HA08z8bByllIzRyAlM8bcR438vw2uhx_CbgvOOHn8vwBPnvWbFqpi2doYoq2xEuFBRe7eBPrxbMRqEd3ExdQ9c9rYT4ivOJ4pbioyi6D5i5_1crvGwM6nQanMZCmooRYJO65NP3B4wWnvQZpJLRD0U08wWcvyGBFWp188ZovDjnkTQZku6lzmwGXfqQwtBz9uNvLcTbp7cVyt5EyQxw  Signature and ISigner SignedHash = Vt-b5QfGPnSPpZuIB8-H4N1K5hQXpImS4e8k56_HruDSqy3DLsz96QKUrccshjr1z9nTK3Mwvd5yPdyTJOqSUcDQqxV46LPhWQNsubqKxAz97ePpeslIH1gHdnzkh46ixsWqgDrhR7egQtDkU8PPsph1qahCxaVkRYspQBV0jPZ-LK4EjoGGnuWTCihVKjruXJZ2VY8yZ9QRAsHVptr0Nv-mldO2MFK-oEVbtVbHqUPf5So8im3oRSm68OqY4g56bCdFNSbhcFBjrZ1QPjnxiIk43-_5tevafqoOB2D_E_mQHCJwmRg3MrNij6IdAdloCejnhCWzgMHdcG1Ug_Qmig </code></pre>  <hr>  <p>So the simplest solution is using Bouncy Castle API:</p>  <pre class="lang-java prettyprint-override"><code>AsymmetricBlockCipher rsaEngine = new PKCS1Encoding(new RSABlindedEngine()); rsaEngine.init(true, privateKey);  DigestInfo dInfo = new DigestInfo(new AlgorithmIdentifier(X509ObjectIdentifiers.id_SHA1, DERNull.INSTANCE), paramDataToSign); byte[] digestInfo = dInfo.getEncoded(ASN1Encoding.DER);  rsaEngine.processBlock(digestInfo, 0, digestInfo.length); </code></pre>