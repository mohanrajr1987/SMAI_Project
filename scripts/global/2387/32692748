<p>I have a requirement to create a signature which is a URL-Safe-Base-64-encoded SHA256+ECDSA signature of a message. This will be used to consume a remote REST service.</p>  <p>I have been given a HAL browser implementation which connects to them as expected and a test implementation done in SCALA.</p>  <pre><code>    val token = generateToken() // Generates a random numeric token, different for each request     val lines = line1 + "\n" + line2 + "\n" + line3 + "\n"     val lineBytes = lines.getBytes()     try {         var sig = Signature.getInstance("SHA256withECDSA")         sig.initSign(privateKey)         sig.update(lineBytes)         body.foreach { input =&gt; // If there is a body, sign it too             input.reset()             var bytes = new Array[Byte](1024)             while (input.available() &gt; 0) {                 val alloc = input.read(bytes)                 sig.update(bytes, 0, alloc)             }         }         val encoder = new Base64(true)         val sigString = encoder.encodeAsString(sig.sign()).replace("\r\n", "")         val headerVal = "authentication.scheme.signed" + " username=" + username + "&amp;token=" + token + "&amp;signature=" + sigString          request.addHeader("Authorization", headerVal)     } catch {         case e : NoSuchAlgorithmException =&gt;             throw new Error("No support for SHA256withECDSA! Check your Java installation.")     } </code></pre>  <p>I am trying to generate the same signature using C#.</p>  <p>So far this is what my Signing method looks like</p>  <pre><code>private byte[] SignData(byte[] hashedMessageToSign) {     CngKey pkey2 = CngKey.Open(@"C:\OpenSSL-Win64\bin\MyPrivateiKeyInPkcs8Format.pem");      using (ECDsaCng dsa = new ECDsaCng(pkey2))     {         //dsa.HashAlgorithm = CngAlgorithm.ECDsaP256;         //bob.key = dsa.Key.Export(CngKeyBlobFormat.EccPublicBlob);          byte[] data = hashedMessageToSign;          return dsa.SignData(data);     } } </code></pre>  <p>I am getting the code building but creating an invalid signature. Here is the calling method</p>  <pre><code>        protected void btnLDiscover_Click(object sender, EventArgs e) {     HttpWebRequest request = WebRequest.Create("https://service.provider/path/") as HttpWebRequest;     request.Method = "GET";     request.ContentType = "application/bespoke.format+json; version=1";     //request.Date = new DateTime(2015, 9, 3, 10, 40, 48);     request.Date = new DateTime(2015, 9, 21, DateTime.Now.Hour, DateTime.Now.Minute, DateTime.Now.Second);     request.CachePolicy = new HttpRequestCachePolicy(HttpRequestCacheLevel.NoCacheNoStore);     request.Accept = "application/bespoke.format+json; version=1";     request.KeepAlive = true;     request.MaximumAutomaticRedirections = 99;     //request.PreAuthenticate = true;      string token = DateTime.Now.Ticks.ToString();     string messageToSign = "GET /path/\n1\n" + token + "\n";      string signatureString = Convert.ToBase64String(SignData(Encoding.ASCII.GetBytes(messageToSign)));     //signatureString = RemoveControlCharacters(signatureString);     //signatureString = HttpUtility.UrlEncode(signatureString);     signatureString = signatureString                         .Replace('+', '-')                         .Replace('/', '_')                         .Replace("=", string.Empty);      request.Headers.Add("Authorization", "authentication.shceme.signed username=someuser&amp;token=" + token + "&amp;signature=" + signatureString);      HttpWebResponse response = request.GetResponse() as HttpWebResponse;      Encoding enc = System.Text.Encoding.GetEncoding(65001);     StreamReader loResponseStream =     new StreamReader(response.GetResponseStream(), enc);      string responseString = loResponseStream.ReadToEnd();      loResponseStream.Close();     response.Close();      resultTextBox.Text = responseString; } </code></pre>