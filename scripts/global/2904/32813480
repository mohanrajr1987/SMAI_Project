<p>I'm currently creating a game where a piece of Sushi traverses platform style levels. I need to essentially not have it be a circles and have it more of a skinny rectangle. Right now, the groundcheck is only on the sushi's backside...so that's all that's registering when it lands. If that doesn't collide with the ground, he continues his jump animation. Unfortunately, I've a lot of different solutions, including doubling the number of groundchecks, with various issues. Any ideas?<a href="http://i.stack.imgur.com/NzZOb.png" rel="nofollow"><img src="http://i.stack.imgur.com/NzZOb.png" alt="enter image description here"></a></p>  <p>using UnityEngine; using System.Collections;</p>  <p>public class yuControllerScript : MonoBehaviour {</p>  <pre><code>public float maxSpeed = 10f; bool facingRight = true;  Animator anim;  bool grounded = false;    public Transform groundCheck;  public Transform groundCheck2;    float groundRadius = 0.2f;   public LayerMask whatIsGround;  public float jumpForce = 700f;  public GameObject sword;  public static bool swingSword = false;  void Start () {      anim = GetComponent&lt;Animator&gt;();  }  // Update is called once per frame void FixedUpdate () {      grounded = Physics2D.OverlapCircle(groundCheck.position, groundRadius, whatIsGround);        anim.SetBool("Ground", grounded);      anim.SetFloat ("vSpeed", GetComponent&lt;Rigidbody2D&gt;().velocity.y);       float move = Input.GetAxis ("Horizontal");      anim.SetFloat ("speed", Mathf.Abs (move));      GetComponent&lt;Rigidbody2D&gt;().velocity = new Vector2(move * maxSpeed, GetComponent&lt;Rigidbody2D&gt;().velocity.y);        if(move &gt; 0 &amp;&amp; facingRight)         Flip ();     else if(move &lt; 0 &amp;&amp; !facingRight)         Flip();  }  void Update(){       if(Input.GetKeyDown(KeyCode.LeftControl)){          print ("attacking");     }     if(Input.GetKeyUp (KeyCode.LeftControl)){          print ("not attacking");     }         if(grounded &amp;&amp; Input.GetKeyDown (KeyCode.Space)){           anim.SetBool ("Ground", false);         GetComponent&lt;Rigidbody2D&gt;().AddForce (new Vector2(0,jumpForce));       }   }  void Flip(){      facingRight = !facingRight;     Vector3 theScale = transform.localScale;     theScale.x *= -1;     transform.localScale = theScale;  } </code></pre>  <p>}</p>