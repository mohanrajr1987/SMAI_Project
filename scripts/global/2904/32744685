<p>Here is a video of the problem:</p>  <p><a href="https://pbs.twimg.com/tweet_video/CPmbdpMWIAAUesX.mp4" rel="nofollow">https://pbs.twimg.com/tweet_video/CPmbdpMWIAAUesX.mp4</a></p>  <p>The issue is whenever the ship flies in the direction of its shield, it seems to stop at regular intervals.</p>  <p>Here's the code for the ship and the shield:</p>  <pre><code>public class MoveOnAxis : MonoBehaviour {  public float speed = 1.0f; public float defaultDrag = 0.0f; public float maxDrag = 3.0f; public float maxAngularDrag = 3.0f; public float maxTumble = 720; public Transform shield;  private float distance; private float hAxis; private float deadzone = 0.15f; private float aVel;  private Rigidbody2D rb;  // Use this for initialization void Start ()  {     rb = GetComponent&lt;Rigidbody2D&gt;(); }  // Update is called once per frame void Update ()  {      hAxis = Input.GetAxis("Horizontal");     aVel = rb.angularVelocity;      if(Mathf.Abs(hAxis) &gt; 0.15f) //Controlls ship rotation     {         if(aVel &gt; 10.0f) //if spinning out after a crash clockwise         {             if(aVel &lt;= maxTumble &amp;&amp; hAxis &gt; deadzone)             {                 rb.angularVelocity -= hAxis*speed*2;             }             else if(aVel &lt; maxTumble &amp;&amp; hAxis &lt; -deadzone)             {                 rb.angularVelocity -= hAxis*speed*2;             }             else if(aVel &gt; maxTumble &amp;&amp; hAxis &lt; -deadzone)             {                 rb.angularVelocity = maxTumble;             }          }         else if (aVel &lt; -10.0f) //if spinning out of a crash anti-clockwise         {             if(aVel &gt;= -maxTumble &amp;&amp; hAxis &lt; -deadzone)             {                 rb.angularVelocity -= hAxis*speed*2;             }             else if(aVel &gt; -maxTumble &amp;&amp; hAxis &gt; deadzone)             {                 rb.angularVelocity -= hAxis*speed*2;             }             else if(aVel &lt; -maxTumble &amp;&amp; hAxis &gt; deadzone)             {                 rb.angularVelocity = -maxTumble;             }         }         else //if no physics angular momentum go back to using transform for rotation         {             rb.angularVelocity = 0;             transform.Rotate(0.0f, 0.0f, hAxis*-speed);         }     }      if(Input.GetAxis("triggerAxis") &gt; 0.1f) //Controlls ship accelleration and decelleration     {         //distance = Mathf.Abs((transform.position - shield.position).magnitude);          //if (distance &lt;= 1.0f &amp;&amp; distance &gt;= 0.6f)         //{             rb.AddForce(transform.up * speed * Input.GetAxis("triggerAxis"));         //}         //else if (distance &lt; 0.6f || distance &gt; 1.0f)         //{         //  rb.velocity = new Vector2(0f,0f);         //}     }      if(Input.GetAxis("triggerAxis") &lt; -0.1f)     {         rb.drag = maxDrag*-Input.GetAxis("triggerAxis");         rb.angularDrag = maxAngularDrag*-Input.GetAxis("triggerAxis");     }     else     {         rb.drag = defaultDrag;         rb.angularDrag = defaultDrag;     }  } } </code></pre>  <p>and</p>  <pre><code>public class ShieldMovement : MonoBehaviour {  public Transform target; //player shield is attaced to public float circSpeed = 0.1f; // Speed Shield moves around ship  private Vector3 direction = Vector3.up; private float distance = 0.8f; // distance from player so it doesn't clip private float deadzone = 0.15f; private float separation; private bool canMove = true;  private Rigidbody2D tRB; private Rigidbody2D rb;  // Use this for initialization void Start ()  {     tRB = target.GetComponent&lt;Rigidbody2D&gt;();     rb = GetComponent&lt;Rigidbody2D&gt;(); }  void OnCollisionEnter2D (Collision2D other)  {     canMove = false; }  void OnCollisionStay2d(Collision2D other) {     canMove = false; }  void OnCollisionExit2D (Collision2D other)  {     canMove = true; }  // Update is called once per frame void Update () {      float rh = Input.GetAxisRaw("rightH");     float rv = Input.GetAxisRaw("rightV");      separation = Mathf.Abs((transform.position - target.position).magnitude);      if(Mathf.Abs(rh) &gt; deadzone || Mathf.Abs(rv) &gt; deadzone)     {         Vector3 targetDir = new Vector3(rh, rv, 0.0f);         direction  = Vector3.Slerp(transform.position-target.position, targetDir, circSpeed);      }      Ray ray = new Ray(target.position, direction); // cast ray in direction of point on circle shield is to go     if(canMove)     {         transform.position = ray.GetPoint(distance); //move shield to the ray as far as the distance     }     else if(!canMove)     {          tRB.velocity = new Vector2(0.0f, 0.0f);         //rb.velocity = new Vector2(0.0f, 0.0f);         transform.position = transform.position;      }     if(separation != distance) //If the shield get torn away from the ship     {         transform.position = ray.GetPoint(distance); //move shield to the ray as far as the distance     }      float angleY = transform.position.y - target.position.y;     float angleX = -(transform.position.x - target.position.x);      float angle = Mathf.Atan2 (angleY, angleX) * Mathf.Rad2Deg-90; //Get angle      if(Mathf.Abs(rh) &gt; deadzone || Mathf.Abs(rv) &gt; deadzone)     {         transform.rotation = Quaternion.AngleAxis(angle,Vector3.forward*-1); // keep shield facing outwards in respect to player     }   }  } </code></pre>  <p>I've tried taking out the stuff that stops moving the ship like tRB.velocity = new Vector2(0.0f, 0.0f); but it didn't make any difference at all. Any ideas on what I need to do here?</p>  <p><strong>Edit</strong></p>  <p>Removing the collider from the shield fixes the problem so it seems like somehow the shield is colliding with the ship even though it doesn't look like it and the raycast should keep it far enough away from the ship. Not sure where to go from here.</p>