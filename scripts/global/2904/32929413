<p><strong>LibGdx Game Won't Render</strong></p>  <p>I cannot seem to solve this problem :((( I created a random dungeon generator with a dungeon building algorithm I found online. Originally, I had 1 class that contained the dungeon algorithm and the rendering method. <strong>It worked perfectly.</strong> However, I want to make themed dungeons so I moved the render method and textures to a subclass called Dungeon1. Now, all I get is a black screen when I run the code. The 2 int[][] arrays do store the map data(tested through debug mode), but for some reason the tiles just wont render. I have displayed the super Dungeon and subclass Dungeon1 below.  </p>  <pre><code>public class Dungeon {  public static final int tileSIZE = 64;  public Random rand = new Random();  public int mapSize = 128; public int[][] bg; public int[][] fg;  public int roomCount = rand.nextInt(20) + 10; public int minSize = 10; public int maxSize = 20;  public ArrayList&lt;Room&gt; rooms; public Room[] room;  public Dungeon() {     bg = new int[mapSize][mapSize];     fg = new int[mapSize][mapSize];     rooms = new ArrayList&lt;Room&gt;();     room = new Room[roomCount];     makeRooms();     squashRooms();     makeCorridors();     fillRoom();     new Autotile(mapSize, bg, fg); }  public void makeRooms() {     for (int i = 0; i &lt; roomCount; i++) {         room[i] = new Room();          room[i].setX(rand.nextInt(mapSize - maxSize - 1) + 1);         room[i].setY(rand.nextInt(mapSize - maxSize - 1) + 1);         room[i].setW(rand.nextInt(maxSize) + minSize);         room[i].setH(rand.nextInt(maxSize) + minSize);          if (DoesCollide(room[i], i)) {             i--;             continue;         }         room[i].setW(room[i].getW() - 1);         room[i].setH(room[i].getH() - 1);          rooms.add(room[i]);     } }  public void fillRoom() {     for (int i = 0; i &lt; roomCount; i++) {         Room room = rooms.get(i);         for (int x = room.getX(); x &lt; room.getX() + room.getW(); x++) {             for (int y = room.getY(); y &lt; room.getY() + room.getH(); y++) {                 bg[x][y] = 1;             }         }     } }  public void makeCorridors() {     for (int i = 0; i &lt; roomCount; i++) {         Room roomA = room[i];         Room roomB = FindClosestRoom(roomA);         int[] pointA = { rand.nextInt(roomA.getW() - 2) + roomA.getX(),                 rand.nextInt(roomA.getH() - 3) + roomA.getY() };         int[] pointA2 = { pointA[0] + 1, pointA[1] + 1 };         int[] pointA3 = { pointA[0] + 2, pointA[1] + 2 };         int[] pointA4 = { pointA[0] + 3, pointA[1] + 3 };         int[] pointB = { rand.nextInt(roomB.getW() - 2) + roomB.getX(),                 rand.nextInt(roomB.getH() - 3) + roomB.getY() };         int[] pointB2 = { pointB[0] + 1, pointB[1] + 1 };         int[] pointB3 = { pointB[0] + 2, pointB[1] + 2 };         int[] pointB4 = { pointB[0] + 3, pointB[1] + 3 };         while ((pointB[0] != pointA[0]) || (pointB[1] != pointA[1])) {             if (pointB[0] != pointA[0]) {                 if (pointB[0] &gt; pointA[0])                     pointB[0]--;                 else                     pointB[0]++;             } else if (pointB[1] != pointA[1]) {                 if (pointB[1] &gt; pointA[1])                     pointB[1]--;                 else                     pointB[1]++;             }              bg[pointB[0]][pointB[1]] = 1;         }         while ((pointB2[0] != pointA2[0]) || (pointB2[1] != pointA2[1])) {             if (pointB2[0] != pointA2[0]) {                 if (pointB2[0] &gt; pointA2[0])                     pointB2[0]--;                 else                     pointB2[0]++;             } else if (pointB2[1] != pointA2[1]) {                 if (pointB2[1] &gt; pointA2[1])                     pointB2[1]--;                 else                     pointB2[1]++;             }              bg[pointB2[0]][pointB2[1]] = 1;         }         while ((pointB3[0] != pointA3[0]) || (pointB3[1] != pointA3[1])) {             if (pointB3[0] != pointA3[0]) {                 if (pointB3[0] &gt; pointA3[0])                     pointB3[0]--;                 else                     pointB3[0]++;             } else if (pointB3[1] != pointA3[1]) {                 if (pointB3[1] &gt; pointA3[1])                     pointB3[1]--;                 else                     pointB3[1]++;             }              bg[pointB3[0]][pointB3[1]] = 1;         }         while ((pointB4[0] != pointA4[0]) || (pointB4[1] != pointA4[1])) {             if (pointB4[0] != pointA4[0]) {                 if (pointB4[0] &gt; pointA4[0])                     pointB4[0]--;                 else                     pointB4[0]++;             } else if (pointB4[1] != pointA4[1]) {                 if (pointB4[1] &gt; pointA4[1])                     pointB4[1]--;                 else                     pointB4[1]++;             }              bg[pointB4[0]][pointB4[1]] = 1;         }     } }  public Room FindClosestRoom(Room room) {     int[] mid = { room.getX() + (room.getW() / 2), // x             room.getY() + (room.getH() / 2) }; // y     Room closest = null;     int closestDistance = 1000;     for (int i = 0; i &lt; rooms.size(); i++) {         Room check = rooms.get(i);         if (check == room)             continue;         int[] check_mid = { check.getX() + (check.getW() / 2), check.getY() + (check.getH() / 2) };         int distance = Math.min(Math.abs(mid[0] - check_mid[0]) - (room.getW() / 2) - (check.getW() / 2),                 Math.abs(mid[1] - check_mid[1]) - (room.getH() / 2) - (check.getH() / 2));         if (distance &lt; closestDistance) {             closestDistance = distance;             closest = check;         }     }     return closest; }  public boolean DoesCollide(Room room, int ignore) {     for (int i = 0; i &lt; rooms.size(); i++) {         if (i == ignore)             continue;         Room check = rooms.get(i);         if (!((room.getX() + room.getW() &lt; check.getX()) || (room.getX() &gt; check.getX() + check.getW())                 || (room.getY() + room.getH() &lt; check.getY()) || (room.getY() &gt; check.getY() + check.getH())))             return true;     }     return false; }  public void squashRooms() {     for (int i = 0; i &lt; 5; i++) {         for (int j = 0; j &lt; rooms.size(); j++) {             Room room = rooms.get(j);             while (true) {                 int[] oldPos = { room.getX(), room.getY() };                 if (room.getX() &gt; 1)                     room.setX(room.getX() - 1);                 if (room.getY() &gt; 1)                     room.setY(room.getY() - 1);                 if ((room.getX() == 1) &amp;&amp; (room.getY() == 1))                     break;                 if (DoesCollide(room, j)) {                     room.setX(oldPos[0]);                     room.setY(oldPos[1]);                     break;                 }             }         }     } } } </code></pre>  <p>Aaannnd Dungeon1:</p>  <pre><code>public class Dungeon1 extends Dungeon implements Screen {  public Texture tiles; public TextureRegion floor, wall, wallLeft, wallRight, tlCorn, trCorn, blCorn, brCorn, c1, c2, c3, c4;  float wh = Gdx.graphics.getWidth(); float ht = Gdx.graphics.getHeight();  public SpriteBatch batch; private OrthographicCamera camera;  NanoRealms game;  public Dungeon1(NanoRealms game) {     super();     this.game = game;     tiles = new Texture(Gdx.files.internal("Map/tiles.png"));     floor = new TextureRegion(tiles, 2 * 64, 0, Dungeon.tileSIZE, Dungeon.tileSIZE);     wall = new TextureRegion(tiles, 64, 64, Dungeon.tileSIZE, Dungeon.tileSIZE);     wallLeft = new TextureRegion(tiles, 0, 2 * 64, Dungeon.tileSIZE, Dungeon.tileSIZE);     wallRight = new TextureRegion(tiles, 2 * 64, 2 * 64, Dungeon.tileSIZE, Dungeon.tileSIZE);     tlCorn = new TextureRegion(tiles, 0, 64, Dungeon.tileSIZE, Dungeon.tileSIZE);     trCorn = new TextureRegion(tiles, 2 * 64, 64, Dungeon.tileSIZE, Dungeon.tileSIZE);     blCorn = new TextureRegion(tiles, 0, 3 * 64, Dungeon.tileSIZE, Dungeon.tileSIZE);     brCorn = new TextureRegion(tiles, 2 * 64, 3 * 64, Dungeon.tileSIZE, Dungeon.tileSIZE);     c1 = new TextureRegion(tiles, 3 * 64, 64, Dungeon.tileSIZE, Dungeon.tileSIZE);     c2 = new TextureRegion(tiles, 4 * 64, 64, Dungeon.tileSIZE, Dungeon.tileSIZE);     c3 = new TextureRegion(tiles, 3 * 64, 2 * 64, Dungeon.tileSIZE, Dungeon.tileSIZE);     c4 = new TextureRegion(tiles, 4 * 64, 2 * 64, Dungeon.tileSIZE, Dungeon.tileSIZE);      batch = new SpriteBatch();     camera = new OrthographicCamera(30, 30 * (Gdx.graphics.getHeight() / Gdx.graphics.getWidth()));     camera.position.set(3000, 3000, 0);     camera.zoom = 300; }  @Override public void render(float delta) {     cameraInput();      Gdx.gl.glClearColor(0, 0, 0, 1);     Gdx.gl.glClear(GL30.GL_COLOR_BUFFER_BIT);      batch.setProjectionMatrix(camera.combined);     ////     batch.begin();      for (int x = 0; x &lt; bg.length; x++) {         float w = x * 64;         for (int y = 0; y &lt; bg[x].length; y++) {             float h = y * 64;             if (bg[x][y] == 1) {                 batch.draw(floor, w, h);             }         }     }     for (int x2 = 0; x2 &lt; fg.length; x2++) {         float w2 = x2 * 64;         for (int y2 = 0; y2 &lt; fg[x2].length; y2++) {             float h2 = y2 * 64;             if (fg[x2][y2] == 2) {                 batch.draw(wall, w2, h2);             } else if (fg[x2][y2] == 3) {                 batch.draw(wallLeft, w2, h2);             } else if (fg[x2][y2] == 4) {                 batch.draw(wallRight, w2, h2);             } else if (fg[x2][y2] == 5) {                 batch.draw(tlCorn, w2, h2);             } else if (fg[x2][y2] == 6) {                 batch.draw(trCorn, w2, h2);             } else if (fg[x2][y2] == 7) {                 batch.draw(blCorn, w2, h2);             } else if (fg[x2][y2] == 8) {                 batch.draw(brCorn, w2, h2);             } else if (fg[x2][y2] == 9) {                 batch.draw(c1, w2, h2);             } else if (fg[x2][y2] == 10) {                 batch.draw(c2, w2, h2);             } else if (fg[x2][y2] == 11) {                 batch.draw(c3, w2, h2);             } else if (fg[x2][y2] == 12) {                 batch.draw(c4, w2, h2);             }         }     }     batch.end();     //// }  public void cameraInput() {     if (Gdx.input.isKeyPressed(Keys.Q))         camera.zoom += 0.5;     if (Gdx.input.isKeyPressed(Keys.E))         camera.zoom -= 0.5;     if (Gdx.input.isKeyPressed(Keys.A))         camera.translate(-10, 0, 0);     if (Gdx.input.isKeyPressed(Keys.D))         camera.translate(10, 0, 0);     if (Gdx.input.isKeyPressed(Keys.S))         camera.translate(0, -10, 0);     if (Gdx.input.isKeyPressed(Keys.W))         camera.translate(0, 10, 0); } } </code></pre>