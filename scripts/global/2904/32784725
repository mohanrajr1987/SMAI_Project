<p>I am building a 2D space game with SpriteKit.  I am going to have multi stage rockets, and I am using SKPhysicsJointFixed to connect the stages.  The game works great, until I am orbiting the Earth.  When the rocket moves around the Earth, the graphics "jump" every rotation at the same point.  By jump, I mean that the planet and rocket graphics looked jumbled for s brief moment, then everything looks normal.  This doesn't seem to happen when I am not using a physics joint.  I have posted my code for the space scene where this happens.  I would so greatly appreciate any suggestions!  I have looked everywhere, and can't seem to find a solution.  Thanks!</p>  <pre><code>// //  SpaceScene.swift //  Delta-V // //  Created by Tim Gleason on 9/8/15. //  Copyright (c) 2015 Tim Gleason. All rights reserved. //  import Foundation import SpriteKit  let Pi = CGFloat(M_PI) let DegreesToRadians = Pi / 180 let RadiansToDegrees = 180 / Pi  class SpaceScene: SKScene, UIGestureRecognizerDelegate {      let engineFireButton = SKSpriteNode()     let rightTurnButton = SKSpriteNode()     let leftTurnButton = SKSpriteNode()     let stageSepButton = SKSpriteNode()     let stopButton = SKSpriteNode()      // store the touch location for other uses     var touchesLocation = CGPoint(x: 0, y: 0)      var stageToRemove = 0     var selectedPartName = ""      var engineState = false      var inEarthOrbit = true      var acceleration: CGFloat = 3.0      // the Earth     let Earth = SKSpriteNode(imageNamed: "Earth")      // world node for the moving camera     let worldNode = SKNode()      // scene bounds     var max_x_bound: CGFloat = 0.0     var max_y_bound: CGFloat = 0.0      var lastUpdateTime: CFTimeInterval = 0      // orbiting variables     var orbitSpeed: CGFloat = 60     let orbitRadius: CGFloat = 150     var orbitAngle: CGFloat = 0      // space travel variables     var earthEscapeVelocity: CGFloat = 150.0     var earthSphereOfInfluence: CGFloat = 300.0      // rocket direction angle     var angle: CGFloat = 0.0      var jointArray: [SKPhysicsJoint] = []      var newRocket = TotalRocket()      var rocketAltitude: Double = 0.0      // update each part's zPosition     var currentZPosition = 0.0       override func didMoveToView(view: SKView) {           // setup and add the world node         self.addChild(worldNode)         self.backgroundColor = UIColor.blackColor()           // setup and add the Earth         Earth.position = CGPointMake(self.size.width/2, self.size.height/2)         Earth.xScale = 0.5         Earth.yScale = 0.5         Earth.zPosition = -4         worldNode.addChild(Earth)          // right turn button         rightTurnButton.color = UIColor.yellowColor()         rightTurnButton.size = CGSizeMake(50, 50)         rightTurnButton.position = CGPointMake(self.size.width/2 + 165, 100)         self.addChild(rightTurnButton)          // left turn button         leftTurnButton.color = UIColor.greenColor()         leftTurnButton.size = CGSizeMake(50, 50)         leftTurnButton.position = CGPointMake(self.size.width/2 + 100, 100)         self.addChild(leftTurnButton)          // stage seperation button         stageSepButton.color = UIColor.whiteColor()         stageSepButton.size = CGSizeMake(50, 50)         stageSepButton.position = CGPointMake(self.size.width/2 + 150, 250)         self.addChild(stageSepButton)          // stop button         stopButton.color = UIColor.blueColor()         stopButton.size = CGSizeMake(50, 50)         stopButton.position = CGPointMake(self.size.width/2 + 150, 25)         self.addChild(stopButton)           // set the scene bounds         max_x_bound = self.frame.width         max_y_bound = self.frame.height          // load the new rocket from memory         let rocketData = NSUserDefaults.standardUserDefaults().objectForKey("rocket") as? NSData          if let rocketData = rocketData {             newRocket.totalParts = NSKeyedUnarchiver.unarchiveObjectWithData(rocketData) as! [RocketPart]         }          // load the altitude data from memory         let altitudeData = NSUserDefaults.standardUserDefaults().objectForKey("altitude") as? NSData          if let altitudeData = altitudeData {             rocketAltitude = NSKeyedUnarchiver.unarchiveObjectWithData(altitudeData) as! Double         }          newRocket.totalParts[0].selectedPart == true          // add the new rocket to the scene         for index in newRocket.totalParts {             index.xScale = 1.0             index.yScale = 1.0             index.zPosition = CGFloat(currentZPosition)             index.physicsBody?.affectedByGravity = false             index.physicsBody?.velocity = CGVectorMake(0, 0)             worldNode.addChild(index)              ++currentZPosition         }          newRocket.totalParts[0].position = CGPointMake(self.size.width/2, self.size.height/2)          newRocket.totalParts[1].position = CGPointMake(self.size.width/2, newRocket.totalParts[0].position.y + (newRocket.totalParts[0].size.height/2 + newRocket.totalParts[1].size.height/2))         newRocket.totalParts[2].zPosition = -1         newRocket.totalParts[2].position = CGPointMake(self.size.width/2, newRocket.totalParts[1].position.y + (newRocket.totalParts[1].size.height/2 + newRocket.totalParts[2].size.height/2) - 13)          let length = newRocket.totalParts.count         var i: Int          for i = 1; i &lt; length; ++i {             let nodeA = newRocket.totalParts[i - 1]             let nodeB = newRocket.totalParts[i]             jointArray.append(SKPhysicsJointFixed.jointWithBodyA(nodeA.physicsBody!,                 bodyB: nodeB.physicsBody!, anchor: CGPointMake(nodeA.position.x, nodeA.position.y)))         }          for index in jointArray {             physicsWorld.addJoint(index)         }            createStars()          // engine fire button         engineFireButton.color = UIColor.redColor()         engineFireButton.size = CGSize(width: 50, height: 50)         engineFireButton.position = CGPoint(x: self.size.width/2 + 150, y: 175)         self.addChild(engineFireButton)      }      override func update(currentTime: CFTimeInterval) {          let deltaTime = max(1.0/80, currentTime - lastUpdateTime)         lastUpdateTime = currentTime          updateOrbit(deltaTime)          physicsUpdate()     }      override func didFinishUpdate() {         worldNode.position = CGPointMake(-(newRocket.totalParts[0].position.x-(self.size.width/2)),             -(newRocket.totalParts[0].position.y - 225))     }      override func touchesBegan(touches: Set&lt;UITouch&gt;, withEvent event: UIEvent?) {         for touch in (touches ) {             let location = touch.locationInNode(self)             _ = self.nodeAtPoint(location)              if engineFireButton.containsPoint(location) {                 engineState = true             }         }     }      override func touchesEnded(touches: Set&lt;UITouch&gt;, withEvent event: UIEvent?) {         for touch in (touches ) {             let location = touch.locationInNode(self)             let newLocation = CGPointMake(location.x - worldNode.position.x, location.y - worldNode.position.y)             touchesLocation = newLocation              if engineFireButton.containsPoint(location) {                 engineState = false             }              if rightTurnButton.containsPoint(location) {                 for index in newRocket.totalParts {                     if index.selectedPart == true {                         index.zRotation -= 0.25                     }                 }              }              if leftTurnButton.containsPoint(location) {                 for index in newRocket.totalParts {                     if index.selectedPart == true {                         index.zRotation -= 0.25                     }                 }             }              if stageSepButton.containsPoint(location) {                 removeStage()             }              if stopButton.containsPoint(location) {                 newRocket.totalParts[0].physicsBody?.velocity = CGVectorMake(0, 0)             }              for index in newRocket.totalParts {                 if index.containsPoint(newLocation) {                     if touch.tapCount &gt;= 2 {                         index.selectedPart = true                         index.color = UIColor.redColor()                         index.colorBlendFactor = 0.5                     } else {                         index.selectedPart = false                         index.colorBlendFactor = 0.0                     }                 }             }         }     }      func updateOrbit(dt: CFTimeInterval) {          if engineState == true {             orbitSpeed += 1.0         }          if inEarthOrbit == true {              orbitAngle = (orbitAngle + orbitSpeed * CGFloat(dt)) % 360              let x = cos(orbitAngle * DegreesToRadians) * orbitRadius             let y = sin(orbitAngle * DegreesToRadians) * orbitRadius              angle = CGFloat(atan2f(Float(y), Float(x)))              newRocket.totalParts[0].position = CGPoint(x: Earth.position.x + x, y: Earth.position.y + y)             newRocket.totalParts[0].zRotation = CGFloat(angle)         }          if orbitSpeed &gt;= 300 {             inEarthOrbit = false         } else {             inEarthOrbit = true         }     }      func physicsUpdate () {         if engineState == true &amp;&amp; inEarthOrbit == false {             for index in newRocket.totalParts {                  if index.selectedPart == true {                     let vectorX = acceleration * cos(index.zRotation - 90 * DegreesToRadians)                     let vectorY = acceleration * sin(index.zRotation - 90 * DegreesToRadians)                     let thrustVector = CGVectorMake(-vectorX, -vectorY)                      index.physicsBody?.applyForce(thrustVector)                 }              }         }     }      func removeStage() {          for index in newRocket.totalParts {             if index.name == "LEM_Fairing" {                 index.removeFromParent()             }         }     }       func createStars() {         var index: Int          for index = 0; index &lt;= 100; ++index {             let sprite = SKSpriteNode(imageNamed: "star")             let xPos = CGFloat(Float(arc4random()) / Float(UINT32_MAX)) * max_x_bound             let yPos = CGFloat(Float(arc4random()) / Float(UINT32_MAX)) * max_y_bound             sprite.position = CGPointMake(xPos, yPos)             sprite.zPosition = -10             worldNode.addChild(sprite)         }     } } </code></pre>