<p>I am trying to create a very realistic scene using Three.js. So far I have implemented mouse controls, loading model from Maya and I came to applying textures. The code works however, as it can be seen on the images below the textures don't fill the box as one would expect. I assume the problem is because each face of the model is filled separately, which occurred to me when I displayed my model as in wireframe mode. </p>  <p><a href="http://i.stack.imgur.com/utZjh.png" rel="nofollow"><img src="http://i.stack.imgur.com/utZjh.png" alt="Model"></a></p>  <pre><code>function init() {          // renderer          renderer = new THREE.WebGLRenderer({antialias: true, alpha: true});         renderer.setSize(window.innerWidth, window.innerHeight);          container = document.getElementById('container');         container.appendChild(renderer.domElement);          camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 10000 );         camera.position.z = 5;          cameraControls = new THREE.TrackballControls(camera, renderer.domElement);         cameraControls.target.set(0, 0, 0);          scene = new THREE.Scene();          light = new THREE.AmbientLight( 0xffffff );         scene.add( light );          material = new THREE.MeshPhongMaterial( {              map: THREE.ImageUtils.loadTexture('images/box_texture.jpg')          } );                 group = new THREE.Object3D();          var loader = new THREE.JSONLoader();         loader.load('models/cube_1.js', modelLoadedCallback);          window.addEventListener( 'resize', onWindowResize, false );  }  function modelLoadedCallback(geometry) {          mesh = new THREE.Mesh( geometry, material );         group.add(mesh);     //     scene.add (new THREE.Mesh (geometry,     // new THREE.MeshBasicMaterial ({ color: 0x000000, wireframe: true })));         scene.add (new THREE.Mesh (geometry, material));         scene.add( group );  }  function onWindowResize() {          camera.aspect = window.innerWidth / window.innerHeight;         camera.updateProjectionMatrix();          renderer.setSize( window.innerWidth, window.innerHeight );          render();  }  function animate() {          var delta = clock.getDelta();          requestAnimationFrame(animate);          cameraControls.update(delta);          renderer.render(scene, camera);  } </code></pre>