<p>I'm currently writing a WebGL programme using THREE.js library to display contours and am trying to use TubeGeometry to achieve this. The end position of the tube will be determined directly from the inputs. The code works but there will be extra black line or sometimes a black region appearing along the tube.</p>  <p>Does anyone know the reason ? Or can anyone offer some better ideas?</p>  <p>This is my code: (You will see the extra black line if you enter x:300 y:0 z:300)</p>  <pre><code>&lt;html&gt; &lt;head runat="server"&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"/&gt;     &lt;title&gt;&lt;/title&gt;     &lt;script src="Scripts/jquery-2.1.1.js"&gt;&lt;/script&gt;     &lt;script src="Scripts/three/three.min.js"&gt;&lt;/script&gt;     &lt;script src="Scripts/three/OrbitControls.js"&gt;&lt;/script&gt;     &lt;script src="Scripts/three/THREEx.WindowResize.js"&gt;&lt;/script&gt;   &lt;/head&gt; &lt;body&gt;     &lt;div id="canvas"&gt;&lt;/div&gt;     &lt;input id="valuex" placeholder="x" /&gt;     &lt;input id="valuey" placeholder="y" /&gt;     &lt;input id="valuez" placeholder="z" /&gt;     &lt;button id="btn"&gt;Go&lt;/button&gt;  &lt;/body&gt;  &lt;script&gt;     if (window.addEventListener)         window.addEventListener('load', initialize, false);     else if (window.attachEvent)         window.attachEvent('onload', initialize);     else window.onload = initialize;      function initialize() {         dreiD1.init();         animate();     }      function animate() {         requestAnimationFrame(animate);         render();     }      function render() {         if (dreiD1.renderer) {             dreiD1.renderer.render(dreiD1.scene, dreiD1.camera);         }     }      var dreiD1 = {         scene: null,         camera: null,         renderer: null,         container: null,         controls: null,          init: function () {             //create scene             this.scene = new THREE.Scene();             var SCREEN_WIDTH = 750,                 SCREEN_HEIGHT = 500;              //camera             var VIEW_ANGLE = 45,                 ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT,                 NEAR = 1,                 FAR = 15000;             this.camera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);             this.scene.add(this.camera);             this.camera.position.set(1400, 550, 1400);             this.camera.lookAt(new THREE.Vector3(500, 0, 500));              //prepare Renderer             this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });             this.renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);             this.renderer.setClearColor(0xccffff);             this.renderer.shadowMapEnabled = true;             this.renderer.shadowMapSoft = true;              //Prepare Container             this.container = document.createElement('div');             document.getElementById("canvas").appendChild(this.container);             this.container.appendChild(this.renderer.domElement);              //events-control renderer and camera when resizing the window             THREEx.WindowResize(this.renderer, this.camera);              //add directional light             dLight = new THREE.DirectionalLight(0xffffff);             dLight.position.set(0, 800, 0);             //dLight.castShadow = true;             //dLight.shadowCameraVisible = true;             dLight.shadowDarkness = 0.2;             dLight.shadowMapWidth = dLight.shadowMapHeight = 1000;             this.scene.add(dLight);              // add simple ground             var groundGeometry = new THREE.PlaneGeometry(12000, 12000, 1, 1);             ground = new THREE.Mesh(groundGeometry, new THREE.MeshLambertMaterial({ color: 0xffffff }));             ground.position.y = 0;             ground.rotation.x = -Math.PI / 2;             ground.receiveShadow = true;             this.scene.add(ground);              //prepare OrbitControls             this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);             this.controls.target = new THREE.Vector3(0, 0, 0);     },     }      $(document).ready(function () {         $('#btn').on('click', function () {             var a = $('#valuex').val();             var b = $('#valuey').val();             var c = $('#valuez').val();              alert("Value=(" + a + "," + b + "," + c + ")");              var points = [];              points.push(new THREE.Vector3(0, 0, 0));             points.push(new THREE.Vector3(a, b, c));              var tube = new THREE.Mesh(new THREE.TubeGeometry(new THREE.SplineCurve3(points), 64, 10), new THREE.MeshLambertMaterial({ color:0x808080 }));//( path, segments, radius, radialSegments, closed, taper )              tube.position.x = 0;             tube.position.y = 0;             tube.position.z = 0;             tube.castShadow = tube.receiveShadow = true;             dreiD1.scene.add(tube);          });     })  &lt;/script&gt; &lt;/html&gt; </code></pre>