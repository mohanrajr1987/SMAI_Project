<p>I was able to implement zooming on pinch gesture using the zoom property and then when calling the stillImage, everything works fine.  For the past 2 days i was struggleing to implement the zooming while recording video on toggleVideo method from apple's example project and didn't succeed. ÃŽs there a way to implement this zoom while recording ? </p>  <pre><code>- (void)toggleMovieRecording{ // [[self recordButton] setEnabled:NO]; int    selectedAVCaptureDeviceFormatIdx = 15; dispatch_async([self sessionQueue], ^{     if (![[self movieFileOutput] isRecording])     {         [self setLockInterfaceRotation:YES];          if ([[UIDevice currentDevice] isMultitaskingSupported])         {             // Setup background task. This is needed because the captureOutput:didFinishRecordingToOutputFileAtURL: callback is not received until OneShot returns to the foreground unless you request background execution time. This also ensures that there will be time to write the file to the assets library when OneShot is backgrounded. To conclude this background execution, -endBackgroundTask is called in -recorder:recordingDidFinishToOutputFileURL:error: after the recorded file has been saved.             [self setBackgroundRecordingID:[[UIApplication sharedApplication] beginBackgroundTaskWithExpirationHandler:nil]];         }          // Update the orientation on the movie file output video connection before starting recording.         [[[self movieFileOutput] connectionWithMediaType:AVMediaTypeVideo] setVideoOrientation:[[(AVCaptureVideoPreviewLayer *)[[self previewView] layer] connection] videoOrientation]];          // Turning OFF flash for video recording         [self setFlashMode:AVCaptureFlashModeOff forDevice:[[self videoDeviceInput] device]];          dispatch_async(dispatch_get_main_queue(), ^{             // AVCaptureDevice *videoDevice = [[self videoDeviceInput] device];             AVCaptureDevice  *videoDevice = [AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeVideo];             [videoDevice lockForConfiguration:nil];              AVCaptureDeviceFormat* currdf = [videoDevice.formats objectAtIndex:selectedAVCaptureDeviceFormatIdx];             videoDevice.activeFormat = currdf;             if (selectedAVCaptureDeviceFormatIdx==12 || selectedAVCaptureDeviceFormatIdx==13)                 videoDevice.activeVideoMaxFrameDuration = CMTimeMake(1,60);              NSLog(@"%f", videoDevice.activeFormat.videoMaxZoomFactor);              NSLog(@"videoZoomFactorUpscaleThreshold: %f", videoDevice.activeFormat.videoZoomFactorUpscaleThreshold);              videoDevice.videoZoomFactor = videoDevice.activeFormat.videoZoomFactorUpscaleThreshold;             videoDevice.videoZoomFactor = 1+ self.currentScale;             [videoDevice unlockForConfiguration];          });            // Start recording to a temporary file.         NSString *outputFilePath = [NSTemporaryDirectory() stringByAppendingPathComponent:[@"movie" stringByAppendingPathExtension:@"mov"]];         [[self movieFileOutput] startRecordingToOutputFileURL:[NSURL fileURLWithPath:outputFilePath] recordingDelegate:self];        }     else     {         [[self movieFileOutput] stopRecording];     } }); </code></pre>  <p>}</p>