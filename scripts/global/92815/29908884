<p>I have two NSData objects, data1 and data2, and I'd like to do a bit-wise XOR and store the result in a third NSData object, xorData.</p>  <p>The first thing I tried was this:</p>  <pre><code>*data1.bytes^*data2.bytes; </code></pre>  <p>but it gave an error of:</p>  <blockquote>   <p>Invalid operands to binary expression ('const void' and 'const void')</p> </blockquote>  <p>So I tried to write a function that would extract the bytes of the data into an array of integers, perform the xor on the integers, then save the result back into an NSData object. The function looks like this:</p>  <pre><code>+(NSData *) DataXOR1:(NSData *) data1 DataXOR2:(NSData *)data2{     const int *data1Bytes = [data1 bytes];     const int *data2Bytes = [data2 bytes];     NSMutableArray *xorBytes = [[NSMutableArray alloc] init ];     for (int i = 0; i &lt; data1.length;i++){          [xorBytes addObject:[NSNumber numberWithInt:(data1Bytes[i]^data2Bytes[i])]];     }     NSData *xorData = [NSKeyedArchiver archivedDataWithRootObject:xorBytes];     return xorData; } </code></pre>  <p>This runs, but gives the wrong answers. When I test it on two simple pieces of data (data1 = 0x7038 and data2 = 0x0038), and use NSLog to output what the values are, I get:</p>  <pre><code>data1Bytes[0] = 8070450532247943280 data2Bytes[0] = 8070450532247943168 data1Bytes[0]^data2Bytes[0] = 112 data1Bytes[1] = 10376302331560798334 data2Bytes[1] = 10376302331560798334 data1Bytes[1]^data2Bytes[1] = 0 </code></pre>  <p>This boggles my mind a bit because the values in the dataXBytes arrays are totally wrong, but they're xor-ing to the right values! (0x70 ^ 0x00 = 0x70 = 112)</p>  <p>I think it might be an endian-ness problem, but when I change the initialization of data1Bytes to:</p>  <pre><code>const int *data1Bytes = CFSwapInt32BigToHost([data1 bytes]); </code></pre>  <p>it runs into an error when it tries to access it, saying:</p>  <blockquote>   <p>Thread 1: EXC_BAD_ACCESS(code=1, address = 0xa08ad539)</p> </blockquote>  <p>Is there a much simpler way to do the xor? If not, how can I fix the endian problem?</p>