<p>I am trying to get nunit tests going in a separate test project. The tests work just fine when included in the same project, but when I create the same test in a separate project, they fail. However, when I create a third consumer project in the solution, that project has no errors calling into the same methods being tested here, so the problem seems to be isolated to nunit. Below is a minimal example that recreates the problem.</p>  <pre><code>using MyUtilities.FileIO.XML; using NUnit.Framework;  [TestFixture] public class ReaderTest {     private string FilePath { get; set; }     private string FileName { get; set; }      [Setup]     public void Setup()     {         this.FilePath = @"c:\testdir\";         this.FileName = "testfile.xml";     }      [Test]     public void Reader_Test()     {         // Commenting out this line makes the test pass         var reader = new XmlObjectReader&lt;string&gt; { FilePath = this.FilePath, FileName = this.FileName };          Assert.True(true);     } } </code></pre>  <p>The call into XmlObjectReader causes a FileLoadException on the MyUtilities assembly, which causes the test to fail. If I comment the call, it works fine. The same test works fine when executed from within the assembly. Below is the exact exception language.</p>  <pre><code>System.IO.FileLoadException : Could not load file or assembly 'MyUtilities, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null' or one of its dependencies. The process cannot access the file because it is being used by another process. (Exception from HRESULT: 0x80070020)    at MyUtilities.Test.FileIO.XML.XmlObjectReaderTest.Reader_Test() </code></pre>  <p>I don't recall having to do any additional configuration for nunit. I am using VS 2013 in Windows 10, if that matters. None of the references are broken, and I don't see why any of them would be locked. Nevertheless, here is the list of references in the MyUtilities project, as the error message seems to think it may be one of those causing the problem.</p>  <ul> <li>log4net</li> <li>Microsoft.CSharp</li> <li>nunit.framework</li> <li>System</li> <li>System.ComponentModel.DataAnnotations</li> <li>System.Core</li> <li>System.Data</li> <li>System.Data.DataSetExtensions</li> <li>System.Xml</li> <li>System.Xml.Linq</li> </ul>  <p>I've tried to debug into the .net code (turning off Just My Code). It debugs just fine through the Setup method, but it dies immediately upon exiting the Setup metho, and fails the test immediately. I don't get a chance to debug anything else. I'm at a loss as to what else I might do.</p>  <p><strong>Edit</strong></p>  <p>I've updated the setup with the appropriate property settings that I failed to provide initially. Additionally, I've included the implementation of XmlObjectReader below. </p>  <pre><code>public class XmlObjectReader&lt;T&gt; : IObjectReader&lt;T&gt; {     private static readonly ILog logFile = LogManager.GetLogger(System.Reflection.MethodBase.GetCurrentMethod().DeclaringType);      [Required]     public string FilePath { get; set; }     [Required]     public string FileName { get; set; }     [Required]     public string FullPath { get { return Path.Combine(this.FilePath, this.FileName); } }      public T ReadObject()     {         this.Validate();         var returnValue = default(T);          var serializer = new XmlSerializer(typeof(T));         try         {             if (File.Exists(this.FullPath))             {                 logFile.InfoFormat(Resources.DeserializingObject, this.FullPath);                 using (var stream = new FileStream(this.FullPath, FileMode.Open))                 using (var reader = XmlReader.Create(stream))                 {                     if (serializer.CanDeserialize(reader))                     { returnValue = (T)serializer.Deserialize(reader); }                 }             }         }         catch (Exception ex)         {             logFile.ErrorFormat(Resources.ErrorDuringSerialization, ex);         }          return returnValue;     }      /// &lt;summary&gt;Determines whether the specified object is valid. &lt;/summary&gt;     /// &lt;returns&gt;A collection that holds failed-validation information. &lt;/returns&gt;     public void Validate()     {         var results = ValidatorHelper.ValidateObjectProperties(this);          if (results.Any())         {             var message = string.Format(Resources.ObjectFailedValidation, this.GetType().Name, results);             logFile.ErrorFormat(message);             throw new ArgumentException(message);         }     } } </code></pre>