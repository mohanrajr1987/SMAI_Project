<p>I have several test assemblies with multiple test fixtures in them testing client server scenarios.</p>  <p>Runnig tests wit the real server is very time consuming and difficult to debug. That's why I developed server fake, so tests can run against fake server.</p>  <p>The same test should also pass with the real server. This tests must run on regular basis in a dedicated environment, but a developer must also have a possibility to start them explicitly.</p>  <p>The solution I found is:</p>  <pre><code>public interface IHaveServer {     IServer GetServer(); }  public abstract class AbstractTests : IHaveServer {     [Test]     public void TestX()     {         var server = GetServer();         var actual = server.Call();         Assert.AreEqual("Hello", actual);     }      public abstract IServer GetServer(); }  [TestFixture] [Explicit] public class TestsWithRealServer : AbstractTests {     public override IServer GetServer()     {         return new RealServer();     } }  [TestFixture] public class TestsWithFakeServer : AbstractTests {     public override IServer GetServer()     {         return new FakeServer();     } } </code></pre>  <p>I don't like it because in this case every developer must think about splitting his test fixture into two. They are also not automatically grouped so that you can run only all fakes or only reals.</p>  <p>Is it a way to do that automatically? I was thinking about NUnit extensibility <a href="http://www.nunit.org/index.php?p=suiteBuilders&amp;r=2.6.4" rel="nofollow">ISuiteBuilder</a>. </p>  <p><strong>So the ultimate goal is</strong> that, developers just write their tests, creating as many fixtures as needed. When you start a test runner two sets of test show up: one against fake one against real server. You can choose to run one of these sets or both.</p>  <p>Technologies used <code>.NET</code>, <code>c#</code>, <code>NUnit</code>, <code>Ninject</code>, <code>moq</code></p>