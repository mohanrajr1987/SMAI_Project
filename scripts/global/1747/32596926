<p>I'm testing a component that somehow reacts to a delegate it receives. Specifically I'm testing that a certain behavior is triggered when the passed delegate throws an exception.</p>  <p>Since it's a test, the life expectancy of the thread is very short. I thought about using AutoResetEvent to signal the main thread when the delegate is completed, but if I invoke Set() before throwing the exception, I end up in a race condition that does not allow the test to be fully repeatable. A solution I tried is to invoke the Set() in a finally block, so that the code is executed regardless of the exception being thrown. But I still have the same problem with the Mock.Verify failing.</p>  <p>Right now I use Task.Delay to synchronize the threads, but I know I can do it without blocking the thread for 2 painful seconds.</p>  <p>Here is the code of the test.</p>  <pre><code>[Test] public async Task TCommand_ErroryStrategy_is_invoked_when_handler_throws() {     AutoResetEvent are = new AutoResetEvent(false);      options.ServiceBusFactory = new LoopbackServiceBusFactory();      var sut = CreateSystemUnderTest();      var exception = Mock.Of&lt;Exception&gt;();      sut.SubscribeToCommand&lt;TestCommand&gt;(msg =&gt;     {         try         {             throw exception;         }         finally         {             are.Set();         }     });      var message = fixture.Create&lt;CommandMessage&lt;TestCommand&gt;&gt;();      mockContextManager.Setup(p =&gt; p.CreateCommandMessage(It.IsAny&lt;IConsumeContext&lt;TestCommand&gt;&gt;())).Returns(message);      await sut.Start();      await sut.SendCommand(message);      are.WaitOne(TimeSpan.FromSeconds(3));      await Task.Delay(TimeSpan.FromSeconds(2));      mockCommandErrorStrategy.Verify(p =&gt; p.HandleError(It.IsAny&lt;IConsumeContext&lt;TestCommand&gt;&gt;(), exception), Times.AtLeastOnce); } </code></pre>