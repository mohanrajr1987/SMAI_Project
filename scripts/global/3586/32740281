<p>So I have a test that load an assembly, get a specific class and run a function. It works fine except that if I get an exception inside the class I can't catch it. </p>  <p>In the test I start with to create a new Appdomain like this: </p>  <pre><code>    [STAThread]     [Test, TestCaseSource("FromFile")]     public void AutomationTest(string testCasePath)     {         var pathToDll = Assembly.GetExecutingAssembly().Location;         string assemblyPath = ...         AppDomainSetup domainSetup = new AppDomainSetup         {             PrivateBinPath = pathToDll         };         AppDomain domain = AppDomain.CreateDomain("TempDomain", null, domainSetup);         InstanceProxy proxy = domain.CreateInstanceFromAndUnwrap(pathToDll, typeof(InstanceProxy).FullName) as InstanceProxy;         if (proxy != null)         {             proxy.LoadLibrary(assemblyPath);         }         AppDomain.Unload(domain);     } </code></pre>  <p>Then I call on my class like this: </p>  <pre><code>    internal class InstanceProxy : MarshalByRefObject     {         public void LoadLibrary(string path)         {             Assembly asm = Assembly.LoadFrom(path);             Type[] types = asm.GetExportedTypes();             Type type = types.FirstOrDefault(t =&gt; (t.FullName == "MyNamespace.SomeClass"));             if (type != null)             {                 var obj = Activator.CreateInstance(type);                  try                 {                     obj.GetType().InvokeMember("Run",                         BindingFlags.InvokeMethod,                         Type.DefaultBinder, obj, null);                 }                 catch (Exception e)                 {                     Assert.Fail(e.Message);                 }             }         }     } </code></pre>  <p>So when I get an exception the code will stop to run at my InvokeMember even when I have a try/catch. Is there some way to get around this? </p>  <p>Update 1: </p>  <p>I Tried to change LoadLibrary to this as Jo√£o Mendes said: </p>  <pre><code>        public void LoadLibrary(string path)         {             Assembly asm = Assembly.LoadFrom(path);             Type[] types = asm.GetExportedTypes();             Type type = types.FirstOrDefault(t =&gt; (t.FullName == "MyNamespace.SomeClass"));             if (type != null)             {                 var obj = Activator.CreateInstance(type);                 var method = type.GetMethod("Run");                 try                 {                     method.Invoke(obj, null);                 }                 catch (Exception e)                 {                     Assert.Fail(e.Message);                 }             }         } </code></pre>  <p>But still breaks inside the try. </p>