<p>I currently have code that looks something like this:</p>  <pre><code>public void doThings() {     int numThreads = 4;     ExecutorService threadPool = Executors.newFixedThreadPool(numThreads);     for (int i = 0; i &lt; numThreads; i++) {          final int index = i;         Runnable runnable = () -&gt; {              // do things based on index         };          threadPool.execute(runnable);      }      threadPool.shutdown();      try {         // I'd like to catch exceptions here from any of the runnables         threadPool.awaitTermination(1, TimeUnit.HOURS);     } catch (InterruptedException e) {         Utils.throwRuntimeInterruptedException(e);     } } </code></pre>  <p>Basically I create a lot of work to do in parallel and wait for it all to be done. If any of that processing fails I need to know quickly and abort it all. <code>threadPool.awaitTermination</code> doesn't seem to notice if an exception was thrown inside one of the threads. I just see a stacktrace in the console.</p>  <p>I don't know a lot about concurrency so I'm a bit lost in all the available interfaces/objects such as <code>Callable</code>, <code>Future</code>, <code>Task</code>, etc.</p>  <p>I see that <code>threadPool.invokeAll(callables)</code> will give me a <code>List&lt;Future&gt;</code> and <code>Future.get()</code> can throw exceptions from within the thread, but if I call this on (if the callable throws an exception in its own thread). But if I <code>.get</code> each callable I have in a sequential collection then I won't know about the last one failing until all the others have finished.</p>  <p>My best guess is to have a queue on which the runnables put a <code>Boolean</code> for success or failure and then <code>take()</code> from the queue as many times as there are threads.</p>  <p>I feel like this is an inordinate amount of complexity (even just the code I've pasted is somewhat surprisingly long) for what seems like a very common, simple use case. And this doesn't even include aborting the runnables when one fails. There has to be a better way, and as a beginner I don't know it.</p>