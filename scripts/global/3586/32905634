<p>I will try to explain my problem as clear as possible. I have a multithreading framework I have to work on. It's a path tracer renderer. It gives me error when I try to store some information provided by my threads. Trying to avoid posting all the code, I will explain what I mean step by step:</p>  <p>my TileTracer class is a thread</p>  <pre><code>class TileTracer : public Thread{ ... } </code></pre>  <p>and I have a certain number of threads:</p>  <pre><code>#define MAXTHREADS      32 TileTracer* worker[MAXTHREADS]; </code></pre>  <p>the number of working threads is set in the following initialization code, where the threads are also started:</p>  <pre><code>void Renderer::Init(){     accumulator = (vec3*)MALLOC64(sizeof(vec3)* SCRWIDTH * SCRHEIGHT);     memset(accumulator, 0, SCRWIDTH * SCRHEIGHT * sizeof(vec3));     SYSTEM_INFO systeminfo;     GetSystemInfo(&amp;systeminfo);     int cores = systeminfo.dwNumberOfProcessors;     workerCount = MIN(MAXTHREADS, cores);     for (int i = 0; i &lt; workerCount; i++)     {         goSignal[i] = CreateEvent(NULL, FALSE, FALSE, 0);         doneSignal[i] = CreateEvent(NULL, FALSE, FALSE, 0);     }     // create and start worker threads     for (int i = 0; i &lt; workerCount; i++)     {          worker[i] = new TileTracer();          worker[i]-&gt;init(accumulator, i);          worker[i]-&gt;start(); //start the thread     }     samples = 0; } </code></pre>  <p>the init() method for my thread is simply defined in my header as the following:</p>  <pre><code>void init(vec3* target, int idx) { accumulator = target, threadIdx = idx; } </code></pre>  <p>while the start() is:</p>  <pre><code>void Thread::start()  {      DWORD tid = 0;       m_hThread = (unsigned long*)CreateThread( NULL, 0,    (LPTHREAD_START_ROUTINE)sthread_proc, (Thread*)this, 0, &amp;tid );      setPriority( Thread::P_NORMAL );  } </code></pre>  <p>somehow (I don't get exactly where), each thread calls the following main method which is meant to define the color of a pixel (you don't have to understand it all):</p>  <pre><code>vec3 TileTracer::Sample(vec3 O, vec3 D, int depth){   vec3 color(0, 0, 0);   // trace path extension ray   float t = 1000.0f, u, v;   Triangle* tri = 0;   Scene::mbvh-&gt;pool4[0].TraceEmbree(O, D, t, u, v, tri, false);   totalRays++;   // handle intersection, if any   if (tri)   {     // determine material color at intersection point     Material* mat = Scene::matList[tri-&gt;material];     Texture* tex = mat-&gt;GetTexture();     vec3 diffuse;     if (tex)     {         ...     }     else diffuse = mat-&gt;GetColor();     vec3 I = O + t * D; //we get exactly to the intersection point on the object      //we need to store the info of each bounce of the basePath for the offsetPaths     basePath baseInfo = { O, D, I, tri };     basePathHits.push_back(baseInfo);      vec3 L = vec3(-1 + Rand(2.0f), 20, 9 + Rand(2.0f)) - I; //(-1,20,9) is Hard-code of the light position, and I add Rand(2.0f) on X and Z axis     //so that I have an area light instead of a point light     float dist = length(L) * 0.99f; //if I cast a ray towards the light source I don't want to hit the source point or the light source     //otherwise it counts as a shadow even if there is not. So I make the ray a bit shorter by multiplying it for 0.99     L = normalize(L);     float ndotl = dot(tri-&gt;N, L);     if (ndotl &gt; 0)     {         Triangle* tri = 0;         totalRays++;         Scene::mbvh-&gt;pool4[0].TraceEmbree(I + L * EPSILON, L, dist, u, v, tri, true);//it just calculates the distance by throwing a ray         //I am just interested in understanding if I hit something or not         //if I don't hit anything I calculate the light transport (diffuse * ndotL * lightBrightness * 1/dist^2         if (!tri) color += diffuse * ndotl * vec3(1000.0f, 1000.0f, 850.0f) * (1.0f / (dist * dist));     }     // continue random walk since it is a path tracer (we do it only if we have less than 20 bounces)     if (depth &lt; 20)     {         // russian roulette         float Psurvival = CLAMP((diffuse.r + diffuse.g + diffuse.b) * 0.33333f, 0.2f, 0.8f);         if (Rand(1.0f) &lt; Psurvival)         {             vec3 R = DiffuseReflectionCosineWeighted(tri-&gt;N);//there is weight             color += diffuse * Sample(I + R * EPSILON, R, depth + 1) * (1.0f / Psurvival);         }     }   }   return color; } </code></pre>  <p>Now, you don't have to understand the whole code for sure because my question is the following: if you notice, in the last method there are the 2 following code lines:</p>  <pre><code>basePath baseInfo = { O, D, I, tri }; basePathHits.push_back(baseInfo); </code></pre>  <p>I just create a simple struct "basePath" defined as follows:</p>  <pre><code>struct basePath {     vec3 O, D, hit;     Triangle* tri; }; </code></pre>  <p>and I store it in a vector of struct defined at the beginning of my code:</p>  <pre><code>vector&lt;basePath&gt; basePathHits; </code></pre>  <p>The problem is that this seems bringing an exception. Indeed if I try to store these information, that I need later in my code, the program crashes giving me the exception:</p>  <p>Unhandled exception at 0x0FD4FAC1 (msvcr120d.dll) in Template.exe: 0xC0000005: Access violation reading location 0x3F4C1BC1.</p>  <p>Some other times, without changing anything, the error is different and it's the following one:</p>  <p><a href="http://i.stack.imgur.com/NTiID.png" rel="nofollow"><img src="http://i.stack.imgur.com/NTiID.png" alt="enter image description here"></a></p>  <p>While, without storing those info, everything works perfectly. Likewise, if I set the number of cores to 1, everything works. So, how come multithreading doesn't allow me to do it? Do not hesitate to ask further info if these are not enough.</p>