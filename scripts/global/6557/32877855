<p>It writes to my BITMAP.bmp file but when I try to view it in Windows Photo Viewer It says "Windows Photo Viewer can't open this picture because the file appears to be damaged, corrupted, or is too large." I know I probably should have put the functions into header files but I haven't ever really delved deeply enough into a project to really make header files so I forgot how. If anyone knows the size limit for pictures in Windows Photo Viewer I would be very thankful. And I got some of these functions from MSDN(unashamed). The error handling could be better but I don't have <code>errorhandler.h</code>. I am not completely sure how all of the functions work because as I said I used some code from MSDN. I would be greatly appreciative of anyone that can help me. :)</p>  <pre><code>#include &lt;errorrep.h&gt; #include &lt;windows.h&gt; #include &lt;iostream&gt; using namespace std;  namespace Globals{     HBITMAP hBitmap;     HDC hScreen; } using namespace Globals;  void GetScreenShot(void) {     int x1, y1, x2, y2, w, h;     LPSIZE lpSize;     LPVOID lpvBits;     // get screen dimensions     x1  = GetSystemMetrics(SM_XVIRTUALSCREEN);     x2  = GetSystemMetrics(SM_CXVIRTUALSCREEN);     y1  = GetSystemMetrics(SM_YVIRTUALSCREEN);     y2  = GetSystemMetrics(SM_CYVIRTUALSCREEN);     w   = x2-x1;     h   = y2-y1;      // copy screen to bitmap     hScreen = GetDC(NULL);     HDC     hDC     = CreateCompatibleDC(hScreen);     hBitmap = CreateCompatibleBitmap(hScreen, w, h);     HGDIOBJ old_obj = SelectObject(hDC, hBitmap);     BOOL    bRet    = BitBlt(hDC, 0, 0, w, h, hScreen, x1, y1, SRCCOPY);     GetBitmapDimensionEx(hBitmap, lpSize);     GetBitmapBits(hBitmap, (LONG)lpSize, lpvBits);     // save bitmap to clipboard     OpenClipboard(NULL);     EmptyClipboard();     SetClipboardData(CF_BITMAP, hBitmap);     CloseClipboard();     // clean up     SelectObject(hDC, old_obj);     /*DeleteDC(hDC);     ReleaseDC(NULL, hScreen);     DeleteObject(hBitmap);*/ }  PBITMAPINFO CreateBitmapInfoStruct(/*HWND hwnd, */HBITMAP hBmp) {     BITMAP bmp;     PBITMAPINFO pbmi;     WORD    cClrBits;      // Retrieve the bitmap color format, width, and height.     if (!GetObject(hBmp, sizeof(BITMAP), (LPSTR)&amp;bmp))         //errhandler("GetObject", hwnd);         cout &lt;&lt; "Error: CreateBitmapInfoStruct" &lt;&lt; endl;      // Convert the color format to a count of bits.     cClrBits = (WORD)(bmp.bmPlanes * bmp.bmBitsPixel);     if (cClrBits == 1)         cClrBits = 1;     else if (cClrBits &lt;= 4)         cClrBits = 4;     else if (cClrBits &lt;= 8)         cClrBits = 8;     else if (cClrBits &lt;= 16)         cClrBits = 16;     else if (cClrBits &lt;= 24)         cClrBits = 24;     else cClrBits = 32;      // Allocate memory for the BITMAPINFO structure. (This structure     // contains a BITMAPINFOHEADER structure and an array of RGBQUAD     // data structures.)       if (cClrBits &lt; 24)          pbmi = (PBITMAPINFO) LocalAlloc(LPTR,                     sizeof(BITMAPINFOHEADER) +                     sizeof(RGBQUAD) * (1&lt;&lt; cClrBits));       // There is no RGBQUAD array for these formats: 24-bit-per-pixel or 32-bit-per-pixel       else          pbmi = (PBITMAPINFO) LocalAlloc(LPTR,                     sizeof(BITMAPINFOHEADER));      // Initialize the fields in the BITMAPINFO structure.      pbmi-&gt;bmiHeader.biSize = sizeof(BITMAPINFOHEADER);     pbmi-&gt;bmiHeader.biWidth = bmp.bmWidth;     pbmi-&gt;bmiHeader.biHeight = bmp.bmHeight;     pbmi-&gt;bmiHeader.biPlanes = bmp.bmPlanes;     pbmi-&gt;bmiHeader.biBitCount = bmp.bmBitsPixel;     if (cClrBits &lt; 24)         pbmi-&gt;bmiHeader.biClrUsed = (1&lt;&lt;cClrBits);      // If the bitmap is not compressed, set the BI_RGB flag.     pbmi-&gt;bmiHeader.biCompression = BI_RGB;      // Compute the number of bytes in the array of color     // indices and store the result in biSizeImage.     // The width must be DWORD aligned unless the bitmap is RLE     // compressed.     pbmi-&gt;bmiHeader.biSizeImage = ((pbmi-&gt;bmiHeader.biWidth * cClrBits +31) &amp; ~31) /8                                   * pbmi-&gt;bmiHeader.biHeight;     // Set biClrImportant to 0, indicating that all of the     // device colors are important.      pbmi-&gt;bmiHeader.biClrImportant = 0;      return pbmi;  }   void CreateBMPFile(/*HWND hwnd, */LPTSTR pszFile, PBITMAPINFO pbi,                   HBITMAP hBMP, HDC hDC)  {      HANDLE hf;                 // file handle     BITMAPFILEHEADER hdr;       // bitmap file-header     PBITMAPINFOHEADER pbih;     // bitmap info-header     LPBYTE lpBits;              // memory pointer     DWORD dwTotal;              // total count of bytes     DWORD cb;                   // incremental count of bytes     BYTE *hp;                   // byte pointer     DWORD dwTmp;      pbih = (PBITMAPINFOHEADER) pbi;     lpBits = (LPBYTE) GlobalAlloc(GMEM_FIXED, pbih-&gt;biSizeImage);      if (!lpBits)          //errhandler("GlobalAlloc", hwnd);         cout &lt;&lt; "!lpBits" &lt;&lt; endl;     // Retrieve the color table (RGBQUAD array) and the bits     // (array of palette indices) from the DIB.     if (!GetDIBits(hDC, hBMP, 0, (WORD) pbih-&gt;biHeight, lpBits, pbi,         DIB_RGB_COLORS))     {         //errhandler("GetDIBits", hwnd);         cout &lt;&lt; "Error 1" &lt;&lt; endl;     }      // Create the .BMP file.     hf = CreateFile(pszFile,                    GENERIC_READ | GENERIC_WRITE,                    (DWORD) 0,                     NULL,                    CREATE_ALWAYS,                    FILE_ATTRIBUTE_NORMAL,                    (HANDLE) NULL);     if (hf == INVALID_HANDLE_VALUE)         //errhandler("CreateFile", hwnd);     hdr.bfType = 0x4d42;        // 0x42 = "B" 0x4d = "M"     // Compute the size of the entire file.     hdr.bfSize = (DWORD) (sizeof(BITMAPFILEHEADER) +                  pbih-&gt;biSize + pbih-&gt;biClrUsed                  * sizeof(RGBQUAD) + pbih-&gt;biSizeImage);     hdr.bfReserved1 = 0;     hdr.bfReserved2 = 0;      // Compute the offset to the array of color indices.     hdr.bfOffBits = (DWORD) sizeof(BITMAPFILEHEADER) +                     pbih-&gt;biSize + pbih-&gt;biClrUsed                     * sizeof (RGBQUAD);      // Copy the BITMAPFILEHEADER into the .BMP file.     if (!WriteFile(hf, (LPVOID) &amp;hdr, sizeof(BITMAPFILEHEADER),         (LPDWORD) &amp;dwTmp,  NULL))     {        //errhandler("WriteFile", hwnd);        cout &lt;&lt; "!WriteFile" &lt;&lt; endl;     }      // Copy the BITMAPINFOHEADER and RGBQUAD array into the file.     if (!WriteFile(hf, (LPVOID) pbih, sizeof(BITMAPINFOHEADER)                   + pbih-&gt;biClrUsed * sizeof (RGBQUAD),                   (LPDWORD) &amp;dwTmp, ( NULL)))         //errhandler("WriteFile", hwnd);         cout &lt;&lt; "!WriteFile" &lt;&lt; endl;      // Copy the array of color indices into the .BMP file.     dwTotal = cb = pbih-&gt;biSizeImage;     hp = lpBits;     if (!WriteFile(hf, (LPSTR) hp, (int) cb, (LPDWORD) &amp;dwTmp,NULL))            //errhandler("WriteFile", hwnd);            cout &lt;&lt; "if (!WriteFile(hf, (LPSTR) hp, (int) cb, (LPDWORD) &amp;dwTmp,NULL))" &lt;&lt; endl;      // Close the .BMP file.      if (!CloseHandle(hf))            //errhandler("CloseHandle", hwnd);      // Free memory.     GlobalFree((HGLOBAL)lpBits); }  int main() {     cout &lt;&lt; "ScreenShot - Takes a screen shot\nScreen shot will be put in your clipboard"     "\nThere will be 10 seconds before it takes the screen shot\n" &lt;&lt; endl;     string input;     do     {         cin &gt;&gt; input;          if(input == "ScreenShot")         {             /*for(int i=1; i&lt;11; i++)             {                 Sleep(1000);                 cout &lt;&lt; i &lt;&lt; endl;                 if(i == 10)                 {                     break;                 }             }*/             GetScreenShot();             PBITMAPINFO pbmi = CreateBitmapInfoStruct(hBitmap);             CreateBMPFile("C:\\Users\\Owner\\Desktop\\BITMAP.bmp", pbmi, hBitmap, hScreen);             cout &lt;&lt; "ScreenShot taken!" &lt;&lt; endl;             cin.ignore(2);             Sleep(3000);             break;         }         else         {             cout &lt;&lt; "Invalid command." &lt;&lt; endl;         }      } while(true);      return 0; } </code></pre>