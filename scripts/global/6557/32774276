<p>Android:</p>  <pre><code>import android.graphics.Bitmap; public void getPixels (int[] pixels, int offset, int stride, int x, int y, int width, int height);  Bitmap bmap = source.renderCroppedGreyscaleBitmap(); int w=bmap.getWidth(),h=bmap.getHeight(); int[] pix = new int[w * h]; bmap.getPixels(pix, 0, w, 0, 0, w, h);  </code></pre>  <p>Returns in pixels[] a copy of the data in the bitmap.    Each value is a packed int representing a <a href="http://cs.szpt.edu.cn/android/reference/android/graphics/Color.html" rel="nofollow">Color</a>.   The stride parameter allows the caller to allow for gaps in the returned pixels array between rows.   For normal packed results, just pass width for the stride value.    The returned colors are non-premultiplied ARGB values.</p>  <p>iOS:</p>  <pre><code>@implementation UIImage (Pixels)  -(unsigned char*) rgbaPixels {     // The amount of bits per pixel, in this case we are doing RGBA so 4 byte = 32 bits     #define BITS_PER_PIXEL 32     // The amount of bits per component, in this it is the same as the bitsPerPixel divided by 4 because each component (such as Red) is only 8 bits     #define BITS_PER_COMPONENT (BITS_PER_PIXEL/4)     // The amount of bytes per pixel, in this case a pixel is made up of Red, Green, Blue and Alpha so it will be 4     #define BYTES_PER_PIXEL (BITS_PER_PIXEL/BITS_PER_COMPONENT)      // Define the colour space (in this case it's gray)     CGColorSpaceRef colourSpace = CGColorSpaceCreateDeviceRGB();      // Find out the number of bytes per row (it's just the width times the number of bytes per pixel)     size_t bytesPerRow = self.size.width * BYTES_PER_PIXEL;     // Allocate the appropriate amount of memory to hold the bitmap context     unsigned char* bitmapData = (unsigned char*) malloc(bytesPerRow*self.size.height);      // Create the bitmap context, we set the alpha to none here to tell the bitmap we don't care about alpha values     CGContextRef context = CGBitmapContextCreate(bitmapData,self.size.width,self.size.height,BITS_PER_COMPONENT,bytesPerRow,colourSpace,kCGImageAlphaFirst);//It returns null      /* We are done with the colour space now so no point in keeping it around*/     CGColorSpaceRelease(colourSpace);      // Create a CGRect to define the amount of pixels we want     CGRect rect = CGRectMake(0.0,0.0,self.size.width,self.size.height);     // Draw the bitmap context using the rectangle we just created as a bounds and the Core Graphics Image as the image source     CGContextDrawImage(context,rect,self.CGImage);     // Obtain the pixel data from the bitmap context     unsigned char* pixelData = (unsigned char*)CGBitmapContextGetData(context);      // Release the bitmap context because we are done using it     CGContextRelease(context);     //CGColorSpaceRelease(colourSpace);      return pixelData;     #undef BITS_PER_PIXEL     #undef BITS_PER_COMPONENT } </code></pre>  <p>But it can't work.</p>  <pre><code>CGBitmapContextCreate(bitmapData,self.size.width,self.size.height,BITS_PER_COMPONENT,bytesPerRow,colourSpace,kCGImageAlphaFirst); </code></pre>  <p>It returns NULL.</p>  <p>I need the same array as <strong>pix[ ]</strong> above,how can I make it?</p>