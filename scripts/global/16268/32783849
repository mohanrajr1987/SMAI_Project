<p>In my current project I have the problem that I end up in an infinite loop when trying to convert an <code>Item</code> or any of its subclasses like <code>ArmorItem</code>.<br> To detect which type of <code>Item</code> I have to deserialize I use a custom <code>JsonConverter</code> called <code>ItemConverter</code>.</p>  <p>Item.cs:</p>  <pre><code>[JsonObject(MemberSerialization.OptIn), JsonConverter(typeof(ItemConverter))] public class Item {     [JsonProperty("id")] public int Id { get; }     [JsonProperty("type")] public string ItemType { get; }      [JsonConstructor]     public Item(int id, string itemType)     {         Id = id;         ItemType = itemType;     } } </code></pre>  <p>ArmorItem.cs  </p>  <pre><code>[JsonObject(MemberSerialization.OptIn)] public sealed class ArmorItem : Item {     [JsonProperty("defense")] public int Defense { get; }      [JsonConstructor]     public ArmorItem(int id, string itemType, int defense) : base(id, itemType)     {         Defense = defense;     } } </code></pre>  <p>ItemConverter.cs</p>  <pre><code>public sealed class ItemConverter : JsonConverter {     public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)     {         throw new NotImplementedException();     }      public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)     {         JObject item = JObject.Load(reader);          switch (item["type"].Value&lt;string&gt;())         {             case "Armor":                 return item.ToObject&lt;ArmorItem&gt;();             default:                 return item.ToObject&lt;Item&gt;();         }     }      public override bool CanConvert(Type objectType)         =&gt; typeof (Item).IsAssignableFrom(objectType); } </code></pre>  <p>I'm usually getting the json data from the web and directly use the <code>WebResponse.GetResponseStream</code> stream to deserialize the data.</p>  <pre><code>using (HttpWebResponse resp = (HttpWebResponse) req.GetResponse()) using (JsonTextReader reader = new JsonTextReader(new StreamReader(resp.GetResponseStream()))) {     return new JsonSerializer().Deserialize&lt;Item&gt;(reader); } </code></pre>  <p>I know why this loop occurs but I can't fix it.<br> However I noticed when deserializing the json data in a different way the problem doesn't occur.<br> (<code>Item</code> was altered for this by removing the <code>JsonConverter</code> attribute)</p>  <pre><code>string json = "SOME JSON DATA HERE"; Item item = JsonConvert.DeserializeObject&lt;Item&gt;(json, new ItemConverter()); </code></pre>  <p>Unfortunately I cannot fix the existing code using streams and I don't want to temporarily store the incoming json data into a string to be able to use the working code.<br> Any ideas how to break the loop?</p>