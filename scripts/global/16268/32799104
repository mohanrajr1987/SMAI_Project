<p>As stated in the <a href="http://www.newtonsoft.com/json/help/html/SerializationGuide.htm" rel="nofollow">Serialization Guide of Json.NET</a> when using complex objects as keys for dictionaries one can use TypeConverters to handle serialization and deserialization.</p>  <p>I am trying to serialize/deserialize the AssymblyNameDefinition-type of <a href="https://github.com/jbevain/cecil" rel="nofollow">Mono.Cecil</a> as dictionary key. </p>  <p>I have a type like this:</p>  <pre><code>public class AssemblyToNamespacesMap : Dictionary&lt;AssemblyNameDefinition, Tuple&lt;string, List&lt;string&gt;&gt;&gt; { } </code></pre>  <p>and this TypeConverter</p>  <pre><code>public class AssemblyNameDefinitionTypeConverter : TypeConverter {     public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)     {         if (sourceType == typeof (string))         {             return true;         }          return base.CanConvertFrom(context, sourceType);     }      public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)     {         if (value is string)         {             return  AssemblyNameReference.Parse(value as string);         }          return base.ConvertFrom(context, culture, value);     }   public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)     {         if (destinationType == typeof (string))         {             return true;         }          return base.CanConvertTo(context, destinationType);     }      public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value,         Type destinationType)     {         if (value is AssemblyNameDefinition)         {             return value.ToString();         }          return base.ConvertTo(context, culture, value, destinationType);     } } </code></pre>  <p>which I register at run-time via</p>  <pre><code>TypeDescriptor.AddAttributes(typeof(AssemblyNameDefinition), new TypeConverterAttribute(typeof(AssemblyNameDefinitionTypeConverter))); </code></pre>  <p>The resulting JSON looks like this</p>  <pre>{   "ABC.Framework.Core, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null": {     "Item1": "/some/path",     "Item2": [       "ABC.Framework.IO",       "TFC.Framework.IO",       "ABC.Framework.Core"     ]   },</pre>  <p>When I try to deserialize the resulting JSON I get the following exception</p>  <pre><code>    System.ArgumentException was unhandled     HResult=-2147024809     Message=The value "ABC.Framework.Core, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null" is not of type "Mono.Cecil.AssemblyNameDefinition" and cannot be used in this generic collection.     Parameter name: key       ParamName=key       Source=mscorlib       StackTrace:            at System.ThrowHelper.ThrowWrongKeyTypeArgumentException(Object key, Type targetType)            at System.Collections.Generic.Dictionary`2.System.Collections.IDictionary.set_Item(Object key, Object value)            at Newtonsoft.Json.Serialization.JsonSerializerInternalReader.PopulateDictionary(IDictionary dictionary, JsonReader reader, JsonDictionaryContract contract, JsonProperty containerProperty, String id)            at Newtonsoft.Json.Serialization.JsonSerializerInternalReader.CreateObject(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, Object existingValue)            at Newtonsoft.Json.Serialization.JsonSerializerInternalReader.CreateValueInternal(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, Object existingValue)            at Newtonsoft.Json.Serialization.JsonSerializerInternalReader.Deserialize(JsonReader reader, Type objectType, Boolean checkAdditionalContent)           -snip- </code></pre>  <p>It seems like the string at first correctly gets converted to a AssemblyNameDefinition (at least the methods of the TypeConverter are called at some point). My wild guess is that this is due to the ToString()-method of AssemblyNameDefinition beeing overridden (The guide mentions "The string written for a key can be customized by either overriding ToString() for the key type or by implementing a TypeConverter") but I am not sure. Taking a look into</p>  <p>Glad about any pointers.</p>