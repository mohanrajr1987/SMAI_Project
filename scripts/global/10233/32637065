<p>I have a jQuery plugin with some custom selectors. In one of the selectors, I want to call another custom selector to filter the results before calling the current one. </p>  <p>So, for example I have <code>:foo</code> and <code>:bar</code>. Whenever I call <code>:bar</code>, I want it to act like calling <code>:not(:foo):bar</code>.</p>  <p>I tried writing <code>:bar</code> like this:</p>  <pre><code>$.extend($.expr[":"], {     bar: function (element) {         $(element).not(':foo').hasClass('bar');     }     foo: function (element) {         // Some very time consuming stuff...     } }); </code></pre>  <p>But <code>:foo</code> is not very efficient, so I only want to call it a single time during the operation. <code>jQuery</code> calls the <code>bar</code> function for <strong>every element</strong> that matches the selector that is passed to bar (typically it is called without one, so <code>*</code> is what is used), so it takes a long time.</p>  <p>Is there some way to wrap up the call to the <code>:bar</code> selector so it automatically applies the <code>:foo</code> filter before iterating all of the calls to the <code>bar</code> function?</p>  <p>According to the selected answer <a href="http://stackoverflow.com/questions/4587327/custom-jquery-selector">here</a> and <a href="http://www.bennadel.com/blog/1457-how-to-build-a-custom-jquery-selector.htm" rel="nofollow">this post</a>, I should have access to 4 parameters in the selector function (element, index, properties, and stack). I was hoping to grab the stack, do my filter on it, determine if any element has the class, then clear the stack. However, index is always 0 and stack is undefined in <code>jQuery</code> 1.10.2.</p>  <p>Are there any other ways of getting this done?</p>  <blockquote>   <p>NOTE: I am looking for a solution that will work in all versions of <code>jQuery</code> 1.4.2 and later.</p> </blockquote>