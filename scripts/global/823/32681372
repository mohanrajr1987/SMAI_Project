<p>I do not know any real assembly, but can read GCC <code>-S</code> output to evaluate actual costs of given C code. </p>  <p>This question is not that much about profiling and benchmarks, but rather educational. I need someone to explain me why [1] snippet is not faster than the second one.</p>  <p>Well, used to think like: "yeah, some operations like MUL are pretty expensive, but if one assembly is X times bigger than another, it should be slower". </p>  <p>This was quite true until I have met those two:</p>  <pre><code>unsigned char bytes[4] = {0, 0, 0, 5};  // 1 int32_t val = *((int32_t*)bytes);       /* produces:         leaq    -16(%rbp), %rax         movl    (%rax), %eax         movl    %eax, -4(%rbp)         movl    $0, %eax */  // 2    val = bytes[3] |                                      (bytes[2] &lt;&lt; 8) |                               (bytes[1] &lt;&lt; 16) |       (bytes[0] &lt;&lt; 24); /* produces:          movzbl  -13(%rbp), %eax         movzbl  %al, %eax         movzbl  -14(%rbp), %edx         movzbl  %dl, %edx         sall    $8, %edx         orl     %eax, %edx         movzbl  -15(%rbp), %eax         movzbl  %al, %eax         sall    $16, %eax         orl     %eax, %edx         movzbl  -16(%rbp), %eax         movzbl  %al, %eax         sall    $24, %eax         orl     %edx, %eax         movl    %eax, -4(%rbp)         movl    $0, %eax */ </code></pre>  <p>And benchmarks are showing that the 2-nd one is 5-10% faster. What is going on here? </p>  <p>The only significant difference and "reason" I can imagine is <code>LEAQ</code> is something very slow. Last 2 lines are identical, so maybe <code>MOV</code> price is so high that 1 extra <code>MOV</code> is worse than tons of instructions.</p>  <p>Here is what I used to measure execution times:</p>  <pre><code>#include &lt;stdio.h&gt; #include &lt;time.h&gt; #include &lt;stdint.h&gt;  #define REPETITIONS 32 #define ITERATIONS 90000  #define CODE1                   \   for (int i = 0; i &lt; ITERATIONS; ++i) {    \     val = *((int32_t*)bytes);           \   }  #define CODE2                   \   for (int i = 0; i &lt; ITERATIONS; ++i) {    \     val = bytes[3] |                \       (bytes[2] &lt;&lt; 8) |             \       (bytes[1] &lt;&lt; 16) |            \       (bytes[0] &lt;&lt; 24);             \   }  int main(void) {   clock_t minTs = 999999999, ts;   unsigned char bytes[4] = {0, 0, 0, 5};       int32_t val;                      for (int i = 0; i &lt; REPETITIONS; ++i) {     ts = clock();      CODE1; // Or CODE2      ts = clock() - ts;     if (ts &lt; minTs) minTs = ts;   }    printf("ts: %ld\n", minTs);    return val; } </code></pre>  <p><hr> <em>Update</em>: as it turns out, results are hardware specific, so while [1] is slower on my laptop (x64 i5-4260U), it is faster on my PC (but by a very small fraction like 5%).</p>