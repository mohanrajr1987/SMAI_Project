<p>My code right now looks like this:</p>  <pre><code>; compute          /   |x+b|            , when c=a*x  ;              y = |   a^2-3b           , when c&lt;a*x ;                  \   (2c-a)/(c+ax)    , when c&gt;a*x    stekas  SEGMENT STACK     DB 256 DUP(0) stekas  ENDS  duom    SEGMENT  a   DB  -2  b   DB  2 c   DW  6 x   DW -10,-8,-3,1,2,4 kiek    = ($-x)/2 y   DB kiek dup(0AAh)      isvb    DB 'x=',6 dup (?), ' y=',6 dup (?), 0Dh, 0Ah, '$' perp    DB 'Overflow', 0Dh, 0Ah, '$' daln    DB '0 division', 0Dh, 0Ah, '$' netb    DB 'Overflow', 0Dh, 0Ah, '$' spausk  DB 'Computing is over', 0Dh, 0Ah, '$'  duom    ENDS  prog    SEGMENT     assume ss:stekas, ds:duom, cs:prog pr: MOV ax, duom     MOV ds, ax     XOR si, si      ; (sum mod 2) si = 0     XOR di, di      ; di = 0 c_pr:   MOV cx, kiek         JCXZ pab cikl:     MOV al, a     CBW     IMUL x[si]        CMP c, ax     JE f2     JL f3    f1: MOV ax, c      MOV bx, 2 ; 2c     IMUL bx     JO kl1     MOV bx, ax     MOV al, a     CBW     XCHG ax, bx     SUB ax, bx ; 2c-a     MOV bx, ax     MOV ax, x[si]     IMUL a        ; a*x     JO kl1     ADD ax, c     ; a*x+c     JO kl1     XCHG ax, bx     CWD      IDIV bx       ; (2c-a)/(a*x+c)     JMP re f3: MOV al, a     CBW     IMUL a     JO kl1     MOV bx, ax     MOV ax, 3       IMUL b     JO kl1     XCHG ax, bx      SUB ax, bx     JMP re f2: MOV bx, x[si]     MOV al, b     CBW     ADD ax, bx  ; x+b     MOV bx, 0     JO kl1     CMP ax, 0     JG mod     NEG ax mod:    ADD ax, bx ;2a+|c|     JO kl1 re:      CMP al, 0     JGE teigr      CMP ah, 0FFh      JE  ger     JMP kl3 teigr:  CMP ah, 0          JE ger       JMP kl3 ger:    MOV y[di], al     INC si     INC si     INC di     LOOP cikl pab:                         ;============================     XOR si, si     XOR di, di          MOV cx, kiek         JCXZ is_pab is_cikl:     MOV ax, x[si]        PUSH ax     MOV bx, offset isvb+2       PUSH bx     CALL binasc     MOV al, y[di]     CBW           PUSH ax     MOV bx, offset isvb+11      PUSH bx     CALL binasc      MOV dx, offset isvb     MOV ah, 9h     INT 21h  ;============================     INC si          INC si     INC di     LOOP is_cikl is_pab:  ;===== PAUZE ===================       LEA dx, spausk     MOV ah, 9     INT 21h     MOV ah, 0          INT 16h  ;============================                 MOV ah, 4Ch      INT 21h ;============================     kl1:    LEA dx, perp     MOV ah, 9     INT 21h     XOR al, al     JMP ger kl2:    LEA dx, daln     MOV ah, 9     INT 21h     XOR al, al     JMP ger kl3:    LEA dx, netb     MOV ah, 9     INT 21h     XOR al, al     JMP ger  binasc  PROC NEAR        PUSH bp     MOV bp, sp      PUSHA        MOV cx, 6        MOV bx, [bp+4] tarp:   MOV byte ptr[bx], ' '     INC bx     LOOP tarp      MOV ax, [bp+6]     MOV si, 10     CMP ax, 0     JGE val      NEG ax val:    XOR dx, dx     DIV si      ADD dx, '0'   ; galima--&gt; ADD dx, 30h      DEC bx     MOV [bx], dl      INC cx      CMP ax, 0     JNZ val      MOV ax, [bp+6]     CMP ax,0     JNS teig      DEC bx     MOV byte ptr[bx], '-'     INC cx     JMP vepab  teig:   DEC bx     MOV byte ptr[bx], '+'     INC cx vepab:       POPA       POP bp     RET binasc  ENDP     prog    ENDS          END pr </code></pre>  <p>I need to change x from DW to DB. This is how code looks like after my changes.</p>  <pre><code>; compute          /   |x+b|            , when c=a*x  ;              y = |   a^2-3b           , when c&lt;a*x ;                  \   (2c-a)/(c+ax)    , when c&gt;a*x    stekas  SEGMENT STACK     DB 256 DUP(0) stekas  ENDS  duom    SEGMENT  a   DB  -2  b   DB  2 c   DW  6 x   **DB** -10,-8,-3,1,2,4 kiek    = ($-x)/2 y   DB kiek dup(0AAh)      isvb    DB 'x=',6 dup (?), ' y=',6 dup (?), 0Dh, 0Ah, '$' perp    DB 'Overflow', 0Dh, 0Ah, '$' daln    DB '0 division', 0Dh, 0Ah, '$' netb    DB 'Overflow', 0Dh, 0Ah, '$' spausk  DB 'Computing is over', 0Dh, 0Ah, '$'  duom    ENDS  prog    SEGMENT     assume ss:stekas, ds:duom, cs:prog pr: MOV ax, duom     MOV ds, ax     XOR si, si      ; (sum mod 2) si = 0     XOR di, di      ; di = 0 c_pr:   MOV cx, kiek         JCXZ pab cikl:     MOV al, a     CBW     IMUL x[si]        CMP c, ax     JE f2     JL f3    f1: MOV ax, c      MOV bx, 2 ; 2c     IMUL bx     JO kl1     MOV bx, ax     MOV al, a     CBW     XCHG ax, bx     SUB ax, bx ; 2c-a     MOV bx, ax     **MOV al, x[si]     CBW**     IMUL a        ; a*x     JO kl1     ADD ax, c     ; a*x+c     JO kl1     XCHG ax, bx     CWD      IDIV bx       ; (2c-a)/(a*x+c)     JMP re f3: MOV al, a     CBW     IMUL a     JO kl1     MOV bx, ax     MOV ax, 3       IMUL b     JO kl1     XCHG ax, bx      SUB ax, bx     JMP re f2: **MOV al, x[si]     CBW     MOV bx, ax**     MOV al, b     CBW     ADD ax, bx  ; x+b     MOV bx, 0     JO kl1     CMP ax, 0     JG mod     NEG ax mod:    ADD ax, bx ;2a+|c|     JO kl1 re:      CMP al, 0     JGE teigr      CMP ah, 0FFh      JE  ger     JMP kl3 teigr:  CMP ah, 0          JE ger       JMP kl3 ger:    MOV y[di], al     INC si     INC si     INC di     LOOP cikl pab:                         ;============================     XOR si, si     XOR di, di          MOV cx, kiek         JCXZ is_pab is_cikl:     **MOV al, x[si]     CBW**       PUSH ax     MOV bx, offset isvb+2       PUSH bx     CALL binasc     MOV al, y[di]     CBW           PUSH ax     MOV bx, offset isvb+11      PUSH bx     CALL binasc      MOV dx, offset isvb     MOV ah, 9h     INT 21h  ;============================     INC si          INC si     INC di     LOOP is_cikl is_pab:  ;===== PAUZE ===================       LEA dx, spausk     MOV ah, 9     INT 21h     MOV ah, 0          INT 16h  ;============================                 MOV ah, 4Ch      INT 21h ;============================     kl1:    LEA dx, perp     MOV ah, 9     INT 21h     XOR al, al     JMP ger kl2:    LEA dx, daln     MOV ah, 9     INT 21h     XOR al, al     JMP ger kl3:    LEA dx, netb     MOV ah, 9     INT 21h     XOR al, al     JMP ger  binasc  PROC NEAR        PUSH bp     MOV bp, sp      PUSHA        MOV cx, 6        MOV bx, [bp+4] tarp:   MOV byte ptr[bx], ' '     INC bx     LOOP tarp      MOV ax, [bp+6]     MOV si, 10     CMP ax, 0     JGE val      NEG ax val:    XOR dx, dx     DIV si      ADD dx, '0'   ; galima--&gt; ADD dx, 30h      DEC bx     MOV [bx], dl      INC cx      CMP ax, 0     JNZ val      MOV ax, [bp+6]     CMP ax,0     JNS teig      DEC bx     MOV byte ptr[bx], '-'     INC cx     JMP vepab  teig:   DEC bx     MOV byte ptr[bx], '+'     INC cx vepab:       POPA       POP bp     RET binasc  ENDP     prog    ENDS          END pr </code></pre>  <p>I seperated places I edited with ** The problem is, that now loop actually is twice shorter. Before changes. Loop was executed six times, and now it is executed only three times with x values of -10, -3, 2 (it seems like one of two only)</p>  <p>I thought that the problem can be with kiek = ($-x)/2 I removed /2 from the end, but then it didn't helped. It started to show some random(I guess) x values.</p>  <p>What am I missing here? Where is the key factor that crashes my program when I try to change x from DW to DB?</p>