<p>I have been pulling my hair for the past few weeks. And still not able to crack this code. I would like to get some guideline and hints on what am I doing wrong reading this binary bomb code.</p>  <p>My objective is trying to defuse the bomb, avoid bomb explosion while I am doing this. </p>  <p>I understand that read_six_numbers function attempting to do is getting value from sscanf. Then when it get to compare ( cmpl ) is when I try to figure it out what is the number I am looking for. </p>  <p>Say my input variables are: a, b, c, d, e, f I got to where I know a=0 , b=1 , but having a hard time where to go from here. </p>  <p>Line 43 - 52 : am I reading it correct? EBP store negative typically store local variables, so I assumed these value from scanf function, and store to registers?  Line 55 : cmpl  : here is where I am confused, ebx is retur Line 67 : cmp   : here is seem to be where the loop is going on.</p>  <p>My approach was to set a breakpoint and then use gdb to read the value off what my input was comparing to. But I don't understand which is input and which is the constant value that I am looking for each loop.</p>  <p>where should I set my break point here and which value exactly I am supposed to read?  </p>  <p>currently, I am doing is</p>  <pre><code>(gdb) b *0x08048cad  // Line 55 (gdb) i r       // Read value looking for %eax ? each time it hit line 55 ? </code></pre>  <p>Some guideline would appreciate.</p>  <pre><code>Dump of assembler code for function phase_2:     0x08048c76 &lt;+0&gt;:   push   %ebp    0x08048c77 &lt;+1&gt;:   mov    %esp,%ebp    0x08048c79 &lt;+3&gt;:   push   %esi    0x08048c7a &lt;+4&gt;:   push   %ebx    0x08048c7b &lt;+5&gt;:   int3       0x08048c7c &lt;+6&gt;:   in     (%dx),%al    0x08048c7d &lt;+7&gt;:   xor    %cl,0x4489e045(%ebp)    0x08048c83 &lt;+13&gt;:      and    $0x4,%al    0x08048c85 &lt;+15&gt;:      mov    0x8(%ebp),%eax    0x08048c88 &lt;+18&gt;:      mov    %eax,(%esp)    0x08048c8b &lt;+21&gt;:      call   0x804917a &lt;read_six_numbers&gt;       0x08048c90 &lt;+26&gt;:      cmpl   $0x0,-0x20(%ebp)      // a = 0    0x08048c94 &lt;+30&gt;:      jne    0x8048c9c &lt;phase_2+38&gt;    0x08048c96 &lt;+32&gt;:     cmpl   $0x1,-0x1c(%ebp)       // b = 1    0x08048c9a &lt;+36&gt;:     je     0x8048ca1 &lt;phase_2+43&gt;          0x08048c9c &lt;+38&gt;:     call   0x8049138 &lt;explode_bomb&gt;    0x08048ca1 &lt;+43&gt;:     lea    -0x18(%ebp),%ebx          // store c into %ebx    0x08048ca4 &lt;+46&gt;:     lea    -0x8(%ebp),%esi          // store d into %esi    0x08048ca7 &lt;+49&gt;:     mov    -0x4(%ebx),%eax          // store e into %eax    0x08048caa &lt;+52&gt;:     add    -0x8(%ebx),%eax       // adding f + e into %eax    0x08048cad &lt;+55&gt;:     cmp    %eax,(%ebx)           // compare  %eax  with (%ebx)  ?? &lt;-    0x08048caf &lt;+57&gt;:     je     0x8048cb6 &lt;phase_2+64&gt;        //value compared : must equal    0x08048cb1 &lt;+59&gt;:     call   0x8049138 &lt;explode_bomb&gt;          0x08048cb6 &lt;+64&gt;:     add    $0x4,%ebx             // %ebx = %ebx + 0x4    0x08048cb9 &lt;+67&gt;:     cmp    %esi,%ebx             // compare %esi   with %ebx     0x08048cbb &lt;+69&gt;:     jne    0x8048ca7 &lt;phase_2+49&gt;        //value compared : must equal , if not go back                                        to 49 adding    0x08048cbd &lt;+71&gt;:     add    $0x30,%esp    0x08048cc0 &lt;+74&gt;:     pop    %ebx    0x08048cc1 &lt;+75&gt;:     pop    %esi    0x08048cc2 &lt;+76&gt;:     pop    %ebp    0x08048cc3 &lt;+77&gt;:     ret  </code></pre>  <p><a href="http://i.stack.imgur.com/kCx9s.png" rel="nofollow"><img src="http://i.stack.imgur.com/kCx9s.png" alt="enter image description here"></a></p>