<p>I have code in my custom bootloader that copies memory from a 512-byte buffer at address <code>0x8E00</code> into high memory, <code>0x100000</code> and higher. This works fine on some computers, and crashes (triple-faults, I assume) on others. This code also works fine in the Bochs x86 emulator.</p>  <p>I have tried replacing the custom segment-offset copy loop with a <code>rep movsb</code>, setting <code>esi</code> and <code>edi</code> to the appropriate addresses, and finding this also faults on some computers. Is there <em>any</em> reason why this should fail?</p>  <p>Bootload.asm:</p>  <pre><code>BOOTLOADER_SECTORS equ 3                ; includes first sector, loaded by   BIOS  ; a boot sector that enters 32-bit protected mode         BITS 16         ORG 0x7c00          jmp short bootloader_start      ; Jump past disk description section         nop                             ; Pad out before disk description   ; ------------------------------------------------------------------ ; Disk description table, to make it a valid floppy ; Note: some of these values are hard-coded in the source! ; Values are those used by IBM for 1.44 MB, 3.5" diskette  OEMLabel                db "OLIVEOS "   ; Disk label BytesPerSector          dw 512          ; Bytes per sector SectorsPerCluster       db 1            ; Sectors per cluster ReservedForBoot         dw BOOTLOADER_SECTORS ; Reserved sectors for boot record NumberOfFats            db 2            ; Number of copies of the FAT RootDirEntries          dw 224          ; Number of entries in root dir                                         ; (224 * 32 = 7168 = 14 sectors to read) LogicalSectors          dw 2880         ; Number of logical sectors MediumByte              db 0F0h         ; Medium descriptor byte SectorsPerFat           dw 9            ; Sectors per FAT SectorsPerTrack         dw 18           ; Sectors per track (36/cylinder) Sides                   dw 2            ; Number of sides/heads HiddenSectors           dd 0            ; Number of hidden sectors LargeSectors            dd 0            ; Number of LBA sectors DriveNo                 dw 0            ; Drive No: 0 Signature               db 41           ; Drive signature: 41 for floppy VolumeID                dd 00000000h    ; Volume ID: any number VolumeLabel             db "OLIVEOS    "; Volume Label: any 11 chars FileSystem              db "FAT12   "   ; File system type: don't change!          KERNEL_OFFSET equ 0x100000      ; kernel load offset         STACK_LOCATION equ 0x7c00       ; stack location         MEM_MAP_ENTRIES equ 0x5000      ; memory map length offset         MEM_MAP_OFFSET equ 0x5004       ; memory map offset  bootloader_start:         ; NOTE: A few early BIOSes are reported to improperly set DL          cmp dl, 0         je no_change         mov [BOOT_DRIVE], dl            ; Save boot device number         mov ah, 8                       ; Get drive parameters         int 13h         jc disk_error         and cx, 3Fh                     ; Maximum sector number         mov [SectorsPerTrack], cx       ; Sector numbers start at 1         movzx dx, dh                    ; Maximum head number         add dx, 1                       ; Head numbers start at 0 - add 1 for total         mov [Sides], dx  no_change:         mov eax, 0                      ; Needed for some older BIOSes          cli         xor ax, ax                      ; make AX zero         mov ds, ax                      ; so we point our segment registers to zero         mov es, ax         mov fs, ax         mov gs, ax         mov ss, ax          jmp 0x0000:bootloader_landing   ; far jump to clear cs to 0  bootloader_landing:         mov bp, STACK_LOCATION          ; set up stack         mov sp, bp          sti          mov si, MSG_STARTING_BOOTLOADER         call bios_print_string          call load_bootloader            ; load the rest of the bootloader (if we don't do it first,                                         ; something is very likely going to mess up)          pusha         mov di, MEM_MAP_OFFSET         jmp bios_get_memory             ; get memory map for kernel bios_get_memory_return:         popa          mov bp, STACK_LOCATION          ; set up stack again (bios_get_memory trashed our stack)         mov sp, bp          jmp second_stage                ; transfer control to second stage!  ; loads the rest of this bootloader load_bootloader:         mov bx, second_stage            ; read to 0x7e00 (right after this 512 byte code segment)         mov al, BOOTLOADER_SECTORS-1    ; sectors to read         mov dl, [BOOT_DRIVE]            ; drive         mov cl, 0x02                    ; start sector         mov ch, 0x00                    ; cylinder         mov dh, 0x00                    ; head         mov ah, 0x02                    ; BIOS read sector function          push ax                         ; store AX on stack so later we can recall                                         ; how many sectors were request to be read,                                         ; even if it is altered in the meantime          int 0x13                        ; call BIOS          jc disk_error                   ; jump if error (carry flag set)          pop dx                          ; restore from stack (was AX before)         cmp dl, al                      ; if AL (sectors read) != DH (sectors expected)         jne disk_error                  ;     display error message          ret  ; displays error message and hangs disk_error:         mov si, DISK_ERROR_MSG         call bios_print_string          sti .halt:         hlt         jmp .halt  ; ----------------------------------------------------------------- ; BOOTLOADER SUBROUTINES: ; bios_print_string:         pusha          mov ah, 0x0e                    ; int 10h teletype function  .repeat:         lodsb                           ; Get char from string          cmp al, 0         je .done                        ; If char is zero, end of string          int 0x10                        ; Otherwise, print it         jmp .repeat                     ; And move on to next char  .done:         popa         ret  ; prints 16 bit hex value from AX bios_print_2hex:         push cx          mov cx, 16-4 .repeat:                 push ax          shr ax, cl         and ax, 0xf         cmp ax, 9         jle .print          add ax, 'A'-'9'-1  .print:         add ax, '0'         mov ah, 0x0e         int 0x10          pop ax          cmp cx, 0         je .done          sub cx, 4         jmp .repeat; .done:         pop cx         ret  ; prints 32 bit hex value from AX bios_print_4hex:         push eax          shr eax, 16         call bios_print_2hex          pop eax         and eax, 0xffff         call bios_print_2hex          ret  ; global variables BOOT_DRIVE      db 0 MSG_STARTING_BOOTLOADER db "OliveOS", 0 MSG_STARTING_SECOND_STAGE db " has started!", 0 MSG_READING     db ".", 0 MSG_READING2    db "!", 0 DISK_ERROR_MSG  db "Disk read error!", 0 MSG_REG_DUMP    db 0xD, 0xA, "INTERNAL REG DUMP", 0xD, 0xA, 0 NEWLINE         db 0xD, 0xA, 0  ; bootsector padding times 510-($-$$) db 0 dw 0xaa55          BITS 16  second_stage:         mov si, MSG_STARTING_SECOND_STAGE         call bios_print_string          ;call bios_enable_a20         call load_kernel          jmp switch_to_pm                ; switch to protected mode, we won't return from here          BITS 32 ; this is where we arrive after switching to and initializing protected mode begin_pm:         call kbd_enable_a20         call fast_enable_a20          call CODE_SEG:KERNEL_OFFSET     ; now call the kernel!  .halt:         hlt                             ; hang         jmp .halt          BITS 16  load_dest:         dd      KERNEL_OFFSET  ; loads the kernel from the floppy image load_kernel:                 mov ax, BOOTLOADER_SECTORS      ; start logical sector         mov cx, 200                     ; number of sectors to read  .continue:         cmp cx, 0         je .done          pusha         mov ebx, 0x8E00                 ; write to 0x8E00 a temporary 512 byte buffer         call bios_disk_load             ; load bytes to buffer          mov si, MSG_READING         call bios_print_string         popa          pusha                           ; copy bytes in buffer to destination         call switch_to_unreal           ; switch to unreal mode to access high memory          mov cx, 0x200                   ; copy 512 bytes         mov ebx, 0x8E00                 ; read from 0x8E00         mov edx, dword [load_dest]      ; load destination address  .copy:         cmp cx, 0         je .done_copying          mov eax, dword [fs:ebx]         mov dword [fs:edx], eax         ; commenting out this line (the actual write) will work on any computer          add ebx, 4         add edx, 4          sub cx, 4         jmp short .copy  .done_copying:         call switch_to_real             ; switch back to real mode         popa          add dword [load_dest], 0x200    ; add 512 bytes to output pointer         inc ax                          ; increment logical sector         dec cx                          ; decrement loop counter          jmp .continue                   ; continue reading .done:             ret  ;sets up LBA address in AX for INT 13H logical_int13_setup:         push bx         push ax          mov bx, ax                      ; Save logical sector          mov dx, 0                       ; First the sector         div word [SectorsPerTrack]         add dl, 0x01                    ; Physical sectors start at 1         mov cl, dl                      ; Sectors belong in CL for int 13h         mov ax, bx          mov dx, 0                       ; Now calculate the head         div word [SectorsPerTrack]         mov dx, 0         div word [Sides]         mov dh, dl                      ; Head/side         mov ch, al                      ; Track          pop ax         pop bx          mov dl, byte [BOOT_DRIVE]       ; Set correct device          ret  ;bios_disk_load: loads logical sector in AX to ES:BX bios_disk_load:         call logical_int13_setup        ; setup our parameters          mov ah, 0x2                     ; INT 0x13 function         mov al, 0x1                     ; load 1 sector          int 0x13          jc disk_error                   ; jump if error (carry flag set)          cmp al, 1                       ; if AL (sectors read) != 1 (sectors expected)         jne disk_error                  ;     display error message          ret  bios_reg_dump:         pusha          mov si, MSG_REG_DUMP         call bios_print_string          mov si, .MSG_AX         call bios_print_string         call bios_print_4hex         mov si, NEWLINE         call bios_print_string          mov si, .MSG_BX         call bios_print_string         mov eax, ebx         call bios_print_4hex         mov si, NEWLINE         call bios_print_string          mov si, .MSG_CX         call bios_print_string         mov eax, ecx         call bios_print_4hex         mov si, NEWLINE         call bios_print_string          mov si, .MSG_DX         call bios_print_string         mov eax, edx         call bios_print_4hex         mov si, NEWLINE         call bios_print_string          mov si, .MSG_CS         call bios_print_string         mov eax, cs         call bios_print_4hex         mov si, NEWLINE         call bios_print_string          mov si, .MSG_DS         call bios_print_string         mov eax, ds         call bios_print_4hex         mov si, NEWLINE         call bios_print_string          mov si, .MSG_ES         call bios_print_string         mov eax, es         call bios_print_4hex         mov si, NEWLINE         call bios_print_string          mov si, .MSG_FS         call bios_print_string         mov eax, fs         call bios_print_4hex         mov si, NEWLINE         call bios_print_string          mov si, .MSG_GS         call bios_print_string         mov eax, gs         call bios_print_4hex         mov si, NEWLINE         call bios_print_string          popa         ret          .MSG_AX db "EAX: 0x", 0         .MSG_BX db "EBX: 0x", 0         .MSG_CX db "ECX: 0x", 0         .MSG_DX db "EDX: 0x", 0         .MSG_CS db "CS: 0x", 0         .MSG_DS db "DS: 0x", 0         .MSG_ES db "ES: 0x", 0         .MSG_FS db "FS: 0x", 0         .MSG_GS db "GS: 0x", 0  %include "source/bootload/gdt.asm" %include "source/bootload/protected_mode.asm" %include "source/bootload/memory.asm"  times (BOOTLOADER_SECTORS*512)-($-$$) db 0 </code></pre>  <p>gdt.asm:</p>  <pre><code>; GDT gdt_start:  gdt_null:                               ; the mandatory null descriptor         dd 0x0                          ; 'dd' means define double word (4 bytes)         dd 0x0  gdt_code:                               ; the code segment descriptor         ; base=0x0, limit=0xfffff,         ; 1st flags: (present)1 (privilege)00 (descriptor type)1 -&gt; 1001b         ; type flags: (code)1 (conforming)0 (readable)1 (accessed)0 -&gt; 1010b         ; 2nd flags: (granularity)1 (32-bit default)1 (64-bit segment)0 (AVL)0 -&gt; 1100b         dw 0xffff                       ; limit (bits 0-15)         dw 0x0                          ; base (bits 0-15)         db 0x0                          ; base (bits 16-23)         db 10011010b                    ; 1st flags, type flags         db 11001111b                    ; 2nd flags, limit (bits 16-19)         db 0x0                          ; base (bits 24-31)  gdt_data:                               ; the data segment descriptor         ; same as code segment except for the type flags:         ; type flags: (code)0 (expand down)0 (writable)1 (accessed)0 -&gt; 0010b         dw 0xffff                       ; limit (bits 0-15)         dw 0x0                          ; base (bits 0-15)         db 0x0                          ; base (bits 16-23)         db 10010010b                    ; 1st flags, type flags         db 11001111b                    ; 2nd flags, limit (bits 16-19)         db 0x0                          ; base (bits 24-31)  gdt_end:                                ; the reason for putting a label at the end of the                                         ; GDT is so we can have the assembler calculate                                         ; the size of the GDT for the GDT descriptor   ; GDT descriptor gdt_descriptor:         dw gdt_end - gdt_start - 1      ; size of our GDT, always less one of the true size         dd gdt_start                    ; start address of our GDT  ; define some handy constants for the GDT segment descriptor offsets, which ; are what segment registers must contain when in protected mode. For example, ; when we set DS = 0x10 in protected mode, the CPU knows that we mean it to use the ; segment described at offset 0x10 (i.e. 16 bytes) in our GDT, which in our ; case is the DATA segment (0x0 -&gt; NULL; 0x08 -&gt; CODE; 0x10 -&gt; DATA) CODE_SEG equ gdt_code - gdt_start DATA_SEG equ gdt_data - gdt_start  ; 16 bit GDT gdt16_start:  gdt16_null:                             ; the mandatory null descriptor         dd 0x0                          ; 'dd' means define double word (4 bytes)         dd 0x0  gdt16_code:                             ; the code segment descriptor         ; base=0x0, limit=0xfffff,         ; 1st flags: (present)1 (privilege)00 (descriptor type)1 -&gt; 1001b         ; type flags: (code)1 (conforming)0 (readable)1 (accessed)0 -&gt; 1010b         ; 2nd flags: (granularity)1 (32-bit default)1 (64-bit segment)0 (AVL)0 -&gt; 1100b         dw 0xffff                       ; limit (bits 0-15)         dw 0x0                          ; base (bits 0-15)         db 0x0                          ; base (bits 16-23)         db 10011010b                    ; 1st flags, type flags         db 11001111b                    ; 2nd flags, limit (bits 16-19)         db 0x0                          ; base (bits 24-31)  gdt16_data:                             ; the data segment descriptor         ; same as code segment except for the type flags:         ; type flags: (code)0 (expand down)0 (writable)1 (accessed)0 -&gt; 0010b         dw 0xffff                       ; limit (bits 0-15)         dw 0x0                          ; base (bits 0-15)         db 0x0                          ; base (bits 16-23)         db 10010010b                    ; 1st flags, type flags         db 11001111b                    ; 2nd flags, limit (bits 16-19)         db 0x0                          ; base (bits 24-31)  gdt16_end:                              ; the reason for putting a label at the end of the                                         ; GDT is so we can have the assembler calculate                                         ; the size of the GDT for the GDT descriptor   ; 16 bit GDT descriptor gdt16_descriptor:         dw gdt16_end - gdt16_start - 1  ; size of our GDT, always less one of the true size         dd gdt16_start                  ; start address of our GDT  ; define some handy constants for the GDT segment descriptor offsets, which ; are what segment registers must contain when in protected mode. For example, ; when we set DS = 0x10 in protected mode, the CPU knows that we mean it to use the ; segment described at offset 0x10 (i.e. 16 bytes) in our GDT, which in our ; case is the DATA segment (0x0 -&gt; NULL; 0x08 -&gt; CODE; 0x10 -&gt; DATA) CODE16_SEG equ gdt16_code - gdt16_start DATA16_SEG equ gdt16_data - gdt16_start </code></pre>  <p>memory.asm:</p>  <pre><code>        BITS 16  ; use the INT 0x15, eax= 0xE820 BIOS function to get a memory map ; inputs: es:di -&gt; destination buffer for 24 byte entries ; outputs: bp = entry count, trashes all registers except esi bios_get_memory:         xor ebx, ebx            ; ebx must be 0 to start         xor bp, bp              ; keep an entry count in bp         mov edx, 0x0534D4150    ; Place "SMAP" into edx         mov eax, 0xe820         mov [es:di + 20], dword 1       ; force a valid ACPI 3.X entry         mov ecx, 24             ; ask for 24 bytes         int 0x15         jc short .failed        ; carry set on first call means "unsupported function"         mov edx, 0x0534D4150    ; Some BIOSes apparently trash this register?         cmp eax, edx            ; on success, eax must have been reset to "SMAP"         jne short .failed         test ebx, ebx           ; ebx = 0 implies list is only 1 entry long (worthless)         je short .failed         jmp short .jmpin .e820lp:         mov eax, 0xe820         ; eax, ecx get trashed on every int 0x15 call         mov [es:di + 20], dword 1       ; force a valid ACPI 3.X entry         mov ecx, 24             ; ask for 24 bytes again         int 0x15         jc short .e820f         ; carry set means "end of list already reached"         mov edx, 0x0534D4150    ; repair potentially trashed register .jmpin:         jcxz .skipent           ; skip any 0 length entries         cmp cl, 20              ; got a 24 byte ACPI 3.X response?         jbe short .notext         test byte [es:di + 20], 1       ; if so: is the "ignore this data" bit clear?         je short .skipent .notext:         mov ecx, [es:di + 8]    ; get lower uint32_t of memory region length         or ecx, [es:di + 12]    ; "or" it with upper uint32_t to test for zero         jz .skipent             ; if length uint64_t is 0, skip entry         inc bp                  ; got a good entry: ++count, move to next storage spot         add di, 24 .skipent:         test ebx, ebx           ; if ebx resets to 0, list is complete         jne short .e820lp .e820f:         mov [MEM_MAP_ENTRIES], bp       ; store the entry count         clc                     ; there is "jc" on end of list to this point, so the carry must be cleared         jmp bios_get_memory_return .failed:         mov [MEM_MAP_ENTRIES], dword 0  ; store 0 entries         stc                     ; "function unsupported" error exit         jmp bios_get_memory_return </code></pre>  <p>protected_mode.asm:</p>  <pre><code>    BITS 16  bios_enable_a20:         mov ax, 0x2401         int 0x15         ret  switch_to_real:         cli          xor eax, eax                    ; make AX zero         mov ds, ax                      ; so we point our segment registers to zero         mov es, ax         mov fs, ax         mov gs, ax          jmp 0x0000:.jump .jump:          sti         ret  ; switch to unreal mode (sets up DS and ES with 32-bit segment descriptors) switch_to_unreal:         cli          push eax         push ebx          lgdt [gdt16_descriptor]          mov eax, cr0         or eax, 0x1         mov cr0, eax          jmp .jump                       ; tell 386/486 not to crash .jump:                 mov ebx, eax         mov ax, DATA16_SEG              ; now in protected mode, our old segments are meaningless,         mov ds, ax                      ; so we point our segment registers to the         mov es, ax                      ; data selector we defined in our GDT         mov fs, ax         mov gs, ax         mov eax, ebx          dec eax         mov cr0, eax          pop ebx         pop eax          sti         ret          BITS 16  ; switch to protected mode switch_to_pm:         call bios_enable_a20            ; attempt to set A20 line using bios          cli                             ; we must switch off interrupts until we have                                         ; set up the protected mode interrupt vector                                         ; otherwise interrupts will run riot.          lgdt [gdt_descriptor]           ; load our global descriptor table, which defines                                         ; the protected mode segments (e.g. for code and data)  .jump:         mov eax, cr0                    ; to make the switch to protected mode, we set the first         or eax, 0x1                     ; bit of CR0, a control register         mov cr0, eax          jmp CODE_SEG:init_pm            ; make a far jump (i.e. to a new segment) to our 32-bit code.                                         ; this also forces the CPU to flush its cache of pre-fetched                                         ; and real-mode decoded instructions, which can cause problems.          BITS 32  ; initialize registers and the stack once in protected mode init_pm:         mov ax, DATA_SEG                ; now in protected mode, our old segments are meaningless,         mov ds, ax                      ; so we point our segment registers to the         mov ss, ax                      ; data selector we defined in our GDT         mov es, ax         mov fs, ax         mov gs, ax          mov ebp, STACK_LOCATION         ; update our stack position so it is right         mov esp, ebp                    ; at the top of the free space          jmp begin_pm                    ; note: external label, defined in bootloader  ;attempts to enable the A20 line with the keyboard controller kbd_enable_a20:         call    .a20wait         mov     al,0xAD         out     0x64,al          call    .a20wait         mov     al,0xD0         out     0x64,al          call    .a20wait2         in      al,0x60         push    eax          call    .a20wait         mov     al,0xD1         out     0x64,al          call    .a20wait         pop     eax         or      al,2         out     0x60,al          call    .a20wait         mov     al,0xAE         out     0x64,al          call    .a20wait         ret  .a20wait:         in      al,0x64         test    al,2         jnz     .a20wait         ret   .a20wait2:         in      al,0x64         test    al,1         jz      .a20wait2         ret  fast_enable_a20:         in al, 0x92         test al, 2         jnz after          or al, 2         and al, 0xFE         out 0x92, al after:         ret </code></pre>  <p>Note: The faulting code is <strong>not</strong> in the <code>bios_print_string</code> routine, as that works flawlessly elsewhere.</p>