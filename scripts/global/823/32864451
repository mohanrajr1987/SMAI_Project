<p>I have to be missing something obvious here, but I can't seem to find the end of a string.</p>  <p>My code starts off with a few calls that read as follows:</p>  <pre><code>; read user input ;     mov     eax, SYSCALL_READ       ; read function     mov     ebx, STDIN              ; Arg 1: file descriptor     mov     ecx, buf                ; Arg 2: address of buffer (buffer is input)     mov     edx, BUFLEN             ; Arg 3: buffer length (defined as 256)     int     080h      mov     [rlen], eax             ; save length of string read </code></pre>  <p>The professor gave us a shell program to work from, but I've got a pretty good handle on most of it. What's throwing me off is that I was of the impression that rlen should now contain the length of the string I'm using, but when I type the following:</p>  <pre><code>mov     byte[esi + rlen], 92            ; add a zero </code></pre>  <p>I get a segfault. Same, also, if I use [buf + rlen]. Neither buf nor ESI on their own cause a segfault, so it seems to me that rlen isn't doing what I think it is.</p>  <p>Anyone able to help me figure out what's going on?</p>