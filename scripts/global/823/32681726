<p>Consider the following code in C++:</p>  <pre><code>bool foo(int x, int y, int z, int P) {   return (x &lt; P &amp;&amp; y &gt; P &amp;&amp; z &gt; P);      }  int tryout(int iS, int iP) {   if(foo(iS,iS,iS,iP)) {        printf("%d", 1000);   } else {         printf("%d", 10);   }   return 0; } </code></pre>  <p>When using Intel's C++ compiler, the code produces the following assembly code:</p>  <pre><code>L__routine_start__Z3fooiiii_0: foo(int, int, int, int):         cmpl      %ecx, %edi                                    #5.15         jge       ..B1.4        # Prob 50%                      #5.15         cmpl      %ecx, %esi                                    #5.24         jle       ..B1.4        # Prob 50%                      #5.24         movl      $1, %esi                                      #5.15         xorl      %eax, %eax                                    #5.15         cmpl      %ecx, %edx                                    #5.15         cmovg     %esi, %eax                                    #5.15         ret                                                     #5.15 ..B1.4:                         # Preds ..B1.2 ..B1.1         xorl      %eax, %eax                                    #5.15         ret                                                     #5.15 L__routine_start__Z6tryoutii_1: tryout(int, int):         pushq     %rsi                                          #11.28         cmpl      %esi, %edi                                    #5.15         jge       ..B2.4        # Prob 50%                      #5.15         jle       ..B2.4        # Prob 50%                      #5.24         movl      $.L_2__STRING.0, %edi                         #14.8         movl      $1000, %esi                                   #14.8         xorl      %eax, %eax                                    #14.8         call      printf                                        #14.8         jmp       ..B2.5        # Prob 100%                     #14.8 ..B2.4:                         # Preds ..B2.1 ..B2.2         movl      $.L_2__STRING.0, %edi                         #16.5         movl      $10, %esi                                     #16.5         xorl      %eax, %eax                                    #16.5         call      printf                                        #16.5 ..B2.5:                         # Preds ..B2.4 ..B2.3         xorl      %eax, %eax                                    #19.10         popq      %rcx                                          #19.10         ret                                                     #19.10 .L_2__STRING.0:     .byte   37     .byte   100     .byte   0 </code></pre>  <p>I have two questions:</p>  <ol> <li>Why are there two jumps to <code>..B2.4</code> in the <code>tryout</code> method while there is only one if-statement?</li> <li><p>What does this code from the method <code>foo</code> do?</p>  <pre><code>movl      $1, %esi                                      #5.15 xorl      %eax, %eax                                    #5.15 cmpl      %ecx, %edx                                    #5.15 cmovg     %esi, %eax                                    #5.15 </code></pre></li> </ol>