<p>I was trying to do a modified version of binary search  with squaring. I have completed the code and it works perfectly. Here I am using squares of 2 to find the location where the key becomes less than the arr[mid] . When this becomes true, I linearly square from the old mid (stored in lo) to the current mid to search for the key.</p>  <p>I know that the first part is O(logN) since I am using squares to find the mid, but I am not sure whether the entire algorithm is OlogN) or not, can someone help about this. The linear scanning is obviously not O(N) as it covers only a range between lets say 2^k to 2^k+1 on the worst case.  How do I compute its big-oh complexity.</p>  <p>Here's the code:</p>  <pre><code>public int search(int key, int arr[]) {     int lo = 0, mid = 1;     while (mid &lt; arr.length) {         if (key &lt; arr[mid]) {             break;         } else if (key &gt; arr[mid]) {             lo = mid + 1;         } else if (key == arr[mid]) {             return mid;         }         mid *= 2;     }      while (lo &lt; arr.length &amp;&amp; lo &lt; mid) {         if (key == arr[lo])             return lo;         lo++;     }     return -1; } </code></pre>  <p>Is the logic true if I use fibonacci numbers? Since there is no squaring component anymore.</p>