<p>Suppose I have an ordered list of weights, having length M. I want to divide this list into N ordered non-empty sublists, where the sum of the weights in each sublist are as close to each other  as possible.  Finally, the length of the list will always be greater than or equal to the number of partitions.</p>  <p>For example:</p>  <p>A reader of epoch fantasy  wants to read the entire Wheel of Time series in N = 90 days.  She wants to read approximately the same amount of words each day, but she doesn't want to break a single chapter across two days.  Obviously, she also doesn't want to read it out of order either.  The series has a total of M chapters, and she has a list of the word counts in each.</p>  <p>What algorithm could she use to calculate the optimum reading schedule?</p>  <p>In this example, the weights probably won't vary much, but the algorithm I'm seeking should be general enough to handle weights that vary widely.</p>  <p>As for what I consider optimum, I would say that given the choice between having two or three partitions vary in weight a small amount from the average would be better than having one partition vary a lot.  Or in other words, She would rather have several days where she reads a few hundred more or fewer words than the average, if it means she can avoid having to read a thousand words more or fewer than the average, even once.  My thinking is to use something like this to compute the score of any given solution:</p>  <p>let W_1, W_2, W_3 ... w_N be the weights of each partition (calculated by simply summing the weights of its elements). let x be the total weight of the list, divided by its length M. Then the score would be the sum, where I goes from 1 to N of (X - w_i)^2</p>  <p>So, I think I know a way to score each solution.  The question is, what's the best way to minimize the score, other than brute force?</p>  <p>Any help or pointers in the right direction would be much appreciated!</p>