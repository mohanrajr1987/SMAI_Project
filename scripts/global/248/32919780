<p>Hi I am trying to solve the topcoder problem IncompleteBST given here: <a href="http://community.topcoder.com/stat?c=problem_statement&amp;pm=6713&amp;rd=9999" rel="nofollow">http://community.topcoder.com/stat?c=problem_statement&amp;pm=6713&amp;rd=9999</a></p>  <p>My approach is : First validate if the input is a BST</p>  <pre><code>1. get the number associated with the current node  2. keep dividing it by 2 until the quotient appears in the input list    this quotient is the parent/ancestor of the current node 3. check if current node is left/right child of the ancestor    isValidChild() function does this.    i) It converts both of the numbers to binary representation   ii) 0 in the binary rep indicates left child and 1 indicates right                    child   iii) At the point of difference in the binary rep check if the next              el is 0 (left) or right(1)    iv) If left the associated character should be &lt;= cur,else &gt; cur 4) If it is a BST getTheValues() </code></pre>  <p>The code is given below</p>  <pre><code>    class IncompleteBST {  public:      vector&lt;int&gt; binaryRep(unsigned long long num) {          cout&lt;&lt;"\nBinart Rep start\n";          vector&lt;int&gt; vBinary;         while(num &gt; 0) {             vBinary.insert(vBinary.begin(),num%2);             num/=2;         }         //vBinary.insert(vBinary.begin(),num);         cout&lt;&lt;"\nBinary rep end\n";         return vBinary;     }       bool isValidChild(unordered_map&lt;unsigned long long ,char&gt;&amp; map, unordered_map&lt;unsigned long long,char&gt;::iterator childItr,unordered_map&lt;unsigned long long,char&gt;::iterator parentItr) {          cout&lt;&lt;"\nIsValidChild Start\n";          if(childItr == map.end())           cout&lt;&lt;"\nChild itr is null\n";          if(parentItr == map.end())             cout &lt;&lt;"\nparent itr is null\n";          vector&lt;int&gt; vChild = binaryRep(childItr-&gt;first);         vector&lt;int&gt; vParent = binaryRep(parentItr-&gt;first);           int i;         for(i =0;i&lt;vParent.size();i++) {             if(vChild[i] != vParent[i])                 break;         }          if(vChild[i] == 1 &amp;&amp; childItr-&gt;second &gt; parentItr-&gt;second) {             cout &lt;&lt;"\nisValidChild if end \n";             return true;         }         else if(vChild[i] == 0 &amp;&amp; childItr-&gt;second &lt; parentItr-&gt;second) {             cout &lt;&lt;"\nisValidChild else if end\n";             return true;         }         else {             cout&lt;&lt;"\nisValidChild else end\n";             return false;         }      }      bool isBST(unordered_map&lt;unsigned long long,char&gt;&amp; map) {         cout&lt;&lt;"\nisBst start";          unordered_map&lt;unsigned long long,char&gt;::iterator it;         for(it = map.begin(); it != map.end(); it++) {           if(it-&gt;first != 1 &amp;&amp; it-&gt;second != '?') {             unsigned long long num = it-&gt;first;             unordered_map&lt;unsigned long long,char&gt;::iterator resultItr;             cout&lt;&lt;"\nFInding parent itr for"&lt;&lt;num&lt;&lt;endl;             while(num &gt; 1) {                 num /= 2;                 resultItr = map.find(num);                  if(resultItr != map.end()) {                    if(resultItr-&gt;second == '?')                     continue;                    else                     break;                 }             }              if (it-&gt;second != '?' &amp;&amp; resultItr-&gt;second != '?' &amp;&amp; !isValidChild(map,it,resultItr)) {                 cout&lt;&lt;"\nIsBST end if\n";                 return false;             }          }          }          cout&lt;&lt; "\nIsBST end\n";          return true;     }      string getValues(unordered_map&lt;unsigned long long,char&gt;&amp; map,unsigned long long missingNum) {          cout&lt;&lt;"\ngetValueSStart\n";          unsigned long long tmp = missingNum;         unordered_map&lt;unsigned long long,char&gt;::iterator it;         while(tmp&gt;1) {             tmp/=2;             it = map.find(tmp);             if(it != map.end())                 break;         }          vector&lt;int&gt; vChild = binaryRep(missingNum);         vector&lt;int&gt; vParent = binaryRep(it-&gt;first);          int i;         for( i =0;i&lt;vParent.size();i++) {             if(vChild[i] != vParent[i])                 break;         }          string strResult="";         if(vChild[i] == 1) {             for(char ch = it-&gt;second+1;ch&lt;='Z';ch++)                 strResult += ch;         }else {             for(char ch = 'A'; ch&lt;=it-&gt;second;ch++)                 strResult += ch;         }         cout&lt;&lt;"\ngetValuesEnd\n";         return strResult;       }      string missingValues(vector&lt;string&gt; tree) {          cout&lt;&lt; "\n Missing Values START \n";         unordered_map&lt;unsigned long long,char&gt; map;          int sz = tree.size();          unsigned long long missingNum = 0;         for(int i=0; i&lt;sz; i++) {              vector&lt;string&gt; vTokens;             split(tree[i],' ',vTokens);             unsigned long long num = stoull(vTokens[1]);             map.insert(make_pair(num,vTokens[0][0]));             if(vTokens[0] == "?")                  missingNum = num;         }          if( !isBST(map)) {             return "";         }          return getValues(map,missingNum);      }      void split(const std::string &amp;s, char delim, std::vector&lt;std::string&gt; &amp;elems) {     std::stringstream ss(s);     std::string item;     while (std::getline(ss, item, delim)) {         elems.push_back(item);     }  }   }; </code></pre>  <p>This approach is giving me wrong answer. Can you please help me fix this</p>