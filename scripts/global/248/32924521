<pre><code>def program2(L):     squares = []     for x in L:         for y in L:             if x == y:                 squares.append(x*y)     return squares </code></pre>  <p>The no of steps taken in worst case according to me are <code>4*n^2 + 2</code> but the answer to this problem is <code>4*n^2 + 2 + n</code> and explanation is as follow                                </p>  <p>In the worst case scenario, <code>L</code> is a long list of one repeated number (i.e. <code>[2, 2, 2, 2, ...]</code>. In this case we go through the loop for <code>x</code> in <code>L</code> n times. Every time through this loop, we perform one assignment of a value to the variable <code>x</code>, then we execute the inner loop for <code>y</code> in <code>L</code> n times.</p>  <p>The inner loop performs one assignment of a value to the variable y. It then has one operation that is checked every time (if <code>x == y</code>). Since the WORST case is when the list is composed of identical elements, this check is always true - so the third and fourth operations (<code>x*y</code>, and list appending) are always performed. So the inner loop executes <code>4*n</code> times on each iteration of the outer loop. Thus the nested loop structure is executed <code>n * (4*n + 1) = 4*n**2 + n</code> times!</p>  <p>Adding in two steps (for the first assignment statement, and the return statement) we see that in the worst case, this program executes <code>4*n**2 + n + 2</code> steps.</p>  <p>Why we are adding + 1 (4n + 1). Cant able to understand this because no of steps executed  are <code>4n</code> (including the inner loop and no steps steps inside it).</p>