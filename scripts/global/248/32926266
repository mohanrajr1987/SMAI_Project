<p>I am trying learn and implement Dijkstra's algorithm for directed graphs in JAVA, I found this piece of code through Stackoverflow.</p>  <p><a href="http://en.literateprograms.org/index.php?title=Special%3aDownloadCode/Dijkstra%27s_algorithm_%28Java%29&amp;oldid=15444" rel="nofollow">http://en.literateprograms.org/index.php?title=Special%3aDownloadCode/Dijkstra%27s_algorithm_%28Java%29&amp;oldid=15444</a></p>  <p>I understand some stuff, but I am having difficulty on figuring out which way to go for these two questions? </p>  <p>1) The number of trips starting at A and ending at A with a maximum of 3 stops. (Does this mean I find the route from A - A ? Because that always comes to 0.</p>  <p>And this:  The distance of the route A-E-B-C-D - (Should I call the compute for each node and then add them all up ? Is this the smartest way ? )</p>  <p>Here is my code:  Any Help would be appreciated. </p>  <p>My Output is: </p>  <p>Distance to A: 0.0 Path: [A] Distance to B: 5.0 Path: [A, B] Distance to C: 9.0 Path: [A, B, C] Distance to D: 5.0 Path: [A, D] Distance to E: 7.0 Path: [A, E]</p>  <p>package src.main.java;</p>  <pre><code>import java.util.PriorityQueue; import java.util.List; import java.util.ArrayList; import java.util.Collections;  class Vertex implements Comparable&lt;Vertex&gt; {     public final String name;     public Edge[] adjacencies;     public double minDistance = Double.POSITIVE_INFINITY;     public Vertex previous;     public Vertex(String argName) { name = argName; }     public String toString() { return name; }     public int compareTo(Vertex other)     {         return Double.compare(minDistance, other.minDistance);     }  }   class Edge {     public final Vertex target;     public final double weight;     public Edge(Vertex argTarget, double argWeight)     { target = argTarget; weight = argWeight; } }  public class Main {     public static void computePaths(Vertex source)     {         source.minDistance = 0.;         PriorityQueue&lt;Vertex&gt; vertexQueue = new PriorityQueue&lt;Vertex&gt;();         vertexQueue.add(source);          while (!vertexQueue.isEmpty()) {             Vertex u = vertexQueue.poll();              // Visit each edge exiting u             for (Edge e : u.adjacencies)             {                 Vertex v = e.target;                 double weight = e.weight;                 double distanceThroughU = u.minDistance + weight;                 if (distanceThroughU &lt; v.minDistance) {                     vertexQueue.remove(v);                      v.minDistance = distanceThroughU ;                     v.previous = u;                     vertexQueue.add(v);                 }             }         }     }      public static List&lt;Vertex&gt; getShortestPathTo(Vertex target)     {         List&lt;Vertex&gt; path = new ArrayList&lt;Vertex&gt;();         for (Vertex vertex = target; vertex != null; vertex = vertex.previous)             path.add(vertex);          Collections.reverse(path);         return path;     }      public static void main(String[] args)     {         Vertex v0 = new Vertex("A");         Vertex v1 = new Vertex("B");         Vertex v2 = new Vertex("C");         Vertex v3 = new Vertex("D");         Vertex v4 = new Vertex("E");         v0.adjacencies = new Edge[]{ new Edge(v1,  5),                 new Edge(v3,  5), new Edge(v4, 7) };         v1.adjacencies = new Edge[]{ new Edge(v2,  4)};         v2.adjacencies = new Edge[]{ new Edge(v3,  8), new Edge(v4, 2) };         v3.adjacencies = new Edge[]{ new Edge(v2, 8),                 new Edge(v4,  6) };         v4.adjacencies = new Edge[]{ new Edge(v1, 3) };          Vertex[] vertices = { v0, v1, v2, v3, v4};          computePaths(v0);         for (Vertex v : vertices)         {             System.out.println("Distance to " + v + ": " + v.minDistance);             List&lt;Vertex&gt; path = getShortestPathTo(v);             System.out.println("Path: " + path);         }     } } </code></pre>