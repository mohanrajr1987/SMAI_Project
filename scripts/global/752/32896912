<p>Despite there are some information in answers to these questions: <a href="http://stackoverflow.com/questions/2207341/cast-ilist-to-list">Cast IList to List</a> and <a href="http://stackoverflow.com/questions/15516462/is-there-a-performance-impact-when-calling-tolist">Performance impact when calling ToList()</a> they do not answer my specific question. I have a class that is a wrapper around List. This class was designed to be sent via WCF services and implements some additional functionality.</p>  <pre><code>[DataContract] public class DataContractList&lt;T&gt; : IList&lt;T&gt; {     [DataMember]     protected readonly List&lt;T&gt; InnerList;      public DataContractList()     {         InnerList = new List&lt;T&gt;();     }      public DataContractList(IList&lt;T&gt; items)     {         InnerList = items as List&lt;T&gt; ?? items.ToList(); //Question is about this line.     } } </code></pre>  <p>So there is a constructor that accepts an <code>IList&lt;T&gt;</code> interface (in order to encourage programming to interface). I need to convert this <code>IList&lt;T&gt;</code> interface to <code>List&lt;T&gt;</code> class. I can use <code>.ToList()</code> extension method which internally creates a new instance of <code>List&lt;T&gt;</code> by passing IEnumrable "this" argument to it's constructor (see <a href="http://referencesource.microsoft.com/#System.Core/System/Linq/Enumerable.cs,833" rel="nofollow">here</a>). Generic <code>List&lt;T&gt;</code> constructor just iterates through this enumberable. So I would like to prevent this iteration if it's not necessary (in case inner items parameter is already a <code>List&lt;T&gt;</code>). So, is it an optimal way (in terms of performance and readability) to do this: <code>InnerList = items as List&lt;T&gt; ?? items.ToList();</code>? If no, please provide with details about better way and why.</p>