<p>I'm have a combobox on a website built with Dojo and using the ArcGIS Javascript API.  Since the combobox can contain thousands of entries, I'm proceeding with paging, dispatching 25 entries at a time.</p>  <p>If the client clicks very quickly, in a very compulsive way, on the "More Results" displayed at the end of my 25 entries list, he ends up (after a few dozens of clicks) with an error.  </p>  <ul> <li>Chrome displays "RangeError : Maximum call stack size exceeded".</li> <li>Firefox gives "Internal Error : too much recursion".   </li> <li>We have not been able to generate the issue on IE.</li> </ul>  <p>Closing the browser or emptying the cache does not help.  The IIS WCF service application pool needs to be recycled if any user wants to call a new request.</p>  <p>The combobox datastore is created within the widget as : </p>  <pre><code>var cboValueDataStore = new com.&lt;...&gt;.data.IdsValuesQueryReadStore(     {         url: "proxy.ashx",         requestMethod: "get",         doClientPaging: false,         url2: getValuesUrl     } ); </code></pre>  <p>The IdsValuesQueryReadStore class starts with</p>  <pre><code>require(     ["dojo/_base/declare",       "dojox/data/QueryReadStore",       "dojo/_base/lang",       "dojo/json",       "dojo/_base/array"],      function(declare, QueryReadStore, lang, json, array) {         declare(             "com.fujitsu.data.IdsValuesQueryReadStore",              QueryReadStore,              { </code></pre>  <p>The IdsValuesQueryReadStore class contains these two functions that are called everytime the user clicks on "More results" : </p>  <pre><code>fetch: function(request) {     console.log("IdsValuesQueryReadStore : fetch");     var pageNumber = Math.floor(request.start / request.count) + 1;     request.serverQuery = {         url: this.url2 +               request.query.where +               "&amp;start=" +               pageNumber +               "&amp;count=" +               request.count     };     return this.inherited("fetch", arguments); }, </code></pre>  <p>and</p>  <pre><code>_filterResponse: function(data) {        console.log("IdsValuesQueryReadStore : _filterResponse");             data = json.parse(data);                 data.items = this._dataToItems(data[0]);     data.numRows = data[1];         return data; }, </code></pre>  <p>I have looked through the code for recursion errors, such as a function calling itself, but I can't find anything.  </p>  <p>I have monitored the ressources while launching the bug, and there were no extraordinary charges on the CPU, the network, the disk or the memory.</p>  <p>I don't really know where to look now to solve the issue.  I have read about this case  <a href="http://www.codeproject.com/Tips/765248/Resolve-Too-Much-Recursion-Error-when-Using-Jquery" rel="nofollow">http://www.codeproject.com/Tips/765248/Resolve-Too-Much-Recursion-Error-when-Using-Jquery</a>  where an Event would propagate recursively between the Previous and Next buttons, and wondered if this couls be the case with the picklist paging...  But if so, I have no idea how to solve this!</p>  <p>Any clue, anyone?</p>  <p><strong><em>Edit #1 (2015-10-01) :</em></strong> </p>  <p>I added some counters for the requests.  Every time the user clicks on "More results", the functions fetch and _filterResponses are called; therefore they should have the same count.  The console.log shows that _filterResponse is somehow slower then fetch.  I have something like </p>  <pre><code>... fetchCount = 220 fetchCount = 221 fetchCount = 222 filterResponseCount = 98 fetchCount = 223 filterResponseCount = 99 ... </code></pre>  <p>I wonder if changing some parameters in IIS such as the queue length could help?</p>  <p><strong><em>Edit #2 (2015-10-01) :</em></strong> </p>  <p>I tried to slow down the fetch function this way : </p>  <pre><code>fetch: function(request) {     console.log("IdsValuesQueryReadStore : fetch");     this.fetchCount++;     console.log("fetchCount = ", this.fetchCount);     this.sleep(1000);     ... },  sleep: function(miliseconds) {     console.log("Go to sleep");     var currentTime = new Date().getTime();     while (currentTime + miliseconds &gt;= new Date().getTime()) {     }     console.log("Wake up!"); }, </code></pre>  <p>By slowing down the fetch function, I saw that the fetchCount and the filterResponse count were closer, but the codes ends up crashing after about 100 clicks...</p>