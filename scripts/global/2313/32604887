<p>I'm writing a class that has a number of methods operating on similar types of arguments:</p>  <pre><code>class TheClass():     def func1(self, data, params, interval):         ....        def func2(self, data, params):         ....     def func3(self, data, interval):         ....     def func4(self, params):         ....     ... </code></pre>  <p>There's a certain convention about these arguments (e.g. <code>data</code>/<code>params</code> should be <code>numpy.farrays</code>, <code>interval</code> - a <code>list</code> of 2 <code>floats</code>), but I'd like to allow user to have more freedom: e.g. functions should accept <code>int</code> as <code>data</code> or <code>params</code>, or only one <code>int</code> as an <code>interval</code> and then assume that this is the end point with the starting point <code>0</code>, etc.</p>  <p>So to avoid all these transformations within methods, that should do only the logic, I'm using decorators like this:</p>  <pre><code>def convertparameters(*types):     def wrapper(func):          def new_func(self, *args, **kwargs):             # Check if we got enough parameters             if len(types) &gt; len(args):                 raise Exception('Not enough parameters')             # Convert parameters             new_args = list(args)             for ind, tip in enumerate(types):                 if tip == "data":                     new_args[ind] = _convert_data(new_args[ind])                 elif tip == "params":                     new_args[ind] = _convert_params(new_args[ind])                 elif tip == "interval":                     new_args[ind] = _convert_interval(new_args[ind])                 else:                     raise Exception('Unknown type for parameter')             return func(self, *new_args, **kwargs)          return new_func     return wrapper </code></pre>  <p>Where <code>_convert_data</code>, <code>_convert_params</code> and <code>_convert_interval</code> do the dirty job. Then I define the class as follows:</p>  <pre><code>class TheClass():     @convertparameters("data", "params", "interval")     def func1(self, data, params, interval):         ....         @convertparameters("data", "params")     def func2(self, data, params):         ....      @convertparameters("data", "interval")     def func3(self, data, interval):         ....      @convertparameters("params")     def func4(self, params):         ....     ... </code></pre>  <p>It does the trick, but there're several quite disturbing things:</p>  <ol> <li>It clutters the code (though it is a minor issue, and I find this solution to be much more compact than explicit call of the transforming function at the beginning of each method)</li> <li>If I need to combine this decorator with another decorator (<code>@staticmethod</code> or something that post-process output of the method) the ordering of these decorators matter</li> <li>The most disturbing thing is that the decorator of this form completely hides the parameter structure of the method and <strong>IPython</strong> shows it as <code>func1(*args, **kwargs)</code></li> </ol>  <p>Are there any better (or more <em>"Pythonic"</em>) ways to do such massive parameter transformation?</p>  <p><strong>UPDATE 1: SOLUTION</strong> based on <em>n9code</em>'s suggestion</p>  <p>In order to avoid confusion there's a modification of the <code>convertparameters</code> wrapper that solves 3rd issue (masking of signature and docstring of methods) - suggested by <em>n9code</em> for Python >2.5. </p>  <p>Using <code>decorator</code> module (to be installed separately: <code>pip install decorator</code>) we can transfer all function's "metadata" (docstring, name and signature) at the same time getting rid of nested structure inside the wrapper</p>  <pre><code>from decorator import decorator   def convertparameters(*types):      @decorator     def wrapper(func, self, *args, **kwargs):         # Check if we got enough parameters         if len(types) &gt; len(args):             raise Exception('Not enough parameters')         # Convert parameters         new_args = list(args)         for ind, tip in enumerate(types):             if tip == "data":                 new_args[ind] = _convert_data(new_args[ind])             elif tip == "params":                 new_args[ind] = _convert_params(new_args[ind])             elif tip == "interval":                 new_args[ind] = _convert_interval(new_args[ind])             else:                 raise Exception('Unknown type for parameter')         return func(self, *new_args, **kwargs)      return wrapper </code></pre>  <p><strong>UPDATE 2: MODIFIED SOLUTION</strong> based on <em>zmbq</em>'s suggestion</p>  <p>Using <code>inspect</code> module we could also get rid of arguments of decorator, checking the names of arguments of the initial function. This will eliminate another layer of the decorator</p>  <pre><code>from decorator import decorator import inspect  @decorator def wrapper(func, self, *args, **kwargs):     specs = inspect.getargspec(func)      # Convert parameters     new_args = list(args)     for ind, name in enumerate(specs.args[1:]):         if name == "data":             new_args[ind] = _convert_data(new_args[ind])         elif name == "params":             new_args[ind] = _convert_params(new_args[ind])         elif name == "interval":             new_args[ind] = _convert_interval(new_args[ind])     return func(self, *new_args, **kwargs) </code></pre>  <p>And the usage is much simpler then. The only important thing is keep using the same names for arguments between different functions.</p>  <pre><code>class TheClass():     @convertparameters     def func1(self, data, params, interval):         ....         @convertparameters     def func2(self, data, params):         .... </code></pre>