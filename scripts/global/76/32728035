<p>I am trying to implement Jspeex sample app in Android in which I am able to encode speech to .spx file while I am unable to retrieve .spx file to speech music file (.mp3/wav).</p>  <p>I need to convert the .spx file to .mp3/wav. Please help me to correct my decode function to implement the decoding. You can download .jar file from this link <a href="http://www.java2s.com/Code/Jar/j/Downloadjspeexjar.html" rel="nofollow">http://www.java2s.com/Code/Jar/j/Downloadjspeexjar.html</a> and add library to project. Thanks in advance.</p>  <pre><code>import android.app.Activity; import android.media.AudioFormat; import android.media.AudioRecord; import android.media.MediaRecorder; import android.os.Bundle; import android.os.Environment; import android.text.format.Time; import android.view.View; import android.widget.Button; import android.widget.Toast;  import org.xiph.speex.AudioFileWriter; import org.xiph.speex.OggSpeexWriter; import org.xiph.speex.SpeexDecoder; import org.xiph.speex.SpeexEncoder;  import java.io.BufferedOutputStream; import java.io.BufferedWriter; import java.io.DataInputStream; import java.io.DataOutputStream; import java.io.EOFException; import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.FileWriter; import java.io.IOException; import java.io.StreamCorruptedException;  public class JSpeexSampleActivity extends Activity { public static final int SAMPLE_RATE = 16000; public static final int CHANNELS = 1; public static final int SPEEX_MODE = 1; public static final int SPEEX_QUALITY = 8; public static final boolean ENHANCED= true; private AudioRecord mRecorder; private SpeexEncoder mEncoder; private SpeexDecoder mDecoder; private byte[] mBuffer; private final String startRecordingLabel = "Start recording"; private final String stopRecordingLabel = "Stop recording"; private boolean mIsRecording = false; private File mRawFile; private File mEncodedFile; private File mDecodedFile; public BufferedWriter bw; @Override public void onCreate(final Bundle savedInstanceState) {     super.onCreate(savedInstanceState);     setContentView(R.layout.main);      initRecorder();     initEncoder();     initDecoder();       final Button button = (Button) findViewById(R.id.button);     final Button button1 = (Button) findViewById(R.id.button1);     button.setText(startRecordingLabel);      button.setOnClickListener(new View.OnClickListener() {         @Override         public void onClick(final View v) {             if (!mIsRecording) {                 button.setText(stopRecordingLabel);                 mIsRecording = true;                 mRecorder.startRecording();                 mRawFile = getFile("raw");                 startBufferedWrite(mRawFile);             }             else {                 button.setText(startRecordingLabel);                 mIsRecording = false;                 mRecorder.stop();                 mEncodedFile = getFile("spx");                 try {                     encodeFile(mRawFile, mEncodedFile);                 } catch (IOException e) {                     Toast.makeText(JSpeexSampleActivity.this, e.getMessage(), Toast.LENGTH_SHORT).show();                 }                 Toast.makeText(JSpeexSampleActivity.this, "Encoded to " + mEncodedFile.getName(),                         Toast.LENGTH_SHORT).show();             }         }     });     button1.setOnClickListener(new View.OnClickListener() {         @Override         public void onClick(View v) {             mDecodedFile = getFile("mp3");             try {                 decodeFile(mEncodedFile, mDecodedFile);             } catch (IOException e) {                 Toast.makeText(JSpeexSampleActivity.this, e.getMessage(), Toast.LENGTH_SHORT).show();             }             Toast.makeText(JSpeexSampleActivity.this, "decoded to " + mEncodedFile.getName(),                     Toast.LENGTH_SHORT).show();         }     }); }  @Override public void onDestroy() {     mRecorder.release();     super.onDestroy(); } private void initRecorder() {     int bufferSize = AudioRecord.getMinBufferSize(SAMPLE_RATE, AudioFormat.CHANNEL_IN_MONO,             AudioFormat.ENCODING_PCM_16BIT);     mBuffer = new byte[bufferSize];     mRecorder = new AudioRecord(MediaRecorder.AudioSource.MIC, SAMPLE_RATE, AudioFormat.CHANNEL_IN_MONO,             AudioFormat.ENCODING_PCM_16BIT, bufferSize); } private void initEncoder() {     mEncoder = new SpeexEncoder();     mEncoder.init(SPEEX_MODE, SPEEX_QUALITY, SAMPLE_RATE, CHANNELS); } private void initDecoder() {     mDecoder = new SpeexDecoder();     mDecoder.init(SPEEX_MODE, SAMPLE_RATE, CHANNELS, ENHANCED); } private void startBufferedWrite(final File file) {     new Thread(new Runnable() {         @Override         public void run() {             DataOutputStream output = null;             try {                 output = new DataOutputStream(new BufferedOutputStream(new FileOutputStream(file)));                 while (mIsRecording) {                     int readSize = mRecorder.read(mBuffer, 0, mBuffer.length);                     for (int i = 0; i &lt; readSize; i++) {                         output.writeByte(mBuffer[i]);                     }                 }             } catch (IOException e) {                 Toast.makeText(JSpeexSampleActivity.this, e.getMessage(), Toast.LENGTH_SHORT).show();             } finally {                 if (output != null) {                     try {                         output.flush();                     } catch (IOException e) {                         Toast.makeText(JSpeexSampleActivity.this, e.getMessage(), Toast.LENGTH_SHORT).show();                     } finally {                         try {                             output.close();                         } catch (IOException e) {                             Toast.makeText(JSpeexSampleActivity.this, e.getMessage(), Toast.LENGTH_SHORT).show();                         }                     }                 }             }         }     }).start(); }  public static int decode(byte[] input, int offset, int length, byte[] output) throws StreamCorruptedException {      SpeexDecoder decoder = new SpeexDecoder();     decoder.init(SPEEX_MODE,SAMPLE_RATE,CHANNELS,ENHANCED);     decoder.processData(input, offset, length);     byte[] decoded_data =  new byte[decoder.getProcessedDataByteSize()];     int result= decoder.getProcessedData(decoded_data, 0);     return result; } private void decodeFile(final File inputFile, final File outputFile) throws IOException {     DataInputStream input = null;     BufferedWriter bw = new BufferedWriter(new FileWriter(outputFile));     try {         input = new DataInputStream(new FileInputStream(inputFile));          byte[] buffer = new byte[2560]; // 2560 is the maximum needed value (stereo UWB)         int packetSize = 2 * CHANNELS * mEncoder.getFrameSize();          while (true) {             input.readFully(buffer, 0, packetSize);             mDecoder.processData(buffer, 0, packetSize);             byte[] decoded_data =  new byte[mDecoder.getProcessedDataByteSize()];             int encodedBytes = mDecoder.getProcessedData(decoded_data, 0);             if (encodedBytes &gt; 0) {                 bw.write(encodedBytes);             }         }     } catch (EOFException e) {     } finally {         try {             if (input != null) {                 input.close();             }         } finally {             if (bw != null) {                 bw.close();             }         }     } }  private void encodeFile(final File inputFile, final File outputFile) throws IOException {     DataInputStream input = null;     AudioFileWriter output = null;     try {         input = new DataInputStream(new FileInputStream(inputFile));         output = new OggSpeexWriter(SPEEX_MODE, SAMPLE_RATE, CHANNELS, 1, false);         output.open(outputFile);         output.writeHeader("Encoded with: " + SpeexEncoder.VERSION);          byte[] buffer = new byte[2560]; // 2560 is the maximum needed value (stereo UWB)         int packetSize = 2 * CHANNELS * mEncoder.getFrameSize();          while (true) {             input.readFully(buffer, 0, packetSize);             mEncoder.processData(buffer, 0, packetSize);             int encodedBytes = mEncoder.getProcessedData(buffer, 0);             if (encodedBytes &gt; 0) {                 output.writePacket(buffer, 0, encodedBytes);             }         }     } catch (EOFException e) {     } finally {         try {             if (input != null) {                 input.close();             }         } finally {             if (output != null) {                 output.close();             }         }     } }  private File getFile(final String suffix) {     Time time = new Time();     time.setToNow();     return new File(Environment.getExternalStorageDirectory(), time.format("%Y%m%d%H%M%S") + "." + suffix); } </code></pre>  <p>}</p>