<pre><code>import sys import os import zlib  try:     import pylzma as lzma except ImportError:     import lzma  from io import StringIO import struct  #-----------------------------------------------------------------------------------------------------------------------  def read_ui8(c):     return struct.unpack('&lt;B', c)[0] def read_ui16(c):     return struct.unpack('&lt;H', c)[0] def read_ui32(c):     return struct.unpack('&lt;I', c)[0]  def parse(input):     """Parses the header information from an SWF file."""     if hasattr(input, 'read'):         input.seek(0)     else:         input = open(input, 'rb')      header = { }      # Read the 3-byte signature field     header['signature'] = signature = b''.join(struct.unpack('&lt;3c', input.read(3))).decode()      # Version     header['version'] = read_ui8(input.read(1))      # File size (stored as a 32-bit integer)     header['size'] = read_ui32(input.read(4))      # Payload      if header['signature'] == 'FWS':         print("The opened file doesn't appear to be compressed")         buffer = input.read(header['size'])     elif header['signature'] == 'CWS':         print("The opened file appears to be compressed with Zlib")         buffer = zlib.decompress(input.read(header['size']))     elif header['signature'] == 'ZWS':         print("The opened file appears to be compressed with Lzma")         # ZWS(LZMA)         # | 4 bytes       | 4 bytes    | 4 bytes       | 5 bytes    | n bytes    | 6 bytes         |         # | 'ZWS'+version | scriptLen  | compressedLen | LZMA props | LZMA data  | LZMA end marker |         size = read_ui32(input.read(4))         buffer = lzma.decompress(input.read())      # Containing rectangle (struct RECT)      # The number of bits used to store the each of the RECT values are     # stored in first five bits of the first byte.      nbits = read_ui8(buffer[0]) &gt;&gt; 3      current_byte, buffer = read_ui8(buffer[0]), buffer[1:]     bit_cursor = 5      for item in 'xmin', 'xmax', 'ymin', 'ymax':         value = 0         for value_bit in range(nbits-1, -1, -1): # == reversed(range(nbits))             if (current_byte &lt;&lt; bit_cursor) &amp; 0x80:                 value |= 1 &lt;&lt; value_bit             # Advance the bit cursor to the next bit             bit_cursor += 1              if bit_cursor &gt; 7:                 # We've exhausted the current byte, consume the next one                 # from the buffer.                 current_byte, buffer = read_ui8(buffer[0]), buffer[1:]                 bit_cursor = 0          # Convert value from TWIPS to a pixel value         header[item] = value / 20      header['width'] = header['xmax'] - header['xmin']     header['height'] = header['ymax'] - header['ymin']      header['frames'] = read_ui16(buffer[0:2])     header['fps'] = read_ui16(buffer[2:4])      input.close()     return header  header = parse(sys.argv[1]);  print('SWF header') print('----------') print('Version:      %s' % header['version']) print('Signature:    %s' % header['signature']) print('Dimensions:   %s x %s' % (header['width'], header['height'])) print('Bounding box: (%s, %s, %s, %s)' % (header['xmin'], header['xmax'], header['ymin'], header['ymax'])) print('Frames:       %s' % header['frames']) print('FPS:          %s' % header['fps']) </code></pre>  <p>I was under the impression the built in python 3.4 LZMA module works the same as the Python 2.7 pyLZMA module. The code I've provided runs on both 2.7 and 3.4, but when it is run on 3.4 (which doesn't have pylzma so it resorts to the inbuilt lzma) I get the following error:</p>  <pre><code>_lzma.LZMAError: Input format not supported by decoder </code></pre>  <p>Why does pylzma work but Python 3.4's lzma doesn't?</p>