<p>here is my problem.</p>  <p>I have a sorted array of dates that is stored in a circular buffer. I have a pointer to last date in buffer. There is a possibility that some dates are missing. Client requires a range of dates. If low limit date is missing, program should return first closest date that is higher then required one and vice versa for upper limit date.<br /> Here is an example:</p>  <p>Dates in circular buffer (int[18]):<br /> 1,2,3,4,5,11,12,13,14,15,21,22,23,24,25,26,27,28<br /> and if client wants from 8 to 23, program should return 11,12,13,14,15,21,22,23.</p>  <p>I tried like this :<br /> Notes:<br /> - number between two stars is current date, and diff is number of steps to go to find 8.<br /> - pointer can not be less then 0 or higher then 17.</p>  <pre><code>{1,2,3,4,5,11,12,13,14,15,21,22,23,24,25,26,27,*28*}, diff = -20 {*1*,2,3,4,5,11,12,13,14,15,21,22,23,24,25,26,27,28}, diff = +7 {1,2,3,4,5,11,12,*13*,14,15,21,22,23,24,25,26,27,28}, diff = -5 {1,2,*3*,4,5,11,12,13,14,15,21,22,23,24,25,26,27,28}, diff = +5 -&gt; (5/2)+1=+3&lt;br /&gt; (if I detect that I will just go x steps forward and x steps backward I split x in half) {1,2,3,4,5,*11*,12,13,14,15,21,22,23,24,25,26,27,28}, diff = -3 -&gt; (-3/2)-1 = -2 {1,2,3,*4*,5,11,12,13,14,15,21,22,23,24,25,26,27,28}, diff = 4 {1,2,3,4,5,11,12,*13*,14,15,21,22,23,24,25,26,27,28}, diff = -5 {1,2,*3*,4,5,11,12,13,14,15,21,22,23,24,25,26,27,28}, diff = +5 -&gt; (5/2)+1=+3 </code></pre>  <p>If we continue like this we will get 13,3,11,4 over and over again.</p>  <p>Notes:<br /> - It is only coincidence that we get 11 here. When I use some real examples, with more dates,this algorithm jumps over some other 4 (or 3) numbers.<br /> - Dates are stored in EEPROM of uC, so reading dates take a while, and I need to find date as quick as it possible (with minimum reads).<br /><br /> Please help.</p>