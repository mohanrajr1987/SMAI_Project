<p>I'm reading about the Linux kernel loading process (just to understand the whole sequence) and I have several doubts specially about the control transition between:</p>  <ol> <li>The boot-loader and the kernel</li> <li>The kernel and the init process </li> </ol>  <p>For example, in the wikipedia I found the following:</p>  <blockquote>   <p>The kernel as loaded is typically an image file, compressed into either zImage or bzImage formats with zlib. <strong>A routine at the head of it</strong> does a minimal amount of hardware setup, decompresses the image fully into high memory, and takes note of any RAM disk if configured.[3] <strong>It then executes kernel startup via ./arch/i386/boot/head and the startup_32 ()</strong></p> </blockquote>  <p>Here I have several questions: </p>  <ol> <li>What this <strong>routine</strong> stands for?</li> <li>In which part of the memory is loaded?</li> <li>Does it already include code to decompress the zImage or this code is loaded separately in another memory location?</li> </ol>  <p>I Continue reading on the same page and I found the following:</p>  <blockquote>   <p>... start_kernel executes a wide range of initialization functions. It sets up interrupt handling (IRQs), further configures memory, starts the Init process (the first user-space process), ...</p> </blockquote>  <p>I know that the init is the first user-space process created. The answer to the following question: </p>  <p><a href="http://stackoverflow.com/questions/20744200/how-the-init-process-is-started-in-linux-kernel">How the init process is started in linux kernel?</a></p>  <p>states that the kernel uses a do_execve() call. However, the semantic for the normal execv system call is to override the calling process (the kernel in this case?) bss, data, text and stack segments with the ones from the new process and <strong>it doesn't return</strong>. </p>  <p>Why in this case it does return? (otherwise, if it doesn't return the kernel wont continue it's starting process)</p>  <p>Thanks in advance,</p>