<p>I have several kernel modules which need to interact with userspace. Hence, each module has a Netlink socket.</p>  <p>My problem is that these sockets interfere with each other. This is because all of them register to the same Netlink address family (because there aren't many available to begin with - the <a href="http://lxr.free-electrons.com/source/include/uapi/linux/netlink.h#L33" rel="nofollow">max is 32</a> and <a href="http://lxr.free-electrons.com/source/include/uapi/linux/netlink.h#L8" rel="nofollow">more than half are already reserved</a>) and also because they all bind themselves to the same pid (the kernel pid - zero).</p>  <p>I wish there were more room for address families. Or, better yet, I wish I could bind my sockets to other pids. How come Netlink is the preferred user-kernel channel if only 32 sockets can be open at any one time?</p>  <p><a href="http://www.carisma.slowglass.com/~tgr/libnl/doc/core.html#core_addressing" rel="nofollow">libnl-3's documentation</a> says</p>  <blockquote>   <p>The netlink address (port) consists of a 32bit integer. Port 0 (zero) is reserved for the kernel and refers to the kernel side socket of each netlink protocol family. Other port numbers usually refer to user space owned sockets, although this is not enforced.</p> </blockquote>  <p>That last claim seems to be a lie right now. The kernel uses a <a href="http://lxr.free-electrons.com/source/net/netlink/af_netlink.c#L2585" rel="nofollow">constant as pid</a> and doesn't export more versatile functions:</p>  <pre><code>if (netlink_insert(sk, 0))     goto out_sock_release; </code></pre>  <p>I guess I can recompile the kernel and increase the address family limit. But these are kernel modules; I shouldn't have to do that.</p>  <p>Am I missing something?</p>