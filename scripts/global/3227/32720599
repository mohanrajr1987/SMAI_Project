<p>In my application I use a <code>ReaderWriterLockSlim</code> to synchronize reads and writes from/to a <code>list&lt;&gt;</code>.</p>  <p>In the following example reading the list is performed inside all 3 sub-methods, thus these 3 should be packed into a <code>ReadLock</code>. The problem is that <code>SubMethod3</code> is called via a <code>BackgroundWorker</code> (as it contains lengthy calculations), so the <code>ExitReadLock()</code> in the finally block of MainMethod1 might be called before SubMethod3 has been finished by the <code>BackgroundWorker</code> (separate thread). Thereby the code in <code>SubMethod3</code> is not really protected by the lock.</p>  <p>What I have considered is to use a lock in each sub-method, so <code>Submethod3</code> would have its own lock, which would be released when the <code>BackgroundWorker</code> was done. The problem with this approach is that another thread could enter in between the calls of the sub-methods, as each of these would release the lock when done. </p>  <p>My question is: How can <code>ReadLock</code> be used to protect over more threads?</p>  <pre><code>ReaderWriterLockSlim synchronizationLock = new ReaderWriterLockSlim();  public void MainMethod1()     {         synchronizationLock.EnterReadLock();         try         {             SubMethod1(); //Run on UI thread             SubMethod2(); //Run on UI thread             myBackgroundWorker.RunWorkerAsync();           }         finally         {             synchronizationLock.ExitReadLock();         }     }   private void myBackgroundWorker_DoWork(object sender, DoWorkEventArgs e)         {             SubMethod3(); //Run on separate thread         } </code></pre>