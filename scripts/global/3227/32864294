<p>Windows service:  Generating a set of FileWatcher objects from a list of directories to watch in a config file, have the following requirements:</p>  <ol> <li>File processing can be time consuming - events must be handled on their own task threads</li> <li>Keep handles to the event handler tasks to wait for completion in an OnStop() event.</li> <li>Track the hashes of uploaded files; don't reprocess if not different</li> <li>Persist the file hashes to allow OnStart() to process files uploaded while the service was down.</li> <li>Never process a file more than once.</li> </ol>  <p>(Regarding #3, we do get events when there are no changes... most notably because of the duplicate-event issue with FileWatchers) </p>  <p>To do these things, I have two dictionaries - one for the files uploaded, and one for the tasks themselves.  Both objects are static, and I need to lock them when adding/removing/updating files and tasks.  Simplified code:</p>  <pre class="lang-cs prettyprint-override"><code>public sealed class TrackingFileSystemWatcher : FileSystemWatcher {      private static readonly object fileWatcherDictionaryLock = new object();     private static readonly object runningTaskDictionaryLock = new object();      private readonly Dictionary&lt;int, Task&gt; runningTaskDictionary = new Dictionary&lt;int, Task&gt;(15);     private readonly Dictionary&lt;string, FileSystemWatcherProperties&gt;  fileWatcherDictionary = new Dictionary&lt;string, FileSystemWatcherProperties&gt;();      //  Wired up elsewhere     private void OnChanged(object sender, FileSystemEventArgs eventArgs) {         this.ProcessModifiedDatafeed(eventArgs);     }      private void ProcessModifiedDatafeed(FileSystemEventArgs eventArgs) {          lock (TrackingFileSystemWatcher.fileWatcherDictionaryLock) {              //  Read the file and generate hash here              //  Properties if the file has been processed before             //  ContainsNonNullKey is an extension method             if (this.fileWatcherDictionary.ContainsNonNullKey(eventArgs.FullPath)) {                  try {                     fileProperties = this.fileWatcherDictionary[eventArgs.FullPath];                 }                 catch (KeyNotFoundException keyNotFoundException) {}                 catch (ArgumentNullException argumentNullException) {}             }             else {                   // Create a new properties object             }               fileProperties.ChangeType = eventArgs.ChangeType;             fileProperties.FileContentsHash = md5Hash;             fileProperties.LastEventTimestamp = DateTime.Now;              Task task;             try {                 task = new Task(() =&gt; new DatafeedUploadHandler().UploadDatafeed(this.legalOrg, datafeedFileData), TaskCreationOptions.LongRunning);             }             catch {               ..             }              //  Only lock long enough to add the task to the dictionary             lock (TrackingFileSystemWatcher.runningTaskDictionaryLock) {                  try {                     this.runningTaskDictionary.Add(task.Id, task);                   }                 catch {                   ..                 }                 }               try {                 task.ContinueWith(t =&gt; {                     try {                         lock (TrackingFileSystemWatcher.runningTaskDictionaryLock) {                             this.runningTaskDictionary.Remove(t.Id);                         }                          //  Will this lock burn me?                         lock (TrackingFileSystemWatcher.fileWatcherDictionaryLock) {                             //  Persist the file watcher properties to                             //  disk for recovery at OnStart()                         }                     }                     catch {                       ..                     }                 });                  task.Start();             }             catch {               ..             }           }      }  } </code></pre>  <p>What's the effect of requesting a lock on the FileSystemWatcher collection in the <code>ContinueWith()</code> delegate when the delegate is defined within a lock on the same object?  I would expect it to be fine, that even if the task starts, completes, and enters the ContinueWith() before <code>ProcessModifiedDatafeed()</code> releases the lock, the task thread would simply be suspended until the creating thread has released the lock.  But I want to make sure I'm not stepping on any delayed execution landmines.</p>  <p>Looking at the code, I may be able to release the lock sooner, avoiding the issue, but I'm not certain yet... need to review the full code to be sure.</p>