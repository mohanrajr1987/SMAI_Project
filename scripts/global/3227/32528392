<pre><code>     public class BodyRefiner     {         private KinectBody[] bodies = new KinectBody[6];         private KinectBody[] copiedBodies = new KinectBody[6];          public static readonly object locker = new object();          BodyDirectionCalculator directionCalculator;         JointOrientationCalculator orientationCalculator;         private BodyManipulator manipulator;          public BodyRefiner()         {             directionCalculator = new BodyDirectionCalculator();             orientationCalculator = new JointOrientationCalculator();         }          public void AttachBodyManipulator(BodyManipulator manipulatorToAttach)         {             this.manipulator = manipulatorToAttach;         }          public void DettachBodyManipulator()         {             this.manipulator = null;         }          public void UpdateBodies(Body[] acquiredBodies)         {             for(int i = 0; i &lt; acquiredBodies.Length; i++)             {                 this.bodies[i] = new KinectBody(acquiredBodies[i]);                 directionCalculator.CalculateDirections(ref this.bodies[i]);                 orientationCalculator.CalculateJointOrientations(ref this.bodies[i]);             }             CopyBodies();         }          public KinectBody[] GetBodies()         {             lock(locker)             {                 foreach(KinectBody b in copiedBodies)                 {                     Debug.Log(b.isTracked);                 }                 return copiedBodies;             }         }          private void CopyBodies()         {             lock (locker)             {                 copiedBodies = bodies;                  if (manipulator != null)                 {                     copiedBodies = manipulator.GetManipulatedBodies(copiedBodies);                 }                  foreach (KinectBody b in copiedBodies)                 {                     Debug.Log(b.isTracked);                 }             }         }     }   public class BodySource : Singleton&lt;BodySource&gt;     {         private Body[] bodies;         private KinectSensor sensor;         private BodyFrameReader reader;         public BodyRefiner contributor;         private Thread worker;          void Awake()         {             base.Awake();              sensor = KinectSensor.GetDefault();              if (!sensor.IsOpen)             {                 sensor.Open();             }              BodyFrameSource source = sensor.BodyFrameSource;             reader = source.OpenReader();             bodies = new Body[source.BodyCount];              contributor = new BodyRefiner();              worker = new Thread(AcquireBodyFrame);             worker.Start();         }          void AcquireBodyFrame()         {             if (reader != null)             {                 using (var frame = reader.AcquireLatestFrame())                 {                     if (frame != null)                     {                         frame.GetAndRefreshBodyData(bodies);                         frame.Dispose();                         contributor.UpdateBodies(bodies);                     }                 }             }              Thread.Sleep(1000 / 30);             AcquireBodyFrame();         }          void OnApplicationQuit()         {             worker.Abort();             worker = null;         }     } public class CustomTrackingTryFullChar : MonoBehaviour {     private Transform[] bones;     private Quaternion[] initialRotations;     public Animator animator;     private Quaternion initRot;     private Alpaca.Kinect.KinectGameComponent comp;     public TrackingMask mask;     public float smoothFactor;     KinectTest.KinectBody b;     Transform boneTransform;     Quaternion jointRotation;     KinectTest.KinectBody[] trackedBodies;      // Use this for initialization     void Start () {         bones = new Transform[27];         MapBones();         initialRotations = new Quaternion[bones.Length];         GetInitialRotations();         comp = GetComponent&lt;Alpaca.Kinect.KinectGameComponent&gt;();          KinectTest.BodyManipulator manipulator = new KinectTest.BodyManipulator();         manipulator.wantedAmountOfTrackedBodies = 0;         KinectTest.BodySource.Instance.contributor.AttachBodyManipulator(manipulator);     }      private void MapBones()     {         for (int boneIndex = 0; boneIndex &lt; bones.Length; boneIndex++)         {             if (!BoneMaps.boneIndex2MecanimMap.ContainsKey(boneIndex))                 continue;              bones[boneIndex] = this.animator.GetBoneTransform(BoneMaps.boneIndex2MecanimMap[boneIndex]);         }     }      private void GetInitialRotations()     {         Quaternion temp = this.transform.rotation;         this.transform.rotation = Quaternion.identity;          for (int i = 0; i &lt; bones.Length; i++)         {             if (bones[i] != null)             {                 initialRotations[i] = bones[i].rotation;             }         }          this.transform.rotation = temp;     }      // Update is called once per frame     void Update () {         trackedBodies = KinectTest.BodySource.Instance.contributor.GetBodies();         foreach (KinectTest.KinectBody bd in trackedBodies)         {             if (bd.isTracked)             {                 b = bd;                 TransformBones();             }         }     }      bool IsJointTracked(KinectTest.KinectJoint joint)     {         return joint.trackingState == TrackingState.Tracked;     }      bool ShallJointBeTracked(JointType type)     {         return mask.TrackJoint(type);     }       void TransformBones()     {         for (int boneIndex = 0; boneIndex &lt; bones.Length; boneIndex++)         {             if (!bones[boneIndex])             {                 continue;             }              if (BoneMaps.boneIndex2JointMap.ContainsKey(boneIndex))             {                 JointType joint = BoneMaps.boneIndex2JointMap[boneIndex];                 TransformBone(joint, boneIndex, null, b.joints);             }         }     }      private void TransformBone(JointType joint, int boneIndex, Dictionary&lt;JointType, Quaternion&gt; orientations, Dictionary&lt;JointType, KinectTest.KinectJoint&gt; joints)     {         boneTransform = bones[boneIndex];         if (boneTransform == null)         {             return;         }         int iJoint = (int)joint;         if (iJoint &lt; 0 || !this.IsJointTracked(b.joints[joint]) || !ShallJointBeTracked(joint))         {             return;         }          // Get Kinect joint orientation         jointRotation = Quaternion.identity;          if (b.isTracked)         {             jointRotation = b.joints[joint].rotation;         }          if (jointRotation == Quaternion.identity)             return;          Kinect2AvatarRot(jointRotation, boneIndex);         if (smoothFactor != 0f)         {             boneTransform.rotation = Quaternion.Slerp(boneTransform.rotation, newRotation, smoothFactor * Time.deltaTime);         }         else         {             boneTransform.rotation = newRotation;         }     }      Quaternion newRotation;     Vector3 totalRotation;     private Quaternion Kinect2AvatarRot(Quaternion jointRotation, int boneIndex)     {         newRotation = jointRotation * initialRotations[boneIndex];          totalRotation = newRotation.eulerAngles + this.transform.rotation.eulerAngles;         newRotation = Quaternion.Euler(totalRotation);          return newRotation;     }   } </code></pre>  <p>As you see the BodySource gets updated in another thread and updates the BodyRefiner as well. The Body Refiner contains a GetBodies() method which is called from the main loop. The Debug Logs in CopyBodies() und GetBodies() dont log the same results. How can something like this happen when the lock statement is used in both of the methods?</p>