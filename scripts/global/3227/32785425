<p>There is an application event that may be fired multiple times within several microseconds. Event's handler contains code that in the end calls the SP. </p>  <p>Stored Procedure</p>  <pre><code>CREATE PROC CreateCampaign (@dripCampaignId bigint, @orderGroupId bigint, @userDocumentId bigint, @ownerId bigint, @totalExecution int, @status tinyint, @createdOn datetime, @lastExecutions datetime) AS DECLARE @lresult int; --PRINT 'BEFORE LOCK: '+CONVERT(nvarchar(100),GETDATE(),113) EXEC @lresult = sp_getapplock @Resource = 'DC_CreateCampaign_Lock',                 @LockMode = 'Exclusive', @DbPrincipal = 'dbo', @LockOwner = 'Session'; --PRINT 'LOCK ACQUIRED: '+CONVERT(nvarchar(100),GETDATE(),113) + ' '+cast(@lresult as varchar(10)) IF @lresult = 0 BEGIN      BEGIN TRY         BEGIN TRAN                       IF NOT EXISTS (SELECT TOP 1 DripCampaignInstanceId FROM DripCampaignInstances WHERE DripCampaignId = @dripCampaignId AND OrderGroupId = @orderGroupId AND UserDocumentId = @userDocumentId)                 BEGIN                 INSERT INTO DripCampaignInstances(DripCampaignId, OrderGroupId, UserDocumentId, OwnerId, TotalExecutions, Status, CreatedOn, LastExecution)                         VALUES (@dripCampaignId, @orderGroupId, @userDocumentId, @ownerId, @totalExecution, @status, @createdOn, @lastExecutions)                 INSERT INTO [dbo].[EventLog]                          ([EventSessionID],[EventOrderGroupID],[EventDocID],[EventMachine],[EventSource],[EventCategory],[EventClass],[EventLevel]                          ,[EventCode],[EventMessage],[EventDateTime],[EventSourceFile],[EventSourceData],[EventMsgExtra],[b_SeenByUserAsInternalError])                     VALUES                          (NULL,@orderGroupId,@userDocumentId,0,0,'DripCampaign CreateCampaignInstance',0,0,701                          ,'Drip campaign instance created.',GETDATE(),NULL,NULL                          ,'Drip campaign instance created. Order id:'+cast(@orderGroupId as varchar(255))+' documentId: '+cast(@userDocumentId as varchar(255))+'',0)                 END                 ELSE                 BEGIN                 INSERT INTO [dbo].[EventLog]                          ([EventSessionID],[EventOrderGroupID],[EventDocID],[EventMachine],[EventSource],[EventCategory],[EventClass],[EventLevel]                          ,[EventCode],[EventMessage],[EventDateTime],[EventSourceFile],[EventSourceData],[EventMsgExtra],[b_SeenByUserAsInternalError])                     VALUES                          (NULL,@orderGroupId,@userDocumentId,0,0,'DripCampaign CreateCampaignInstance',0,0,701                          ,'Drip campaign instance attempted to insert duplicate.',GETDATE(),NULL,NULL                          ,'Drip campaign instance already exists. Order id:'+cast(@orderGroupId as varchar(255))+' documentId: '+cast(@userDocumentId as varchar(255))+'',0)                 END          COMMIT TRAN     END TRY     BEGIN CATCH     SELECT ERROR_NUMBER() AS ErrorNumber ,ERROR_SEVERITY() AS ErrorSeverity ,ERROR_STATE() AS ErrorState ,ERROR_PROCEDURE() AS ErrorProcedure ,ERROR_LINE() AS ErrorLine ,ERROR_MESSAGE() AS ErrorMessage;         ROLLBACK TRAN     END CATCH     END EXEC @lresult = sp_releaseapplock @Resource = 'DC_CreateCampaign_Lock', @DbPrincipal ='dbo', @LockOwner = 'Session';         --PRINT 'LOCK RELEASED: '+CONVERT(nvarchar(100),GETDATE(),113) GO </code></pre>  <p>(there should be only one item in table, so the code works only on 0 returned by sp_getapplock, no need to call that for 1).</p>  <p>While testing in SSMS using</p>  <pre><code>waitfor delay '00:00:05.000' </code></pre>  <p>inside SP body (to be able to EXEC the same procedure in other tab to verify if lock works or using .exe that creates 4 threads to run this SP directly) and everything works exactly according to the theory (took approach from <a href="http://aboutsqlserver.com/2010/09/26/sunday-t-sql-tip-application-locks" rel="nofollow">http://aboutsqlserver.com/2010/09/26/sunday-t-sql-tip-application-locks</a>).</p>  <p>When the same SP is deployed to target environment, I'm getting duplicates (nearly 1 duplicate per 200 even fires; sometimes it creates even triplicates). </p>  <p>As my manual testing had 100% success rate, I'm wondering what would happen if this SP will be called by multiple threads within extremely short time frame? I understand the magnitude of probability that event will fire very quickly, CLR will go through event handler code at exactly same speed, connecting the db at exactly same speed, but if the runtime will step into sp_getapplock multiple times, can multiple locks be acquired and thus critical section will be entered by multiple instances?</p>  <p>P.S. Locking at .NET code level for some (or same) reasons doesn't work (entire handler body is within lock statement that is using private static member as argument).</p>