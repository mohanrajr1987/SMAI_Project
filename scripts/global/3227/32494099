<p>I want to free a structure with spin_lock is embedded.</p>  <p>scenario is as follows:</p>  <p>I have two functions</p>  <pre><code>f1 () { *****************     spin_lock_irqsave(&amp;my_obj_ptr-&gt;my_lock, flags)       ....       .... ........................................ here f2 is called                                                 spin_lock_irqstore(&amp;my_obj_ptr-&gt;my_lock, flags) *******************     kfree(my_obj_ptr)  }   </code></pre>  <p>and f2 has similar content with f1. </p>  <p>when f2 is called my_lock is being used, f2 must busy waiting. however, when f2 is entering the critical section, my_obj_ptr is free.  So kernel crash...</p>  <p>What I think now is adding a ref_count variable in struct my_obj</p>  <p>before spin_lock_irqsave  => ref_count++</p>  <p>after  spin_lock_irqstore => ref_count--</p>  <p>And before free, check the ref_count variable.</p>  <p>And it seems no crash now. </p>  <p>I just wonder will there be corner cases, I don't consider?  Or there is any much better way to handle this problem?</p>  <p>Any help will be appreciate.</p>  <p>Thanks</p>