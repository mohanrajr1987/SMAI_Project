<p>If I have a global array that multiple threads are writing to and reading from, and I want to ensure that this array remains synchronized between threads, is using std::mutex enough for this purpose, as shown in pseudo code below? I came across with <a href="http://en.cppreference.com/w/cpp/atomic/memory_order" rel="nofollow">this resource</a>, which makes me think that the answer is positive:</p>  <blockquote>   <p>Mutual exclusion locks (such as std::mutex or atomic spinlock) are an example of release-acquire synchronization: when the lock is released by thread A and acquired by thread B, everything that took place in the critical section (before the release) in the context of thread A has to be visible to thread B (after the acquire) which is executing the same critical section. </p> </blockquote>  <p>I'm still interested in other people's opinion.</p>  <pre><code>float * globalArray; std::mutex globalMutex;  void method1()  {     std::lock_guard&lt;std::mutex&gt; lock(globalMutex);     // Perform reads/writes to globalArray }  void method2()  {     std::lock_guard&lt;std::mutex&gt; lock(globalMutex);     // Perform reads/writes to globalArray }  main()  {     std::thread t1(method1());     std::thread t2(method2());     std::thread t3(method1());     std::thread t4(method2());     ...     std::thread tn(method1()); } </code></pre>