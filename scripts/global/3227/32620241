<p>I have a mongo (offline) database call that deletes old records and then inserts new records from a SQL (online) database. I want to lock this method down to prevent race conditions such as below:</p>  <ol> <li>Thread 1 deletes old data</li> <li>Thread 2 deletes (same) old data (which really doesn't exist anymore since thread 1 already took care of it)</li> <li>Thread 1 inserts new data</li> <li>Thread 2 inserts (same) new data; UNIQUE KEY VIOLATION WILL HAPPEN HERE!!!</li> </ol>  <p>I know a way to lock it down is to turn all the async methods in to sync methods by using the Task.Wait() or Task.Result, and then lock it down using c# lock method (<a href="https://msdn.microsoft.com/en-us/library/c5kehkcz.aspx" rel="nofollow">https://msdn.microsoft.com/en-us/library/c5kehkcz.aspx</a>). But is that a good practice? </p>  <p>I was trying to follow Stephen Cleary's best practices on Asynch programming (<a href="https://msdn.microsoft.com/en-us/magazine/JJ991977.aspx" rel="nofollow">https://msdn.microsoft.com/en-us/magazine/JJ991977.aspx</a>) and wanted to let the async calls bubble up so that would go against my suggested solution above of turning async methods back in to sync methods in attempt to be able to wrap it in the lock statement. </p>  <p>Here is the code sample:</p>  <pre><code>    public async static Task SyncUserPermissionsForDocsAsync(List&lt;long&gt; docIdList)     {         var permissionListToSync = await OnlineDataAccess.GetPermissionListToSync(docIdList).ConfigureAwait(false);         await OfflineDataAccess.DropUserPermissionAsync(docIdList).ConfigureAwait(false);         await OfflineDataAccess.AddUserPermissionsAsync(permissionListToSync).ConfigureAwait(false);     } </code></pre>