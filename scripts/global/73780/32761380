<p>I was wondering whether it's possible to wait for a callback before continuing a process.</p>  <p>I'm using a library that handles a future internally and then if it was successful, does a callback, otherwise handles the error internally with no callback.</p>  <p>Now I'm trying to use this library to create an instance, then fill it with random test data and then update that entity.</p>  <pre><code>Map generateRandomizedInstance() {   lib.createEntity((result1){       result1["a"] = generateRandomA();       result1["b"] = generateRandomB();       result1["c"] = generateRandomC();       ...       lib.updateEntity(result1, (result2){         // want to return this result2         return result2;       })   }); } </code></pre>  <p>This would be fine if I'm only creating one entity and updating it once, but I want to create lots of random data:</p>  <pre><code>ButtonElement b = querySelector("button.create")..onClick.listen((e){     for (int i = 0; i &lt; 500; i++) {         generateRandomizedInstance();     } }); </code></pre>  <p>It doesn't take long for this code to crash spectacularly as the callbacks aren't coming back fast enough.</p>  <p>I've tried changing the method signature to </p>  <pre><code>generateRandomizedInstance() async {  </code></pre>  <p>and then doing:</p>  <pre><code>for (int i = 0; i &lt; 500; i++) {     print(await generateRandomizedInstance()); } </code></pre>  <p>but that await syntax seems to be invalid and I'm not completely sure how to wrap that callback code in some kind of future that I can wait for the callback to come back before continuing to the next iteration of the loop.</p>  <p>I've tried a while loop at the end of <code>generateRandomizedInstance</code> that waits for a result variable to not be null, but that kills the browser and seeing as I'm not always getting a callback, in some cases it could cause an infinite loop.</p>  <p>Any ideas / suggestion on how to pause that for loop while waiting for the callback? </p>