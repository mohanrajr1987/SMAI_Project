<p>I have an existing task called <code>myTask</code>, whose implementation I don't control.</p>  <p>I want to redefine it in this way: <code> myTask := {   val x = prepare()   try     myTask.value   finally     cleanup(x) } </code></p>  <p>As you probably know, this code wouldn't work, as we don't control when <code>myTask.value</code> is executed.</p>  <p><code>prepare</code> can be called with <code>Def.sequential()</code>, and <code>cleanup</code> with the <code>andFinally</code> construct.  The only problem is how <code>cleanup</code> can get the return value of <code>prepare()</code>.<br> <code> Def.sequential{    Def.task{       prepare()   },    myTask  }.andFinally(cleanup(???)) </code></p>  <p>One workaround is to use global variables, but this is a dirty hack.</p>  <p>Any ideas?</p>  <p><a href="http://www.scala-sbt.org/0.13/docs/Combined+Pages.html" rel="nofollow">Related doc</a></p>