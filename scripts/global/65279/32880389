<p>I am trying to implement the search functionality in android the data is binding through the result recieved from webservice.</p>  <p>This is working but problem is its lagging a bit.  For eg After first word typed it waits for results to come and then type next word. </p>  <p>Its because async task is running on first word click.But its annoying for users to wait.</p>  <p>Any suggestion or changes which can make things smooth.</p>  <pre><code>    public MultiAutoCompleteTextView editText1;     ArrayList&lt;setFilterItems&gt; searchFilter=new ArrayList&lt;setFilterItems&gt;();  editText1.addTextChangedListener(new TextWatcher() {                  @Override                  public void onTextChanged(CharSequence cs, int arg1, int arg2, int arg3) {                     // When user changed the Text                       String cs1= cs.toString();                      if (cs1.length() == 1) {                         System.out.println("Size : "+searchFilter.size());                         //if(searchFilter.size()&lt;1) {                             try {                                 result = new getSearchTags(cs.toString().toLowerCase(Locale.US)).execute().get();                                 System.out.println("yeh hai mera result " + result);                             } catch (InterruptedException e) {                                 e.printStackTrace();                             } catch (ExecutionException e) {                                 e.printStackTrace();                             }                         //}else{                         //     searchadapter.getFilter().filter(cs.toString().toLowerCase(Locale.US));                         //}                         //searchadapter.getFilter().filter(cs.toString().toLowerCase(Locale.US));                     }                     if (result.equals("1")) {                                 try {                                     System.out.println("Pehle Baar");                                     searchadapter.getFilter().filter(cs.toString().toLowerCase(Locale.US));                                     }                     catch(Exception e)                                    {                                     //System.out.println(e.getMessage().toString());                                    }                         }                  }                  @Override                 public void beforeTextChanged(CharSequence arg0, int arg1, int arg2, int arg3) {                     //TODO Auto-generated method stub                 }                  @Override                 public void afterTextChanged(Editable arg0) {                     //TODO Auto-generated method stub                   }             }); </code></pre>  <blockquote>   <p>ASYNC TASK getSearchTags</p> </blockquote>  <pre><code>public class getSearchTags extends AsyncTask&lt;String, Void, String&gt; {         private final String empId;          public getSearchTags(String empId) {             this.empId = empId;         }          @Override         protected void onPreExecute() {             super.onPreExecute();          }          @Override         protected String doInBackground(String... params) {             String result= Utils.getSearchTags(connString + "/GetSearchAutoComplete", empId);             System.out.println("result :" + result + "||");             if (null == result || result.length() == 2) {                 System.out.println("No results");                 return "0";             }             else {                 searchFilter.clear();                 try {                      JSONArray jsonArray=new JSONArray(result);                     System.out.println("Length :"+jsonArray.length());                     for (int i = 0; i &lt; jsonArray.length(); i++) {                         JSONObject objJson = jsonArray.getJSONObject(i);                         setFilterItems objItem = new setFilterItems();                         objItem.setID(objJson.getString("tag_id"));                         objItem.setImage(objJson.getString("tag_type"));                         objItem.setName(objJson.getString("tag_name"));                          searchFilter.add(objItem);                      }                 } catch (Exception e) {                     e.printStackTrace();                     System.out.println("Exception:" + e.getLocalizedMessage() + "||");                  }                 return "1";             }         }          @Override         protected void onPostExecute(String result) {             super.onPostExecute(result);             if(result=="1") {                 //setAdapterToListview();                 searchadapter = new searchRowAdapter(MainActivity_old.this, R.layout.searchrow, searchFilter);                 editText1.setAdapter(searchadapter);                 editText1.setTokenizer(new MultiAutoCompleteTextView.CommaTokenizer());                 searchadapter.notifyDataSetChanged();                 editText1.showDropDown();                 System.out.println("Success");             }else{                 System.out.println("Error");             }         }       } </code></pre>  <blockquote>   <p>Filter Interface</p> </blockquote>  <pre><code>private class NameFilter extends Filter {          @Override         protected FilterResults performFiltering(CharSequence constraint) {             FilterResults filterResults = new FilterResults();             if (constraint == null || constraint.length() == 0) {                 filterResults.values = originalList;                 filterResults.count = originalList.size();             } else {                 final String lastToken = constraint.toString().toLowerCase();                 final int count = originalList.size();                 final List&lt;setFilterItems&gt; list = new ArrayList&lt;setFilterItems&gt;();                 setFilterItems contact;                  for (int i = 0; i &lt; count; i++) {                     contact = originalList.get(i);                     if (contact.getName().toLowerCase().contains(lastToken)                             || contact.getName().toLowerCase().startsWith(lastToken)) {                         list.add(contact);                     }                 }                  filterResults.values = list;                 filterResults.count = list.size();             }             return filterResults;         }          @Override         protected void publishResults(CharSequence constraint, FilterResults results) {             list = (List&lt;setFilterItems&gt;) results.values;             if (results.count &gt; 0) {                 notifyDataSetChanged();             } else {                 notifyDataSetInvalidated();             }         }      } </code></pre>