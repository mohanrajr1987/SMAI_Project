<p>I have this code for serial communication on C++</p>  <pre><code>    *hDev = CreateFile(PortNameUNC, GENERIC_READ|GENERIC_WRITE, 0, NULL,        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);      if(*hDev == INVALID_HANDLE_VALUE) return false ;      DCB *dcb = new DCB ;     memset(dcb, 0x00, sizeof(DCB)) ;     dcb-&gt;DCBlength       = sizeof(DCB);     dcb-&gt;BaudRate        = BaudRate;     dcb-&gt;Parity          = Parity;     dcb-&gt;StopBits        = StopBits;     dcb-&gt;ByteSize        = ByteSize;     dcb-&gt;fBinary         = TRUE;     dcb-&gt;fDsrSensitivity = 0;     dcb-&gt;fDtrControl     = (DTR ? DTR_CONTROL_ENABLE : DTR_CONTROL_DISABLE) ;     dcb-&gt;fRtsControl     = (RTS ? RTS_CONTROL_ENABLE : RTS_CONTROL_DISABLE) ;     dcb-&gt;fOutxCtsFlow    = (CTS ? 1 : 0) ;     dcb-&gt;fOutxDsrFlow    = (DSR ? 1 : 0) ;     dcb-&gt;fOutX           = (XonnXoff ? 1 : 0) ;     dcb-&gt;fInX            = 0 ;      if(!SetCommState(*hDev, dcb))      {       delete dcb ;       CloseHandle(*hDev) ;       *hDev = INVALID_HANDLE_VALUE ;       return false;     }      delete dcb ;     this-&gt;BaudRate = BaudRate;     this-&gt;Parity = Parity;     this-&gt;StopBits = StopBits;     this-&gt;ByteSize = ByteSize;      if(!SetTimeOut(readTimeOut, ReadIntervalTimeout) || !Reset())        {          CloseHandle(*hDev) ;       *hDev = INVALID_HANDLE_VALUE ;       return false;     }            isOpen = true ;     return true ; } </code></pre>  <p>and this:</p>  <pre><code>bool serial::SetTimeOut(DWORD readTimeOut, DWORD ReadIntervalTimeout) {   COMMTIMEOUTS *timeouts = new COMMTIMEOUTS ;   memset(timeouts, 0, sizeof(COMMTIMEOUTS)) ;   timeouts-&gt;ReadIntervalTimeout          = ReadIntervalTimeout ;   timeouts-&gt;ReadTotalTimeoutMultiplier   = 5 ;   timeouts-&gt;ReadTotalTimeoutConstant     = readTimeOut ; //...   timeouts-&gt;WriteTotalTimeoutConstant    = 0 ; //   timeouts-&gt;WriteTotalTimeoutMultiplier  = 2*BaudRate/8 ;   const bool ret = SetCommTimeouts(*hDev, timeouts) != FALSE ;   delete timeouts ;   m_currentTimeOut = readTimeOut ;   return ret ; } </code></pre>  <p>I need to rewrite this to C#. I did most of the part using this function:</p>  <pre><code> public SerialPortHASP(string portName, int baudRate, Parity parity, int dataBits, StopBits stopBits, bool dtr, bool rts, bool xonxoff)         {              m_port = new SerialPort(portName, baudRate, parity, dataBits, stopBits);              // Just store parameters user entered             m_portName = portName;             m_baudRate = baudRate;             m_parity = parity;             m_dataBits = dataBits;             m_stopBits = stopBits;             m_xonxoff = xonxoff;             m_dtr = dtr;             m_rts = rts;              // Set XonXoff if set             if (xonxoff)                 m_port.Handshake = Handshake.XOnXOff;              // Set DTR/RTS             m_port.DtrEnable = dtr;             m_port.RtsEnable = rts;              // Open the port for communications             m_port.Open();         } </code></pre>  <p>But I don't know how to implement <code>bool serial::SetTimeOut(DWORD readTimeOut, DWORD ReadIntervalTimeout)</code> in C#. Any advice? Will using below properties be enough?</p>  <pre><code>   _serialPort.ReadTimeout = 500;    _serialPort.WriteTimeout = 500; </code></pre>  <p>PS. In general is my approach in translating that C++ code to C# correct? Thanks.</p>