<p>I have 2 serial port. I am getting the data very fast about 4 milliseconds.</p>  <p>I am getting the data how ever the data is not organized per the date and time.  I tried to user the event serial port and it still doesn't work so I moved to another thread.</p>  <p>here is my code:</p>  <pre><code>using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Threading; using System.Collections; using System.IO.Ports; using System.Windows.Forms;   namespace MyserialPort { public class MyserialPort {      private SerialPort sp; // the object serial port                 private Thread ThreadRead; // the thread to read the data.     //private Task ThreadRead2; // the thread to read the data.     private Thread ThreadSendingToUserData;      //private Task ThreadRead;      private byte[] dataRead; // the data that has been read.     private Queue&lt;byte[]&gt; _queueReadData; // this queue contain all the data that has been read.     private Queue&lt;DateTime&gt; _queueDateTime;      public delegate void sendData(byte[] arr, DateTime dt); // delegate for sending data     public event sendData RecieivedData; // an event that the user will recieved data      // private CancellationTokenSource cts;      /// &lt;summary&gt;     ///  // a property get set the port name     /// &lt;/summary&gt;     public string PortName     {         get { return sp.PortName ; }         set { sp.PortName = value; }     }      /// &lt;summary&gt;     /// get or set the standart bit of the data bis.      /// &lt;/summary&gt;     public int DataBits     {         get { return sp.DataBits; }         set { sp.DataBits = value; }     }      /// &lt;summary&gt;     /// get or sets the pairty of the portocol.     /// &lt;/summary&gt;     public System.IO.Ports.Parity Parity     {         get { return sp.Parity; }         set { sp.Parity = value; }     }      /// &lt;summary&gt;     /// get or set the amuount of stop bits in the serial port.     /// &lt;/summary&gt;     public System.IO.Ports.StopBits StopBits     {         get { return sp.StopBits; }         set { sp.StopBits = value; }     }      /// &lt;summary&gt;     /// get or set the amuount of baud Rate  in the serial port.     /// &lt;/summary&gt;     public int BaudRate     {         get { return sp.BaudRate; }         set { sp.BaudRate = value; }     }      /// &lt;summary&gt;     /// this property describe if the port is open or not open.     /// &lt;/summary&gt;     public bool IsOpen     {         get { return sp.IsOpen; }                  }      /// &lt;summary&gt;     /// a constructor for creating the serial port     /// &lt;/summary&gt;     /// &lt;param name="comPort"&gt;"the com port name"&lt;/param&gt;     /// &lt;param name="baudRate"&gt;the baud rate&lt;/param&gt;     /// &lt;param name="pairty"&gt;the pairty&lt;/param&gt;     /// &lt;param name="dataBits"&gt;the data bits&lt;/param&gt;     /// &lt;param name="stopbit"&gt;the stop bits&lt;/param&gt;     public MyserialPort(string comPort, int baudRate, Parity pairty, int dataBits, StopBits stopbit)     {                     _queueReadData = new Queue&lt;byte[]&gt;(); // init the queue for reading.         _queueDateTime = new Queue&lt;DateTime&gt;();         sp = new SerialPort(comPort, baudRate, pairty, dataBits, stopbit); //init serial port                               //sp.DataReceived += sp_DataReceived;          //init the thread to read                     ThreadRead = new Thread(new ThreadStart(readDataLoop));                    ThreadRead.Priority = ThreadPriority.Highest;          // init the thread to send for the user interface.         ThreadSendingToUserData = new Thread(new ThreadStart(SendEvents));         ThreadSendingToUserData.Priority = ThreadPriority.AboveNormal;         ThreadSendingToUserData.IsBackground = true;                     ThreadSendingToUserData.Start();             }      void sp_DataReceived(object sender, SerialDataReceivedEventArgs e)     {         readDataLoop();     }         /// &lt;summary&gt;     /// Writes a specific numeber of bytes to the serial ports     /// &lt;/summary&gt;     /// &lt;param name="buffer"&gt;the byte array to write to the port&lt;/param&gt;     /// &lt;param name="offset"&gt;the offser&lt;/param&gt;     /// &lt;param name="cnt"&gt;the number of bytes to write&lt;/param&gt;     public void Write(byte [] buffer,int offset,int cnt)     {         sp.Write(buffer, offset, cnt);     }      /// &lt;summary&gt;     /// perform open port     /// &lt;/summary&gt;     public void Open()     {         try         {             sp.Open();                         }         catch (Exception err)         {             MessageBox.Show(err.Message + "\n" + "\n" + err.InnerException);         }     }      /// &lt;summary&gt;     /// Close port.     /// &lt;/summary&gt;     public void Close()     {         try         {             sp.Close();                         }          catch (Exception err)         {             MessageBox.Show(err.Message + "\n" + "\n" + err.InnerException);         }     }       /// &lt;summary&gt;     /// reading Data Loop;     /// &lt;/summary&gt;     private void readDataLoop()    {        while (true)        {            //store data in queue                            if (sp.IsOpen)            {                if (sp.BytesToRead &gt; 0)                {                    lock (_queueDateTime)                    {                        DateTime dt = new DateTime(DateTime.Now.Ticks);                        _queueDateTime.Enqueue(dt);                        dataRead = new byte[sp.BytesToRead];                        sp.Read(dataRead, 0, dataRead.Length);                        if (dataRead.Length &gt; 0)                        {                            _queueReadData.Enqueue(dataRead);                        }                    }                }                 //           }                 Thread.Sleep(1);            }        }                }         /// &lt;summary&gt;     /// this method send Events to the user who want to recieved data     /// &lt;/summary&gt;     private void SendEvents()     {         while (true)         {             if (_queueReadData.Count &gt; 0) // check for Empty queue             {                                         RecieivedData(_queueReadData.Dequeue(), _queueDateTime.Dequeue()); // send the user an event with the data.                     }             System.Threading.Thread.Sleep(1);             }     }      public void Read()     {         //ThreadRead = Task.Factory.StartNew(() =&gt; { readDataLoop(); });                                 ThreadRead.Start();     } }  } </code></pre>