<p>I am trying to read data sent from the tty/USB0 and print it out with byte format.</p>  <p>Question:</p>  <ol> <li>I expect to print out the data once the reading bytes reach 40 However, the time takes much longer than I expect. The read() system call hangs and I believe the data should already be larger than 40. The data will finally be printed out but it should not take so long. Did I make anything wrong in this programming ?</li> </ol>  <p>thanks </p>  <pre><code>#include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include &lt;fcntl.h&gt; #include &lt;termios.h&gt; #include &lt;stdio.h&gt;  #define BAUDRATE B9600             #define MODEMDEVICE "/dev/ttyUSB0"  #define FALSE 0 #define TRUE 1  main() { int fd,c, res; struct termios oldtio,newtio; unsigned char buf[40]; fd = open(MODEMDEVICE, O_RDWR | O_NOCTTY ); if (fd &lt;0) {perror(MODEMDEVICE); exit(-1); }  tcgetattr(fd,&amp;oldtio); bzero(&amp;newtio, sizeof(newtio));  newtio.c_cflag = BAUDRATE | CS8 | CLOCAL | CREAD;  newtio.c_iflag = IGNPAR | ICRNL; newtio.c_oflag = 1; newtio.c_lflag = ICANON;  tcflush(fd, TCIOFLUSH); tcsetattr(fd,TCSANOW,&amp;newtio);  int i; while (1) {     res = read(fd,buf,40);     if(res==40){         printf("res reaches 40 \n");     }     printf("res: %d\n",res);     for(i=0;i&lt;res;++i){     printf("%02x ", buf[i]);     }     return;     } } </code></pre>  <p>--------------------raw mode code------------------------</p>  <pre><code>  #include &lt;sys/types.h&gt;   #include &lt;sys/stat.h&gt;   #include &lt;fcntl.h&gt;   #include &lt;termios.h&gt;   #include &lt;stdio.h&gt;    #define BAUDRATE B9600   #define MODEMDEVICE "/dev/ttyUSB0"   #define _POSIX_SOURCE 1 /* POSIX compliant source */   #define FALSE 0   #define TRUE 1    volatile int STOP=FALSE;    main()   {     int fd,c, res;     struct termios oldtio,newtio;     unsigned char buf[255];      fd = open(MODEMDEVICE, O_RDWR | O_NOCTTY );     if (fd &lt;0) {perror(MODEMDEVICE); exit(-1); }      tcgetattr(fd,&amp;oldtio); /* save current port settings */      bzero(&amp;newtio, sizeof(newtio));     newtio.c_cflag = BAUDRATE | CRTSCTS | CS8 | CLOCAL | CREAD;     newtio.c_iflag = IGNPAR;     newtio.c_oflag = 0;      /* set input mode (non-canonical, no echo,...) */     newtio.c_lflag = 0;      newtio.c_cc[VTIME]    = 0;        newtio.c_cc[VMIN]     = 40;         tcflush(fd, TCIFLUSH);     tcsetattr(fd,TCSANOW,&amp;newtio);      int i;     while (STOP==FALSE) {              res = read(fd,buf,255);          for( i=0;i&lt;res;++i){         printf("%02x \n", buf[i]);       }     }     tcsetattr(fd,TCSANOW,&amp;oldtio);   } </code></pre>  <p>It now can print out the data once buffer capacity is full ( which is 40 ). 1 question:</p>  <ol> <li><p>When I modified the printf </p>  <p><code>printf("%02x ", buf[i]); ( remove "\n" )</code> It will not print out when the buffer is full until more bytes are received. Why this happens?</p></li> </ol>  <p>Thanks</p>