<p>I want to know if I correctly mapped this C++ code which establishes serial port communication to C#.</p>  <pre><code>void some func(...) {  *hDev = CreateFile(PortNameUNC, GENERIC_READ|GENERIC_WRITE, 0, NULL,        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);      if(*hDev == INVALID_HANDLE_VALUE) return false ;      DCB *dcb = new DCB ;     memset(dcb, 0x00, sizeof(DCB)) ;     dcb-&gt;DCBlength       = sizeof(DCB);     dcb-&gt;BaudRate        = BaudRate;     dcb-&gt;Parity          = Parity;     dcb-&gt;StopBits        = StopBits;     dcb-&gt;ByteSize        = ByteSize;     dcb-&gt;fBinary         = TRUE;     dcb-&gt;fDsrSensitivity = 0;     dcb-&gt;fDtrControl     = (DTR ? DTR_CONTROL_ENABLE : DTR_CONTROL_DISABLE) ;     dcb-&gt;fRtsControl     = (RTS ? RTS_CONTROL_ENABLE : RTS_CONTROL_DISABLE) ;     dcb-&gt;fOutxCtsFlow    = (CTS ? 1 : 0) ;     dcb-&gt;fOutxDsrFlow    = (DSR ? 1 : 0) ;     dcb-&gt;fOutX           = (XonnXoff ? 1 : 0) ;     dcb-&gt;fInX            = 0 ;            if(!SetCommState(*hDev, dcb))      {       delete dcb ;       CloseHandle(*hDev) ;       *hDev = INVALID_HANDLE_VALUE ;       return false;     }       if(!SetTimeOut(readTimeOut, ReadIntervalTimeout) || !Reset())        {          CloseHandle(*hDev) ;       *hDev = INVALID_HANDLE_VALUE ;       return false;     } }  bool serial::SetTimeOut(DWORD readTimeOut, DWORD ReadIntervalTimeout) {   COMMTIMEOUTS *timeouts = new COMMTIMEOUTS ;   memset(timeouts, 0, sizeof(COMMTIMEOUTS)) ;   timeouts-&gt;ReadIntervalTimeout          = ReadIntervalTimeout ;   timeouts-&gt;ReadTotalTimeoutMultiplier   = 5 ;   timeouts-&gt;ReadTotalTimeoutConstant     = readTimeOut ; //...   timeouts-&gt;WriteTotalTimeoutConstant    = 0 ; //   timeouts-&gt;WriteTotalTimeoutMultiplier  = 2*BaudRate/8 ;   const bool ret = SetCommTimeouts(*hDev, timeouts) != FALSE ;   delete timeouts ;   m_currentTimeOut = readTimeOut ;   return ret ; } </code></pre>  <p>This is my C# mapping:</p>  <pre><code> public SerialPortHASP(string portName, int baudRate, Parity parity, int dataBits, StopBits stopBits, bool dtr, bool rts, bool xonxoff)         {              m_port = new SerialPort(portName, baudRate, parity, dataBits, stopBits);              // Just store parameters user entered             m_portName = portName;             m_baudRate = baudRate;             m_parity = parity;             m_dataBits = dataBits;             m_stopBits = stopBits;             m_xonxoff = xonxoff;             m_dtr = dtr;             m_rts = rts;              // Set XonXoff if set             if (xonxoff)                 m_port.Handshake = Handshake.XOnXOff;              // Set DTR/RTS             m_port.DtrEnable = dtr;             m_port.RtsEnable = rts;              m_port.ReadTimeout = 500; // or some other values             m_port.WriteTimeout = 500;              // Open the port for communications             m_port.Open();         } </code></pre>  <p>I will need to implement some other read write operations (according to protocol) till I can test if my mapping is right, so this is why I want to double check if I took correct approach in mapping above code to C#? Or should I take <a href="http://forums.codeguru.com/showthread.php?182234-serial-ports-C" rel="nofollow">this</a> route with PInvoke calls? Or still try my current approach? Thanks </p>  <p>PS. Thing is you can see this way I can't replicate all parameters that C++ calls allow one to make</p>