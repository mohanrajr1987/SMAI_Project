<p>I have a requirement in which I need to map multiple determinants to values. </p>  <ul> <li><p>Each set of determinants in a given job execution is guaranteed to be unique. The value to be determined doesn't have to be unique but it probably is.</p></li> <li><p>Depending on the input to the job execution, this could be either one key, or the combination of two keys, or the combination of <code>n</code> keys that will be mapped to a single value. In practice this <code>n</code> will probably be limited to no more than 5, although it is possible it could exceed that.</p></li> <li><p>Each job execution will have a set number of determinants for all inputs (I.e., all inputs will have either 2 determinants, 3 determinants, or n determinants, and will not have a mix). </p></li> </ul>  <p>One key example: <code>foo --&gt; bar</code></p>  <p>Two keys: <code>foo, bar --&gt; baz</code></p>  <p>Three keys: <code>foo, bar, baz --&gt; hai</code></p>  <p>Prior to this, the requirement was that I would only ever map two values to another value. I created an immutable Key class with two member variables and the appropriate override of <code>equals</code> and <code>hashCode</code>. </p>  <pre><code>public class Key {     String determinant0;     String determinant1;     public Key(String d0, d1) {         determinant0 = d0;         determinant1 = d1;     }     // .. }  </code></pre>  <p>However, now that I may be dealing with n number of values, I want to take a look at using a list as the key.</p>  <pre><code>Map&lt;List, String&gt; map = new HashMap&lt;List, String&gt;(); map.put(Arrays.asList("foo", "bar", "baz"), "hai"); String determined = map.get(Arrays.AsList("foo","bar","baz")); assert (determined.equals("hai")); </code></pre>  <p>This <a href="http://stackoverflow.com/questions/9973596/arraylist-as-key-in-hashmap">question</a> reminds me that it is bad to use a mutable object (like a List) as a key in a map. However, in my application, the key is only set once and is never altered. Here is an alternative from this <a href="http://stackoverflow.com/a/16839191/1391717">question</a> that forces it to be immutable:</p>  <pre><code>HashMap&lt;List&lt;String&gt;, String&gt; map;  map.put(     // unmodifiable so key cannot change hash code     Collections.unmodifiableList(Arrays.asList("foo", "bar", "baz")),     "hai" ); </code></pre>  <p>In addition, I could always make a class like the following to prevent mutations on the list:</p>  <pre><code>public class Key {     List&lt;String&gt; determinants;     public Key(List&lt;String&gt; determinants) {         this.determinants = determinants     }     @Override     public boolean equals(Object obj) {         //...     }     @Override     public int hashCode() {         //...     } }  Key key = new Key(Arrays.asList("foo","bar","baz")); </code></pre>  <p>Using a plain array as the key won't work, because an array's equal method only checks for identity:</p>  <pre><code>Map&lt;String[], String&gt; map = new HashMap&lt;String[], String&gt;(); String[] key = new String[]{"foo", "bar", "baz"} map.put(key, "hai"); System.out.println(map.get(key)); // null </code></pre>  <p>That could be fixed by the following:</p>  <pre><code>public class Key {     String[] determinants;     public Key(String... determinants) {         this.determinants = determinants;     }     @Override     public boolean equals(Object obj) {         //...     }     @Override     public int hashCode() {         //...     } } </code></pre>  <p>How about concatting all the determinants together in a string?</p>  <pre><code>public class Key {     String hash = "";     public Key(String... determinants) {         for (String determinant : determinants) {             hash += determinant + "_";         }      }     @Override     public boolean equals(Object obj) {         //...     }     @Override     public int hashCode() {         //...     } } </code></pre>  <p>Which one of these solutions (or another one that I did not propose) is the best suited for these requirements?</p>