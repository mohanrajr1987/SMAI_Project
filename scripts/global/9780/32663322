<p>Suppose you have a class <code>Foo</code>:</p>  <pre><code>public class Foo {     public static implicit operator Foo(string s)      {         return new Foo();     } } </code></pre>  <p>If you try to leverage this operator in the usual way it works fine, of course:</p>  <pre><code>var s = "foo"; Foo foo = s; </code></pre>  <p>But what if you have the operand (<code>s</code>) but you <em>only</em> have it as an <code>object</code>:</p>  <pre><code>object s = "foo"; Foo foo = s; </code></pre>  <p>This fails for obvious reasons since there is no implicit conversion from <code>object</code> to <code>Foo</code>.  However, the instance <em>is</em> a <code>string</code> and a type conversion operator does exist for this scenario.  For the purpose of this question, assume that the variable in question (<code>s</code>) could be any of a number of types that might possibly have a type conversion operator defined to perform the requested conversion.</p>  <p>If you wanted, you could use reflection:</p>  <pre><code>object s = "foo"; var converter = typeof(Foo)     .GetMethods()     .Single(x =&gt;          x.Name == "op_Implicit" &amp;&amp;          x.ReturnType == typeof(Foo) &amp;&amp;          x.GetParameters().Single().ParameterType == typeof(string)); Foo foo = (Foo)converter.Invoke(null, new[] { s }); </code></pre>  <p>I tried using <code>Convert.ChangeType(s, typeof(Foo));</code>, but this does not work. <strong>Is there any better alternative or is using reflection the best choice?</strong>  (I'm unhappy with using reflection for the standard reasons -- it's probably not maximally performant and the appearance of the code is unseemly.  But if it's the best bet, then fine.)</p>