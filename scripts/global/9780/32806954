<p>Consider the following code:</p>  <pre><code>#include &lt;cstdint&gt; #include &lt;iostream&gt; #include &lt;iomanip&gt;  int main() {     auto x=std::uint32_t(1)&lt;&lt;31;     std::cout &lt;&lt; " x: 0x" &lt;&lt; std::hex &lt;&lt; x &lt;&lt; " =  " &lt;&lt; std::dec &lt;&lt; x &lt;&lt; "\n";     int32_t sx=x;     std::cout &lt;&lt; "sx: 0x" &lt;&lt; std::hex &lt;&lt; sx &lt;&lt; " = " &lt;&lt; std::dec &lt;&lt; sx &lt;&lt; "\n"; } </code></pre>  <p>I get the following output from it:</p>  <pre><code> x: 0x80000000 =  2147483648 sx: 0x80000000 = -2147483648 </code></pre>  <p>Here the value of <code>x</code> can't be represented in <code>int32_t</code>, and the C++11 Standard says the following about this conversion:</p>  <blockquote>   <p>If the destination type is signed, the value is unchanged if it can be represented in the destination type (and   bit-field width); otherwise, the value is implementation-defined.</p> </blockquote>  <p>Is this still implementation-defined even with <code>intXX_t</code>, for which we have certain guarantees on representation? If yes, then how can I guarantee that the result will be as shown above? Should I <code>memcpy</code> my unsigned value to signed to get two's complement interpretation, or is there a more straightforward way?</p>