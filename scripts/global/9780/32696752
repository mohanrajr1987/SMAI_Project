<p>In the given scenario we have two tables:</p>  <ol> <li>ChangeLog: Containing historical values of a "field", stored as varchar(23).</li> <li>ViewFields: Containing meta information about a "field", e.g. datatype, max value, min value, display name. This is for validation tasks and UI configuration.</li> </ol>  <p>The following statement shall update all historical values of all "fields" which are convertible to "DateTime":</p>  <pre><code>BEGIN TRAN  UPDATE c    SET c.OldValue = CONVERT(varchar(23), CONVERT(DATETIME, c.OldValue, 101), 21)   FROM ChangeLog c  WHERE c.FieldID IN (   SELECT v.FieldID                           FROM ViewFields v                          WHERE FieldDataType IN (4,5,6)) </code></pre>  <p>When executing the statement, I'm getting the following error message:</p>  <blockquote>   <p>Msg 241, Level 16, State 1, Line 5   Conversion failed when converting date and/or time from character string.</p> </blockquote>  <p>Assuming, that there are values in the result, which are not convertible, the following statement should fail as well:</p>  <pre><code>SELECT CONVERT(varchar(23), CONVERT(DATETIME, c.OldValue, 101), 21)   FROM ChangeLog c  WHERE c.FieldID IN (   SELECT v.FieldID                           FROM ViewFields v                          WHERE FieldDataType IN (4,5,6)) </code></pre>  <p>Surprisingly, the select statement does work without errors. When I now try to execute the update statement again, it works as well. To break the statement again, execute <strong>DBCC DROPCLEANBUFFERS</strong>.</p>  <p>In my opinion, the condition should always be evaluated first, before reading the value. But this seems to be obviously not the case in this example. The problem seems to be related to the cache. Execution plans are identical.</p>  <p>Can somebody explain what does happen here?</p>  <p>Possible solution would be to update the values using cursors, but in my opinion this is no clean solution.</p>