<p>I was wondering if I write something like this:</p>  <pre><code>Type &amp;var = database.get&lt;TYPE&gt;(name); </code></pre>  <p>Assuming that <code>database</code> is a container able to store datablocks of different datatypes. To get a reference to that datablock, the <code>name</code> as <code>std::string</code> is passed to get() so that at different places with that call I have a way to access certain 'global' variables. I have get() as a template method and I would like to keep it that way.</p>  <p>What I want to do is shorten that call an elegant way like this:</p>  <pre><code>Type &amp;var = database.get(name); </code></pre>  <p>So the template deduction is automatically performed. Now I could create a macro for that, but this is not what I want to do, as I do not consider it elegant for such case.</p>  <p>That deduction though does not work, because we need a template parameter. Why can't the compiler take what is set for the variable and pass it as template parameter automatically? Is there a way to do this? I don't want to have any type conversions in this case. Can we omit it?</p>