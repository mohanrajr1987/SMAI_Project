<p>If I get some values from the database in C#, they are type object. Now I want to convert this values <code>typesafe</code> to load them into my object which represents a <code>datarow</code> more or less. So I thought it would be nice to create a generic extend-method for extend object.</p>  <p>So I build the following:</p>  <pre><code>public static T ConvertToType&lt;T&gt;(this object value) {    T returnValue = default(T);    if (value != DBNull.Value)    {       returnValue = (T)value;    }     return returnValue; } </code></pre>  <p>So I can use this to convert the different values from the given <code>datarow</code> and if the database stores <code>null</code> value I get the default type.</p>  <p>For example:</p>  <pre><code>foreach (DataRow row in myTable.Rows) {    MyClass myObject = new MyClass();    myObject.Id = row["ID"].ConvertToType&lt;int&gt;(); } </code></pre>  <p>This works for compile time but it seems not possible to cast object to <code>int</code> for example. So I thought all value types have to be handled manually.</p>  <p>So I extend the first Code-Block:</p>  <pre><code>public static T ConvertToType&lt;T&gt;(this object value) {    T returnValue = default(T);    if (value != DBNull.Value)    {       if (wert is int)       {         rueckgabe = Convert.ToInt32(wert);       }       //else if All Value-Types are following...       else       {         returnValue = (T)value;       }    }     return returnValue; } </code></pre>  <p>But for sure the compiler now tells me that target type T can't be converted to <code>int</code>. This is quite clear.</p>  <p>Is someone out there who got a well solution for this issue? Or is this not as simple as I hoped.</p>