<p>I'm trying to implement GCM in my iOS app. Everything seems to work fine, the app is connecting to GCM and getting a registration ID back. If I send a notification to that regid using Postman it works and I get a success response back from Google. However, whatever I try, the notification isn't actually shown on the device. </p>  <p>The post messsage to the GCM servers I'm using is </p>  <pre><code>{     "to" : "RegID",     "content_available" : true,     "notification" : {         "body" : "Test Body",         "title" : "Test Title"     } } </code></pre>  <p>which gives me the response:</p>  <pre><code>{     "multicast_id": 6594175386712804014,     "success": 1,     "failure": 0,     "canonical_ids": 0,     "results": [         {             "message_id": "0:1443445858075083%c4cfa24dc4cfa24d"         }     ] } </code></pre>  <p>This makes me believe there is something wrong with the code in my app. Below I've pasted all the relevant code. I've written the code 3 times without success, first following the tutorial and editing it to fit in my app properly, second time I copied the code from the tutorial and the third time I got the example app from the Github repo and copied everything relevant to GCM over.</p>  <p>AppDelegate: </p>  <pre><code>class AppDelegate: UIResponder, UIApplicationDelegate  {      var window: UIWindow?      var connectedToGCM = false     var gcmSenderID: String?     var registrationToken: String?     var registrationOptions = [String: AnyObject]()     let defaults = NSUserDefaults.standardUserDefaults()      let registrationKey = "onRegistrationCompleted"     let messageKey = "onMessageReceived"     let notification = "isNotificationEnabled"      func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -&gt; Bool {         // Google Cloud Messaging         var configureError:NSError?         GGLContext.sharedInstance().configureWithError(&amp;configureError)         assert(configureError == nil, "Error configuring Google services: \(configureError)")         gcmSenderID = GGLContext.sharedInstance().configuration.gcmSenderID          var types: UIUserNotificationType = UIUserNotificationType.Badge |             UIUserNotificationType.Alert |             UIUserNotificationType.Sound         var settings: UIUserNotificationSettings =         UIUserNotificationSettings( forTypes: types, categories: nil )         application.registerUserNotificationSettings( settings )         application.registerForRemoteNotifications()          var gcmConfig = GCMConfig.defaultConfig()         GCMService.sharedInstance().startWithConfig(gcmConfig)          return true     }      func applicationDidBecomeActive(application: UIApplication) {                       GCMService.sharedInstance().connectWithHandler({             (NSError error) -&gt; Void in             if error != nil {                 println("Could not connect to GCM: \(error.localizedDescription)")             } else {                 self.connectedToGCM = true                 println("Connected to GCM")                 // ...             }         })      }      func application( application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken         deviceToken: NSData ) {             println(deviceToken)             // [END receice_apns_token]             // [START get_gcm_reg_token]             // Create a config and set a delegate that implements the GGLInstaceIDDelegate protocol.             var instanceIDConfig = GGLInstanceIDConfig.defaultConfig()             // Start the GGLInstanceID shared instance with that config and request a registration             // token to enable reception of notifications             GGLInstanceID.sharedInstance().startWithConfig(instanceIDConfig)             registrationOptions = [kGGLInstanceIDRegisterAPNSOption:deviceToken,                 kGGLInstanceIDAPNSServerTypeSandboxOption:true]             GGLInstanceID.sharedInstance().tokenWithAuthorizedEntity(gcmSenderID,                 scope: kGGLInstanceIDScopeGCM, options: registrationOptions, handler: registrationHandler)             // [END get_gcm_reg_token]     }      func registrationHandler(registrationToken: String!, error: NSError!) {         if (registrationToken != nil) {             self.registrationToken = registrationToken             println("Registration Token: \(registrationToken)")             let userInfo = ["registrationToken": registrationToken]             NSNotificationCenter.defaultCenter().postNotificationName(                 self.registrationKey, object: nil, userInfo: userInfo)         } else {             println("Registration to GCM failed with error: \(error.localizedDescription)")             let userInfo = ["error": error.localizedDescription]             NSNotificationCenter.defaultCenter().postNotificationName(                 self.registrationKey, object: nil, userInfo: userInfo)         }     }      func onTokenRefresh() {         // A rotation of the registration tokens is happening, so the app needs to request a new token.         println("The GCM registration token needs to be changed.")         GGLInstanceID.sharedInstance().tokenWithAuthorizedEntity(gcmSenderID,             scope: kGGLInstanceIDScopeGCM, options: registrationOptions, handler: registrationHandler)     }       func application( application: UIApplication, didReceiveRemoteNotification userInfo: [NSObject : AnyObject]) {         println("Notification received: \(userInfo)")         // This works only if the app started the GCM service         GCMService.sharedInstance().appDidReceiveMessage(userInfo);         // Handle the received message         // Invoke the completion handler passing the appropriate UIBackgroundFetchResult value         // [START_EXCLUDE]         NSNotificationCenter.defaultCenter().postNotificationName(messageKey, object: nil,             userInfo: userInfo)     } </code></pre>  <p>If anyone asked a similar question before let me know, I wasn't able to find one that described my situation properly.</p>  <p>Thanks in advance!</p>