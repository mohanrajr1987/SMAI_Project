<p>I am using an indefinitely running service (with its own process) and an extension of GcmListenerService to receive push messages. The push messages will initiate an operation within the service. The problem is, that if the app is closed/removed from the recently used app, the service is still running, but will stop immediately if a new message is received. The process list shows that first the background process is terminated and then a usual application process starts without any processing of the push message.</p>  <p>AndroidManifest.xml</p>  <pre><code>&lt;application android:allowBackup="false" android:label="@string/app_name"     android:icon="@drawable/icon" android:theme="@style/AppTheme"     android:process="domain.android.Application"     android:name=".Application"&gt;     &lt;receiver         android:name="com.google.android.gms.gcm.GcmReceiver"         android:exported="true"         android:permission="com.google.android.c2dm.permission.SEND" &gt;         &lt;intent-filter&gt;             &lt;action android:name="com.google.android.c2dm.intent.RECEIVE" /&gt;             &lt;category android:name="domain.android" /&gt;         &lt;/intent-filter&gt;     &lt;/receiver&gt;      &lt;service         android:name=".service.MyGcmListenerService"         android:exported="false" &gt;         &lt;intent-filter&gt;             &lt;action android:name="com.google.android.c2dm.intent.RECEIVE" /&gt;         &lt;/intent-filter&gt;     &lt;/service&gt;      &lt;service         android:name=".service.BackgroundService"         android:icon="@drawable/icon"         android:label="@string/service_name"         android:process="domain.android.service.BackgroundService"         android:exported="false"         android:enabled="true"/&gt; &lt;/application&gt; </code></pre>  <p>The GCM listener</p>  <pre><code>public class MyGcmListenerService extends GcmListenerService {      @Override     public void onMessageReceived(String from, Bundle data) {         String code = data.getString("code");         if ("j".equals(code)) {             final String id = data.getString("id", null);             String status = data.getString("status", null);              Intent serviceIntent = new Intent(getBaseContext(), domain.android.service.BackgroundService.class);             serviceIntent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);             serviceIntent.putExtra("method", "push");             serviceIntent.putExtra("id", id);             serviceIntent.putExtra("status", status);             serviceIntent.putExtra("notificationId", (new Date()).getTime());             startService(serviceIntent);         }     } } </code></pre>  <p>The service:</p>  <pre><code>public class BackgroundService extends Service {     @Override     public int onStartCommand(Intent intent, int flags, final int startId) {         if (intent.hasExtra("method")) {             // Start processing         }     }     @Override     public void onCreate() {         Intent notificationIntent = new Intent(this, Main.class);         PendingIntent intent = PendingIntent.getActivity(getBaseContext(), 0, notificationIntent, 0);         android.app.Notification.Builder builder = new android.app.Notification.Builder(this)             .setContentIntent(intent)             .setContentTitle(getText(R.string.app_name))                 .setContentText("Connected")                 .setSmallIcon(R.drawable.marker_walker_white);          android.app.Notification notification = builder.build();         startForeground(1, notification);     } } </code></pre>