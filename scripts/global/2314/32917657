<p>I have been using OpenAL soft for Win32, and I I ran into a particular problem.  </p>  <p>My goal is to play a looping sound that has a one-shot intro portion, similar to a .WAV file with a loop marker.  As I understand it, this must be achieved in OpenAL by using multiple buffers on a source.  In general, my approach is to queue up both buffers, then wait until the second buffer is playing, and set the source to loop.  This works, but the problem is that once I am ready to stop the sound, I don't seem to be able to unqueue the last buffer.  My code looks roughly like this:</p>  <pre><code>// set up the sound alSourceQueueBuffers(source, 1, &amp;buffer1); alSourceQueueBuffers(source, 1, &amp;buffer2); alSourcePlay(source);  ...  // check to loop sound in update ALint buffer; alGetSourcei(source, AL_BUFFER, &amp;buffer); if (buffer == buffer2) {     alSourcei(source, AL_LOOPING, true); }  ..  // check to stop sound in update if (shouldStop) {     alSourcei(source, AL_LOOPING, false);     alSourceStop(source);      alSourceUnqueueBuffers(source, 1, &amp;buffer1);     alSourceUnqueueBuffers(source, 1, &amp;buffer2); // AL_INVALID_OPERATION } </code></pre>  <p>The result seems to be that the buffer is not properly unqueued, and will be heard the next time I play this source.  I know that typically you can only unqueue a buffer after it finished playing, but I would think that I could freely unqueue any buffers on a stopped sound.  I am wondering if perhaps my use of the loop flag is causing this behavior?  </p>  <p>I'd greatly appreciate any advice.</p>  <p>Thank you, Mike</p>