<p>I have an application that uses JNI and the NDK to run native C++ in background of the UI. The native layer is initialized in <code>onCreate</code>, and finalized in <code>onDestroy</code>.</p>  <pre><code>public class XXXXActivity extends Activity {     TermScreenView mTermScreenView = null;      @Override     protected void onCreate( Bundle savedInstanceState )     {         super.onCreate( savedInstanceState );          try         {             this.setRequestedOrientation( ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE );              setContentView( R.layout.activity_XXXX );             mTermScreenView = (TermScreenView) findViewById( R.id.termScreenView );              if( ! initializeNative() )             {                 Toast.makeText( getBaseContext(), "Failed to initialize", Toast.LENGTH_LONG ).show();                 throw new Exception( "Failed to initialize native layer" );             }         }         catch( Exception exc )         {             exc.printStackTrace();         }     }      @Override     public void onDestroy()     {         finalizeNative();          super.onDestroy();     }      public native boolean initializeNative();      public native boolean finalizeNative();      // Etc } </code></pre>  <p>For some reason, after <code>initializeNative</code> ends successfully by returning <code>true</code> and without throwing any exception in the native code and <code>onCreate</code> ends successfully too, <code>onDestroyed</code> gets called several milliseconds after. Nothing is supposed to be called once onCreate ends in my application, except <code>onDestroy</code> when the user quits it.</p>  <p>I don't know why <code>onDestroy</code> is called since <code>onCreate</code> succeeds. What could be the reason ?</p>  <p>Thank you :)</p>  <p>EDIT : Here is the code from initializeNative :</p>  <pre><code>jboolean XXXXActivity_initializeNative( JNIEnv * pEnv, jobject pActivityObject ) {     TRACE_I( g_pJniLog, "::XXXXActivity_initializeNative() - Begin." );      if( NULL != g_pAppAdapt )     {         TRACE_I( g_pJniLog, "::XXXXActivity_initializeNative() - End, already called." );         return false;     }      jclass pActivityClass = pEnv-&gt;FindClass( "XXXXActivity" );     assert( NULL != pActivityClass );     TRACE_I( g_pJniLog, "::XXXXActivity_initializeNative() - pActivityClass = %p.", pActivityClass );      g_pActivityClass = (jclass) pEnv-&gt;NewGlobalRef( pActivityClass );     assert( NULL != g_pActivityClass );      g_pActivityObject = (jobject) pEnv-&gt;NewGlobalRef( pActivityObject );     assert( NULL != g_pActivityObject );      TRACE_I( g_pJniLog, "::XXXXActivity_initializeNative() - Creating XXXXActivityAdapter." );     g_pAppAdapt = new XXXXActivityAdapter();      TRACE_I( g_pJniLog, "::XXXXActivity_initializeNative() - Initializing XXXXActivityAdapter." );     g_pAppAdapt-&gt;InitializeInstance();      TRACE_I( g_pJniLog, "::XXXXActivity_initializeNative() - End, success." );     return true;  } </code></pre>  <p>I don't think it would be relevant to provide more since since it would get very big. I can tell you that the function doesn't throw a native exception and doesn't return false.</p>