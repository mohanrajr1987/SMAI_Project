<p>I tried to make an algorithm to find the nth Hardy-Ramanujan number(a number which can be expressed in more than one way as a sum of 2 cubes). Except I'm basically checking every single cube with another to see if it equals a sum of another 2 cubes. Any tips on how to make this more efficient? I'm kind of stumped. </p>  <pre><code>public static long nthHardyNumber(int n) {      PriorityQueue&lt;Long&gt; sums = new PriorityQueue&lt;Long&gt;();     PriorityQueue&lt;Long&gt; hardyNums = new PriorityQueue&lt;Long&gt;();     int limit = 12;     long lastNum = 0;      //Get the first hardy number     for(int i=1;i&lt;=12;i++){         for(int j = i; j &lt;=12;j++){             long temp = i*i*i + j*j*j;             if(sums.contains(temp)){                 if(!hardyNums.contains(temp))                     hardyNums.offer(temp);                 if(temp &gt; lastNum)                     lastNum = temp;             }             else                 sums.offer(temp);         }     }     limit++;      //Find n hardy numbers     while(hardyNums.size()&lt;n){         for(int i = 1; i &lt;= limit; i++){             long temp = i*i*i + limit*limit*limit;             if(sums.contains(temp)){                 if(!hardyNums.contains(temp))                     hardyNums.offer(temp);                 if(temp &gt; lastNum)                     lastNum = temp;             }             else                 sums.offer(temp);         }         limit++;     }      //Check to see if there are hardy numbers less than the biggest you found     int prevLim = limit;     limit = (int) Math.ceil(Math.cbrt(lastNum));     for(int i = 1; i &lt;= prevLim;i++){         for(int j = prevLim; j &lt;= limit; j++){             long temp = i*i*i + j*j*j;             if(sums.contains(temp)){                 if(!hardyNums.contains(temp))                     hardyNums.offer(temp);                 if(temp &gt; lastNum)                     lastNum = temp;             }             else                 sums.offer(temp);         }     }      //Get the nth number from the pq     long temp = 0;     int count = 0;     while(count&lt;n){         temp = hardyNums.poll();         count++;     }     return temp;  } </code></pre>