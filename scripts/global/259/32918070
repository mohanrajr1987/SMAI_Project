<p>I can't understand the solution for the following problem:</p>  <p>Alice and Bob are playing a game.</p>  <p>In this game, the players are supposed to show at the same time using the hands an integer between 0 and 10 million. If the numbers shown by both players are equal, we have a tie. Otherwise, the players alternate writing down numbers in a piece of paper. </p>  <p>Let A be an integer shown by Alice in the beginning of the match and let B be an integer show by Bob, each number written down must be a product of |A - B| factors, with all factors being prime numbers, not necessarily distinct, belonging to the interval defined by the integers A and B.</p>  <p>Alice always play first.</p>  <p>For example, if A = 2 and B = 5, there are only 10 numbers (Bob Wins) which can be written down in the paper, which are:</p>  <pre><code>8 = 2 x 2 x 2    12 = 2 × 2 × 3   20 = 2 × 2 × 5   18 = 2 × 3 × 3   30 = 2 × 3 × 5   50 = 2 × 5 × 5   27 = 3 × 3 × 3   45 = 3 × 3 × 5   75 = 3 × 5 × 5   125 = 5 × 5 × 5   </code></pre>  <p>The input has two numbers A and B as described. </p>  <p>The output has 1 line containing singly the match winner's name, assuming that both players play optimally. If the match ties, the output line shall contain singly the symbol '?'.</p>  <p>Here is a solution to this problem :</p>  <pre><code>#include &lt;stdio.h&gt; #include &lt;math.h&gt; #include &lt;string.h&gt;  #define MAX 11234567  int primes[MAX], primeIndex;  inline void sieve(int limit) {      bool sieve[limit];     memset(sieve, 0 , sizeof(sieve));      primeIndex = 0;     primes[primeIndex] = 2;      for (int i = 3; i &lt; limit ; i += 2) {         if(!sieve[i]){             primes[++primeIndex] = i;             for (int j = i + i; j &lt;= limit; j += i) {                 sieve[j] = 1;             }         }     }      ++primeIndex; }  inline int mul(int n) {     int ret = 0;     while (n &gt; 0) {         n /= 2;         ret += n;     }     return ret; }  inline void swap(int *a, int *b){     int aux = *a;     *a = *b;     *b = aux; }  int main(void) {     int A, B;     scanf("%d %d", &amp;A, &amp;B);      if (A == B) {         puts("?");         return 0;     }      if (A &gt; B) {         swap(&amp;A, &amp;B);     }       sieve(B);      int position_of_largest_prime;     for (position_of_largest_prime = 0; position_of_largest_prime &lt; primeIndex &amp;&amp; primes[position_of_largest_prime] &lt; A; ++position_of_largest_prime);      int intervalBA = B - A;     int primeCount = (primeIndex - position_of_largest_prime);      puts(primeCount &gt; 0 &amp;&amp; mul(intervalBA + primeCount - 1) == mul(primeCount - 1) + mul(intervalBA) ? "Alice" : "Bob");      return 0; } </code></pre>  <blockquote>   <p>mul(intervalBA + primeCount - 1) == mul(primeCount - 1) + mul(intervalBA)</p> </blockquote>  <p>I don't understand the above condition.  Is this some number theory problem ?  Someone can help me to identify it ?</p>  <blockquote>   <p>As pointed on the answer there is a lack of information on the description. <a href="http://www.urionlinejudge.com.br/repository/UOJ_1904_en.html" rel="nofollow">Here</a> is a link to the problem with a detailed description. </p> </blockquote>