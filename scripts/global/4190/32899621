<p>I am trying to compile a C++ module to use in <code>scipy.weave</code> that is composed of several headers and source C++ files. These files contain classes and methods that extensively use the Numpy/C-API interface. But I am failing to figure out how to include <code>import_array()</code> successfully. I have been struggling on this for the past week and I am going nuts. I hope you could help me with it because the <code>weave</code> <a href="http://docs.scipy.org/doc/numpy/reference/c-api.array.html#importing-the-api" rel="nofollow">help</a> is not very explanatory.</p>  <p>In practice I have first a module called <code>pycapi_utils</code> that contains some routines to interface C objects with Python objects. It consists of a header file <code>pycapi_utils.h</code> and a source file <code>pycapi_utils.cpp</code> such as:</p>  <pre><code>//pycapi_utils.h #if ! defined _PYCAPI_UTILS_H #define _PYCAPI_UTILS_H 1  #include &lt;stdlib.h&gt; #include &lt;Python.h&gt; #include &lt;numpy/arrayobject.h&gt; #include &lt;tuple&gt; #include &lt;list&gt;  typedef std::tuple&lt;const char*,PyObject*&gt; pykeyval; //Tuple type (string,Pyobj*) as dictionary entry (key,val) typedef std::list&lt;pykeyval&gt; kvlist;                      //Declaration of methods PyObject* array_double_to_pyobj(double* v_c, long int NUMEL); //Convert from array to Python list (double) ... ... #endif </code></pre>  <p>and</p>  <pre><code>//pycapi_utils.cpp  #include "pycapi_utils.h"  PyObject* array_double_to_pyobj(double* v_c, long int NUMEL){     //Convert a double array to a Numpy array     PyObject* out_array = PyArray_SimpleNew(1, &amp;NUMEL, NPY_DOUBLE);     double* v_b = (double*) ((PyArrayObject*) out_array)-&gt;data;     for (int i=0;i&lt;NUMEL;i++) v_b[i] = v_c[i];     free(v_c);     return out_array; } </code></pre>  <p>Then I have a further module <code>model</code> that contains classes and routines dealing with some mathematical model. Again it consists of a header and source file like:</p>  <pre><code>//model.h #if ! defined _MODEL_H #define _MODEL_H 1  //model class class my_model{     int i,j;     public:         my_model();         ~my_model();         double* update(double*);  }  //Simulator    PyObject* simulate(double* input); #endif   </code></pre>  <p>and</p>  <pre><code>//model.cpp  #include "pycapi_utils.h" #include "model.h"  //Define class and methods model::model{ ... ... }  ... ...  double* model::update(double* input){     double* x = (double*)calloc(N,sizeof(double));     ...     ...      // Do something     ...     ...      return x; }  PyObject* simulate(double* input){     //Initialize Python interface      Py_Initialize;     import_array();      model random_network;     double* output;      output = random_network.update(input);     return array_double_to_pyobj(output);  // from pycapi_utils.h      } </code></pre>  <p>The above code is included in a <code>scipy.weave</code> module in Python with</p>  <pre><code>def model_py(input):     support_code="""                  #include "model.h"                  """     code = """            return_val = simulate(input.data());            """     libs=['gsl','gslcblas','m']     vars = ['input']     out = weave.inline(code,                        vars,                        support_code=support_code,                        sources = source_files,                        libraries=libs                        type_converters=converters.blitz,                        compiler='gcc',                        extra_compile_args=['-std=c++11'],                        force=1)  </code></pre>  <p>It fails to compile giving:</p>  <pre><code>error: int _import_array() was not declared in this scope </code></pre>  <p>Noteworthy is that if I lump into <code>pycapi_utils.h</code> also the source <code>pycapi_utils.cpp</code>, everything works fine. But I don't want to use this solution, as in practice my modules here need to be included in several other modules that also use PyObjects and need call <code>import_array()</code>.</p>  <p>I was looking to <a href="http://stackoverflow.com/questions/31971185/segfault-when-import-array-not-in-same-translation-unit">this post</a> on stack exchange, but I cannot figure out if and how to properly define the <code>#define</code> directives in my case. Also the example in that post is not exactly my case as there, <code>import_array()</code> is called within the global scope of <code>main()</code> whereas in my case <code>import_array()</code> is called within my <code>simulate</code> routine which is invoked by <code>main()</code> build by <code>scipy.weave</code>.</p>