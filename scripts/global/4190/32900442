<p>Given two large numpy arrays, one for a list of 3D points, and another for a list of transformation matrices. Assuming there is a 1 to 1 correspondence between the two lists, i'm looking for the best way to calculate the result array of each point transformed by it's corresponding matrix.</p>  <p>My solution to do this was to use slicing (see "test4" in the example code below) which worked fine with small arrays, but fails with large arrays because of how memory-wasteful my method is :)</p>  <pre><code>import numpy as np COUNT    = 100 matrix   = np.random.random_sample((3,3,))   # A single matrix matrices = np.random.random_sample((COUNT,3,3,)) # Many matrices point    = np.random.random_sample((3,))     # A single point points   = np.random.random_sample((COUNT,3,)) # Many points  # Test 1, result of a single point multiplied by a single matrix # This is as easy as it gets test1 = np.dot(point,matrix) print 'done'  # Test 2, result of a single point multiplied by many matrices # This works well and returns a transformed point for each matrix test2 = np.dot(point,matrices) print 'done'  # Test 3, result of many points multiplied by a single matrix # This works also just fine test3 = np.dot(points,matrix) print 'done'  # Test 4, this is the case i'm trying to solve. Assuming there's a 1-1 # correspondence between the point and matrix arrays, the result i want # is an array of points, where each point has been transformed by it's # corresponding matrix test4 = np.zeros((COUNT,3)) for i in xrange(COUNT):     test4[i] = np.dot(points[i],matrices[i]) print 'done'  </code></pre>  <p>With a small array, this works fine. With large arrays, (COUNT=1000000) Test #4 works but gets rather slow.</p>  <p>Is there a way to make Test #4 faster? Presuming without using a loop?</p>