<p>I am using <em>OpenCV</em> for some time and now I hit the point where I need a multiplication of this type:</p>  <blockquote>   <p>Define a matrix <code>T</code>, which contains elements of the type <code>Vec3d</code><sup>1</sup>  . Matrix <code>T</code> has the size: M X N. Matrix <code>T</code> has to be multiplied with a Vector <code>Phi</code>, which has the size: N X 1, containing <code>double</code>s as values. Each element of the result has to be the result of a matrix multiplication of both matrices.</p> </blockquote>  <p>I don't want to do a component-wise multiplication, but a "real" matrix multiplication, e.g. multiplying the first element of <code>T</code><sup>2</sup> with the first element of matrix <code>J</code>, then multiplying the second element of matrix <code>T</code><sup>3</sup> with the second element of matrix <code>J</code>. Do this until you completed the first row of <code>T</code> and then sum up the results. The result is a M X 1.</p>  <p>For example, if <code>T</code> would be a 3 X 2 matrix and <code>Phi</code> a 2 X 1 matrix, then the calculation should be <code>T_11 * phi_11 + T_12 * phi_21</code> for the first value of the result. Currently I'm using two for loops which are slow:</p>  <pre><code>for (int i = 0; i&lt;M; ++i){     cv::Mat summedResult = cv::Mat(3, 1, CV_64F, double(0));     for (uint32 j = 0; j&lt;N; ++j){         summedResult = summedResult +          (cv::Mat(mMatrixT.at&lt;cv::Vec3d&gt;(i, j)) * mMatrixPhi.at&lt;double&gt;(j));     }     // The result matrix contains values of type Vec3d again     mResultMatrix.at&lt;cv::Vec3d&gt;(i) = cv::Vec3d(summedResult); } </code></pre>  <p>More generally: Is it possible to efficiently multiply matrices containing <code>Vec3ds</code> and <code>double</code>s in OpenCV?</p>  <hr>  <p><sup>1. three dimensional vector containing doubles.</sup> </p>  <p><sup>2. coordinate: 1,1</sup>  </p>  <p><sup>3. coordinate: 1,2</sup> </p>