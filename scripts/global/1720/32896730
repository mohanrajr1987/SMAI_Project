<p>I'm running OpenCvSharp on Unity 5.2.1f, and I need to run Unity and OpenCv together. I want to do like <a href="https://www.youtube.com/watch?v=lti8qx7KqGk" rel="nofollow">this guy has done</a>. But with my own code In the description of his video is a link to the sourcecode on github.  </p>  <p>I've search all around his code and I cannot find a reason why mine isn't working. My code has over than 300 lines, and I think that the solution is pretty simple, so I might not post the code, but if needed I will</p>  <p>I think the problem is in the Cv.WaitKey()</p>  <p>Some details: Sometimes press "esc" and Unity "play button" stops the program and Unity back to live, but opencv freezes. Some other times OpenCv still running and I have to close Unity by the task bar.</p>  <p>I'm programming in C# and here is the code:</p>  <pre><code>    //imports using UnityEngine; using System.Collections; using System.Runtime.InteropServices; using System; using OpenCvSharp; using Uk.Org.Adcock.Parallel; using UnityCV; using Color = UnityEngine.Color; using System.Collections.Generic; using System.Linq; using OpenCvSharp.CPlusPlus; using OpenCvSharp.Blob; using UnityEngine.UI; using System.Diagnostics; public class Recognition : MonoBehaviour{      // HSV values     public int H_MIN = 0;     public int H_MAX = 255;     public int S_MIN = 0;     public int S_MAX = 255;     public int V_MIN = 0;     public int V_MAX = 255;     public int Y_MIN = 0;     public int Y_MAX = 255;     public int Cr_MIN = 0;     public int Cr_MAX = 255;     public int Cb_MIN = 0;     public int Cb_MAX = 255;     //Size     public CvSize kSize;     public CvSize imSize;     public CvScalar cvfrom, cvto;     //Helpers     public bool Run;     public bool CaptureWebcam;     public bool ShowWebcam;     public bool ConvertAll;     public bool ShowBlur;     public bool ShowHue;     public bool ShowBw;     public bool ShowErode;     public bool ShowDilate;     public bool doublebool;     public bool ShowHull;     public bool ShowDefects;     public GameObject target;     public Vector2 ColorPosition;     public double  HandX;     public float HandY;     public double centralMoment;     public double centralMoment2;     public bool takePhoto;     void Start()     {         takePhoto = true;       }     void Update()     {         //ConvexityDefects();       }        void Awake()     {         if(Cv.WaitKey(10) == 27)         {             Cv.WaitKey(0);             Cv.DestroyAllWindows();          }         if(Run){             using (CvMemStorage storage = Cv.CreateMemStorage(0)){             using (CvCapture cap = CvCapture.FromCamera(0)){             while(CvWindow.WaitKey(1) &lt; 0){             using (IplImage src = cap.QueryFrame()){               //Face Detect values             CvColor[] colors = new CvColor[]{                 new CvColor(0,0,255),                 new CvColor(0,128,255),                 new CvColor(0,255,255),                 new CvColor(0,255,0),                 new CvColor(255,128,0),                 new CvColor(255,255,0),                 new CvColor(255,0,0),                 new CvColor(255,0,255),             };              const double Scale = 1.14;             const double ScaleFactor = 1.0850;             const int MinNeighbors = 2;              IplImage dst;             dst = Cv.CreateImage (Cv.Size(640,420),BitDepth.U8,3);              Cv.Resize(src,dst);             //dst.SaveImage("C:\\Users\\Matias Marques\\Desktop\\iplImage.jpg");              CvScalar lowerLimitHSV = new CvScalar(H_MIN, S_MIN, V_MIN);             CvScalar upperLimitHSV = new CvScalar (H_MAX, S_MAX, V_MAX);              CvScalar lowerLimitYCrCb = new CvScalar(Y_MIN, Cr_MIN, Cb_MIN);             CvScalar upperLimitYCrCb = new CvScalar (Y_MAX, Cr_MAX, Cb_MAX);               IplImage frame2 = new IplImage (Cv.GetSize(dst), BitDepth.U8,3);             IplImage framehue = new IplImage (Cv.GetSize(dst), BitDepth.U8,3);             IplImage frameYCrCb = new IplImage (Cv.GetSize(dst), BitDepth.U8,3);             Cv.Smooth(dst,frame2, SmoothType.Gaussian);             Cv.CvtColor(dst,frameYCrCb,ColorConversion.BgrToCrCb);             Cv.CvtColor (dst, framehue, ColorConversion.BgrToHsv);              IplImage bw;             IplImage bw2;             IplImage bw3;             IplImage erode;             IplImage dilate;             IplImage hullImg;             IplImage imgDefect;             bw = Cv.CreateImage(Cv.GetSize(dst), BitDepth.U8,1);             bw2 = Cv.CreateImage(Cv.GetSize(dst), BitDepth.U8,1);             bw3 = Cv.CreateImage(Cv.GetSize(dst), BitDepth.U8,1);             erode = Cv.CreateImage(Cv.GetSize(dst), BitDepth.U8,1);             dilate = Cv.CreateImage(Cv.GetSize(dst), BitDepth.U8,1);             hullImg = Cv.CreateImage(Cv.GetSize(dst), BitDepth.U8,1);             imgDefect = Cv.CreateImage(Cv.GetSize(dst), BitDepth.U8,1);               Cv.InRangeS(framehue,lowerLimitHSV,upperLimitHSV,bw);             Cv.InRangeS(frameYCrCb,lowerLimitYCrCb,upperLimitYCrCb,bw2);             Cv.Erode(bw2,erode);             Cv.Dilate(erode,dilate);             //X and Y pos             CvMoments moments;             Cv.Moments(dilate, out moments, true);              var moment10 = Cv.GetSpatialMoment(moments, 1, 0);             var moment01 = Cv.GetSpatialMoment(moments, 0, 1);             var area = Cv.GetSpatialMoment(moments, 0, 0);             ColorPosition = new Vector2((float)(moment10 / area), (float)(moment01 / area));             ColorPosition.Scale(new Vector2((float)Screen.width / dst.Width,                                                             (float)Screen.height / dst.Height));              ColorPosition -= new Vector2(Screen.width, Screen.height) * .5f;               using (CvFont font = new CvFont(FontFace.HersheySimplex, 1.0, 1.0, 0, 2, LineType.Link8))             {                 string[] text = new string[2];                 text[0] = string.Format("spatial={0:F3}", ColorPosition.x);                 text[1] = string.Format("spatial={0:F3}", ColorPosition.y);                 CvSize textSize = font.GetTextSize(text[0]);                 for (int i = 0; i &lt; 2; i++)                 {                 //src.PutText(text[i], new CvPoint(10, (textSize.Height + 3) * (i + 1)), font, CvColor.Red);                 }             }              CvSeq&lt;CvPoint&gt; contours = FindContours(dilate,storage);             if(contours!= null)             {             //Cv.DrawContours(frame2,contours,CvColor.Red,CvColor.Green,8,8,LineType.AntiAlias);             //Find contours hulls             int[] hull;             Cv.ConvexHull2(contours,out hull,ConvexHullOrientation.Clockwise);             Cv.Copy(dilate,hullImg);              //Get Convexity Defect             Cv.Copy (dilate,imgDefect);             CvSeq&lt;CvConvexityDefect&gt; defect = Cv.ConvexityDefects(contours,hull);             //DrawDefects(frame2,defect);             }              //FaceDetect (Doesnt't work)             using (IplImage webgray = new IplImage(dst.Size, BitDepth.U8, 1))             {             Cv.CvtColor (dst,webgray,ColorConversion.BgrToGray);             using (var cascade = CvHaarClassifierCascade.FromFile ("C:\\Users\\Matias Marques\\Desktop\\haarcascade_frontalface_default.xml"))             {             CvSeq&lt;CvAvgComp&gt;faces = Cv.HaarDetectObjects(webgray,cascade,storage,ScaleFactor,MinNeighbors,0, new CvSize(30,30));             for (int i = 0;i &lt; faces.Total; i++ )             {             CvRect r = faces[i].Value.Rect;             CvPoint center = new CvPoint              {             X = Cv.Round((r.X + r.Width * 0.5) * Scale),             Y = Cv.Round((r.Y + r.Height * 0.5) * Scale)             };             int Radius = Cv.Round((r.Width + r.Height) * 0.25 * Scale);             src.Circle (center,Radius,colors[i%8],3,LineType.AntiAlias,0);              }         }          if(ShowBlur)             Cv.ShowImage("Blur", frame2);         if(ShowHue){                 Cv.ShowImage("Gray",webgray );             Cv.ShowImage("HSV", framehue);             Cv.ShowImage ("YcrCb", frameYCrCb);                          }         if(ShowBw)         {             Cv.ShowImage("Thres", bw);             Cv.ShowImage("Thres2", bw2);         }         if(ShowErode)             Cv.ShowImage("Erode", erode);         if(ShowDilate)             Cv.ShowImage("Dilate", dilate);         if(ShowWebcam)             Cv.ShowImage("Webcam",src);          if(ShowHull)             Cv.ShowImage("Hull",hullImg);            if(ShowDefects){             Cv.ShowImage("Defect",imgDefect);                                        }                             }                         }                     }                 }             }         }     }    //My private functions private CvSeq&lt;CvPoint&gt; FindContours(IplImage img, CvMemStorage storage)     {         CvSeq&lt;CvPoint&gt; contours;         using (IplImage imgClone = img.Clone())         {             Cv.FindContours(imgClone,storage,out contours);             if(contours == null)             {                 return null;             }             contours = Cv.ApproxPoly(contours, CvContour.SizeOf, storage, ApproxPolyMethod.DP, 3, true);         }         CvSeq&lt;CvPoint&gt; max = contours;         for (CvSeq&lt;CvPoint&gt; c = contours; c!= null; c = c.HNext)         {             if(max.Total &lt; c.Total)             {                 max = c;             }         }         return max;      }     private void DrawConvexHull(CvSeq&lt;CvPoint&gt; contours,int[] hull, IplImage img)     {         CvPoint pt0 = contours[hull.Last()].Value;         foreach (int idx in hull)         {             CvPoint pt = contours[idx].Value;             Cv.Line(img,pt0,pt,new CvColor(255,255,255));             pt0 = pt;         }     }     private void DrawDefects (IplImage img,CvSeq&lt;CvConvexityDefect&gt; defect)     {         int count = 0;         foreach (CvConvexityDefect item in defect)         {             CvPoint p1 = item.Start, p2 = item.End;             //double dist = GetDistance(p1,p2);             CvPoint2D64f mid = GetMidPoint(p1,p2);             img.DrawLine(p1,p2,CvColor.White,3);             img.DrawCircle(item.DepthPoint,10,CvColor.Green,-1);             img.DrawLine(mid,item.DepthPoint,CvColor.White,1);             count++;          }     }     private double GetDistance(CvPoint p1, CvPoint p2)     {         return Math.Sqrt(Math.Pow(p1.X - p2.X,2)+ Math.Pow(p1.Y - p2.Y,2));      }     private CvPoint2D64f GetMidPoint(CvPoint p1,CvPoint p2)     {         return new CvPoint2D64f         {             X = (p1.X + p2.X) / 2.0,             Y = (p1.Y + p2.Y) / 2.0         };      }    } </code></pre>  <p>And the guy, who I'm talking about code:</p>  <pre><code>using System.Collections; using OpenCvSharp; using Uk.Org.Adcock.Parallel; using UnityCV; using UnityEngine; using Color = UnityEngine.Color;  // ReSharper disable once CheckNamespace public class UnityCvTest : MonoBehaviour {      public BitDepth ImagesDepth = BitDepth.U8;     public Color ThreshFromColor, ThreshToColor;     public bool UpdateColorsEachFrame;     public bool ShowThresholdedImage;     public Renderer TargetRenderer;      public int RequestedWidth;     public int RequestedHeight;     public int RequestedFps;      public Vector2 ColorPosition;     private CvScalar _cvScalarFrom, _cvScalarTo;      public GameObject FollowerPrefab;     private Transform _dummyTransform;      private IplImage _scribbleImage;     private Vector3 _smoothVel;     public float SmoothTime;      private IplImage GetThresholdedImage(IplImage img, CvScalar from, CvScalar to)     {         var imgHsv = Cv.CreateImage(Cv.GetSize(img), ImagesDepth, 3);         Cv.CvtColor(img, imgHsv, ColorConversion.BgrToHsv);         var imgThreshed = Cv.CreateImage(Cv.GetSize(img), ImagesDepth, 1);         Cv.InRangeS(imgHsv, from, to, imgThreshed);         Cv.ReleaseImage(imgHsv);         if (ShowThresholdedImage) Cv.ShowImage("Threshold", imgThreshed);         return imgThreshed;     }      public void Awake()     {         UnityCvBase.Init(WebCamTexture.devices[0].name, RequestedWidth, RequestedHeight, RequestedFps, ImagesDepth);         TargetRenderer.sharedMaterial.mainTexture = UnityCvBase.WebCamTexture;          Camera.main.orthographicSize = Screen.height / 2f;         var tr = TargetRenderer.transform;         tr.localScale = new Vector3(Screen.width, Screen.height);          _cvScalarFrom = UnityCvUtils.ColorToBGRScalar(ThreshFromColor);         _cvScalarTo = UnityCvUtils.ColorToBGRScalar(ThreshToColor);          if (FollowerPrefab) _dummyTransform = ((GameObject)Instantiate(FollowerPrefab)).transform;          if (ShowThresholdedImage) Cv.NamedWindow("Threshold", WindowMode.FreeRatio);          WebCamTextureProxy.OnFrameReady += Process;     }      public void Process(IplImage frame)     {         if (UpdateColorsEachFrame)         {             _cvScalarFrom = UnityCvUtils.ColorToBGRScalar(ThreshFromColor);             _cvScalarTo = UnityCvUtils.ColorToBGRScalar(ThreshToColor);         }          var imgThresh = GetThresholdedImage(frame, _cvScalarFrom, _cvScalarTo);          CvMoments moments;         Cv.Moments(imgThresh, out moments, true);          var moment10 = Cv.GetSpatialMoment(moments, 1, 0);         var moment01 = Cv.GetSpatialMoment(moments, 0, 1);         var area = Cv.GetSpatialMoment(moments, 0, 0);         ColorPosition = new Vector2((float)(moment10 / area), (float)(moment01 / area));         ColorPosition.Scale(new Vector2((float)Screen.width / frame.Width,            (float)Screen.height / frame.Height));          ColorPosition -= new Vector2(Screen.width, Screen.height) * .5f;          Cv.ReleaseImage(imgThresh);     }      public void OnDestroy()     {         WebCamTextureProxy.OnFrameReady -= Process;         Cv.DestroyAllWindows();         TargetRenderer.sharedMaterial.mainTexture = null;     }      public void Update()     {         if (ColorPosition.magnitude &gt; 0 &amp;&amp; _dummyTransform != null)             _dummyTransform.position = Vector3.SmoothDamp(_dummyTransform.position, new Vector3(ColorPosition.x, ColorPosition.y), ref _smoothVel, SmoothTime);     }  } </code></pre>