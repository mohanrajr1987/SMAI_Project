<p>As I'm not sure I'm able to name/formulate everything precisely, so I would use a naive example. Let's have following:</p>  <pre><code>class Base&lt;T&gt; {     ... }  /*  * Please note the Derived is not generic, only derives from generic class  */ class Derived : Base&lt;SomeType&gt; {     /*      * Here, I would like to use SomeType's "generic name" (like the T in the Base),       * so it might look like:      */     Base.T field1; // This would translate to 'SomeType field1' for this particular case     ... } </code></pre>  <p>Is there any method in <code>C#</code> syntax how to access the <code>Base.T</code>?</p>  <p><em>Of course I'm aware of the fact that if we make the <code>Derived</code> also generic, we can pass its type parameter to the <code>Base</code> and use it in <code>Derived</code>.</em></p>  <p><strong>EDIT:</strong><br> Please consider this as a theoretical question, where I would like to determine, if there is a <code>C#</code> syntax way to reach the symbolic type names used for "templatization" in the base class. The initial motivation might be: If the developer modifies the <code>Derived</code> class the way he replaces <code>Base&lt;SomeType&gt;</code> by <code>Base&lt;OtherType&gt;</code>, he also needs to replace this in all occurences within the <code>Derived</code> body. For the cases, the <code>SomeType</code> is compatible to <code>OtherType</code> and there is also a symbolic name available (like the Base.T), there is no other work do to. (Yes, I know, we have automatic refactoring tools... Just a question...)</p>