<p>Consider the following class hierarchy in Swift:</p>  <p><a href="http://i.stack.imgur.com/hnJVR.png" rel="nofollow"><img src="http://i.stack.imgur.com/hnJVR.png" alt="Class Hierarchy"></a></p>  <p>GMSMarker is a class provided by the GoogleMaps library. It has two public initializers (one designated, one convenience).</p>  <p>MapItem, ClusterItem and Cluster are part of my model. I don't want to allow construction of MapItem objects; only ClusterItems and Clusters. Since Swift doesn't have abstract classes, having a private initializer would be sufficient for my purposes. However, given that MapItem inherits from GMSMarker with a convenience constructor, I can't simply override the designated initializer as private.</p>  <p>Given the rules of initializer inheritance in Swift, the only way that I've been able to prevent construction of the MapItem class is by declaring a new private initializer with a different signature so that the base class initializers aren't inherited.</p>  <pre><code>class MapItem : GMSMarker {      private init(dummyParam: Int) {         super.init()     } } </code></pre>  <p>So far so good. Now, when trying to create my initializer for the ClusterItem class, I run into a problem.</p>  <pre><code>class ClusterItem : MapItem {      weak var post: Post?      init(post: Post) {         self.post = post         super.init(dummyParam: 0)     } } </code></pre>  <p>I receive the following compiler error on the line that calls the super.init(): <code>'MapItem' does not have a member named 'init'</code>.</p>  <p>If I omit the call to super.init, I receive the following error: <code>Super.init isn't called before returning from initializer</code>.</p>  <p>Is there any way of accomplishing what I want in swift. I would like to keep the inheritance hierarchy as is if possible because MapItem contains some common implementation code for ClusterItem and Cluster. Furthermore, I would like to be able to reference both ClusterItems and Clusters using a collection of MapItems.</p>