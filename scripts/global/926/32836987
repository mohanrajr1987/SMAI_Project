<p>I discovered something strange, which I didn't expect to work, actually works. I can access a subclass' (constant) property from the base class' constructor:</p>  <pre><code>public abstract class Parent {    public Parent() {     var constName = ConstName;            // &lt;-- surprisingly, this works       var randomName = RandomName;          // &lt;-- surprisingly, this works     }    public abstract string ConstName { get; }    public abstract string RandomName { get; }  }   public class Child : Parent {    public override string ConstName { get { return "Mike"; } }    public override string RandomName { get { return new Random().Next().ToString(); } }  } </code></pre>  <p><code>Name</code> is a non-static <em>property</em> rather than field. I always thought a type's initializers (for <code>static</code> and <code>const</code> fields) were executed, then those of its base class, then the base ctor and then the subclass' ctor. <em>Which means that the child is not fully constructed yet while in the parent ctor.</em></p>  <p>Is this "legal" C# which will work under all circumstances? Why does this work?</p>  <p>EDIT:</p>  <p>No it's not a dupe question. That one doesn't have the class schema in my question.</p>