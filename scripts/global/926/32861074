<p>From what I understand, the <code>total_ordering</code> decorator from <code>functools</code> is not expected to work nicely with classes inherited from an ordered class: it doesn't try to define the comparison functions because they are already defined.</p>  <p>See this example:</p>  <pre><code>from functools import total_ordering from collections import namedtuple  Test = namedtuple('Test',['a','b'])  @total_ordering class TestOrd(Test):     def __lt__(self,other):         return self.b &lt; other.b or self.b == other.b and self.a &lt; other.a  x = TestOrd(a=1,b=2) y = TestOrd(a=2,b=1) print(x &lt; y)   # Expected: False print(x &lt;= y)  #           False print(x &gt; y)   #           True print(x &gt;= y)  #           True print(y &lt; x)   #           True print(y &lt;= x)  #           True print(y &gt; x)   #           False print(y &gt;= x)  #           False </code></pre>  <p>Of all the tests, only the ones involving the <code>&lt;</code> operator give the expected result.</p>  <p>I can get the <code>&gt;</code> ones to work as well by adding <code>__gt__ = lambda *_ : NotImplemented</code> to the class definition. On the other hand, if I add similar definitions for <code>__le__</code> or <code>__ge__</code>, the corresponding tests fail with (for <code>__le__</code>):</p>  <pre><code>TypeError: unorderable types: TestOrd() &lt;= TestOrd() </code></pre>  <p>which leads me to believe that this is not the proper way to address the problem.</p>  <p>Hence the question: <strong>is there a proper way to reorder a class with total_ordering?</strong></p>  <p>(Yes, I know that doing <code>total_ordering</code>'s job by hand is trivial, and I know that for this example, defining an unordered <code>namedtuple</code> is trivial too.)</p>