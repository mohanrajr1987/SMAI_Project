<p>I'm trying to build a generics system that allows me to make subclasses that can call statics which exist on the abstract superclass that return the subclass' type. So far, this works:</p>  <pre><code>public abstract class GenericsTest&lt;T extends GenericsTest&lt;T&gt;&gt; {      @SuppressWarnings("unchecked")     protected T createT() {         try {             Type supe = getClass().getGenericSuperclass();             Type t = ((ParameterizedType) supe).getActualTypeArguments()[0];             // This means that the type needs a default constructor.             // Sadly there is no real way to enforce this in java.             return (T) (Class.forName(t.toString()).newInstance());         } catch (Exception e) {             return null;         }     }      public static &lt;T extends GenericsTest&lt;T&gt;&gt; T fetch(int key) {         GenericsTest&lt;T&gt; obj = new GenericsTest&lt;T&gt;() {};         T ret = obj.createT();         // do stuff here to actually fetch/fill the object         return ret;     } } </code></pre>  <p>Now, by defining the implementing class as</p>  <pre><code>public class GenericsTestImpl extends GenericsTest&lt;GenericsTestImpl&gt; </code></pre>  <p>I can call <code>GenericsTestImpl coolstuff = GenericsTestImpl.fetch(k);</code>, which is pretty cool.</p>  <p>However... when I add a second generic type parameter, changing the final type definition to <code>&lt;T extends GenericsTest&lt;T, E&gt;, E&gt;</code> the whole system fails, for some bizarre reason. The original superclass has no problems, but the actual call to fetch() says that the types don't match:</p>  <pre><code>// Bound mismatch: The generic method fetch(int) of type GenericsTest&lt;T,E&gt; // is not applicable for the arguments (int). The inferred type // GenericsTestImpl&amp;GenericsTest&lt;GenericsTestImpl&amp;GenericsTest&lt;T,E&gt;,Object&gt; // is not a valid substitute for the bounded parameter &lt;T extends GenericsTest&lt;T,E&gt;&gt; </code></pre>  <p>(added as commented code because the markup swallows &lt;> stuff)</p>  <p>New code:</p>  <pre><code>public abstract class GenericsTest&lt;T extends GenericsTest&lt;T, E&gt;, E&gt; {      @SuppressWarnings("unchecked")     protected T createT() {         try {             Type supe = getClass().getGenericSuperclass();             Type t = ((ParameterizedType) supe).getActualTypeArguments()[0];             // This means that the type needs a default constructor.             // Sadly there is no real way to enforce this in java.             return (T) (Class.forName(t.toString()).newInstance());         } catch (Exception e) {             return null;         }     }      public static &lt;T extends GenericsTest&lt;T, E&gt;, E&gt; T fetch(int key) {         GenericsTest&lt;T, E&gt; obj = new GenericsTest&lt;T, E&gt;() {};         T ret = obj.createT();         // do stuff here to actually fetch/fill the object         return ret;     } } </code></pre>  <p>And the implementation:</p>  <pre><code>public class GenericsTestImpl extends GenericsTest&lt;GenericsTestImpl, String&gt; </code></pre>  <p>Does anyone have any idea why the additional type messes it up? As far as I can see, that does match.</p>