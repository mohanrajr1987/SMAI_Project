<p>I've never seen this happen before: I've decorated a controller with an <code>[Authorize (Roles = "Admin"]</code>attribute, but instead of sending unregistered/un-signed users to the Login View via 302 redirect, a javascript-generated sign-in prompt appears in the Chrome browser:</p>  <p><a href="http://i.stack.imgur.com/jkNmq.png" rel="nofollow"><img src="http://i.stack.imgur.com/jkNmq.png" alt="enter image description here"></a></p>  <p>After entering in his or her credentials, the user is then given a 401 error. The suggestions on SO for <a href="http://stackoverflow.com/questions/27421703/asp-net-mvc-5-wrong-redirect-login-page">setting the <code>&lt;authentication mode&gt;</code></a> and <a href="http://stackoverflow.com/questions/21652808/asp-net-mvc-5-web-config-formsauthenticationmodule-or-formsauthentication?lq=1">removing the <code>&lt;FormsAuthenticationModule&gt;</code></a> in Web.Config don't alter this behavior. I have previously created another project using the exact same controllers, reference libraries, etc. and never encountered this undesired behavior.</p>  <p>The big blind spot for me right now is whether there is some sort of OWIN conflict going on. To observe my app's behavior at startup, I created a test variable inside <code>app.UseCookieAuthentication()</code> method and set a breakpoint. I observed during debug that this method wasn't being called at all (see full code block below):</p>  <pre><code> app.UseCookieAuthentication(new CookieAuthenticationOptions         {             AuthenticationType = DefaultAuthenticationTypes.ApplicationCookie,             LoginPath = new PathString("/Account/Login"),             Provider = new CookieAuthenticationProvider             {                 // Enables the application to validate the security stamp when the user logs in.                 // This is a security feature which is used when you change a password or add an external login to your account.                   OnValidateIdentity = SecurityStampValidator.OnValidateIdentity&lt;ApplicationUserManager, ApplicationUser&gt;(                     validateInterval: TimeSpan.FromMinutes(30),                     regenerateIdentity: (manager, user) =&gt; user.GenerateUserIdentityAsync(manager)),                 OnApplyRedirect = ctx =&gt;                 {                     var t = 2;                 }             }         }); </code></pre>  <p>To provide more clarity here's the decorated controller with the uncooperative <code>[Authorize]</code> attribute.</p>  <pre><code>    [Authorize(Roles = "Admin")]     public ActionResult BlogPostsAdmin()     {         return View(db.BlogPosts.ToList());     } </code></pre>  <p>Here's the AccountController that is supposed to return the Login View:</p>  <pre><code> [AllowAnonymous]     public ActionResult Login(string returnUrl)     {         ViewBag.ReturnUrl = returnUrl;         return View();     } </code></pre>  <p>Any help?</p>  <p><strong>UPDATE:</strong> I am just going to hack together a custom authorize attribute from now, though this is not desirable for production:</p>  <pre><code>using System; using System.Collections.Generic; using System.Linq; using System.Web; using System.Web.Mvc;  namespace PortfolioSite.Framework {      public class SiteAuthorizeAttribute : AuthorizeAttribute     {         protected override void HandleUnauthorizedRequest(AuthorizationContext filterContext)         {             base.HandleUnauthorizedRequest(filterContext);              filterContext.HttpContext.Response.Redirect("/Account/Login");         }     } } </code></pre>