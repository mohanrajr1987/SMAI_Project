<p>Below you can see a simplified version of my SignalR self hosted hub on a windows service:</p>  <pre><code>public static class SubscriptionHandler {     public static int PriceFeedMembersCount = 0; }  public class PriceHub : Hub {     public Task SubscribeToPriceFeed()     {         IHubContext context = GlobalHost.ConnectionManager.GetHubContext&lt;PriceHub&gt;();         if (SubscriptionHandler.PriceFeedMembersCount == 0)         {             context.Clients.All.updatePriceSubscriptionStatus(true);         }         SubscriptionHandler.PriceFeedMembersCount++;         return context.Groups.Add(Context.ConnectionId, "PriceFeed");     }      public Task UnsubscribeFromPriceFeed()     {         IHubContext context = GlobalHost.ConnectionManager.GetHubContext&lt;PriceHub&gt;();         SubscriptionHandler.PriceFeedMembersCount--;         if (SubscriptionHandler.PriceFeedMembersCount == 0)         {             context.Clients.All.updatePriceSubscriptionStatus(false);         }         return context.Groups.Remove(Context.ConnectionId, "PriceFeed");     }      public void NotifySubscribers(Price price)     {         IHubContext context = GlobalHost.ConnectionManager.GetHubContext&lt;PriceHub&gt;();         context.Clients.Group("PriceFeed").updatePrice(price);     } } </code></pre>  <p>And I have two types of clients for that hub: One of them is web applications and the other one is windows services. Here you can see a demo implementation for my windows service as a signalr client:</p>  <pre><code>public partial class WinSer45 : ServiceBase {     private HubConnection hubConnection;     private IHubProxy priceProxy;     private Timer timer = new Timer();     private bool hasSubscribers = false;      public WinSer45()     {         InitializeComponent();     }      protected override void OnStart(string[] args)     {         timer.Interval = 1000; // saniyede bir         timer.Elapsed += timer_Elapsed;         timer.Enabled = true;          hubConnection = new HubConnection("http://localhost:8080/signalr", useDefaultUrl: false);         priceProxy = hubConnection.CreateHubProxy("PriceHub");         hubConnection.Start().Wait();         priceProxy.On&lt;bool&gt;("UpdatePriceSubscriptionStatus", hasSubscribers =&gt;         {             this.hasSubscribers = hasSubscribers;         });     }      void timer_Elapsed(object sender, ElapsedEventArgs e)     {            if (hasSubscribers)         {             TestPrice testPrice = new TestPrice() { Id = 1, Buy = 1.2345, Sell = 9.8765, Symbol = "EURUSD" };             priceProxy.Invoke("NotifySubscribers", testPrice).Wait();             }     }         protected override void OnStop()     {     } } </code></pre>  <p>As you see I use the <strong>hasSubscribers</strong> flag to minimize the messages between hub and clients. And hasSubscribers flag is changed by <strong>SubscribeToPriceFeed</strong>  and <strong>UnsubscribeFromPriceFeed</strong> methods. </p>  <p>If you look carefully you see the line below in SubscribeToPriceFeed:</p>  <blockquote>   <p>context.Clients.All.updatePriceSubscriptionStatus(true);</p> </blockquote>  <p>I don't want to send the message to all clients but my client windows service. How can I store the connection Id of a specific client in my hub? If I can do that, I know I can send message to a specific connectionId as in the line below:</p>  <blockquote>   <p>context.Clients.Client(connectionId).updatePriceSubscriptionStatus(true);</p> </blockquote>  <p>Thanks in advance,</p>