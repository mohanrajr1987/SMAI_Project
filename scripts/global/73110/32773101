<p>I have written a simple 'analytics' tracking tool for my site, which has boolean columns such as</p>  <p><code>Visited_Store</code> <code>Visited_Homepage</code> <code>Checkout_Started</code> <code>MainVideo_Played</code>  <code>MainVideo_Completed</code></p>  <p>I am also using Google Analytics but wanted a secondary place to montor activity.</p>  <hr>  <p>I had been testing my application primarily in Chrome which of course will use  web sockets by default. I switched to long polling because I wanted to be able to monitor the requests in Fiddler.</p>  <p>The way the hub works is pretty simple. The SignalR client sends events which sets flags (columns) when a particular event has completed. So on invocation it does the following :</p>  <ul> <li>Find row for user - or create if non existent</li> <li>Set flags</li> <li>Save row</li> </ul>  <p>I had no concurrency issues until I switched to long polling - when I found instant deadlocks.</p>  <p>My client will often send multiple events simultaneously (separate issue to fix - yes) and when using web sockets they are nicely queued and executed one by one. So obviously any deadlocks are going to be extremely unlikely.</p>  <p>Long polling is a different story - I suddenly found that my hub method was being entered multiple times and trying to create multiple rows, and deadlocks and 'row modified' errors all over the place.</p>  <p>One simple solution is just to <code>lock(lockObj)</code> when making a request, but if I have many clients I'd rather not do that. Another is to catch the deadlock and re-execute the request which right now occurs on just about every page load.</p>  <p>Is there perhaps a way to configure SignalR long polling to <strong>not</strong> send requests all at once? Or some other way to execute requests in turn (like ASP.NET does when you use SessionState).</p>