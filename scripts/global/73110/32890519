<p>We're running a windows console app that's sending SignalR messages to multiple browsers through the SignalR backplane. We're doing this by hosting a SignalR server using OWN.WebApp:</p>  <pre><code>public class SignalRWebApp : IDisposable {     public readonly string signalRUrl;     private IDisposable webApp;      public SignalRWebApp()     {         this.signalRUrl = String.Format("http://localhost:{0}", getFreePort());         this.webApp = null;     }      private static int getFreePort()     {         var listener = new TcpListener(IPAddress.Loopback, 0);         listener.Start();         var port = ((IPEndPoint) listener.LocalEndpoint).Port;         listener.Stop();         return port;     }      public bool started { get { return this.webApp != null; } }     public void start(string signalRBackplaneConnectionString)     {         if (this.webApp != null)             return;          Action&lt;IAppBuilder&gt; startAction = app =&gt;         {             app.UseCors(CorsOptions.AllowAll);             GlobalHost.DependencyResolver.UseSqlServer(signalRBackplaneConnectionString);             app.MapSignalR();         };          this.webApp = WebApp.Start(this.signalRUrl, startAction);     }      #region IDisposable      public void Dispose()     {         this.dispose(true);         GC.SuppressFinalize(this);     }      ~SignalRWebApp()     {         this.dispose(false);     }      private bool alreadyDisposed;      protected virtual void dispose(bool disposing)     {         if (!this.alreadyDisposed)         {             if (disposing)             {                 // dispose managed objects                 if (this.webApp != null)                 {                     this.webApp.Dispose();                     this.webApp = null;                 }             }              // free unmanaged objects             // set large fields to null.              this.alreadyDisposed = true;         }     }      #endregion } </code></pre>  <p>Basically, we create a SignalRWebApp object, then call start(), passing it the connection string to the SqlServer backplane database. OWIN fires up a website in a background thread, and our code communicates with it through the signalRUrl (which is localhost with a dynamically allocated port number).</p>  <p>My problem: this is working in our dev and QA environments, but in our demo environment it's crashing without explanation.</p>  <p>I'm going through and trying to make sure that we at least catch and log any exception that might happen. And here's the thing - I can't see how to catch and log any exceptions that the OWIN WebApp might be throwing.</p>  <p>Any ideas?</p>