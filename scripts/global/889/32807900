<p>I'm making Othello game. Nearly all is coded, and i need to run the program. But, there's error C2228. I don't know why this error has been occured. At my code, which line is problem?</p>  <p>This is API code.</p>  <pre><code>#include "Basic.h" #include "Othello.h" #include "resource.h"  LRESULT CALLBACK WndProc ( HWND , UINT , WPARAM , LPARAM ) ; HINSTANCE g_hInst ; LPCWSTR lpszClass = TEXT ( "First" ) ;  //Tile tile () ;  int APIENTRY WinMain ( HINSTANCE hInstance , HINSTANCE hPrevInstance                       , LPSTR lpszCmdParam , int nCmdShow ) {     HWND hWnd ;     MSG Message ;     WNDCLASS WndClass ;     g_hInst = hInstance ;      WndClass.cbClsExtra = 0 ;     WndClass.cbWndExtra = 0 ;     WndClass.hbrBackground = ( HBRUSH ) GetStockObject ( WHITE_BRUSH ) ;     WndClass.hCursor = LoadCursor ( NULL , IDC_ARROW ) ;     WndClass.hIcon = LoadIcon ( NULL , IDI_APPLICATION ) ;     WndClass.hInstance = hInstance ;     WndClass.lpfnWndProc = ( WNDPROC)WndProc ;     WndClass.lpszClassName = lpszClass ;     WndClass.lpszMenuName = NULL ;     WndClass.style = CS_HREDRAW | CS_VREDRAW ;     RegisterClass ( &amp;WndClass ) ;      hWnd = CreateWindow ( lpszClass , lpszClass , WS_OVERLAPPEDWINDOW ,         CW_USEDEFAULT , CW_USEDEFAULT , CW_USEDEFAULT , CW_USEDEFAULT ,         NULL , ( HMENU ) NULL , hInstance , NULL ) ;     ShowWindow ( hWnd , nCmdShow ) ;      while ( GetMessage ( &amp;Message , 0 , 0 , 0 ) )     {         TranslateMessage ( &amp;Message ) ;         DispatchMessage ( &amp;Message ) ;     }     return Message.wParam ; }  LRESULT CALLBACK WndProc ( HWND hWnd , UINT iMessage , WPARAM wParam , LPARAM lParam ) {     HDC hdc , hMemdc [ 3 ] ;     PAINTSTRUCT ps ;     HBITMAP hEmpty , hBlack , hGray ;     BITMAP bit ;     Tile tile () ;      switch(iMessage)     {     case WM_LBUTTONDOWN :         break ;      case WM_PAINT :          hdc = BeginPaint ( hWnd , &amp;ps ) ;          for ( int i = 0 ; i &lt; 3 ; ++i )         {             hMemdc [ i ] = CreateCompatibleDC ( hdc ) ;         }          hEmpty = LoadBitmap ( g_hInst , MAKEINTRESOURCE ( IDB_BITMAP1 ) ) ;         hBlack = LoadBitmap ( g_hInst , MAKEINTRESOURCE ( IDB_BITMAP2 ) ) ;         hGray = LoadBitmap ( g_hInst , MAKEINTRESOURCE ( IDB_BITMAP3 ) ) ;          SelectObject ( hMemdc [ 0 ] , hEmpty ) ;         SelectObject ( hMemdc [ 1 ] , hBlack ) ;         SelectObject ( hMemdc [ 2 ] , hGray ) ;          for ( int j = 0 ; j &lt; 10 ; ++j )         {             for ( int i = 0 ; i &lt; 10 ; ++i )             {                 BitBlt ( hdc , 50 * i , 50 * j , 50 , 50 , hMemdc [ tile . iTileinfo ( i , j ) ] , 0 , 0 , SRCCOPY ) ;             }         }          BitBlt ( hdc , 550 , 250 , 50 , 50 , hMemdc [ 2 - ( tile . bTurninfo () ) ] , 0 , 0 , SRCCOPY ) ;          DeleteObject ( hEmpty ) ;         DeleteDC ( hMemdc [ 0 ] ) ;         DeleteObject ( hBlack ) ;         DeleteDC ( hMemdc [ 1 ] ) ;         DeleteObject ( hGray ) ;         DeleteDC ( hMemdc [ 2 ] ) ;          EndPaint ( hWnd , &amp;ps ) ;          break ;      case WM_DESTROY :         PostQuitMessage ( 0 ) ;         return 0 ;     }     return ( DefWindowProc ( hWnd , iMessage , wParam , lParam ) ) ; } </code></pre>  <p>And this is class code.</p>  <pre><code>#include "Othello.h"  Tile :: Tile () {     aryRemover = new Remover [ 8 ] ;      for ( int i = 0 ; i &lt; 8 ; ++i )     {         aryRemover [ i ] . iDirection = 0 ;         aryRemover [ i ] . iNum = 0 ;     }      for ( int i = 0 ; i &lt; 10 ; ++i )     {         for ( int j = 0 ; j &lt; 10 ; ++j )         {             iAry [ i ] [ j ] = 0 ;         }     }      iAry [ 4 ] [ 4 ] = 1 ;     iAry [ 4 ] [ 5 ] = 2 ;     iAry [ 5 ] [ 4 ] = 2 ;     iAry [ 5 ] [ 5 ] = 1 ;      bTurn = false ;     iCount = 0 ; }  Tile :: ~ Tile () {     delete [] aryRemover ; }  void Tile :: Possible ( int iX , int iY ) {     if ( bTurn ) // Player 1     {     long code     }      else // Player 2     {     long code     } }  void Tile :: Change ( int iX , int iY ) {     if ( bTurn ) // Player 1     {         for ( int i = 0 ; i &lt; iCount ; ++i )         {             switch ( aryRemover [ i ] . iDirection )             {             case 0 :                 long code             default :                 break ;             }          }          bTurn = false ; // Turn Player 2         iCount = 0 ;     }      else // Player 2     {         for ( int i = 0 ; i &lt; iCount ; ++i )         {             switch ( aryRemover [ i ] . iDirection )             {             case 0 :                 long code             default :                 break ;             }         }          bTurn = true ; // Turn Player 1         iCount = 0 ;     } }  int Tile :: iTileinfo ( int iX , int iY ) {     return iAry [ iX ] [ iY ] ; }  bool Tile :: bTurninfo () {     if ( bTurn )         return true ;     else         return false ; }  void Tile :: Routine ( int iX , int iY ) {     Tile :: Possible ( iX , iY ) ;     Tile :: Change ( iX , iY ) ; } </code></pre>  <p>and error.</p>  <blockquote>   <p>error C2228: left of '.bTurninfo' must have class/struct/union.</p>      <p>error C2228: left of '.iTileinfo' must have class/struct/union.</p> </blockquote>  <p>Problem's code is in API code.</p>  <p>At <code>WM_PAINT</code> Section, code using <code>Bitblt</code> function.</p>  <p>I wait for your answer. Have a good day :)</p>