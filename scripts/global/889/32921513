<p>I have hand-made thread pool. Threads read from completion port and do some other stuff. One particular thread has to be ended. How to interrupt it's waiting if it hangs on GetQueuedCompletionStatus() or GetQueuedCompletionStatusEx()?</p>  <ul> <li>Finite timeout (100-1000 ms) and exiting variable are far from elegant, cause delays and left as last resort.</li> <li>CancelIo(completionPortHandle) within APC in target thread causes <code>ERROR_INVALID_HANDLE</code>.</li> <li>CancelSynchronousIo(completionPortHandle) causes <code>ERROR_NOT_FOUND</code>.</li> <li>PostQueuedCompletionStatus() with termination packet doesn't allow to choose thread.</li> <li>Rough TerminateThread() with mutex should work. (I haven't tested it.) But is it ideologically good?</li> <li>I tried to wait on special event and completion port. <code>WaitForMultipleObjects()</code> returned immediately as if completion port was signalled. <code>GetQueuedCompletionStatus()</code> shows didn't return anything.</li> </ul>  <p>I read <a href="http://stackoverflow.com/questions/961343/overlapped-i-o-how-to-wake-a-thread-on-a-completion-port-event-or-a-normal-even">Overlapped I/O: How to wake a thread on a completion port event or a normal event?</a> and googled a lot.</p>  <p>Probably, the problem itself – ending thread's work – is sign of bad design and all my threads should be equal and compounded into normal thread pool. In this case, PostQueuedCompletionStatus() approach should work. (Although I have doubts that this approach is beautiful and laconic especially if threads use GetQueuedCompletionStatusEx() to get multiple packets at once.)</p>