<p>I am working on a mostly compute-bound application.  For simplicity, think of it as a set of worker threads pulling blocks of work off an atomic queue, processing them, and then combining them back together in an output buffer.</p>  <p>In my tests, I have a Windows 7 machine with a 6-core Intel 990x (12 hardware threads), and so I create 12 threads.</p>  <p>Here are some graphs of the performance (three trials): <a href="http://i.stack.imgur.com/I0ZPJ.png" rel="nofollow"><img src="http://i.stack.imgur.com/I0ZPJ.png" alt="trial one"></a> <a href="http://i.stack.imgur.com/vnpVo.png" rel="nofollow"><img src="http://i.stack.imgur.com/vnpVo.png" alt="trial two"></a> <a href="http://i.stack.imgur.com/aq2hi.png" rel="nofollow"><img src="http://i.stack.imgur.com/aq2hi.png" alt="trial three"></a></p>  <p>After a serial initialization phase, you can see the 12 threads all start pulling work, work in parallel, and then terminate when there's none left.  Thread contention appears in orange (there's practically none).</p>  <p>However, notice the weird square wave pattern that occurs occasionally: <a href="http://i.stack.imgur.com/yjrIi.png" rel="nofollow"><img src="http://i.stack.imgur.com/yjrIi.png" alt="square wave"></a></p>  <p>This translates into a significant performance loss.  In trials where it doesn't happen very often, the performance is significantly faster.</p>  <hr>  <p>One thing I've noticed is that the waves like to trade off with each other--that is, the peaks of one thread coincide with the troughs of another.</p>  <p>This suggests one worker thread is being preempted by another.  This is bad, since the CPU has enough resources to run all 12 threads at the same time.</p>  <p>Therefore, my suspicion is that this is an OS-level thread scheduling issue.  If not, what is it?  What should I look into to start fixing it?</p>