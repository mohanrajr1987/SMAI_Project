<p>I'm trying to understand an LLVM CodeGen/Generic testcase so I can get it passing for a backend for a new processor.</p>  <p>This is the testcase (llvm/test/CodeGen/Generic/2007-04-08-MultipleFrameIndices.ll): </p>  <pre><code>; RUN: llc -no-integrated-as &lt; %s ; XFAIL: sparc-sun-solaris2 ; PR1308 ; PR1557 define i32 @stuff(i32, ...) {     %foo = alloca i8*     %bar = alloca i32*     %A = call i32 asm sideeffect "inline asm $0 $2 $3 $4", "=r,0,i,m,m"( i32 0, i32 1, i8** %foo, i32** %bar )     ret i32 %A } </code></pre>  <p>I'm specifically wondering about this part:</p>  <pre><code>    %A = call i32 asm sideeffect "inline asm $0 $2 $3 $4", "=r,0,i,m,m"( i32 0, i32 1, i8** %foo, i32** %bar ) </code></pre>  <p>What exactly should that inline asm accomplish?</p>  <p>When I run it through <em>llc</em> as indicated in the comment, I see this on the output (for x86_64):</p>  <pre><code>    .text     .file   "&lt;stdin&gt;"     .globl  stuff     .align  16, 0x90     .type   stuff,@function stuff:                                  # @stuff     .cfi_startproc # BB#0:     leaq    -8(%rsp), %rax     movq    %rax, -24(%rsp)     leaq    -16(%rsp), %rax     movq    %rax, -32(%rsp)     xorl    %eax, %eax     #APP     inline asm %eax $1 -24(%rsp) -32(%rsp)     #NO_APP     retq .Ltmp0:     .size   stuff, .Ltmp0-stuff     .cfi_endproc       .section    ".note.GNU-stack","",@progbits </code></pre>  <p>It seems to have resulting in the following line in the output asm code:</p>  <pre><code>   inline asm %eax $1 -24(%rsp) -32(%rsp) </code></pre>  <p>...but I'm not entirely sure how that was generated from the input. Where does the %eax come from, for example? What does this generated line mean/do?</p>