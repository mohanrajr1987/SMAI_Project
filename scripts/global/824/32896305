<p>When I compile</p>  <pre><code>#include &lt;stdio.h&gt; int main () {     return 0; } </code></pre>  <p>to x86 assembly the result is plain and expected:</p>  <pre><code>$&gt; cc -m32 -S main.c -o -|sed -r "/\s*\./d" main:     pushl   %ebp     movl    %esp, %ebp     movl    $0, %eax     popl    %ebp     ret </code></pre>  <p>But when studying different disassembled binaries, the function prologue is never that simple. Indeed, changing the C source above into</p>  <pre><code>#include &lt;stdio.h&gt; int main () {     printf("Hi");     return 0; } </code></pre>  <p>the result is</p>  <pre><code>$&gt; cc -m32 -S main.c -o -|sed -r "/\s*\./d" main:     leal    4(%esp), %ecx     andl    $-16, %esp     pushl   -4(%ecx)     pushl   %ebp     movl    %esp, %ebp     pushl   %ecx     subl    $4, %esp     subl    $12, %esp     call    printf     addl    $16, %esp     movl    $0, %eax     movl    -4(%ebp), %ecx     leave     leal    -4(%ecx), %esp     ret </code></pre>  <p>In particular, I don't get why these instructions</p>  <pre><code>leal    4(%esp), %ecx andl    $-16, %esp pushl   -4(%ecx) </code></pre>  <p>are generated -- specifically why not directly storing <code>%esp</code> into <code>%ecx</code>, instead of into<code>%esp+4</code>?</p>