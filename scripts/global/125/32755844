<p>If you have a base class</p>  <pre><code>public abstract class AbsHashtableish&lt;TKey, TValue&gt; {     public abstract TKey ConvertToKey(string key);     public abstract bool KeyExists(TKey key);      public virtual bool KeyExists(string key)     {          Console.WriteLine("In Base");          return KeyExists(ConvertToKey(key));     } } </code></pre>  <p>and a concerete class</p>  <pre><code>public class ConcreteHashtableish: AbsHashtableish&lt;string, Dinosaur&gt; {     ...      public override string ConvertToKey(string key)     {          return key;     }      public override bool KeyExists(string key)     {          Console.WriteLine("In Sub");          return _list.Contains(key);     } } </code></pre>  <p>and client A</p>  <pre><code>AbsHashtableish&lt;string, Dinosaur&gt; concreteA = new ConcreteHashtableish&lt;string, Dinosaur&gt;(); </code></pre>  <p>and client B</p>  <pre><code>ConcreteHashtableish&lt;string, Dinosaur&gt; concreteB = new ConcreteHashtableish&lt;string, Dinosaur&gt;(); </code></pre>  <p>What are the rules (and if possible, the reasoning behind them) for determining whether the code shown above is sufficient to compile and if so:</p>  <ol> <li>Is there a difference between calling <code>KeyExists</code> on <code>concreteA</code> vs <code>concreteB</code>?</li> <li>Assuming we can somehow enter the base class method <code>KeyExists(string key)</code>, will we be able to get out of it?</li> </ol>  <p>For question #2, what I mean is that if somehow the compiler is able to compile this code, does it do so by effectively hiding the base method from the client - because if that code was reached, it would result in an infinite loop?</p>