<p>Consider this situation: </p>  <p>Style1: </p>  <pre><code>static enum Style1{     FIRE_BALL {         @Override         public boolean isCold() {             return false;         }     },ICE_BALL {         @Override         public boolean isCold() {             return true;         }     },FIRE_ARROW {         @Override         public boolean isCold() {             return false;         }     },ICE_ARROW {         @Override         public boolean isCold() {             return true;         }     };     public abstract boolean isCold(); } </code></pre>  <p>Style2:</p>  <pre><code>static enum Style2{     FIRE_BALL,ICE_BALL,FIRE_ARROW,ICE_ARROW;     public boolean isCold(){         //return this.toString().contains("ICE")?true:false; //sorry         return this.toString().contains("ICE");     } } </code></pre>  <p>Now, I simply want to know whether it's cold. So I'm going to ask:</p>  <p><strong>Can compiler know the destined results and constant-fold Style2 ?</strong></p>  <p>If not, Style1 should be obviously faster, but more verbose. Assume this were more complicated situation and there were many more combinations, such as BIG_FIRE_SLOW_BALL with isFast(), isBig(), Style1 will end up with chunks of codes.</p>  <hr>  <p>So I did some tests with jmh and jUnit:</p>  <p>1.with jmh:</p>  <pre><code>@Benchmark public boolean testStyle1() {     return Style1.values()[ThreadLocalRandom.current().nextInt(4)].isCold(); }  @Benchmark public boolean testStyle2() {     return Style2.values()[ThreadLocalRandom.current().nextInt(4)].isCold(); } </code></pre>  <p>when setting:</p>  <pre><code>            .warmupIterations(10)             .measurementIterations(10)             .threads(8)  Benchmark             Mode  Cnt   Score   Error  Units EnumTest1.testStyle1  avgt   10  34.057 ± 0.101  ns/op EnumTest1.testStyle2  avgt   10  36.196 ± 0.453  ns/op </code></pre>  <p>well, set thread number to 1</p>  <pre><code>            .threads(1) Benchmark             Mode  Cnt   Score    Error  Units EnumTest1.testStyle1  avgt   10  34.306 ± 11.692  ns/op EnumTest1.testStyle2  avgt   10  44.279 ± 11.103  ns/op </code></pre>  <p>So, it seems like <strong>Style2 can't be optimized by compiler.</strong></p>  <p>2,with jUnit:</p>  <pre><code>private static final int LOOP_TIMES = 100000000; private static final Random random1=new Random(47); private static final Random random2=new Random(47);  @Test public void testStyle1() {     int cnt = 0;     for (int i = 0; i &lt; LOOP_TIMES; i++) {         if(Style1.values()[random1.nextInt(4)].isCold()){             cnt++;         }     }     System.out.println(cnt); }  @Test public void testStyle2() {     int cnt = 0;     for (int i = 0; i &lt; LOOP_TIMES; i++) {         if(Style2.values()[random2.nextInt(4)].isCold()){             cnt++;         }     }     System.out.println(cnt); } </code></pre>  <p>results:</p>  <pre><code>Time:      1       2       3    inverse order   4      5       6 Style1: 3.631s  4.578s  3.754s    Style2     4.131s  5.487s  4.261s   Style2: 2.559s  4.216s  3.155s    Style1     2.316s  3.977s  4.152s </code></pre>  <p>So, <strong>Style1 is likely to be faster</strong>. </p>  <hr>  <p><strong>But why two results are close, especially when I concurrently do the test with jmh? Or how indeed should we deal with this?</strong></p>  <p>Maybe giving Style1 some fields to store each one's result could make it less redundant. But I still feel not very satisfied. Hope some of you could tell me more.</p>  <hr>  <p>Thank you guys very much. @Andy gave a very good example, I add it here:</p>  <pre><code>enum Style4{     FIRE_BALL,     ICE_BALL,     FIRE_ARROW,     ICE_ARROW;      private boolean cold;      private Style4(){         this.cold = this.toString().contains("ICE");     }      public boolean isCold(){         return cold;     } } </code></pre>  <p>This fourth style works without mentioning true or false.</p>