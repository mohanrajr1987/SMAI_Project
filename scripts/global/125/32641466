<p>I would like to write a syntax extension that combines information from a related type when generating a new function. As a nonsense example, pretend I have this code:</p>  <pre><code>struct Monster {     health: u8, }  impl Monster {     fn health(&amp;self) { self.health } }  #[attack(Monster)] struct Player {     has_weapon: true, } </code></pre>  <p>I'd like the <code>attack</code> attribute to be expanded to a function that knows about the methods of <code>Monster</code>. A simple example would be</p>  <pre><code>impl Player {     fn attack_monster(m: &amp;Monster) {         println!("{}", m.health());     } } </code></pre>  <p>Specifically, I'd like to be able to get the function signatures of the inherent methods of a type. I'd also be OK with being able to the function signatures of a trait. The important distinction is that my extension does <strong>not</strong> know ahead of time which type or trait to look up - it would be provided by the user as an argument to the annotation.</p>  <p>I currently have a syntax extension that decorates a type, as I want to add methods. To that end, I have implemented a <code>MultiItemDecorator</code>. After looking at the parameters to the <code>expand</code> function, I've been unable to figure out any way of looking up a type or a trait, only ways of generating brand-new types or traits:</p>  <pre><code>trait MultiItemDecorator {     fn expand(&amp;self,               ctx: &amp;mut ExtCtxt,               sp: Span,               meta_item: &amp;MetaItem,               item: &amp;Annotatable,               push: &amp;mut FnMut(Annotatable)); } </code></pre>