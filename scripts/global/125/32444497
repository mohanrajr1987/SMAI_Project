<p>Here is a simple C program:</p>  <pre><code>struct S {char c; short arr[16]; char dummy2;};  extern struct S A[20]; extern short* p;  int main() {     p = &amp;A[10].arr[6];     return 0; } </code></pre>  <p>And here is the LLVM IR:</p>  <pre><code>%struct.S = type { i8, [16 x i16], i8 }  @A = external global [20 x %struct.S] @p = external global i16*  ; Function Attrs: nounwind define i32 @main() #0 { entry:   store i16* getelementptr inbounds ([20 x %struct.S]* @A, i64 0, i64 10, i32 1, i64 6), i16** @p, align 8, !tbaa !1   ret i32 0 } </code></pre>  <p>How can I calculate the byte offset that is being added to <code>@A</code> by the <a href="http://llvm.org/docs/GetElementPtr.html" rel="nofollow">getelementptr</a>?</p>  <p>I can loop through and print out the GEP easily enough:</p>  <pre><code>  auto&amp; P = *GEP.getPointerOperand();   Out &lt;&lt; "GEP(";   GEP.getType()-&gt;print(Out); // return type   Out &lt;&lt; ", ";   P.printAsOperand(Out); // base   for (auto i=0U; i&lt;GEP.getNumIndices(); i++) {     Out &lt;&lt; ", ";     GEP.getOperand(i+1)-&gt;printAsOperand(Out); // index i   }   Out &lt;&lt; ")\n"; </code></pre>  <p>This prints:</p>  <pre><code> GEP(i16*, [20 x %struct.S]* @A, i64 0, i64 10, i32 1, i64 6) </code></pre>  <p>Assuming <em>all</em> the indices are constant integer, how can you determine the byte offset relative to the base pointer?</p>