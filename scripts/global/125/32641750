<p>I'm writing a compiler in a functional style. The type checker is currently fairly straightforward: it's (mostly) just a function from <code>Expr</code> to <code>Type</code>.</p>  <p>Now, I want to add a step to the workflow that preserves the type information for later stages. There are a number of ways to do this (symbol tables, etc.), but a simple one is to translate into an IR that looks like the AST but contains type information. For example, if the AST data type is:</p>  <pre><code>datatype Expr = Literal of int               | Add of Expr * Expr               | ... </code></pre>  <p>Then the typed IR would be:</p>  <pre><code>type TExpr = Type * TExpr' datatype TExpr' = TLiteral of int                 | TAdd of TExpr * TExpr                 | ... </code></pre>  <p>So my goal now is to convert my type checker into a type annotator: a function <code>Expr -&gt; TExpr</code> instead of <code>Expr -&gt; Type</code>. Here's my question: <em>How would you do this without adding a bunch of boilerplate clutter to the type checker function?</em></p>  <p>Naively, I would need to add wrapping and unwrapping code all over the place, ruining the simple legibility of the type checker function as it stands. That is, the case for <code>Add</code> in the type checker currently looks like:</p>  <pre><code>let lhs_t = check lhs in let rhs_t = check rhs in case (lhs_t, rhs_t) of   (Int, Int) =&gt; Int | (_, _) =&gt; Error </code></pre>  <p>Nice and clean! Exactly matches the typing judgment in the formalism! ‚ù§Ô∏èüéâ</p>  <p>If I mucked up the type checker with the additional translation logic, it would look like this (now <code>check</code> has type <code>Expr -&gt; TExpr</code>):</p>  <pre><code>(* Recursive calls to translate the children. *) let lhs_typed = check lhs in let rhs_typed = check rhs in (* We don't care about the expression for checking, just the resulting  * type. So extract that from each child. *) let lhs_t, _ = lhs_typed in let rhs_t, _ = rhs_typed in case (Int, Int) =&gt;   (* Construct a TExpr with the new type. *)   (Int, TAdd (lhs_typed, rhs_typed)) | (_, _) =&gt; Error </code></pre>  <p>This has unpleasantly intermingled the interesting type checking logic with the boring boilerplate for destructing and constructing <code>TExpr</code>. üò¨üí©</p>  <p>Is there any way to separate these components? That is, can the type checking logic live in one recursive function while the translation machinery acts as an external client of it? Bonus points if it's still easy to run the type checker <em>without</em> doing translation if you want to.</p>  <hr>  <p>Bonus context: this follows the "Separate IR" option from <a href="http://blog.ezyang.com/2013/05/the-ast-typing-problem/" rel="nofollow">Edward Z. Yang's post on "The AST Typing Problem"</a>. I've considered generic programming a la <a href="http://www.staff.science.uu.nl/~3860418/msc/02_infogp/papers/SYB1.pdf" rel="nofollow">Scrap Your Boilerplate</a> but can't quite get it to fit this case. Related but different questions on SO:</p>  <ul> <li><a href="https://stackoverflow.com/questions/29588141/how-do-purely-functional-compilers-annotate-the-ast-with-type-info">How do purely functional compilers annotate the AST with type info?</a></li> <li><a href="http://stackoverflow.com/questions/16204177/how-should-i-represent-an-ast-annotated-with-additional-information">How should I represent an AST annotated with additional information?</a></li> </ul>