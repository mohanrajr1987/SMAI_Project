<p>Bear with my English. I have a simple json,</p>  <pre><code>{     "Hint2": "L" } </code></pre>  <p>this is the POJO that works.</p>  <pre><code> public class Hints {     @SerializedName("Hint2")     @Expose     private String Hint2;     public void setHint1(Object Hint2) {       this.Hint2 = (Hint2);    }  } </code></pre>  <p>i want to change it to</p>  <pre><code>public class Hints {     @SerializedName("Hint2")     @Expose     public final ObservableField&lt;String&gt; Hint2 = new ObservableField&lt;&gt;();     public void setHint2(String Hint2) {       this.Hint2.set(Hint2);    } } </code></pre>  <p>both class has same setter method, same @SerializedName annotation tag. only type of Hint2 object is changed. but the latter one throws exception shown below</p>  <pre><code>Caused by: com.google.gson.JsonSyntaxException: java.lang.IllegalStateException: Expected BEGIN_OBJECT but was STRING at.. </code></pre>  <p>so i believe deserialization depends on what kind of variable "Hint2" is.  <br/> Is there a way to make it work with ObservableField rather than using String?</p>  <p>The reason i'm trying this is android binding library, which supports binding objects directly to xml files. and the ObservableField automatically updates UI when corresponding value in POJO is changed.</p>  <p><br/> <strong>Update:</strong> <br/><a href="https://sites.google.com/site/gson/gson-design-document" rel="nofollow">gson design document</a> has this</p>  <p>Using fields vs getters to indicate Json elements <br/> <em>Some Json libraries use the getters of a type to deduce the Json elements. We chose to use all fields (up the inheritance hierarchy) that are not transient, static, or synthetic. We did this because not all classes are written with suitably named getters. Moreover, getXXX or isXXX might be semantic rather than indicating properties.  <br/>However, there are good arguments to support properties as well. We intend to enhance Gson in a latter version to support properties as an alternate mapping for indicating Json fields. <strong>For now, Gson is fields-based.</em></strong> </p>  <p><br/> so this indicates that Gson is fields-based. this pretty much answers my question but still waiting if anyone has someway around this. </p>