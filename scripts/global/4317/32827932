<p>I always thought that inlining always happens at compile time. But when I read this article by Herb Sutter <a href="http://www.drdobbs.com/inline-redux/184403879" rel="nofollow">here</a>, he says that inlining can also happen at runtime. I was really surprised when I read that. Herb says in this article that:</p>  <blockquote>   <p>It might seem impossible that inlining can still be performed at   runtime, but in fact there are several ways it can be done. In   particular, I want to mention profile-directed optimization and   guarded inlining. Like a managed environment (see previous and next   sections), this requires some tool support to exist on the user's   machine at runtime.</p>      <p>The idea behind profile-directed optimization is that when the   application is actually run, instrumentation hooks inserted into the   executing program can gather data about how the program is actually   being used, in particular what functions are being called heavily and   under what conditions (e.g., the size of the working set compared to   the total cache memory when the function is called). The data gathered   from these instrumented hooks can be used to modify the executable   image so that selected function calls can be inlined to tune the   application to its target environment based on actual runtime   performance measurements.</p>      <p>Guarded inlining is another example of how aggressive the runtime   inline optimizations can be. In particular, [4] and [5] document the   Jikes Research Virtual Machine (RVM), née the Jalapeño dynamic   optimizing compiler, for JVM targets. Among other things, this   compiler is able to inline virtual member functions by assuming that   the receiver of the virtual call will be of a given declared type (in   order to avoid the cost not only of the function call but of the extra   expense of virtual dispatch). Now, compilers can already routinely   nonvirtualize (and therefore also optionally inline) certain virtual   function calls today, if the type of the target is statically known.   What's new here is that the Jikes/Jalapeño environment can   nonvirtualize and inline calls to virtual functions even if the static   type of the target is not known. Because the guess might not be right,   it inserts a guard that performs a runtime check that validates that   the target object's type is what was expected; if it's not, it falls   back to a normal virtual function call.</p> </blockquote>  <p>I still don't understand what exactly is profile directed optimization &amp; how it performed? Same way what are instrumentation hooks &amp; who inserts them into executing program? It would be also better if someone explain more clearly about guarded inlining. </p>