<p>I have a BuildPredicate method that is tightly coupled to a type ProductSearchResult as follow - </p>  <pre><code>private void BuildPredicate(string searchTerm,         List&lt;string&gt; searchFields,         ref Expression&lt;Func&lt;ProductSearchResult,bool&gt;&gt; queryPredicate)     {         //Build query with search fields         if (searchFields != null &amp;&amp; searchFields.Count &gt; 0)         {             foreach (string searchField in searchFields)             {                 queryPredicate = queryPredicate.Or(i =&gt; i[searchField].Contains(searchTerm));                                 }         }     } </code></pre>  <p>However now i intend to extend (generalize) it to build a predicate over any other type (e.g. ArticleSearchResult, UserSearchResult etc). However when using generics as follows -</p>  <pre><code>private void BuildPredicate&lt;T&gt;(string searchTerm,         List&lt;string&gt; searchFields,         ref Expression&lt;Func&lt;T,bool&gt;&gt; queryPredicate)     {         //Build query with search fields         if (searchFields != null &amp;&amp; searchFields.Count &gt; 0)         {             foreach (string searchField in searchFields)             {                 queryPredicate = queryPredicate.Or(i =&gt; i[searchField].Contains(searchTerm));                                 }         }     } </code></pre>  <p>now i get compilation error "cannot apply indexing with [] to an expression of type 'T'"</p>  <p>The closest solution that should work for me seems to be  <a href="http://blog.willbeattie.net/2008/10/linq-to-entities-dynamic-linq-to.html" rel="nofollow">this</a></p>  <p>However not sure if simple generic implementation or runtime type resolving should translate to that much code. Will appreciate if anyone can point to similar implementation as this looks like a standard scenario for search implementations.</p>