<p>The following code in Erlang catches the value of 3 if its equivalent to the value that Four is assigned to:</p>  <pre><code>run() -&gt;     Four = 4,     case 3 of         Four -&gt; io:format("3 == 4~n", []);         _ -&gt; io:format("3 /= 4~n", [])     end. </code></pre>  <p>When executed it prints out "3 /= 4". Similar code in Haskell:</p>  <pre><code>main = do     let four = 4     case 3 of         four -&gt; putStrLn "3 == 4"         _ -&gt; putStrLn "3 /= 4" </code></pre>  <p>prints "3 == 4" which is a statement I'm not (at this point in my life) ready to accept as truth.</p>  <p>Why does Haskell not let me match against previously bound variables? Is it per design or just a result of how do-notation (and case .. of expressions by the way, I tested binding a name to a value in one case .. of and then matching against it in another case .. of inside and it didn't work) are implemented? Is there some way to get it to work and be as cool and simple as the Erlang one or do I have to manually compare them?</p>