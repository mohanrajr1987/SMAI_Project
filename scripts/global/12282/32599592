<p>I've scoured the web and haven't found any good examples for doing pattern scans of a byte array. I do pattern scans of memory using ReadProcessMemory that allow me to look for a pattern by passing some bytes, <code>74 C7 2F 00 00 02</code> and a match, <code>xxx??x</code> for instance.</p>  <p>I would like to do the same thing but with a <code>byte[]</code> array in C#.</p>  <p>The best method I've found for searching for a byte array inside a large byte array (20mb or so) is this.</p>  <pre><code>public static unsafe long IndexOfBytes(this byte[] haystack, byte[] needle, string match, long startOffset = 0)         {             fixed (byte* h = haystack) fixed (byte* n = needle)             {                 for (byte* hNext = h + startOffset, hEnd = h + haystack.LongLength + 1 - needle.LongLength, nEnd = n + needle.LongLength; hNext &lt; hEnd; hNext++)                     for (byte* hInc = hNext, nInc = n; *nInc == *hInc; hInc++)                         if (++nInc == nEnd)                             return hNext - h;                 return -1;             }         } </code></pre>  <p>This works great for finding <code>74 C7 2F 00 00 02</code> but has no way of matching against <code>74 C7 2F 20 20 02</code>. I'd like to use the same method of including a "match" parameter. I started on it, as you can see "match" exists as a paramater, but it doesn't do anything. The unsafe code is very confusing and after a few hours of sitting in a debugger trying to figure out what it's doing, I'm completely at a loss.</p>  <p>I'm guessing there's an easy way to have it check the index of the current byte it's matching and if it's a "?" in the match to allow it to pass even if it doesn't match, then it goes to the next byte and if it is an "x" in the match it continues searching on. If it finds a byte array that completely matches up with the "match" then it returns. </p>  <p>Any help on this would be greatly appreciated. </p>