<p>I have a written a simple audio player application in c++ using gstreamer apis. I followed <a href="http://gstreamer.freedesktop.org/data/doc/gstreamer/head/manual/html/chapter-helloworld.html" rel="nofollow">Gstreamer Hello world example</a>. This is my code:</p>  <pre><code>CMediaPlayer::CMediaPlayer(QString path)  {     gst_init(NULL, NULL);     createElements(path); }  createElements(QString &amp;path)     {             /* Create gstreamer elements */             m_pipeline  = gst_pipeline_new("audio-player");             m_fileSource = gst_element_factory_make("filesrc", "file-source");             m_audioDecoder = gst_element_factory_make("mad", "mp3-decoder");             m_volume = gst_element_factory_make("volume", "volume-name");             m_audioConverter = gst_element_factory_make("audioconvert", "audio-converter");             m_sink = gst_element_factory_make("alsasink", "audio-output");           if (!m_pipeline || !m_fileSource || !m_audioDecoder || !m_volume || !m_audioConverter || !m_sink) {             g_printerr ("One or more elements could not be created !! \n");             return false;         }         /* Set up the pipeline */         else {             /* set a message handler on a bus */             GstBus *bus = gst_pipeline_get_bus (GST_PIPELINE (m_pipeline));             gst_bus_add_watch(bus, bus_call, m_loop);             gst_object_unref(bus);              g_object_set (G_OBJECT (m_fileSource), "location", path.toLatin1().data(), NULL);              /* add all elements into the pipeline */             gst_bin_add_many (GST_BIN (m_pipeline), m_fileSource, m_audioDecoder, m_volume, m_audioConverter, m_sink, NULL);              /* link the elements together */             if(!gst_element_link_many (m_fileSource, m_audioDecoder, NULL)) {                 g_printerr("ERROR: Failed to link file-source and audio-decoder !! \n");                 return false;             }             if(!gst_element_link_many (m_audioDecoder, m_volume, NULL)) {                 g_printerr("ERROR: Failed to link audio-decoder and volume !! \n");                 return false;             }             if(!gst_element_link_many (m_volume, m_audioConverter, NULL)) {                 g_printerr("ERROR: Failed to link audio-decoder and audio-converter !! \n");                 return false;             }             if(!gst_element_link_many (m_audioConverter, m_sink, NULL)) {                 g_printerr("ERROR: Failed to link audio-converter and sink !! \n");                 return false;             }         }      /* Prepare the pipeline */     gst_element_set_state(m_pipeline, GST_STATE_READY);     gst_element_set_state(m_pipeline, GST_STATE_PAUSED);  }  bus_call(GstBus *bus, GstMessage *msg, gpointer data) {      CMediaPlayer *ptr = (CMediaPlayer*)(data);     switch(GST_MESSAGE_TYPE(msg))     {         case GST_MESSAGE_EOS:             // Reset the position of the stream             gst_element_set_state (ptr-&gt;m_pipeline, GST_STATE_READY);             gst_element_set_state (ptr-&gt;m_pipeline, GST_STATE_PAUSED);             g_message("GST_MESSAGE_EOS \n");             break;          case GST_MESSAGE_ERROR:             gchar  *debug;             GError *error;              gst_message_parse_error (msg, &amp;error, &amp;debug);             g_free (debug);              g_printerr ("ERROR: %s\n", error-&gt;message);             g_error_free (error);             break;         default:             g_message("default \n");             break;     }     bus = bus; // prevent "unused" warning     return TRUE; }  slot_play() {     m_gstReturnValue = gst_element_set_state (m_pipeline, GST_STATE_PLAYING);     if(m_gstReturnValue == GST_STATE_CHANGE_FAILURE)     {         g_printerr("ERROR: Cannot play !! \n");     } }  slot_pause() {     m_gstReturnValue = gst_element_set_state (m_pipeline, GST_STATE_PAUSED);     if(m_gstReturnValue == GST_STATE_CHANGE_FAILURE)     {         g_printerr("ERROR: Cannot pause !! \n");     } }  slot_stop() {     m_gstReturnValue = gst_element_set_state (m_pipeline, GST_STATE_READY);     m_gstReturnValue = gst_element_set_state (m_pipeline, GST_STATE_PAUSED);     if(m_gstReturnValue == GST_STATE_CHANGE_FAILURE)     {         g_printerr("ERROR: Cannot stop !! \n");     } }  slot_setVolume(int vol_i) {     vol_i = (vol_i &gt; 10) ? 10 : (vol_i &lt; 0) ? 0 : vol_i;     g_object_set(G_OBJECT(m_volume), "volume", (gdouble(vol_i)/10), NULL); } </code></pre>  <p>When I run the application, it behaves strangely. Sometimes it plays and sometimes it doesn't. This i the info from whenever it doesn't play:</p>  <pre><code>0:01:12.000176325 31988   0x5e3000 INFO               GST_EVENT gstevent.c:1244:gst_event_new_latency: creating latency event 0:00:00.000000000 0:01:12.000953562 31988   0x5e3000 INFO                     bin gstbin.c:2502:gst_bin_do_latency_func:&lt;audio-player&gt; configured latency of 0:00:00.000000000 0:01:12.001444706 31988   0x5e3000 INFO              GST_STATES gstbin.c:2230:gst_bin_element_set_state:&lt;audio-output&gt; current PAUSED pending VOID_PENDING, desired next PLAYING 0:01:12.004258709 31988   0x5e3000 INFO              GST_STATES gstelement.c:2328:gst_element_continue_state:&lt;audio-output&gt; completed state change to PLAYING 0:01:12.004433239 31988   0x5e3000 INFO              GST_STATES gstelement.c:2233:_priv_gst_element_state_changed:&lt;audio-output&gt; notifying about state-changed PAUSED to PLAYING (VOID_PENDING pending) 0:01:12.004624124 31988   0x5e3000 INFO              GST_STATES gstbin.c:2673:gst_bin_change_state_func:&lt;audio-player&gt; child 'audio-output' changed state to 4(PLAYING) successfully 0:01:12.004783134 31988   0x5e3000 INFO              GST_STATES gstbin.c:2230:gst_bin_element_set_state:&lt;audio-converter&gt; current PAUSED pending VOID_PENDING, desired next PLAYING 0:01:12.004904644 31988   0x5e3000 INFO              GST_STATES gstelement.c:2328:gst_element_continue_state:&lt;audio-converter&gt; completed state change to PLAYING 0:01:12.004990634 31988   0x5e3000 INFO              GST_STATES gstelement.c:2233:_priv_gst_element_state_changed:&lt;audio-converter&gt; notifying about state-changed PAUSED to PLAYING (VOID_PENDING pending) 0:01:12.005134540 31988   0x5e3000 INFO              GST_STATES gstbin.c:2673:gst_bin_change_state_func:&lt;audio-player&gt; child 'audio-converter' changed state to 4(PLAYING) successfully 0:01:12.005267925 31988   0x5e3000 INFO              GST_STATES gstbin.c:2230:gst_bin_element_set_state:&lt;volume-name&gt; current PAUSED pending VOID_PENDING, desired next PLAYING 0:01:12.005386310 31988   0x5e3000 INFO              GST_STATES gstelement.c:2328:gst_element_continue_state:&lt;volume-name&gt; completed state change to PLAYING 0:01:12.005483653 31988   0x5e3000 INFO              GST_STATES gstelement.c:2233:_priv_gst_element_state_changed:&lt;volume-name&gt; notifying about state-changed PAUSED to PLAYING (VOID_PENDING pending) 0:01:12.005634851 31988   0x5e3000 INFO              GST_STATES gstbin.c:2673:gst_bin_change_state_func:&lt;audio-player&gt; child 'volume-name' changed state to 4(PLAYING) successfully 0:01:12.005785006 31988   0x5e3000 INFO              GST_STATES gstbin.c:2230:gst_bin_element_set_state:&lt;mp3-decoder&gt; current PAUSED pending VOID_PENDING, desired next PLAYING 0:01:12.005916673 31988   0x5e3000 INFO              GST_STATES gstelement.c:2328:gst_element_continue_state:&lt;mp3-decoder&gt; completed state change to PLAYING 0:01:12.006004329 31988   0x5e3000 INFO              GST_STATES gstelement.c:2233:_priv_gst_element_state_changed:&lt;mp3-decoder&gt; notifying about state-changed PAUSED to PLAYING (VOID_PENDING pending) 0:01:12.006142245 31988   0x5e3000 INFO              GST_STATES gstbin.c:2673:gst_bin_change_state_func:&lt;audio-player&gt; child 'mp3-decoder' changed state to 4(PLAYING) successfully 0:01:12.006259484 31988   0x5e3000 INFO              GST_STATES gstbin.c:2230:gst_bin_element_set_state:&lt;file-source&gt; current PAUSED pending VOID_PENDING, desired next PLAYING 0:01:12.006381567 31988   0x5e3000 INFO              GST_STATES gstelement.c:2328:gst_element_continue_state:&lt;file-source&gt; completed state change to PLAYING 0:01:12.006465942 31988   0x5e3000 INFO              GST_STATES gstelement.c:2233:_priv_gst_element_state_changed:&lt;file-source&gt; notifying about state-changed PAUSED to PLAYING (VOID_PENDING pending) 0:01:12.006599379 31988   0x5e3000 INFO              GST_STATES gstbin.c:2673:gst_bin_change_state_func:&lt;audio-player&gt; child 'file-source' changed state to 4(PLAYING) successfully 0:01:12.006726983 31988   0x5e3000 INFO              GST_STATES gstelement.c:2328:gst_element_continue_state:&lt;audio-player&gt; completed state change to PLAYING 0:01:12.006812868 31988   0x5e3000 INFO              GST_STATES gstelement.c:2233:_priv_gst_element_state_changed:&lt;audio-player&gt; notifying about state-changed PAUSED to PLAYING (VOID_PENDING pending) </code></pre>  <p>According to the log, state of the pipeline is changed to PLAYING. But I don't hear anything. When I try to stop or pause or change the volume, the application hangs.</p>  <p>I referred this <a href="http://stackoverflow.com/questions/8396127/gstreamer-code-for-playing-avi-file-is-hanging">link</a>. But it didn't help.</p>  <p>What am I missing? I am new to gstreamer. Any pointers would be really helpful.</p>