<p>I'm trying to generate a spectrogram from an <code>AVAudioPCMBuffer</code> in Swift. I install a tap on an <code>AVAudioMixerNode</code> and receive a callback with the audio buffer. I'd like to convert the signal in the buffer to a <code>[Float:Float]</code> dictionary where the key represents the frequency and the value represents the magnitude of the audio on the corresponding frequency.</p>  <p>I tried using Apple's Accelerate framework but the results I get seem dubious. I'm sure it's just in the way I'm converting the signal.</p>  <p>I looked at <a href="https://www.mikeash.com/pyblog/friday-qa-2012-10-26-fourier-transforms-and-ffts.html" rel="nofollow">this blog post</a> amongst other things for a reference.</p>  <p>Here is what I have:</p>  <pre class="lang-swift prettyprint-override"><code>self.audioEngine.mainMixerNode.installTapOnBus(0, bufferSize: 1024, format: nil, block: { buffer, when in     let bufferSize: Int = Int(buffer.frameLength)      // Set up the transform     let log2n = UInt(round(log2(Double(bufferSize))))     let fftSetup = vDSP_create_fftsetup(log2n, Int32(kFFTRadix2))      // Create the complex split value to hold the output of the transform     var realp = [Float](count: bufferSize/2, repeatedValue: 0)     var imagp = [Float](count: bufferSize/2, repeatedValue: 0)     var output = DSPSplitComplex(realp: &amp;realp, imagp: &amp;imagp)      // Now I need to convert the signal from the buffer to complex value, this is what I'm struggling to grasp.     // The complexValue should be UnsafePointer&lt;DSPComplex&gt;. How do I generate it from the buffer's floatChannelData?     vDSP_ctoz(complexValue, 2, &amp;output, 1, UInt(bufferSize / 2))      // Do the fast Fournier forward transform     vDSP_fft_zrip(fftSetup, &amp;output, 1, log2n, Int32(FFT_FORWARD))      // Convert the complex output to magnitude     var fft = [Float](count:Int(bufferSize / 2), repeatedValue:0.0)     vDSP_zvmags(&amp;output, 1, &amp;fft, 1, vDSP_length(bufferSize / 2))      // Release the setup     vDSP_destroy_fftsetup(fftsetup)      // TODO: Convert fft to [Float:Float] dictionary of frequency vs magnitude. How? } </code></pre>  <h2>My questions are</h2>  <ol> <li>How do I convert the <code>buffer.floatChannelData</code> to <code>UnsafePointer&lt;DSPComplex&gt;</code> to pass to the <code>vDSP_ctoz</code> function? Is there a different/better way to do it maybe even bypassing <code>vDSP_ctoz</code>?</li> <li>Is this different if the buffer contains audio from multiple channels? How is it different when the buffer audio channel data is or isn't interleaved?</li> <li>How do I convert the indices in the <code>fft</code> array to frequencies in Hz?</li> <li>Anything else I may be doing wrong?</li> </ol>  <h1>Update</h1>  <p>Thanks everyone for suggestions. I ended up filling the complex array as suggested in the accepted answer. When I plot the values and play a 440 Hz tone on a tuning fork it registers exactly where it should.</p>  <p>Here is the code to fill the array: </p>  <pre><code>var channelSamples: [[DSPComplex]] = [] for var i=0; i&lt;channelCount; ++i {     channelSamples.append([])     let firstSample = buffer.format.interleaved ? i : i*bufferSize     for var j=firstSample; j&lt;bufferSize; j+=buffer.stride*2 {         channelSamples[i].append(DSPComplex(real: buffer.floatChannelData.memory[j], imag: buffer.floatChannelData.memory[j+buffer.stride]))     } } </code></pre>  <p>The <code>channelSamples</code> array then holds separate array of samples for each channel.</p>  <p>To calculate the magnitude I used this: </p>  <pre><code>var spectrum = [Float]() for var i=0; i&lt;bufferSize/2; ++i {     let imag = out.imagp[i]     let real = out.realp[i]     let magnitude = sqrt(pow(real,2)+pow(imag,2))     spectrum.append(magnitude) } </code></pre>