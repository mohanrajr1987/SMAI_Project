<p>I'm refactoring a piece of code I've written some times ago. I wrote a custom usercontrol that allows a user to select a counterpart.</p>  <p>The viewmodel has 2 properties defined as</p>  <pre><code>#region Properties [ViewToViewModel(MappingType = ViewToViewModelMappingType.TwoWayViewWins)] public bool AllowNull {     get { return (bool)GetValue(AllowNullProperty); }     set { SetValue(AllowNullProperty, value); } } public static readonly DependencyProperty AllowNullProperty = DependencyProperty.Register("AllowNull", typeof(bool),     typeof(CounterpartChooserControl), new PropertyMetadata(default(bool)));   /// &lt;summary&gt; /// This Dependency property is used upon KeyDown to propagate the click to the target usercontrol /// &lt;/summary&gt; public ICommandSource DestinationControl {     get { return (ICommandSource)GetValue(DestinationControlProperty); }     set { SetValue(DestinationControlProperty, value); } }  public static readonly DependencyProperty DestinationControlProperty = DependencyProperty.Register("DestinationControl", typeof(ICommandSource), typeof(CounterpartChooserControl), new FrameworkPropertyMetadata(null, FrameworkPropertyMetadataOptions.None)); #endregion </code></pre>  <p>and in the view I need to use it I do something as</p>  <pre><code>  &lt;views4:CounterpartChooserControl Grid.Row="9" Grid.Column="1" Margin="5,2,5,2" DataContext="{Binding CounterPartModel}" &gt;         &lt;/views4:CounterpartChooserControl&gt; </code></pre>  <p>This means that I've in the viewmodel a property defined as </p>  <pre><code>[ViewModelToModel("Model")] public CounterPartModel CounterPartModel {     get { return GetValue&lt;CounterPartModel&gt;(CounterPartModelProperty); }     set { SetValue(CounterPartModelProperty, value); } }  public static readonly PropertyData CounterPartModelProperty = RegisterProperty("CounterPartModel", typeof(CounterPartModel), null); </code></pre>  <p>The problem I'm facing right now is that when the SelectedItem (which is defined in the CounterpartChooserViewModel) is changed this information is not directly propagated to the main viewmodel (and that's reasonable since it's inside a viewmodel and so the nested property is not notified in the main viewmodel).</p>  <p>Is this ok or should I have a SelectedCounterpart in the main viwemodel, bind it via XAML as   </p>  <p>and have the datacontext resolved somehow by the view itself?</p>