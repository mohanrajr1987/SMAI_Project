<p>I have a working program where the view model feed the data to the view. This is done in the constructor and also in a <em>Refresh()</em> method, as shown below. I usually put a private property referring to the view model because I want to omit casting when communicating with it.</p>  <pre><code>public class TheView {   private ViewModel TheViewModel { get; set; }    public TheView()   {     TheViewModel = new ViewModel();     DataContext = TheViewModel;   }    public Refresh()   {     TheViewModel = new ViewModel();     DataContext = TheViewModel;   } } </code></pre>  <p>Then, I got gready and started chasing lines. Since the constructor connects <em>DataContext</em> to the property <em>TheViewModel</em>, I figured I could just assign to the latter and the former would get it's stuff updated by itself. To my disappointment, I discovered that it wasn't so. The following get me the correct list of objects <strong>but</strong> the <em>DataContext</em> stays unaffected.</p>  <pre><code>public class TheView {   private ViewModel TheViewModel { get; set; }    public TheView()   {     TheViewModel = new ViewModel();     DataContext = TheViewModel;   }    public Refresh() { TheViewModel = new ViewModel(); } } </code></pre>  <p>The question is why it is so. Or rather, if it's supposed to be so. I'm thinking, in case it isn't supposed to behave like this, perhaps I have issues elsewhere in the code that poofs the flow...</p>