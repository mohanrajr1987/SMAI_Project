<p>I am trying to parallelize just the innermost loop of matrix multiplication. However, whenever there is more than 1 thread, the matrix multiplication does not store the correct values in the output array, and I am trying to figure out why.</p>  <pre><code>void matrix() { int i,j,k,sum; for (i = 0; i &lt; N; i++) {     for (j = 0; j &lt; N; j++){          sum = 0;         #pragma omp parallel for shared(sum,i,j) private(k)             for (k = 0; k &lt; N; k++) {                 #pragma omp critical                     sum = sum + A[i][k] * B[k][j];             }         C[i][j] = sum;     } } } </code></pre>  <p>I also tried using: </p>  <pre><code>void matrix() { int i,j,k,sum; for (i = 0; i &lt; N; i++) {     for (j = 0; j &lt; N; j++){          sum = 0;         #pragma omp parallel for shared(sum,i,j) private(k)             for (k = 0; k &lt; N; k++) {                 #pragma omp atomic                     sum += A[i][k] * B[k][j];             }         C[i][j] = sum;     } } } </code></pre>  <p>But that didn't work either. I also tried it without the second #pragma, and with:</p>  <pre><code>void matrixC() { int i,j,k,sum,np; for (i = 0; i &lt; N; i++) {     for (j = 0; j &lt; N; j++){          sum = 0;         #pragma omp parallel for reduction(+:sum)             for (k = 0; k &lt; N; k++) {                     sum = sum + A[i][k] * B[k][j];             }         C[i][j] = sum;     } } } </code></pre>  <p>I'm new to OpenMP but from everything I've read online, at least one of these solutions should work. I know its probably a problem with the race condition while adding to sum, but I have no idea why it's still getting the wrong sums. </p>  <p>EDIT: Here is a more complete version of the code:</p>  <pre><code>double A[N][N]; double B[N][N]; double C[N][N]; int CHOOSE = CH;  void matrixSequential() { int i,j,k,sum; for (i = 0; i &lt; N; i++) {     for (j = 0; j &lt; N; j++) {         sum = 0;         for (k = 0; k &lt; N; k++) {             sum += A[i][k] * B[k][j];         }         C[i][j] = sum;     } } }  void matrixParallel() { int i,j,k,sum; for (i = 0; i &lt; N; i++) {     for (j = 0; j &lt; N; j++){          sum = 0;         #pragma omp parallel for shared (i,j) private(k) reduction(+:sum)             for (k = 0; k &lt; N; k++) {                 sum = sum + A[i][k] * B[k][j];             }         C[i][j] = sum;     } } }  int main(int argc, const char * argv[]) { //populating arrays int i,j; for(i=0; i &lt; N; i++){     for(j=0; j &lt; N; j++){         A[i][j] = i+j;         B[i][j] = i+j;     } }  for(i=0; i &lt; N; i++){     for(j=0; j &lt; N; j++){         C[i][j] = 0;     } }  if (CHOOSE == 0) {     matrixSequential(); } else if(CHOOSE == 1) {     matrixParallel(); }  //checking for correctness double sum; for(i=0; i &lt; N; i++){     sum += C[i][i]; } printf("Sum of diagonal elements of array C: %f \n", sum); return 0; } </code></pre>