<p>I'm having a hard time believing this isn't a dupe, but I can't find <em>any</em> posts answering this question, so I'll try to make it a good one.</p>  <p>Essentially the problem is this: you have a matrix of size <code>Row X Column</code> and your number of processors is <code>P</code>.  The max size of your partition (the number of elements each processor is allocated) is <code>((Rows*Columns)/processors)+1</code>, and you'll have to do some logic to make sure you don't go out of bounds.  Each processor is assigned a starting point and must jump forward <code>P</code> indexes.</p>  <p>So on a 4x4 matrix which is sequentially numbered like the following:<br/></p>  <blockquote>   <p>[1] [2] [3] [4]<br>       [5] [6] [7] [8]<br>       [9] [10][11][12]<br>       [13][14][15][16]</p> </blockquote>  <p>a processor with id <code>0</code> would get 1, 4, 7, 10, 13, and 16. (the max partition size).</p>  <p>The algorithm my instructor gave us is like this:</p>  <blockquote>   <p>i / columns = row# and i % columns = column# </p> </blockquote>  <p>This worked for the examples he gave us like <code>6 / 4 = 1</code> and <code>6 % 4 = 2</code> so 6 is at index <code>[1][2]</code> The logic is intuitive at least, but fails on several occasions.</p>  <p>So what is an algorithm which can reliably produce the indexes of the desired values on an <code>NxM</code> matrix?</p>