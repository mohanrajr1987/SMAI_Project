<p>I had an idea for an asynchronous parallel program for a data science application. Considering a shared-memory system with one "master" and 20 "slaves". It would have a matrix at the master node; the slaves would read the value of the matrix, do some operations using random numbers and the return value would modify some elements of the matrix (asynchronously, allowing for overwrites; i.e. the slave who came 2nd could overwrite some of the work done by the slave who came 1st). </p>  <p>I know this can be done in <code>pthreads</code> but I didn't want to spend energy coding it up before having some prototype. </p>  <p>I wrote a parallel program simulator in MATLAB which:</p>  <ul> <li>One-at-a-time and sequentially, does the operation which the slave would do and records the time. Store that in a vector called NEXT_EVENT_TIME_ARRAY.</li> <li>Adds an artificial delay to that time (= how_many_procs * BANDWIDTH_CONSTANT * size_of_M_in_megabytes)</li> <li>Set CURRENT_TIME = 0</li> </ul>  <p>Now, we loop:</p>  <ul> <li>Picks the slave with minimum time as the one that "finished first in parallel"</li> <li>Set the value of CURRENT_TIME as CURRENT_TIME + this (minimum) time. </li> <li>This slave is then asked to do the same operation again with the updated matrix (the return value would change because the process involves random numbers). </li> <li>Record the time needed for the slave to finish and update the corresponding element of NEXT_EVENT_TIME_ARRAY to be CURRENT_TIME + time the slave took to finish computation with new value of M.</li> <li>Loop for a few iterations!</li> </ul>  <p>I will pick the BANDWIDTH_CONSTANT to match my computer.  Is this is a reasonable model to get a proof-of-concept whether my algorithm will work in the asynchronous setting?</p>