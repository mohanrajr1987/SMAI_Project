<p>I'm using locationA.distanceTo(locationB) method for retrieving the distance user walks (or runs) in kms, but it gets absolutely wrong values (something like 19 kms while I'm simply on stairs)! I cannot guess what's wrong...</p>  <pre><code>    static final long TIME_UPDATES = 10000; // 10 seconds     static final long MINIMUM_TIME_UPDATES = 5000; // 5 seconds     GoogleApiClient mGoogleApiClient;     Location mFirstLocation;     Location mLastLocation;     Location mCurrentLocation;     double distance=0.00;     protected LocationManager locationManager;     LocationRequest mLocationRequest;  public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {         locationManager = (LocationManager) getActivity().getSystemService(Context.LOCATION_SERVICE);         View v =inflater.inflate(R.layout.tab_1,container,false);         createLocationRequest();         newGoogleClient();         ButterKnife.inject(this, v);         return v;     }     protected synchronized void newGoogleClient() {         mGoogleApiClient = new GoogleApiClient.Builder(getActivity())                 .addConnectionCallbacks(this)                 .addOnConnectionFailedListener(this)                 .addApi(LocationServices.API)                 .build();     }     @OnClick({R.id.button_start, R.id.button_pause, R.id.button_stop})     public void OnSession(View view) {          switch (view.getId()) {              case R.id.button_start:                  startRun();                 break;              case R.id.button_pause:                 timeTemp = timeAtStop;                 customHandler.removeCallbacks(updated);                 LocationServices.FusedLocationApi.removeLocationUpdates(mGoogleApiClient, this);                 break;             case R.id.button_stop:                 timeTemp = 0L;                 mGoogleApiClient.disconnect();                 customHandler.removeCallbacks(updated);                 onDialog(this.getArguments());                  break;         }      }     private Runnable updated = new Runnable() {         @Override         public void run() {             milliTime = SystemClock.uptimeMillis() - timeAtStart;             timeAtStop = timeTemp + milliTime;             int seconds = (int) (timeAtStop / 1000);             int minutes = seconds / 60;             totalTime = minutes;             int hours = minutes / 60;             seconds = seconds % 60;             minutes = minutes % 60;              if (mGoogleApiClient.isConnected())                 startLocationUpdates();             else                 mGoogleApiClient.connect();             timerValue.setText(String.format("%02d", hours) + ":" + String.format("%02d", minutes) + ":" + String.format("%02d", seconds));             if (mLastLocation != null)                 updateDistance();             customHandler.postDelayed(this, 0);          }     };      public void onConnected(Bundle connectionHint) {         mFirstLocation = LocationServices.FusedLocationApi.getLastLocation(mGoogleApiClient);         mLastLocation = LocationServices.FusedLocationApi.getLastLocation(mGoogleApiClient);         mCurrentLocation = mLastLocation;         if (mLastLocation == null) {             mLastLocation = new Location(mCurrentLocation);         }         else{             startLocationUpdates();             updateDistance();         }      }     protected void createLocationRequest() {         mLocationRequest = new LocationRequest();         mLocationRequest.setInterval(TIME_UPDATES);         mLocationRequest.setFastestInterval(MINIMUM_TIME_UPDATES);         mLocationRequest.setPriority(LocationRequest.PRIORITY_HIGH_ACCURACY);     }     protected void startLocationUpdates() {         LocationServices.FusedLocationApi.requestLocationUpdates(mGoogleApiClient, mLocationRequest, this);     }     public void onConnectionSuspended(int i) {         Log.i(TAG, "GoogleAPI has been suspended");     }       @Override     public void onConnectionFailed(ConnectionResult result) {         if (mResolvingError) {             // Already attempting to resolve an error.             return;         } else if (result.hasResolution()) {             try {                 mResolvingError = true;                 result.startResolutionForResult(getActivity(), REQUEST_RESOLVE_ERROR);             } catch (IntentSender.SendIntentException e) {                 // There was an error with the resolution intent. Try again.                 mGoogleApiClient.connect();             }         } else {             // Show dialog using GoogleApiAvailability.getErrorDialog()             errorDialog(result.getErrorCode());             mResolvingError = true;         }     }     @Override     public void onLocationChanged(Location location) {         mLastLocation = mCurrentLocation;         mCurrentLocation = location;         //updateDistance();     }      public void updateDistance() {         if (!mLastLocation.equals(mCurrentLocation)) {         distance += mLastLocation.distanceTo(mCurrentLocation) / 1000;          }         //uso Locale.US per usare il punto al posto delle virgole        Log.i(TAG, new Double(distance).toString());         String dist = String.format(Locale.US, "%.2f", distance);         distanceValue.setText(dist);     } </code></pre>