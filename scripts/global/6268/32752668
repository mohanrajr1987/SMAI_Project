<p>I've written script to temporarily delete files in Unix and then save the file path so they can be restored. I have 2 functions, one to delete files, and one to delete a directory that also recursively deletes files. I have the appropriate commands to recognize the directory name and path as well as checking to see if files remain in the directory and then deleting them. At first I was getting an infinite loop but I made some changes and now, it's saying there is no such file or directory when I try to delete a directory. It still runs through the code but it doesn't delete any files. Can anyone figure this out?</p>  <pre><code>    #!/bin/bash     #checks to see if deleted folder exists. If it doesn't, it is created.     if [ ! -d ~/deleted ];       then           mkdir ~/deleted     fi     if [ ! -f ~/.restore.info ] ;        then           touch ~/.restore.info     fi     function recur_delete {     dir=$1 #this will indicate the directory name only     dirpath=$(dirname $dir) #gets the directory path    if [ "$( ls -A /$dirpath/$dir)" ]; #determines if the directory contains files.    then       filename=$(find dirpath/dir -type f -printf "%f\n" | head -1)       delete_file $filename #filename is found and sent to delete_file function to be deleted.       recur_delete $dir #function is called again to see if more files are present.       else        echo Directory is empty, the directory will be deleted        echo $dirpath/$dir &gt;&gt; ~/.restore.info        rmdir ${dirpath/$dir}  fi      }     function delete_file {     inode=$(stat -c%i $filename) #grabs inode # for the chosen filename.     filename=$1 #reinitializes the variable filename as the first argument     pwd=$(readlink -e $filename) #This gets the entire path for the chosen file       if $interactive         then           if [ $verbose = true ];                  then                  read -p "Are you SURE you want to delete $filename ????" i_input                      if [ $i_input == "y"  ] || [ $i_input == "Y" ];                          then                          mv $filename ~/deleted/${filename}_$inode                          echo ${filename}_$inode:$pwd &gt;&gt; ~/.restore.info                          echo $filename has been deleted. Congrats.                              else                              echo Nothing has been done, the file or files remain.                      fi                 else                     read -p "Are you SURE you want to delete $filename ????" i_input                     if [ $i_input == "y"  ] || [ $i_input == "Y" ];                       then                       mv $filename ~/deleted/${filename}_$inode                       echo ${filename}_$inode:$pwd &gt;&gt; ~/.restore.info                          else                          echo Aborted                     fi           fi       elif $verbose         then          mv $filename ~/deleted/${filename}_$inode          echo ${filename}_$inode:$pwd &gt;&gt; ~/.restore.info          echo $filename has been deleted. Congrats.       else          mv $filename ~/deleted/${filename}_$inode          echo ${filename}_$inode:$pwd &gt;&gt; ~/.restore.info          echo Executed     fi     }     interactive=false     verbose=false     recursive=false     while getopts ivr OPTION     do       case $OPTION in         i) interactive=true;;         v) verbose=true;;         r) recursive=true;;       esac     done     shift $[OPTIND-1]     for i in $*       do     filename=$i     basefile=$(basename $i)     if [ "$i" == "" ];        then          echo No file provided         elif [ -d $filename ];          then             if [ $recursive = true ];                then                  recur_delete $filename                else                echo This is a directory, please provide a file name.             fi        elif [ ! -f $filename ];         then          echo File does not exist        elif [ "$basefile" == "safe_rm" ];          then           echo Attempting to delete safe_rm - operation aborted!!!!     #This is the line that takes the filename to be deleted and modifies the     #experience based on what the user wants.     else        delete_file $filename     fi     done </code></pre>