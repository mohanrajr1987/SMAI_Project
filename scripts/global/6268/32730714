<p>The following code works but not sure if it is the right way. A few questions:</p>  <ul> <li>Should I use <code>Path</code> or <code>PathBuf</code>?</li> <li>Should I use <code>AsRef</code>?</li> <li>Do I need <code>PathBuf::from(path)</code> in order to have path owned by the struct?</li> </ul>    <pre><code>use std::fmt; use std::path::PathBuf;  struct Example {     path: PathBuf, }  impl fmt::Display for Example {     fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {         write!(f, "{}", self.path.to_str().unwrap())     } }  impl Example {      fn new(path: &amp;PathBuf) -&gt; Example {         // Do something here with path.         Example {             path: PathBuf::from(path),         }     } }  fn main() {     let x = Example::new(&amp;PathBuf::from("test.png"));     println!("{}", x); } </code></pre>  <p>Some context: I am trying to have a high-level abstraction over a file that should know its own path. Maybe the design is plain wrong.</p>