<p>I am animating several React.js components based on their position in the viewport. If the component is in the viewport, animate the opacity to 1, if it's not in the viewport, animate its opacity to 0. I am using <code>getBoundingClient()</code>'s <code>top</code> and <code>bottom</code> properties to determine if the component is within the viewport.</p>  <p>ComponentA shows the pattern I followed for the other B, C, and D components. They each are listening for the <code>window</code> scroll event. </p>  <p>Is this the "React" way to do this by each component having its having to add an event listener to the <code>window</code>? Multiple scroll event listeners on the same window?  </p>  <p>Or is there a better way by adding the scroll event listener to the window once at the <code>Home</code> owner component? Then would the ownee child components still be able to know where they are in the DOM using the <code>getBoundingClient()</code>?</p>  <pre><code>Home = React.createClass({  render: function() {     &lt;div&gt;        &lt;ComponentA /&gt;        &lt;ComponentB /&gt;        &lt;ComponentC /&gt;        &lt;ComponentD /&gt;     &lt;/div&gt;   }; });  ComponentA = React.createClass({   componentDidMount: function() {    window.addEventListener('scroll', this.handleScroll); },   componentWillUnmount: function() {     window.removeEventListener('scroll', this.handleScroll);    },  handleScroll: function() {   var domElement = this.refs.domElement.getDOMNode();   this.inViewPort(domElement); },  inViewPort: function(element) {   var elementBounds = element.getBoundingClientRect();   (elementBounds.top &lt;= 769 &amp;&amp; elementBounds.bottom &gt;= 430) ? TweenMax.to(element, 1.5, { opacity: 1 }) : TweenMax.to(element, 1.5, { opacity: 0 }); }, render: function() {   return (/* html to render */);  }  }); </code></pre>