<p>I have a RDD of this type:</p>  <pre><code>[(1, [3, 10, 11]), (2, [3, 4, 10, 11]), (3, [1, 4]), (4, [2, 3, 10])...] </code></pre>  <p>And I need a function that follows this rule:</p>  <p><strong>if the key <code>x</code> does not contain the key <code>y</code> (and vice versa) in its value-list</strong>, then outputs a tuple having the following syntax:</p>  <pre><code>[(x, [y, len(values_x ^ values_y)]), ...] </code></pre>  <p>where <code>len(values_x ^ values_y)</code> is the number of values in common between the two keys. If this value is <code>0</code> (i.e., no values in common), just skip this pair of keys.</p>  <p>E.g., from the sample above, the output should be:</p>  <pre><code>(1, [2, 3]) # because keys 1 and 2 share the values 3, 10, 11 (1, [4, 2]) # because keys 1 and 4 share the values 3, 10 skipping: (2, [1, 3]) is the inverse of (1, [2, 3]), so it can be skipped (2, [3, 1]) # because keys 2 and 3 share the value 4 ... </code></pre>  <p>The pair of keys <code>1</code> and <code>3</code> (and other similar cases) is skipped because key <code>3</code> is included in the list-value of key <code>1</code> and vice versa.</p>  <p>A solution that I've implemented (but I don't like at all), is using the <code>cartesian</code> function to create all the combinations between keys and then a mapping and a filtering to delete unnecessary pairs.</p>  <p>Is there a better solution without using <code>cartesian</code>?</p>