<p>I am using JPA, Hibernate, Spring and MySQL.</p>  <p>I am trying to use an <code>UserDetailsService</code> to authenticate users from my MySQL database using hibernate. But it works sometimes when I am stepping though a breakpoint <code>auth.userDetailsService(customAuthenticationProvider);</code> in netbeans</p>  <p>CustomUserDetailsService</p>  <pre><code>import com.fotoshop.dao.UserDAO; import com.fotoshop.model.Account; import com.fotoshop.model.Role; import java.util.ArrayList; import java.util.Collection; import java.util.List;  import org.springframework.beans.factory.annotation.Autowired; import org.springframework.security.core.GrantedAuthority; import org.springframework.security.core.authority.SimpleGrantedAuthority; import org.springframework.security.core.userdetails.User; import org.springframework.security.core.userdetails.UserDetails; import org.springframework.security.core.userdetails.UserDetailsService; import org.springframework.security.core.userdetails.UsernameNotFoundException; import org.springframework.stereotype.Service;  @Service public class CustomUserDetailsService implements UserDetailsService {      @Autowired     private UserDAO userDAO;          public UserDetails loadUserByUsername(String login)             throws UsernameNotFoundException {                    Account domainUser = userDAO.getUser(login);          boolean enabled = true;         boolean accountNonExpired = true;         boolean credentialsNonExpired = true;         boolean accountNonLocked = true;          return new User(                 domainUser.getUsername(),                  domainUser.getPassword(),                  enabled,                  accountNonExpired,                  credentialsNonExpired,                  accountNonLocked,                 getGrantedAuthorities(domainUser.getRoleCollection())         );     }         public static List&lt;GrantedAuthority&gt; getGrantedAuthorities(Collection&lt;Role&gt; roles) {         List&lt;GrantedAuthority&gt; authorities = new ArrayList&lt;GrantedAuthority&gt;();          for (Role role : roles) {             authorities.add(new SimpleGrantedAuthority(role.getName()));         }         return authorities;     }  } </code></pre>  <p>SecurityConfig</p>  <pre><code>import com.fotoshop.service.CustomUserDetailsService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Configuration; import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder; import org.springframework.security.config.annotation.web.builders.HttpSecurity; import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity; import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter; import org.springframework.security.web.util.AntPathRequestMatcher; import org.springframework.transaction.annotation.EnableTransactionManagement;  @Configuration @EnableWebSecurity @EnableTransactionManagement @ComponentScan(basePackages = {"com.fotoshop"}) public class SecurityConfig extends WebSecurityConfigurerAdapter {      @Autowired     private CustomUserDetailsService customAuthenticationProvider;      protected void configure(AuthenticationManagerBuilder auth) throws Exception {         auth.userDetailsService(customAuthenticationProvider);     }  //    @Autowired //    public void configureUsers(AuthenticationManagerBuilder auth) throws Exception { //        auth.inMemoryAuthentication().withUser("user1").password("pwd").roles("USER").and().withUser("admin").password("admin_pwd").roles("USER", "ADMIN"); //    }      @Override     protected void configure(HttpSecurity http) throws Exception {         http.authorizeRequests().antMatchers("/resources/css/**").permitAll().anyRequest().authenticated();         http.authorizeRequests().antMatchers("/logout").permitAll().anyRequest().authenticated();         http.authorizeRequests().anyRequest().authenticated();         http.formLogin().loginPage("/login").permitAll();          AntPathRequestMatcher pathRequestMatcher = new  AntPathRequestMatcher("/logout");  http.logout().logoutRequestMatcher(pathRequestMatcher);      }  } </code></pre>  <p>Role service and implementation </p>  <pre><code>import com.fotoshop.model.Role;  public interface RoleService {      public Role getRole(String id);  }  import com.fotoshop.dao.RoleDAO; import com.fotoshop.model.Role; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import org.springframework.transaction.annotation.Transactional;  @Service @Transactional public class RoleServiceImpl implements RoleService {      @Autowired     private RoleDAO roleDAO;      public Role getRole(String id) {         return roleDAO.getRole(id);     }  } </code></pre>  <p>User service and implementation </p>  <pre><code>import com.fotoshop.model.Account;  public interface UserService {      public Account getUser(String login);  }  import com.fotoshop.dao.UserDAO; import com.fotoshop.model.Account; import org.springframework.transaction.annotation.Transactional;   import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service;   @Service @Transactional public class UserServiceImpl implements UserService {      @Autowired     private UserDAO userDAO;      public Account getUser(String login) {         return userDAO.getUser(login);     }  } </code></pre>  <p>Role DAO and implementation </p>  <pre><code>package com.fotoshop.dao;  import com.fotoshop.model.Role;   public interface RoleDAO {      public Role getRole(String id);  }  import com.fotoshop.model.Role; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Repository;  import org.hibernate.Session; import org.hibernate.SessionFactory;  @Repository public class RoleDAOImpl implements RoleDAO {      @Autowired     private SessionFactory sessionFactory;      private Session getCurrentSession() {         return sessionFactory.getCurrentSession();     }      public Role getRole(String id) {         Role role = (Role) getCurrentSession().load(Role.class, id);         return role;     }  } </code></pre>  <p>User DAO and implementation </p>  <pre><code>import com.fotoshop.model.Account;   public interface UserDAO {      public Account getUser(String login);  }  import com.fotoshop.model.Account; import java.util.ArrayList; import java.util.List;  import org.springframework.beans.factory.annotation.Autowired; import org.hibernate.Query; import org.hibernate.Session; import org.hibernate.SessionFactory; import org.springframework.stereotype.Repository;  @Repository public class UserDAOImpl implements UserDAO {      @Autowired     private SessionFactory sessionFactory;      private Session openSession() {         return sessionFactory.getCurrentSession();     }      public Account getUser(String login) {         List&lt;Account&gt; userList = new ArrayList&lt;Account&gt;();         Query query = openSession().createQuery("from Account u WHERE u.username = :username");         query.setParameter("username", login);         userList = query.list();         if (userList.size() &gt; 0)             return userList.get(0);         else             return null;         }  } </code></pre>  <p>Role entity</p>  <pre><code>@Entity @Table(name = "Role", catalog = "photoshop", schema = "") @XmlRootElement @NamedQueries({     @NamedQuery(name = "Role.findAll", query = "SELECT r FROM Role r"),     @NamedQuery(name = "Role.findByName", query = "SELECT r FROM Role r WHERE r.name = :name"),     @NamedQuery(name = "Role.findByDescription", query = "SELECT r FROM Role r WHERE r.description = :description")}) public class Role implements Serializable {     private static final long serialVersionUID = 1L;     @Id     @Basic(optional = false)     @NotNull     @Size(min = 1, max = 20)     @Column(name = "Name")     private String name;     @Size(max = 50)     @Column(name = "Description")     private String description;     @JoinTable(name = "Role_Account", joinColumns = {         @JoinColumn(name = "RoleName", referencedColumnName = "Name")}, inverseJoinColumns = {         @JoinColumn(name = "AccountUsername", referencedColumnName = "Username")})     @ManyToMany     private Collection&lt;Account&gt; accountCollection;      public Role() {     }      public Role(String name) {         this.name = name;     }      public String getName() {         return name;     }      public void setName(String name) {         this.name = name;     }      public String getDescription() {         return description;     }      public void setDescription(String description) {         this.description = description;     }      @XmlTransient     public Collection&lt;Account&gt; getAccountCollection() {         return accountCollection;     }      public void setAccountCollection(Collection&lt;Account&gt; accountCollection) {         this.accountCollection = accountCollection;     }      @Override     public int hashCode() {         int hash = 0;         hash += (name != null ? name.hashCode() : 0);         return hash;     }      @Override     public boolean equals(Object object) {         // TODO: Warning - this method won't work in the case the id fields are not set         if (!(object instanceof Role)) {             return false;         }         Role other = (Role) object;         if ((this.name == null &amp;&amp; other.name != null) || (this.name != null &amp;&amp; !this.name.equals(other.name))) {             return false;         }         return true;     }      @Override     public String toString() {         return "com.fotoshop.dao.Role[ name=" + name + " ]";     }  } </code></pre>  <p>Account entity</p>  <pre><code>@Entity @Table(name = "Account", catalog = "photoshop", schema = "") @XmlRootElement @NamedQueries({     @NamedQuery(name = "Account.findAll", query = "SELECT a FROM Account a"),     @NamedQuery(name = "Account.findByUsername", query = "SELECT a FROM Account a WHERE a.username = :username"),     @NamedQuery(name = "Account.findByPassword", query = "SELECT a FROM Account a WHERE a.password = :password"),     @NamedQuery(name = "Account.findByFirstname", query = "SELECT a FROM Account a WHERE a.firstname = :firstname"),     @NamedQuery(name = "Account.findByLastname", query = "SELECT a FROM Account a WHERE a.lastname = :lastname"),     @NamedQuery(name = "Account.findByEmail", query = "SELECT a FROM Account a WHERE a.email = :email"),     @NamedQuery(name = "Account.findByTelephoneNumber", query = "SELECT a FROM Account a WHERE a.telephoneNumber = :telephoneNumber"),     @NamedQuery(name = "Account.findByAddress", query = "SELECT a FROM Account a WHERE a.address = :address"),     @NamedQuery(name = "Account.findByCity", query = "SELECT a FROM Account a WHERE a.city = :city"),     @NamedQuery(name = "Account.findByZipcode", query = "SELECT a FROM Account a WHERE a.zipcode = :zipcode")}) public class Account implements Serializable {     private static final long serialVersionUID = 1L;     @Id     @Basic(optional = false)     @NotNull     @Size(min = 1, max = 25)     @Column(name = "Username")     private String username;     @Size(max = 50)     @Column(name = "Password")     private String password;     @Size(max = 25)     @Column(name = "Firstname")     private String firstname;     @Size(max = 25)     @Column(name = "Lastname")     private String lastname;     // @Pattern(regexp="[a-z0-9!#$%&amp;'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&amp;'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?", message="Invalid email")//if the field contains email address consider using this annotation to enforce field validation     @Size(max = 50)     @Column(name = "Email")     private String email;     @Size(max = 25)     @Column(name = "TelephoneNumber")     private String telephoneNumber;     @Size(max = 25)     @Column(name = "Address")     private String address;     @Size(max = 25)     @Column(name = "City")     private String city;     @Size(max = 10)     @Column(name = "Zipcode")     private String zipcode;     @ManyToMany(mappedBy = "accountCollection", cascade = CascadeType.ALL)     private Collection&lt;Role&gt; roleCollection;     @JoinTable(name = "PhotoAlbum_Account", joinColumns = {         @JoinColumn(name = "AccountUsername", referencedColumnName = "Username")}, inverseJoinColumns = {         @JoinColumn(name = "PhotoAlbumID", referencedColumnName = "ID")})     @ManyToMany     private Collection&lt;PhotoAlbum&gt; photoAlbumCollection;     @OneToMany(mappedBy = "accountUsername")     private Collection&lt;Delivery&gt; deliveryCollection;     @OneToOne(cascade = CascadeType.ALL, mappedBy = "account")     private Photographer photographer;      @Autowired     @Transient     SessionFactory sessionFactory;      @Transactional     public void SaveOrUpdate(Account account) {         sessionFactory.getCurrentSession().saveOrUpdate(account);     }      public Account() {     }      public Account(String username) {         this.username = username;     }      public String getUsername() {         return username;     }      public void setUsername(String username) {         this.username = username;     }      public String getPassword() {         return password;     }      public void setPassword(String password) {         this.password = password;     }      public String getFirstname() {         return firstname;     }      public void setFirstname(String firstname) {         this.firstname = firstname;     }      public String getLastname() {         return lastname;     }      public void setLastname(String lastname) {         this.lastname = lastname;     }      public String getEmail() {         return email;     }      public void setEmail(String email) {         this.email = email;     }      public String getTelephoneNumber() {         return telephoneNumber;     }      public void setTelephoneNumber(String telephoneNumber) {         this.telephoneNumber = telephoneNumber;     }      public String getAddress() {         return address;     }      public void setAddress(String address) {         this.address = address;     }      public String getCity() {         return city;     }      public void setCity(String city) {         this.city = city;     }      public String getZipcode() {         return zipcode;     }      public void setZipcode(String zipcode) {         this.zipcode = zipcode;     }      @XmlTransient     public Collection&lt;Role&gt; getRoleCollection() {         return roleCollection;     }      public void setRoleCollection(Collection&lt;Role&gt; roleCollection) {         this.roleCollection = roleCollection;     }      @XmlTransient     public Collection&lt;PhotoAlbum&gt; getPhotoAlbumCollection() {         return photoAlbumCollection;     }      public void setPhotoAlbumCollection(Collection&lt;PhotoAlbum&gt; photoAlbumCollection) {         this.photoAlbumCollection = photoAlbumCollection;     }      @XmlTransient     public Collection&lt;Delivery&gt; getDeliveryCollection() {         return deliveryCollection;     }      public void setDeliveryCollection(Collection&lt;Delivery&gt; deliveryCollection) {         this.deliveryCollection = deliveryCollection;     }      public Photographer getPhotographer() {         return photographer;     }      public void setPhotographer(Photographer photographer) {         this.photographer = photographer;     }      @Override     public int hashCode() {         int hash = 0;         hash += (username != null ? username.hashCode() : 0);         return hash;     }      @Override     public boolean equals(Object object) {         // TODO: Warning - this method won't work in the case the id fields are not set         if (!(object instanceof Account)) {             return false;         }         Account other = (Account) object;         if ((this.username == null &amp;&amp; other.username != null) || (this.username != null &amp;&amp; !this.username.equals(other.username))) {             return false;         }         return true;     }      @Override     public String toString() {         return "com.fotoshop.dao.Account[ username=" + username + " ]";     }  } </code></pre>