<p>This is going to be somewhat long, but I am simply trying to learn fancy things using spring 4.1.7</p>  <p>The problem that I am facing is that spring doesn't like that there is no bean declared for R and W in the Reader and Writer Controllers. Everything compiles but during runtime nothing works and I get error</p>  <pre><code>Error creating bean with name 'userController': Injection of autowired dependencies failed; nested exception is org.springframework.beans.factory.BeanCreationException: Could not autowire field: protected carefree.coding.dao.CommerceReaderDAO carefree.coding.controllers.rest.CommerceReaderController.reader; nested exception is java.lang.IllegalArgumentException: Can not set carefree.coding.dao.CommerceReaderDAO field carefree.coding.controllers.rest.CommerceReaderController.reader to com.sun.proxy.$Proxy57 </code></pre>  <p>I have a simple DAO class</p>  <pre><code>@MappedSuperclass public abstract class CommerceObject {     public enum Type     {         USER     }      @Transient     protected Type type;      @Id     @GeneratedValue     @Column(name = "id")     protected long id;      public CommerceObject(Type type)     {         this.type = type;         setId(-1l);     }      public Type getType()     {         return type;     }      public long getId()     {         return id;     }      public void setId(long id)     {         this.id = id;     }      public boolean equals(CommerceObject object)     {         return getId() == object.getId() &amp;&amp; getType().equals(object.getType());     }      @Override     public String toString()     {         return new Gson().toJson(this);     }      public CommerceObject fromString(String json)     {         return new Gson().fromJson(json, getClass());     }      public abstract boolean update(CommerceObject object);      public abstract CommerceObject copy();      @Override     public int hashCode()     {         throw new UnsupportedOperationException("No hashing for game objects");     } } </code></pre>  <p>Which is extended by</p>  <pre><code>@Entity(name = "user") public class User extends CommerceObject {     @Column(name = "email")     private String email;      public User()     {         super(Type.USER);     }      public String getEmail()     {         return email;     }      public void setEmail(String email)     {         this.email = email;     }      @Override     public boolean update(CommerceObject object)     {         if (object instanceof User)         {             User user = (User) object;             if (equals(user))             {                 user.setEmail(email);             }         }         return false;     }      @Override     public CommerceObject copy()     {         User user = new User();         user.setEmail(getEmail());         return user;     } } </code></pre>  <p>For reading and writing things to database I have two interfaces</p>  <p><strong>Reader</strong></p>  <pre><code>public interface CommerceReaderInterface&lt;V extends CommerceObject&gt; {     @Transactional(readOnly = true)     List&lt;V&gt; get();      @Transactional(readOnly = true)     V get(long id); } </code></pre>  <p><strong>Writer</strong></p>  <pre><code>public interface CommerceWriterInterface&lt;V extends CommerceObject&gt; {     @Transactional     V add(V v);      @Transactional     V update(V v);      @Transactional     V delete(V v); } </code></pre>  <p>Basic database access class</p>  <pre><code>public abstract class CommerceDAO {     protected SessionFactory sessionFactory;     protected Class aClass;      public CommerceDAO(SessionFactory sessionFactory, Class aClass)     {         this.sessionFactory = sessionFactory;         this.aClass = aClass;     } } </code></pre>  <p>Which allows reader and writer to exist</p>  <p><strong>Reader</strong></p>  <pre><code>public class CommerceReaderDAO&lt;V extends CommerceObject&gt; extends CommerceDAO implements CommerceReaderInterface&lt;V&gt; {     public CommerceReaderDAO(SessionFactory sessionFactory, Class aClass)     {         super(sessionFactory, aClass);     }      @Override     public List&lt;V&gt; get()     {         ClassMetadata hibernateMetadata = sessionFactory.getClassMetadata(aClass);         if (hibernateMetadata == null)         {             return null;         }         if (hibernateMetadata instanceof AbstractEntityPersister)         {             AbstractEntityPersister persister = (AbstractEntityPersister) hibernateMetadata;             String tableName = persister.getTableName();             if (tableName != null)             {                 return sessionFactory.getCurrentSession().                         createQuery(tableName).list();             }         }         return null;     }      @Override     public V get(long id)     {         V object = (V) sessionFactory.getCurrentSession().                 get(aClass, id);         Hibernate.initialize(object);         return object;     } } </code></pre>  <p><strong>Writer</strong></p>  <pre><code>public class CommerceWriterDAO&lt;V extends CommerceObject&gt; extends CommerceDAO implements CommerceWriterInterface&lt;V&gt; {     public CommerceWriterDAO(SessionFactory sessionFactory, Class aClass)     {         super(sessionFactory, aClass);     }      @Override     public V add(V v)     {         if (v != null)         {             sessionFactory.getCurrentSession().save(v);             return v;         }         return null;     }      @Override     public V update(V v)     {         if (v != null)         {             sessionFactory.getCurrentSession().update(v);             return v;         }         return null;     }      @Override     public V delete(V v)     {         if (v != null)         {             sessionFactory.getCurrentSession().delete(v);             sessionFactory.getCurrentSession().flush();             return v;         }         return null;     } } </code></pre>  <p>And for controllers I decided to do same thing and have a reader and writer interface</p>  <p><strong>Reader</strong></p>  <pre><code>public interface CommerceReaderInterface {     @RequestMapping(value = "/get",             method = RequestMethod.GET,             produces = MediaType.APPLICATION_JSON_VALUE)     ResponseEntity&lt;String&gt; get();      @RequestMapping(value = "/get/{id}",             method = RequestMethod.GET,             produces = MediaType.APPLICATION_JSON_VALUE)     ResponseEntity&lt;String&gt; get(@PathVariable long id); } </code></pre>  <p><strong>Writer</strong></p>  <pre><code>public interface CommerceWriterInterface&lt;V extends CommerceObject&gt; {     @RequestMapping(value = "/add",             method = RequestMethod.POST,             produces = MediaType.APPLICATION_JSON_VALUE)     ResponseEntity&lt;String&gt; add(@RequestBody V v);      @RequestMapping(value = "/update",             method = RequestMethod.POST,             produces = MediaType.APPLICATION_JSON_VALUE)     ResponseEntity&lt;String&gt; update(@RequestBody V v);      @RequestMapping(value = "/delete",             method = RequestMethod.POST,             produces = MediaType.APPLICATION_JSON_VALUE)     ResponseEntity&lt;String&gt; delete(@RequestBody V v); } </code></pre>  <p>And they are implemented normally</p>  <p><strong>Reader</strong></p>  <pre><code>public abstract class CommerceReaderController&lt;R extends CommerceReaderDAO&lt;V&gt;, V extends CommerceObject&gt; implements CommerceReaderInterface {     @Autowired     protected R reader;      @Override     public ResponseEntity&lt;String&gt; get()     {         List&lt;V&gt; list = reader.get();         if (list == null || list.isEmpty())         {             return ResponseUtil.notFound();         }         return ResponseUtil.ok(list);     }      @Override     public ResponseEntity&lt;String&gt; get(@PathVariable long id)     {         V object = reader.get(id);         if (object == null)         {             return ResponseUtil.notFound();         }         return ResponseUtil.ok(object);     } } </code></pre>  <p><strong>Writer</strong></p>  <pre><code>public abstract class CommerceWriterController&lt;W extends CommerceWriterDAO&lt;V&gt;, R extends CommerceReaderDAO&lt;V&gt;, V extends CommerceObject&gt; extends CommerceReaderController&lt;R, V&gt; implements CommerceWriterInterface&lt;V&gt; {     @Autowired     protected W writer;      @Override     public ResponseEntity&lt;String&gt; add(@RequestBody V v)     {         v = writer.add(v);         if (v == null)         {             return ResponseUtil.notFound();         }         return ResponseUtil.ok(v);     }      @Override     public ResponseEntity&lt;String&gt; update(@RequestBody V v)     {         v = writer.update(v);         if (v == null)         {             return ResponseUtil.notFound();         }         return ResponseUtil.ok(v);     }      @Override     public ResponseEntity&lt;String&gt; delete(@RequestBody V v)     {         v = writer.delete(v);         if (v == null)         {             return ResponseUtil.notFound();         }         return ResponseUtil.ok(v);     } } </code></pre>  <p>After all that work I thought that having a simple controller would be allowed</p>  <pre><code>@Controller @RequestMapping("/commerce/api/user") public class UserController extends CommerceWriterController&lt;UserWriterDAO, UserReaderDAO, User&gt; { } </code></pre>  <p>However as I understand in my abstract controllers I am not allowed to have such vague DAO objects. Is there any way I can circumvent this?</p>