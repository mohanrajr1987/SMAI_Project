<p>Here is a simplified version of my code:</p>  <pre><code>class foo:     def __init__(self, thing):         self.thing = thing  def bar():     foo = foo('test')  bar() </code></pre>  <p>And here's what it produces:</p>  <pre><code>Traceback (most recent call last):   File "filepath", line 8, in &lt;module&gt;     bar()   File "filepath", line 6, in bar     foo = foo('test') UnboundLocalError: local variable 'foo' referenced before assignment </code></pre>  <p>I have a two part question regarding this.</p>  <p>Firstly, <strong>how can I get around this</strong>? After some Googling I found that adding a <code>global foo</code> before the <code>foo = foo('test')</code> line does the trick. But the general consensus seems to be that global variables are bad things to be avoided, so is there a way around this that doesn't use global variables?</p>  <p>And secondly, <strong>why is this actually happening?</strong> I understand about functions only being able to access variables created inside that function (and global variables of course). But I'm not trying to access a variable that was defined outside of the function, I'm just creating a new one. Logically speaking, why is it forbidden to create a new object inside a function (unless you declare it as global first)?</p>