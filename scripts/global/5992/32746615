<p>Apparently, <a href="https://www.reddit.com/r/javascript/comments/2xsdwp/how_do_you_namespace_with_es6/" rel="nofollow">ES6 doesn't need namespacing</a> because each file is a separate module.</p>  <p>But then, how do I avoid global namespace interference?</p>  <p>For example, <a href="https://babeljs.io" rel="nofollow">Babel</a> compiles my <code>scripts/main.js</code> file by merely replacing <code>const</code> with <code>var</code>.</p>  <p><div class="snippet" data-lang="js" data-hide="false"> <div class="snippet-code"> <pre class="snippet-code-js lang-js prettyprint-override"><code>var alert = 'This line doesn\'t do anything.' window.alert(alert)</code></pre> </div> </div> </p>  <p>A namespace (named <code>ANS</code> below) with an IIFE prevents name collisions:</p>  <p><div class="snippet" data-lang="js" data-hide="false"> <div class="snippet-code"> <pre class="snippet-code-js lang-js prettyprint-override"><code>const ANS = (function () {   const alert = 'This works'   window.alert(alert + '.')   return {alert: alert + ' too.'} })() alert(ANS.alert)</code></pre> </div> </div> </p>  <p>Adding properties to the namespace <code>ANS</code> is cleaner than adding them to the global namespace, <code>window</code>, or <code>this</code>. And, the IIFE provides further encapsulation.</p>  <p>So, isn't the second way, i.e., creating a custom namespace with an IIFE, better than the first? If so, is there a newer/nicer way of doing this in ES2015? Why doesn't Babel do this for me?</p>