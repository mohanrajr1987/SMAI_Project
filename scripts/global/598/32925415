<p>I'm trying to implement basic pathfinding to my tile editor program. This is the first time I'm trying to implement pathfinding so I found it most easy to stick with the depth first search algorithm, because I found a great example of how to use that algorithm on the internet. </p>  <p>I have managed to find the path from one tile to an another tile. The problem is that the program run extremely slow when it try to check which tiles who's walkable and who's not. </p>  <p>In the code example that I have used as a starting point, the guy who wrote it have used recursion, and the performance drops drastically. </p>  <pre><code>int pathFinding::dfs(int x, int y, vector&lt;pair&lt;int, int&gt; &gt; path) {   if(path.size() &gt; max_size){     cout &lt;&lt; "Returning : path size too big" &lt;&lt; endl;     return 0;   }    if(x &lt; 0 || x &gt;= TILES_X || y &lt; 0 || y &gt;= TILES_Y)   {     cout &lt;&lt; "Returning : bounds" &lt;&lt; endl;     return 0;   }    if(map[y][x] == blockedTile)   {     cout &lt;&lt; "Returning : blocked" &lt;&lt; endl;     return 0;   }    if(visited[y][x])   {     cout &lt;&lt; "Returning : visited" &lt;&lt; endl;     if (tileMap[x][y] != 3)     {         tileMap[x][y] = 5;     }     return 0;   }    visited[y][x] = true;    cout &lt;&lt; "Visiting " &lt;&lt; x &lt;&lt; " " &lt;&lt; y &lt;&lt; endl;    path.push_back(make_pair(x, y));    if(map[y][x] == goalTile)   {     final_path = path;     visited[y][x] = false;     return 0;   }    ///I think the problem lies here   dfs(x, y - 1, path);   dfs(x + 1, y, path);   dfs(x, y + 1, path);   dfs(x - 1, y, path);    visited[y][x] = false;    return 0; } </code></pre>  <p>I would also like to know how I can move the sprite after I have found the path. I have stored the coordinates in the vector final_path, but how can I move the sprite so it moves smooth step for step until the sprite reach its destination?</p>  <p>btw sorry for bad English :)</p>