<p>I was just revisiting some of my code to improve the performance and stumpled over something strange:</p>  <pre><code>a = np.linspace(10,1000,1000000).reshape(1000,1000)  %timeit np.square(a) 100 loops, best of 3: 8.07 ms per loop  %timeit a*a 100 loops, best of 3: 8.18 ms per loop  %timeit a**2 100 loops, best of 3: 8.32 ms per loop </code></pre>  <p>Ok it seems to have some overhead when using the power-operator but otherwise they seem identical (I guess numpy is doing that) but then it got strange:</p>  <pre><code>In [46]: %timeit np.power(a, 2) 10 loops, best of 3: 121 ms per loop </code></pre>  <p>So there is no problem but it seems a bit inconsistent to have a fallback for the magic pow but not for the UFUNC. But then I got interested since i am using third powers a lot:</p>  <pre><code>%timeit a*a*a 100 loops, best of 3: 18.1 ms per loop  %timeit a**3 10 loops, best of 3: 121 ms per loop  %timeit np.power(a, 3) 10 loops, best of 3: 121 ms per loop </code></pre>  <p>There seems to be no "shortcut" in the third power and UFUNC and 'magic-pow' work the same (at least in regard to performance).</p>  <p>But that's not that good since I want a consistent method of using powers in my code and I'm not quite sure how to wrap the __pow__ of numpy.</p>  <h1>So to get to the point, my question is :</h1>  <p>Is there a way I can wrap the numpys __pow__ method? Because I want a consistent way of writing powers in my script not writing a**2 and at another place power(a, 3). Simply writing a**3, and redirecting this to my power function, would be preferred (but for that I would need to somehow wrap the ndarrays __pow__ or?).  Currently I am using a shortcut but that's not that beautiful (I even have to declare the exponent==2 case since np.power performs not optimal there):</p>  <pre><code>def power(array, exponent):     if exponent == 2: #catch this, or it calls the slow np.power(array, exponent)         return np.square(array)     if exponent == 3:         return array * array * array     #As soon as np.cbrt is avaiable catch the exponent 4/3 here too     return np.power(array, exponent)   %timeit power(a, 3) 100 loops, best of 3: 17.8 ms per loop %timeit a**3 10 loops, best of 3: 121 ms per loop </code></pre>  <p>I am using numpy v1.9.3 and I do not want to subclass np.ndarray just for wrapping the __pow__ method. :-)</p>  <p>EDIT: I rewrote the part where I get to my question. To clarify it: I am not asking about why numpy does it the way it does - that is just to explain why I ask the question.</p>