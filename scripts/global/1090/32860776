<p>I have a bit of assembly code that calls another using <code>callq</code>. Upon calling <code>retq</code>, the program crashes with a segmentation fault.</p>  <pre><code>    .globl  main main:                   # def main():     pushq   %rbp        #     movq    %rsp, %rbp  #      callq   input       # get input     movq    %rax, %r8      callq   r8_digits_to_stack     # program is not getting here before the segmentation fault     jmp     exit_0  # put the binary digits of r8 on the stack, last digit first (lowest) # uses: rcx, rbx r8_digits_to_stack:     movq    %r8, %rax       # copy for popping digits off      loop_digits_to_stack:         cmpq    $0, %rax    # if our copy is zero, we're done!         jle     return          movq    %rax, %rcx  # make another copy to extract digit with         andq    $1, %rcx    # get last digit         pushq   %rcx        # push last digit to stack         sarq    %rax        # knock off last digit for next loop         jmp     loop_digits_to_stack  # return from wherever we were last called return:     retq  # exit with code 0 exit_0:     movq    $0, %rax    # return 0     popq    %rbp     retq </code></pre>  <p>Where <code>input</code> is a C function that returns keyboard input to <code>%rax</code>.</p>  <p>I assume that this might have something to do with the fact that I'm manipulating the stack, iis that the case? </p>