<p>Here is my problem, can anyone help me?</p>  <p>I'm trying to use QOpenGLWidget to render a trivial example, a triangle. But the problem is that the widget is totally black and not rendering anything.</p>  <p><strong>In main.cpp:</strong></p>  <pre><code>int main(int argc, char **argv) {     QApplication app(argc, argv);              QSurfaceFormat format;     format.setProfile (QSurfaceFormat::CoreProfile);     format.setVersion (4 , 3);     format.setSwapBehavior (QSurfaceFormat::DoubleBuffer);     format.setRenderableType (QSurfaceFormat::OpenGL);     QSurfaceFormat::setDefaultFormat (format);      MyViewer.show();      return app.exec(); } </code></pre>  <p><strong>In MyViewer.cpp:</strong></p>  <pre><code>namespace {     static const char VertexShaderCode[] =         "#version 410\n"         "layout(location=0) in vec2 position;"         "layout(location=1) in vec3 color;"         ""         ""         "void main()"         "{"         "   gl_Position = vec4(position, 0.0, 1.0);"         "}\0";      static const char FragmentShaderCode[] =         "#version 410\n"         ""         "out vec4 output_color;"         ""         "void main()"         "{"         "   output_color = vec4(1.0, 0.0, 0.0, 1.0);"         "}\0";      void InstallShaders () {         QOpenGLShader vertex_shader (QOpenGLShader::Vertex , 0);         QOpenGLShader fragment_shader (QOpenGLShader::Fragment , 0);          vertex_shader.compileSourceCode (::VertexShaderCode);         fragment_shader.compileSourceCode (::FragmentShaderCode);          assert(vertex_shader.isCompiled () and fragment_shader.isCompiled ());          QOpenGLShaderProgram program;          program.addShader (&amp; vertex_shader);         program.addShader (&amp; fragment_shader);          program.link ();          assert(program.isLinked ());          assert(program.bind ());         // glUseProgram (program.programId ());     } };  ...  void MyViewer::InitializeGL() {     initializeOpenGLFunctions();     InistallShaders();     GLuint buffer_id;     glGenBuffers (1 , &amp; buffer_id);     glBindBuffer (GL_ARRAY_BUFFER , buffer_id);      GLfloat vertices[] = {         +0.0f , +0.8f , // top         +1.0f , +0.0f , +0.0f , // red         -0.8f , -0.8f , // left         +0.0f , +1.0f , +0.0f , // blue         +0.8f , -0.8f , // right         +0.0f , +0.0f , +1.0f , // green     };      glBufferData (GL_ARRAY_BUFFER , sizeof (vertices) , vertices , GL_STATIC_DRAW);     glEnableVertexAttribArray (0);     glEnableVertexAttribArray (1);      glVertexAttribPointer (0 , 2 , GL_FLOAT , GL_FALSE , sizeof (float) * 5 , 0);     glVertexAttribPointer (1 , 3 , GL_FLOAT , GL_FALSE , sizeof (float) * 5 , (char *) (sizeof (float) * 2)); }  void MyViewer::paintGL () {     glDrawArrays (GL_TRIANGLES , 0 , 3); } </code></pre>  <p>But nothing is rendered and I only got a black window.</p>  <p>I tried to render the triangle without shaders too, and remove the</p>  <p><code>glVertexAttribPointer(1);</code> </p>  <p>and </p>  <p><code>glVertexAttribPointer (1 , 3 , GL_FLOAT , GL_FALSE , sizeof (float) * 5 , (char *) (sizeof (float) * 2));</code></p>  <p>in order to render a white triangle on the black plane, but it's not working either. By the way, build and all the <code>assert(...)</code> succeeded, and I think the shader compilation worked out fine.</p>