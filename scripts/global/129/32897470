<p>I'm not very experience with the OpenGL library so I'm having trouble understanding why when I move some initialization code to a class or a function, GL stops drawing onto the screen. Some research indicates that the library is "global" or state-based rather than object based? </p>  <p>Anyway, here is some code that <strong>works</strong></p>  <pre><code>GLuint vertexArrayBuffer; glGenVertexArrays(1, &amp;vertexArrayBuffer); glBindBuffer(GL_ARRAY_BUFFER, vertexArrayBuffer); // VBO is ready to accept vertex data glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW); glBindVertexArray(0);     while(!screen.isClosed()) {     // Give the screen a background color     screen.paint(0.0f, 0.0f, 0.5f, 1.0f);      glBindBuffer(GL_ARRAY_BUFFER, vertexArrayBuffer);     glEnableVertexAttribArray(0);     glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0);     glDrawArrays(GL_TRIANGLES, 0, 3);      glDisableVertexAttribArray(0);       // Switch to display buffer after drawing all of the above        screen.swapBuffers(); </code></pre>  <p>This is all enclosed in the main function, with not much programming structure. The output is a nice white triangle onto a blueish background.</p>  <p>This is the issue here, taking the <em>exact</em> code prior to the event loop and wrapping it into a function:</p>  <pre><code>GLuint initVertexArray(vertex vertices[]) { // Create file descriptor for the VBO for use as reference to gl vertex functions GLuint vertexArrayBuffer; glGenVertexArrays(1, &amp;vertexArrayBuffer); glBindBuffer(GL_ARRAY_BUFFER, vertexArrayBuffer); // VBO is ready to accept vertex data glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW); glBindVertexArray(0);  return vertexArrayBuffer; } </code></pre>  <p>and calling it <code>GLuint vertexArrayBuffer = initVertexArray(vertices);</code> in the main function, produces no output of any kind, no errors either, just the same blueish background.</p>