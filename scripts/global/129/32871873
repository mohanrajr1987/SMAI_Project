<p>So, I'm building a default context in OpenGL, (Without extensions) and for some reason, as soon as my window opens, I BSOD with an "Unexpected Kernel Mode Trap"</p>  <p>Now, this is pretty default. As I've just used the startup VS 2015 Community win32 application, and applied the OpenGL context code verbatim. Which includes a message box which supposedly should show me my OpenGL version (4.4). However, it opens blank, and upon closing, when it should open the OpenGL CS_DCOWN window, I BSOD.</p>  <p>Just wondering if anyone has insight as to what command is specifically causing the BSOD, or if my practices are wrong?</p>  <p>I come from a mostly Direct3D9 background.</p>  <pre><code>#include "stdafx.h" #include "PureGL.h" #include &lt;gl\GL.h&gt;  #pragma comment (lib, "opengl32.lib");  #define MAX_LOADSTRING 100  // Global Variables: HINSTANCE hInst;                                // current instance WCHAR szTitle[MAX_LOADSTRING];                  // The title bar text WCHAR szWindowClass[MAX_LOADSTRING];            // the main window class name  // Forward declarations of functions included in this code module: ATOM                MyRegisterClass(HINSTANCE hInstance); BOOL                InitInstance(HINSTANCE, int); LRESULT CALLBACK    WndProc(HWND, UINT, WPARAM, LPARAM);  int APIENTRY wWinMain(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPWSTR lpCmdLine, _In_ int nCmdShow) {     UNREFERENCED_PARAMETER(hPrevInstance);     UNREFERENCED_PARAMETER(lpCmdLine);      // TODO: Place code here.      // Initialize global strings     LoadStringW(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING);     LoadStringW(hInstance, IDC_PUREGL, szWindowClass, MAX_LOADSTRING);     MyRegisterClass(hInstance);      // Perform application initialization:     if (!InitInstance (hInstance, nCmdShow))     {         return FALSE;     }      HACCEL hAccelTable = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDC_PUREGL));      MSG msg;      // Main message loop:     while (GetMessage(&amp;msg, nullptr, 0, 0))     {         if (!TranslateAccelerator(msg.hwnd, hAccelTable, &amp;msg))         {             TranslateMessage(&amp;msg);             DispatchMessage(&amp;msg);         }     }      return (int) msg.wParam; }  ATOM MyRegisterClass(HINSTANCE hInstance) {     WNDCLASSEXW wcex;         wcex.cbSize = sizeof(WNDCLASSEX);         wcex.style          = CS_OWNDC | CS_HREDRAW | CS_VREDRAW;     wcex.lpfnWndProc    = WndProc;     wcex.cbClsExtra     = 0;     wcex.cbWndExtra     = 0;     wcex.hInstance      = hInstance;     wcex.hIcon          = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_PUREGL));     wcex.hCursor        = LoadCursor(nullptr, IDC_ARROW);     wcex.hbrBackground  = (HBRUSH)(COLOR_WINDOW+1);     wcex.lpszMenuName   = MAKEINTRESOURCEW(IDC_PUREGL);     wcex.lpszClassName  = szWindowClass;     wcex.hIconSm        = LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_SMALL));      return RegisterClassExW(&amp;wcex); }  BOOL InitInstance(HINSTANCE hInstance, int nCmdShow) {    hInst = hInstance; // Store instance handle in our global variable     HWND hWnd = CreateWindowW(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW,       CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, nullptr, nullptr, hInstance, nullptr);     if (!hWnd)    {       return FALSE;    }     ShowWindow(hWnd, nCmdShow);    UpdateWindow(hWnd);     return TRUE; }  LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) {     PIXELFORMATDESCRIPTOR pfd = {         sizeof(PIXELFORMATDESCRIPTOR),         1,         PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER,         PFD_TYPE_RGBA,         32,         0, 0, 0, 0, 0, 0,         0,         0,         0,         0, 0, 0, 0,         24,         8,         0,         PFD_MAIN_PLANE,         0,         0, 0, 0     };      HDC ourWindowHandleToDeviceContext = GetDC(hWnd);      int letWindowsChooseThisPixelFormat;     letWindowsChooseThisPixelFormat = ChoosePixelFormat(ourWindowHandleToDeviceContext, &amp;pfd);     SetPixelFormat(ourWindowHandleToDeviceContext, letWindowsChooseThisPixelFormat, &amp;pfd);      HGLRC ourOpenGLRenderingContext = wglCreateContext(ourWindowHandleToDeviceContext);     wglMakeCurrent(ourWindowHandleToDeviceContext, ourOpenGLRenderingContext);      MessageBoxA(0, (char*)glGetString(GL_VERSION), "OPENGL VERSION", 0);      wglDeleteContext(ourOpenGLRenderingContext);     PostQuitMessage(0);      switch (message)     {     case WM_COMMAND:         {             int wmId = LOWORD(wParam);             // Parse the menu selections:             switch (wmId)             {             case IDM_EXIT:                 DestroyWindow(hWnd);                 break;             default:                 return DefWindowProc(hWnd, message, wParam, lParam);             }         }         break;     case WM_PAINT:         {             PAINTSTRUCT ps;             HDC hdc = BeginPaint(hWnd, &amp;ps);             // TODO: Add any drawing code that uses hdc here...             EndPaint(hWnd, &amp;ps);         }         break;     case WM_DESTROY:         PostQuitMessage(0);         break;     default:         return DefWindowProc(hWnd, message, wParam, lParam);     }     return 0; } </code></pre>  <p>Hardware details if known issues - AMD FX 6300, ASUS Radeon R9-285</p>