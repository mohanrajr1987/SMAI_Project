<p>I'm trying to use anti-aliasing to get shaper edges in my scene. However, when I enable multisampling and I call QOpenGLWidget::update() the scene doesn't update. Although if I click on the scene then an anti-aliased scene is rendered. If I comment out the one line setting the number of samples used then an aliased scene is rendered as normal when calling update. </p>  <p>I set the default surface format in main.cpp I'm using CoreProfile 4.3 with samples set to 4.</p>  <pre><code>#include &lt;QApplication&gt; #include "widgets/mainwindow.h"  int main(int argc, char *argv[]) {     auto format = QSurfaceFormat();     format.setVersion(4,3);     //If I comment out this line everything works great but with jagged edges      format.setSamples(4);     format.setProfile(QSurfaceFormat::CoreProfile);     QSurfaceFormat::setDefaultFormat(format);     QApplication a(argc, argv);     MainWindow w;     w.show();     w.resize(1200, 800);     return a.exec(); } </code></pre>  <p>In my viewer.cpp which inherits from QOpenGLWidget I enable GL_MULTISAMPLE</p>  <pre><code>   QOpenGLFunctions *f = QOpenGLContext::currentContext()-&gt;functions();      f-&gt;glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);     f-&gt;glEnable(GL_MULTISAMPLE); </code></pre>  <p>An example (there are many more) that doesn't render when I call update when using multisampling is when I load in a new mesh. </p>  <pre><code>auto ViewerWidget::importMesh(QString filename) -&gt; void {     mesh = new Mesh(filename);     initializeGL();     update();  } </code></pre>  <p>However, when I click on the screen then the scene does update. My mouse movement events are below and don't do anything special compared to my mesh import method. </p>  <pre><code>void ViewerWidget::mousePressEvent(QMouseEvent *event) {     if (event-&gt;buttons() &amp; Qt::LeftButton) {         m_rotationTrackball.push(pixelPosToViewPos(event-&gt;pos()), m_scaleTrackball.rotation().conjugate());     }     update(); }  void ViewerWidget::mouseReleaseEvent(QMouseEvent *event) {     if (event-&gt;buttons() &amp; Qt::LeftButton) {         m_rotationTrackball.release(pixelPosToViewPos(event-&gt;pos()), m_scaleTrackball.rotation().conjugate());     }     update(); }  void ViewerWidget::mouseMoveEvent(QMouseEvent *event) {     if (event-&gt;buttons() &amp; Qt::LeftButton)     {         m_rotationTrackball.move(pixelPosToViewPos(event-&gt;pos()), m_scaleTrackball.rotation().conjugate());     }     else     {         m_rotationTrackball.release(pixelPosToViewPos(event-&gt;pos()), m_scaleTrackball.rotation().conjugate());     }     update(); } </code></pre>  <p>Any suggestions on how to solve this would be appreciated! Thanks in advance.</p>