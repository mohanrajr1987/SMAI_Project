<p><strong>UPDATE</strong> I just discovered my question is likely a duplicate of <a href="http://stackoverflow.com/questions/20983416/if-you-call-glbufferdata-after-already-calling-it-on-a-buffer-is-there-a-memory?rq=1">If you call glBufferData after already calling it on a buffer, is there a memory leak?</a></p>  <p>Hopefully my question is still useful to someone, as I give code samples, rather than merely mentioning the gl function calls, as in that Q&amp;A.</p>  <hr>  <p>I don't understand the relationship between <code>glGenBuffers / glBindBuffer / glBufferData</code> and <code>gldeletebuffers</code>.</p>  <p>Consider drawing a sequence of lines (a line strip). The original sequence is drawn over some number of frames, but then new user input increases the number of lines.</p>  <p>My first thought is to re-use the buffer object name assigned by <code>glGenBuffers</code>, when the size changes. But since the buffer size needs to be larger, I can't use the existing buffer as-is.</p>  <p>NOTE: At this time, I would rather not assume some "maximum size", allocate that, and then do sub-data calls for the size I currently need.</p>  <p>Consider code based on this example: <a href="http://stackoverflow.com/questions/27937285/when-should-i-call-gldeletebuffers">When should I call glDeleteBuffers()?</a></p>  <p>If I had done these lines in an initialization function before drawing the first frame (code may not compile -- I'm concerned about the call sequence, not the exact parameters to pass -- I'm actually working in C# under Xamarin using OpenTK to access OPENGL ES 2.0, but it is easier to find examples in C++ using opengl):</p>  <pre><code>GLuint VBO;  void init(int size, float* data) {     glGenBuffers(1, &amp;VBO);     glBindBuffer(GL_ARRAY_BUFFER, VBO);     glBufferData(GL_ARRAY_BUFFER, size, data, GL_STATIC_DRAW); } </code></pre>  <p>which many frames later (or when app exits) is released via:</p>  <pre><code>void destroy() {     glDeleteBuffers(1, &amp;VBO); } </code></pre>  <p>But now I want to have a "re_init" function that allocates a different size, what exactly do I need to do?</p>  <p>I could re-assign a new VBO buffer name:</p>  <pre><code>void re_init(newSize, newData) {     destroy();     init(newSize, newData); } </code></pre>  <p>But this seems like overkill. What is the <em>minimum</em> work that I can do?  And is that any more efficient than the brute-force destroy/create-a-new-one above?</p>  <p>It seems that any set of calls I do works, but i don't know whether the result is leaking memory or not. I will eventually need to learn how to test for memory leaks in the environment I am in, but right now I want to get the theory right, in hopes that I will write code that is both efficient and non-leaking.</p>  <p>Will this leak memory?</p>  <pre><code>void re_init(newSize, newData) {     glBindBuffer(GL_ARRAY_BUFFER, VBO);     glBufferData(GL_ARRAY_BUFFER, newSize, newData, GL_STATIC_DRAW); } </code></pre>  <p>That is, I haven't done <code>glDeleteBuffers</code> on the old buffer, because doing so freed the VBO buffer name, and I am trying to find out how to not do so.</p>  <p>One question is whether there is a way to re-use a VBO buffer name, with data of a different size?</p>  <p>Or am I better off sticking to the simple model of freeing the buffer <strong><em>and its name</em></strong> every time I need to change buffer size? (That is what glDeleteBuffers seems to do.)</p>