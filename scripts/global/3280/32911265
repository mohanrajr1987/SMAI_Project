<p>SO I have this code and it is working. It shows marker on my current location and when I click location on the map, it draw a marker and route. My problem is that my destinations are fixed latlng. When you open the map, it has many markers which is my destination. What should I do so that if I click that marker, it will show the route. </p>  <p>public class MainActivity extends FragmentActivity implements LocationListener {</p>  <pre><code>GoogleMap map; ArrayList&lt;LatLng&gt; markerPoints; TextView tvDistanceDuration; Map&lt;Marker, Class&lt;?&gt;&gt; allMarkersMap = new HashMap&lt;Marker, Class&lt;?&gt;&gt;(); LocationManager locationManager; LocationManager locationListener; double mLatitude = 0; double mLongitude = 0;  @Override protected void onCreate(Bundle savedInstanceState) {     super.onCreate(savedInstanceState);     setContentView(R.layout.activity_main);      tvDistanceDuration = (TextView) findViewById(R.id.tv_distance_time);       // Initializing     markerPoints = new ArrayList&lt;LatLng&gt;();      // Getting reference to SupportMapFragment of the activity_main     SupportMapFragment fm = (SupportMapFragment) getSupportFragmentManager().findFragmentById(R.id.map);      // Getting Map for the SupportMapFragment     map = fm.getMap();      // Enable MyLocation Button in the Map     map.setMyLocationEnabled(true);      // Creating a criteria object to retrieve provider     Criteria criteria = new Criteria();      locationManager = (LocationManager) getSystemService(Context.LOCATION_SERVICE);      final Location location = locationManager.getLastKnownLocation(LocationManager.NETWORK_PROVIDER);      String provider = locationManager.getBestProvider(criteria, true);       if (location != null) {         onLocationChanged(location);     }     locationManager.requestLocationUpdates(provider, 20000, 0, this);       // Setting onclick event listener for the map     map.setOnMapClickListener(new GoogleMap.OnMapClickListener() {           @Override         public void onMapClick(LatLng point) {              // Already two locations             if (markerPoints.size() &gt; 1) {                  FragmentManager fm = getSupportFragmentManager();                 markerPoints.clear();                 LatLng startPoint = new LatLng(mLatitude, mLongitude);                  // draw the marker at the current position                 drawMarker(startPoint);             }              // draws the marker at the currently touched location             drawMarker(point);               // Checks, whether start and end locations are captured             if (markerPoints.size() &gt;= 2) {                 LatLng origin = markerPoints.get(0);                 LatLng dest = markerPoints.get(1);                  // Getting URL to the Google Directions API                 String url = getDirectionsUrl(origin, dest);                  DownloadTask downloadTask = new DownloadTask();                  // Start downloading json data from Google Directions API                 downloadTask.execute(url);             }         }     });         Marker marker1 = map.addMarker(new MarkerOptions()             .position(new LatLng(14.608177, 120.967422))             .title("Tondo Church")             .snippet("Santo Nino de Tondo Parochial Church"));     allMarkersMap.put(marker1, TondoHigh.class);      Marker marker2 = map.addMarker(new MarkerOptions()             .position(new LatLng(14.609253, 120.966283))             .title("Mary Johnston")             .snippet("Libre Tule"));     allMarkersMap.put(marker2, TondoHigh.class);       map.setOnInfoWindowClickListener(new GoogleMap.OnInfoWindowClickListener() {         @Override         public void onInfoWindowClick(Marker marker) {             Class&lt;?&gt; cls = allMarkersMap.get(marker);             Intent intent = new Intent(MainActivity.this, cls);             startActivity(intent);         }     }); }  private String getDirectionsUrl(LatLng origin, LatLng dest) {      // Origin of route     String str_origin = "origin=" + origin.latitude + "," + origin.longitude;      // Destination of route     String str_dest = "destination=" + dest.latitude + "," + dest.longitude;      // Sensor enabled     String sensor = "sensor=false";      // Building the parameters to the web service     String parameters = str_origin + "&amp;" + str_dest + "&amp;" + sensor;      // Output format     String output = "json";      // Building the url to the web service     String url = "https://maps.googleapis.com/maps/api/directions/" + output + "?" + parameters;      return url; }  private String downloadUrl(String strUrl) throws IOException {     String data = "";     InputStream iStream = null;     HttpURLConnection urlConnection = null;     try {         URL url = new URL(strUrl);          // Creating an http connection to communicate with url         urlConnection = (HttpURLConnection) url.openConnection();          // Connecting to url         urlConnection.connect();          // Reading data from url         iStream = urlConnection.getInputStream();          BufferedReader br = new BufferedReader(new InputStreamReader(iStream));          StringBuffer sb = new StringBuffer();          String line = "";         while ((line = br.readLine()) != null) {             sb.append(line);         }          data = sb.toString();          br.close();      } catch (Exception e) {         Log.d("Exception Url", e.toString());     } finally {         iStream.close();         urlConnection.disconnect();     }     return data; }  // Fetches data from url passed private class DownloadTask extends AsyncTask&lt;String, Void, String&gt; {      // Downloading data in non-ui thread     @Override     protected String doInBackground(String... url) {          // For storing data from web service         String data = "";          try {             // Fetching the data from web service             data = downloadUrl(url[0]);         } catch (Exception e) {             Log.d("Background Task", e.toString());         }         return data;     }      // Executes in UI thread, after the execution of     // doInBackground()     @Override     protected void onPostExecute(String result) {         super.onPostExecute(result);          ParserTask parserTask = new ParserTask();          // Invokes the thread for parsing the JSON data         parserTask.execute(result);     } }  /**  * A class to parse the Google Places in JSON format  */ private class ParserTask extends AsyncTask&lt;String, Integer, List&lt;List&lt;HashMap&lt;String, String&gt;&gt;&gt;&gt; {      // Parsing the data in non-ui thread     @Override     protected List&lt;List&lt;HashMap&lt;String, String&gt;&gt;&gt; doInBackground(String... jsonData) {          JSONObject jObject;         List&lt;List&lt;HashMap&lt;String, String&gt;&gt;&gt; routes = null;          try {             jObject = new JSONObject(jsonData[0]);             DirectionsJSONParser parser = new DirectionsJSONParser();              // Starts parsing data             routes = parser.parse(jObject);         } catch (Exception e) {             e.printStackTrace();         }         return routes;     }      // Executes in UI thread, after the parsing process     @Override     protected void onPostExecute(List&lt;List&lt;HashMap&lt;String, String&gt;&gt;&gt; result) {         ArrayList&lt;LatLng&gt; points = null;         PolylineOptions lineOptions = null;         MarkerOptions markerOptions = new MarkerOptions();         String distance = "";         String duration = "";          if (result.size() &lt; 1) {             Toast.makeText(getBaseContext(), "No Points", Toast.LENGTH_SHORT).show();             return;         }          // Traversing through all the routes         for (int i = 0; i &lt; result.size(); i++) {             points = new ArrayList&lt;LatLng&gt;();             lineOptions = new PolylineOptions();              // Fetching i-th route             List&lt;HashMap&lt;String, String&gt;&gt; path = result.get(i);              // Fetching all the points in i-th route             for (int j = 0; j &lt; path.size(); j++) {                 HashMap&lt;String, String&gt; point = path.get(j);                  if (j == 0) {    // Get distance from the list                     distance = (String) point.get("distance");                     continue;                 } else if (j == 1) { // Get duration from the list                     duration = (String) point.get("duration");                     continue;                 }                  double lat = Double.parseDouble(point.get("lat"));                 double lng = Double.parseDouble(point.get("lng"));                 LatLng position = new LatLng(lat, lng);                  points.add(position);             }              // Adding all the points in the route to LineOptions             lineOptions.addAll(points);             lineOptions.width(2);             lineOptions.color(Color.RED);         }          tvDistanceDuration.setText("Distance:" + distance + ", Duration:" + duration);          // Drawing polyline in the Google Map for the i-th route         map.addPolyline(lineOptions);     } }   private void drawMarker(LatLng point) {     markerPoints.add(point);      // Creating MarkerOptions     MarkerOptions options = new MarkerOptions();      // Setting the position of the marker     options.position(point);      options.title("Lat:" + point.latitude + "," + "Lng:" + point.longitude);     options.snippet("try lang");      /**      * For the start location, the color of marker is GREEN and      * for the end location, the color of marker is RED.      */     if (markerPoints.size() == 1) {         options.icon(BitmapDescriptorFactory.defaultMarker(BitmapDescriptorFactory.HUE_GREEN));     } else if (markerPoints.size() == 2) {         options.icon(BitmapDescriptorFactory.defaultMarker(BitmapDescriptorFactory.HUE_RED));         options.visible(false);     }      // Add new marker to the Google Map Android API V2     map.addMarker(options);  }  @Override public void onLocationChanged(Location location) {     // Draw the marker, if destination location is not set     if (markerPoints.size() &lt; 2) {          mLatitude = location.getLatitude();         mLongitude = location.getLongitude();         LatLng point = new LatLng(mLatitude, mLongitude);          drawMarker(point);     } </code></pre>