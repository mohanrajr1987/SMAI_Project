<p>code shown below:</p>  <pre><code>final ListeningExecutorService executor = MoreExecutors.listeningDecorator(Executors.newFixedThreadPool(4));  final Callable&lt;String&gt; asyncTask = new Callable&lt;String&gt;() {     @Override     public String call() throws Exception {     return TestFuture.computeResult();     } };  final int listSize = 10;  final List&lt;ListenableFuture&lt;String&gt;&gt; listenableFutures = Lists.newArrayListWithExpectedSize(listSize); for (int i = 0; i &lt; listSize; i++) {     listenableFutures.add(executor.submit(asyncTask)); }  for (final ListenableFuture&lt;String&gt; listenableFuture2 : listenableFutures) {     Futures.addCallback(listenableFuture2, new FutureCallback&lt;String&gt;() {     @Override     public void onSuccess(final String result) {         System.out.println("callback success with " + result + " at " + Thread.currentThread().getName());     }      @Override     public void onFailure(final Throwable thrown) {         System.out.println("callback failed with " + thrown.getMessage());     }     }); } </code></pre>  <p>I cannot figure out that HOW the callback is scheduled to be executed at the thread that will executing the <code>asyncTask</code>?</p>  <p>I can see that <code>Futures.addCallback</code> calls <code>addCallback(future, callback, MoreExecutors.sameThreadExecutor());</code>, but I donnot know How MoreExecutors.sameThreadExecutor guarantee this?</p>