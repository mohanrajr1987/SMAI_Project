<p>This must be done without Java concurrency libraries.</p>  <p>Within a consumer thread:</p>  <pre><code>   A.consume(500);    A.consume(100);    A.consume(200); </code></pre>  <p>The starting balance is 200. So, the first consume cannot be done and the consumer thread is forced into waiting. However, this is not desired because the second consume(100) should be executed right away. The first consume should still be pending, but future consumes should be allowed if the balance is enough.</p>  <p>So, how can a synchronized consume function such as:</p>  <pre><code>public synchronized void consume(double amt) {      while(amt&gt;balance) //While not enough balance     {            //Not enough balance, go into waiting         try         {wait();}         catch(InterruptedException e){}     }     //thread is done waiting     balance -= amt;  } </code></pre>  <p>...be made non-blocking?</p>