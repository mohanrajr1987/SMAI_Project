<p>Good morning all,</p>  <p>I am trying to implement concurrency in a very specific environment, and keep getting stuck. Maybe you can help me.</p>  <p>this is the situation:</p>  <p>-I have N nodes that can read/write in a shared folder. </p>  <p>-I want to execute an application in one of them. this can be anything, like a shell script, an installed code, or whatever. </p>  <p>-To do so, I have to send the same command to all of them. The first one should start the execution, and the rest should see that somebody else is running the desired application and exit.</p>  <p>-The execution of the application can be killed at any time. This is important because does not allow  relying on any cleaning step after the execution. </p>  <p>-if the application gets killed, the user may want to execute it again. He would then send the very same command. </p>  <p>My current approach is to create a shell script that wraps the command to be executed. This could also be implemented in C. Not python or other languages, to avoid library dependencies. </p>  <pre><code>#!/bin/sh # (folder structure simplified for legibility) mutex(){   lockdir=".lock"   firstTask=1 #false    if mkdir "$lockdir"  &amp;&gt; /dev/null   then     controlFile="controlFile"      #if this is the first node, start coordinator     if [ ! -f $controlFile ]; then       firstTask=0 #true       #tell the rest of nodes that I am in control       echo "some info" &gt; $controlFile      fi       # remove control File when script finishes      trap 'rm $controlFile' EXIT   fi   return $firstTask }   #The basic idea is that a task executes the desire command, stated as arguments to this script. The rest do nothing if  ! mutex ; then   exit 0 fi  #I am the first node and the only one reaching this, so I execute whatever $@ </code></pre>  <p>If there are no failures, this wrapper works great.  The problem is that, if the script is killed before the execution, the trap is not executed and the control file is not removed. Then, when we execute the wrapper again to restart the task, it won't work as every node will think that somebody else is running the application. </p>  <p>A possible solution would be to remove the control script just before the "$@" call, but that it would lead to some race condition. </p>  <p>Any suggestion or idea?</p>  <p>Thanks for your help.</p>  <p><strong>edit</strong>: edited with correct solution as future reference</p>