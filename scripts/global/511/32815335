<p>In <a href="https://books.google.com/books?id=EK43StEVfJIC&amp;pg=PT41&amp;lpg=PT41&amp;dq=stateless%20objects%20are%20always%20thread-safe%20Stateless%20Factorization&amp;source=bl&amp;ots=uoXAA2qNgA&amp;sig=HdkaPXiubzXg8_0Ds5eldYi4r6w&amp;hl=en&amp;sa=X&amp;ved=0CB8Q6AEwAGoVChMIzNK6teKYyAIV1SmICh38FwUG#v=onepage&amp;q=stateless%20objects%20are%20always%20thread-safe%20Stateless%20Factorization&amp;f=false" rel="nofollow">Java Concurrency In Practice, Section 2.1</a>, it states:</p>  <blockquote>   <p>Stateless objects are always thread-safe.</p> </blockquote>  <p>And gives the following class as an example:</p>  <pre><code>@ThreadSafe public class StatelessFactorization implements Servlet {     public void service(ServletRequest req, ServletResponse resp){         BigInteger i = extractFromRequest(req);         BigInteger[] factors = factor(i);         encodeIntoResponse(resp, factors);       // &lt;-- isn't it possible for resp to be                                                  //     modified by mult. threads at once?     } } </code></pre>  <hr>  <h1>Question:</h1>  <p>As indicated in the code above, what happens if multiple threads try to modify the same <code>ServletResponse</code> variable.</p>  <p>From my understanding of memory allocation, the above class does not seem completely thread safe. </p>  <p>While the reference to the <code>ServletRequest</code> and <code>ServletResponse</code> are put on the local stack for the calling thread, the actual objects are stored on the heap --which is shared between all threads.</p>