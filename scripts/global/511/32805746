<pre><code>void method1() {     if (is_true) {         mutex1.lock();         condition_var.wait(mutex1,                               [=] { return is_true == false; });         mutex1.unlock();     }     // do some work }   void method2() {     if (is_true) {         mutex1.lock();         condition_var.wait(mutex1,                               [=] { return is_true == false; });         mutex1.unlock();     }     // do some work }  void method3() {     mutex2.lock();     is_true = true;     // do some job     mutex1.lock();     is_true = false;     condition_var.notify_all();     mutex1.unlock();     mutex2.unlock(); } </code></pre>  <p><code>method1</code> and <code>method2</code> can be executed concurrently and do not require to have any self synchronization, <code>method3</code> synchronize itself with <code>mutex2</code>. <code>method1</code>/<code>method2</code> cannot run concurrently with <code>method3</code> for this <code>condition_var</code> and <code>is_true</code> boolean are used as well as <code>mutex1</code>. What I am concerned here that <code>mutex1</code> creates a zone of code where <code>method1</code> and <code>method2</code> are prevented from its concurrent behaviour. But I cannot remove this mutex because <code>is_true = false; condition_var.notify_all();</code> must be an atomic action. How can I redesign it to remove locks from <code>method1</code> and <code>method2</code>?</p>