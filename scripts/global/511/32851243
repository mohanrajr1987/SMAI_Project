<pre><code>@Repository public class MyClass{     public int myFunction(Integer id){         Record x = recordDao.get(id,LockMode.UPGRADE);         int d = x.getProp();         x.setProp(d+1);         recordDao.update(z);     } }  @Service @Transactional public class MyOtherClass{      @Autowired     private MyClass myClass;      public void myOtherFnx(Integer id){         try{             myClass.myFunction(id);         }catch(Exception e){             throw new RuntimeException(e.getMessage());         }     } } </code></pre>  <p>What happens when <code>new MyOtherClass().myOtherFnx(3)</code> was invoked at same time but at separate request/transactions. I tried creating runnables and invoke <code>myOtherFunx</code> on separate threads to simulate concurrency. I was expecting to get RuntimeException but  so far I haven't notice getting any runtime exception even if i increase the threads running <code>myOtherFunx</code> to 50.  Can you explain to me why this happens? Or is my assumption that a runtime exception will occur. The case when I am expecting a runtime exception is when multiple threads invoke <code>myClass.myFunction(3)</code> and the Record object retrieved on these threads are the same, let's say id=3,prop=4. Since one of them gets the lock first, when threads try to update the record only one should update and others will throw exception since I am catching all Exception.</p>