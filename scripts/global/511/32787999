<p>So I'm having some trouble figuring out best practices for using concurrency with a MongoDB in go. My first implementation of getting a session looked like this:</p>  <pre><code>var globalSession *mgo.Session  func getSession() (*mgo.Session, error) {     //Establish our database connection     if globalSession == nil {         var err error         globalSession, err = mgo.Dial(":27017")         if err != nil {             return nil, err         }          //Optional. Switch the session to a monotonic behavior.         globalSession.SetMode(mgo.Monotonic, true)     }      return globalSession.Copy(), nil } </code></pre>  <p>This works great the trouble I'm running into is that mongo has a limit of 204 connections then it starts refusing connections <code>connection refused because too many open connections: 204</code>;however, the issue is since I'm calling <code>session.Copy()</code> it only returns a session and not an error. So event though the connection refused my program never thrown an error.</p>  <p>Now what I though about doing is just having one session and using that instead of copy so I can have access to a connection error like so:</p>  <pre><code>var session *mgo.Session = nil  func NewSession() (*mgo.Session, error) {     if session == nil {         session, err = mgo.Dial(url)         if err != nil {             return nil, err         }     }      return session, nil } </code></pre>  <p>Now the problem I have with this is that I don't know what would happen if I try to make concurrent usage of that same session. </p>