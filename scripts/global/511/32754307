<p>I've a thread dump where many threads are in blocked state. </p>  <blockquote>   <p>I could find why some threads are blocked but couldn't find point from   where these threads starts to block.</p> </blockquote>  <p>Here are some threads of that dump.</p>  <pre><code>"ajp-bio-11009-exec-1141" daemon prio=10 tid=0x00007fcef801d800 nid=0x45aa waiting for monitor entry [0x00007fcf54b3d000]    java.lang.Thread.State: BLOCKED (on object monitor)     at java.util.Arrays.copyOfRange(Arrays.java:3209)     at java.lang.String.&lt;init&gt;(String.java:215)     at java.lang.StringBuilder.toString(StringBuilder.java:430)     at java.util.Date.toString(Date.java:1030)     at java.lang.String.valueOf(String.java:2826)     at java.lang.StringBuilder.append(StringBuilder.java:115)     at com.appnetix.app.util.DBConnectionManager.log(DBConnectionManager.java:494)     at com.appnetix.app.util.DBConnectionManager.access$000(DBConnectionManager.java:49)     at com.appnetix.app.util.DBConnectionManager$DBConnectionPool.freeConnection(DBConnectionManager.java:625)     - locked &lt;0x00000006c0b9a6c0&gt; (a com.appnetix.app.util.DBConnectionManager$DBConnectionPool)     at com.appnetix.app.util.DBConnectionManager.freeConnection(DBConnectionManager.java:137)     at com.appnetix.app.util.QueryUtil.getResult(QueryUtil.java:565) </code></pre>  <blockquote>   <p>Why above thread is blocked?</p> </blockquote>  <p>log() method uses PrintWriter class to write into a file to maintain used and free connection. If this thread acquired a lock on DBConnectionPool class than no other threads that will try to acquire the lock on same object will get blocked . like this one.</p>  <pre><code>"ajp-bio-11009-exec-1146" daemon prio=10 tid=0x00007fcef8003000 nid=0x4b31 waiting for monitor entry [0x00007fcf5493b000]    java.lang.Thread.State: BLOCKED (on object monitor)     at com.appnetix.app.util.DBConnectionManager$DBConnectionPool.getConnection(DBConnectionManager.java:684)     - waiting to lock &lt;0x00000006c0b9a6c0&gt; (a com.appnetix.app.util.DBConnectionManager$DBConnectionPool)     at com.appnetix.app.util.DBConnectionManager.getConnection(DBConnectionManager.java:169) </code></pre>  <p>There is another thread in which we are putting approx(5 lacs) of data in hashmap of object size (500MB approx). </p>  <blockquote>   <p>Why this thread is blocked while putting data into HashMap.</p> </blockquote>  <p>Like this thread there are six other caused OutOfMemory error.</p>  <pre><code>    "ajp-bio-11009-exec-1059" daemon prio=10 tid=0x00007fcef8014000 nid=0x65f1 waiting for monitor entry [0x00007fcf54203000]        java.lang.Thread.State: BLOCKED (on object monitor)         at java.util.HashMap.addEntry(HashMap.java:753)         at java.util.HashMap.put(HashMap.java:385)         at com.appnetix.app.util.SequenceMap.put(SequenceMap.java:61)         at com.appnetix.app.components.rssmgr.manager.dao.RssFeedCaptureDAO.getItemForChannel(RssFeedCaptureDAO.java:90)         at com.appnetix.app.portal.rssFeed.FeedCaptureAction.execute(FeedCaptureAction.java:66)  "ajp-bio-11009-exec-1045" daemon prio=10 tid=0x00007fcef8018800 nid=0x343e runnable [0x00007fcf54a3b000]    java.lang.Thread.State: RUNNABLE     at java.util.regex.Pattern$BnM.optimize(Pattern.java:4946)     at java.util.regex.Pattern.compile(Pattern.java:1473)     at java.util.regex.Pattern.&lt;init&gt;(Pattern.java:1133)     at java.util.regex.Pattern.compile(Pattern.java:823)     at java.lang.String.replaceAll(String.java:2189)     at com.appnetix.app.portal.rssFeed.FeedCaptureAction.formatDescription(FeedCaptureAction.java:173)     at com.appnetix.app.portal.rssFeed.FeedCaptureAction.execute(FeedCaptureAction.java:109) </code></pre>  <p>Here is my DBConnectionPool class</p>  <pre><code>class DBConnectionPool {      public synchronized void freeConnection(Connection con) {         if (con == null) {             return;         }         freeConnections.addElement(con);         checkedOut--;         log("FreeConnection is called, No checkout connection: " + checkedOut + " , No of connection in FreePool :" + freeConnections.size());         notifyAll();     }      public synchronized Connection getConnection() {         Connection con = null;         if (freeConnections.size() &gt; 0){                 con = (Connection) freeConnections.firstElement();             freeConnections.removeElementAt(0);             if (!isAlive(con)){                 log("Removed bad connection from " + name);                 con = getConnection();             }         }         else if (maxConn == 0 || checkedOut &lt; maxConn) {             con = newConnection();         }         if (con != null) {             checkedOut++;         }         log("No of checkout connection :" + checkedOut);         return con;     } public synchronized Connection getConnection(long timeout) {         long startTime = new Date().getTime();         Connection con;         while ((con = getConnection()) == null) {             try {                 wait(timeout);             } catch (InterruptedException e) {            }             if ((new Date().getTime() - startTime) &gt;= timeout) {                 return null;             }         }         return con;     }     private Connection newConnection() {         Connection con = null;         try {             if (user == null) {                 con = DriverManager.getConnection(URL);             } else {                 con = DriverManager.getConnection(URL, user, password);             }         } catch (SQLException e) {             e.printStackTrace();             log(e, "Can't create a new connection for " + URL);             return null;         }         return con;     } } </code></pre>