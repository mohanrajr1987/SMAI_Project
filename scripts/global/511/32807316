<p>When I ran the below code</p>  <pre><code>package main  import (     "fmt" )  func say(s string) {     for i := 0; i &lt; 5; i++ {         fmt.Println(s)     } }  func main() {     go say("first goroutine")     say("main goroutine") } </code></pre>  <p>I got output as </p>  <pre><code>main goroutine main goroutine main goroutine main goroutine main goroutine </code></pre>  <p>I ran this code on Windows laptop with Core i7(3rd gen) having 4 cores and hyperthreading which is equivalent to 8 virtual cores. I also tried this code on a Mac with 4 virtual cores and I am getting the same result. Ideally Goroutine should run in separate thread and I should get output similar to :</p>  <pre><code>main goroutine first goroutine main goroutine first goroutine main goroutine first goroutine main goroutine first goroutine main goroutine </code></pre>  <p>Why isn't GO using separate threads to run this program?</p>  <p>EDIT: To validate the number of processors on my PC I also executed the following code</p>  <pre><code>package main  import (     "fmt"     "runtime" )  func main() {     fmt.Println("%d", runtime.GOMAXPROCS(0))     fmt.Println("%d", runtime.NumCPU()) } </code></pre>  <p>and as expected I got output as</p>  <pre><code>8 8 </code></pre>