<p>After hours tearing my hair out, it appears I've been savagely mauled by unexpected behaviour from c++11's <code>unique_lock</code>.  I must have horribly misunderstood something :</p>  <pre><code>#include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;thread&gt; #include &lt;mutex&gt;  #define N_THREADS 4 #define N_ITERATIONS 10000 #define N_LOOPS 1000000  class ThingMaJigger { public:     void fight()    {         if(m.try_lock()) {             // more then one thread ends up here??!?!?             printf("I'm the winner!\n" );             m.unlock();         } else {             printf("Sleeping \n" );         }     } private:     std::mutex m; };  void worker(ThingMaJigger* ar,int tIdx) {     ar-&gt;fight(); }  int main(int argc, char const *argv[]) {     for (int _loop = 0; _loop &lt; N_LOOPS; ++_loop) {         std::vector&lt;std::thread&gt; ts;         ThingMaJigger t;         for (int i = 0; i &lt; N_THREADS; ++i)         {             ts.emplace_back(worker,&amp;t,i);         }          for (int i = 0; i &lt; N_THREADS; ++i)         {             ts[i].join();         }          printf("\n");      }         return 0; } </code></pre>  <p>Compile with <code>clang++ -std=c++11 -O2 -lpthread ./unique_lock.cpp</code></p>  <p>clang 3.7.0, g++ 5.1.1, both behave in the same way.</p>  <h1>Example output:</h1>  <pre><code>I'm the winner! Sleeping  Sleeping  I'm the winner!  I'm the winner! Sleeping  I'm the winner! Sleeping   I'm the winner! I'm the winner! Sleeping  Sleeping  </code></pre>  <p>Kinda looks like multiple workers holding the same lock at the same time, don't it?</p>  <p><a href="http://en.cppreference.com/w/cpp/thread/mutex/try_lock" rel="nofollow">http://en.cppreference.com/w/cpp/thread/mutex/try_lock</a> says:</p>  <blockquote>   <h3>Return value</h3>      <p>true if the lock was acquired successfully, otherwise false. </p> </blockquote>  <p>Note: <code>try_lock</code> is allowed to return false even if no one else  has the lock. That's not what this is about.</p>