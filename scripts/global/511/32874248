<p>I have a situation where multiple concurrent invocations of a python script takes place involving initializing and loading some system info in a file.</p>  <p>This initialization should happen only once and while it is happening the other invocations must wait somehow. And when this has happened, the other invocations must proceed with reading the file. However, since an unknown number of concurrent invocation of the program is taking place, the section is entered multiple times causing problems.</p>  <p>Here is my code:</p>  <pre><code>#initialization has already happened, load info from file if os.path.isfile("/tmp/corners.txt"):     logging.info("corners exist, load'em up!")      #load corners from cornersfile     cornersfile=open("/tmp/corners.txt","r")     for line in cornersfile:         corners.append((line.split()[0], line.split()[1]))`     cornersfile.close()     logging.info("corners is %s", corners)  else:     # initialize and do not let other concurrent invocations to proceed!     logging.info("initiation not done, do it!")     #init blocks and return the list of corners     #write corners to file     cornersfile=open("/tmp/corners.txt", "w")     cornersfile.write("\n".join('%s %s' % x for x in corners))     cornersfile.close() </code></pre>  <p>I did some testing running the code 8 times concurrently. In the logs, I see that the first part of code enters thrice and the <code>else</code> part is entered 5 times.</p>  <p>How do I make sure the that the following happens:</p>  <ol> <li>If any concurrent invocation finds that the initialization (the <code>else</code> part) is happening, it will wait; all other concurrent invocations will go into a wait state.</li> <li>If any concurrent invocation finds that the initialization has already happened (that is the file <code>/tmp/corners.txt</code> is present) it will be loaded up.</li> </ol>