<p>I'm starting a new project that has to convert data from <code>XML</code> to <code>db</code>. <code>XMLs</code> have their own format and cannot be used to fill a <code>db</code>.</p>  <p>I choose to use <code>sqlite</code>, because it is an embedded platform and I need a lightweight library.</p>  <p>I'm struggling with columns types. I wrote the sql below:</p>  <pre><code>static int callback(void *NotUsed, int argc, char **argv, char **azColName) {    int i;    for(i=0; i&lt;argc; i++){       printf("%s = %s\n", azColName[i], argv[i] ? argv[i] : "NULL");    }    printf("\n");    return 0; }  static bool exec_sql (sqlite3 *db, char *sql, bool use_callback) {     int rc;     char *zErrMsg = 0;      // Execute SQL statement     if (use_callback == true)     {         rc = sqlite3_exec(db, sql, callback, 0, &amp;zErrMsg);     }     else     {         rc = sqlite3_exec(db, sql, NULL, 0, &amp;zErrMsg);     }      if( rc != SQLITE_OK )     {         fprintf(stderr, "SQL: %s FAIL!!!\nError: %s\n", sql, zErrMsg);         sqlite3_free(zErrMsg);         return false;     }     return true; }  int main ( int argc, char *argv[] ) {     xmlDoc *doc;     xmlNode *root_element;     FILE *fw;     int i, srcidx, next_start;      sqlite3 *db;     char *zErrMsg = 0;     int rc;     char *sql;      rc = sqlite3_open("Configuration.db", &amp;db);      if( rc )     {         XML2DB_DEBUG_ERR("Can't open database: %s\n", sqlite3_errmsg(db));      }     else     {         XML2DB_DEBUG_INFO("Opened database successfully\n");     }      sql = "CREATE TABLE Table2("  \          "ID          INT      NOT NULL PRIMARY KEY," \          "TABLE_1_ID  INT      FOREGN KEY REFERENCES Table1(ID) NOT NULL ," \           "COLUMN_1    INT[512] NOT NULL,"\          "COLUMN_2    TEXT     NOT NULL,"\          "COLUMN_3    BOOLEAN  DEFAULT FALSE);";      // Execute SQL statement     exec_sql(db, sql, false);      sql = "INSERT INTO Models (ID, TABLE_1_ID, COLUMN_1, COLUMN_2, COLUMN_3) "\           "VALUES (1, 1, '{1,2,3,4,5}', 'blabla', TRUE); ";      // Execute SQL statement     exec_sql(db, sql,true);      sql = "SELECT * FROM Table2;";      // Execute SQL statement     exec_sql(db, sql, true);      sqlite3_close(db);      return 0; } </code></pre>  <p>That code works well, <strong><em>but now I found out that <code>sqlite3</code> does not support <code>boolean</code> and <code>array</code> datatypes.</em></strong></p>  <p>I wrote, "it works well", because of a <code>SELECT</code> and <code>DBVisualizer</code> can display data and do not give me errors.</p>  <p>So, the questions are: </p>  <ol> <li><strong><em>Why sql are executes well even if datatype are not supported and inserted values are not correct?</em></strong></li> <li><strong>*Is there a feature that can be enable to always check that values of insert are well formatted? *</strong></li> </ol>