<p>Suppose you have some data transmitting peripheral, like a UART, that signals an interrupt whenever it's ready to transmit more data. We're sending data from a circular buffer, where <code>tail</code> is where the data is removed from, <code>head</code> is where you add data, and <code>tail == head</code> means that there's no more data to transmit.</p>  <p>Let's also assume that the peripheral has no buffering whatsoever, and you can't pass it the next value to send while it's busy sending the current one. If you need a concrete, if made-up, example, think of a shift register attached directly to a CPU's parallel I/O port.</p>  <p>To keep transmitter as busy as possible, you might wish to transmit as soon as the transmit interrupt handler is entered. When there's no data to transmit, the interrupt is masked out and the handler will not be invoked even though the interrupt has been armed. The system starts in with the interrupt masked out. </p>  <p>I'll use C to illustrate things, although the issue is not C-specific. The interrupt handler, and the buffer, are set up as follows:</p>  <pre><code>char buf[...]; char * head = buf;                     ///&lt; write pointer char * tail = buf;                     ///&lt; read pointer char * const first = buf;              ///&lt; first byte of the buffer char * const last = buf+sizeof(buf)-1; ///&lt; last byte of the buffer  /// Sends one byte out. The interrupt handler will be invoked as soon /// as another byte can be sent. void transmit(char);       void handler() {   transmit(*tail);   if (tail == last)     tail = first;   else     tail++;   if (tail == head)     mask_interrupt(); } </code></pre>  <p>So far, so good. Now let's see how one might implement <code>putch()</code>.  We can invoke <code>putch()</code> in bursts much faster than the device is able to send the data out. Let's assume that the caller knows not to overflow the buffer.</p>  <pre><code>void putch(char c) {   *head = c;   if (head == last)     head = first;   else     head++;   /***/   unmask_interrupt(); } </code></pre>  <p>Suppose now that these things happen:</p>  <ol> <li>The transmitter was busy, and when <code>putch</code> was called, there a byte was being sent.</li> <li>The transmission happens to finish when <code>putch</code> is in the spot marked <code>/***/</code> above. The <code>handler()</code> happens to execute right there. </li> <li>The <code>handler()</code> happens to send the last byte of the data in the buffer - the byte that we have just loaded in preceding lines in <code>putch()</code>.</li> </ol>  <p>The handler masks the interrupt, as there's no more data to send, but <code>putch</code> incorrectly unmasks it right after <code>handler()</code> returns. Thus the <code>handler</code> will have another go through the buffer, and will send a buffer's worth of stale data until <code>tail</code> equals <code>head</code> again.</p>  <p>My questions is: <strong>Is the only fix to increase the latency and check for empty buffer before sending in the <code>handler</code>?</strong> The fixed code looks as follows:</p>  <pre><code>void fixed_handler() {   if (head == tail) {     mask_interrupt();     arm_interrupt(); // so that next time we unmask it, we get invoked     return;   }   transmit(*tail);   if (tail == last)     tail = first;   else     tail++; } </code></pre>  <p>This fix adds some latency, and also adds an extra operation (<code>arm_interrupt</code>) that's executed once when there's no more data to send.</p>  <p>For possible other approaches, feel free to assume the existence of at least the following operations:</p>  <pre><code>/// Is the interrupt armed and will the handler fire once unmasked? bool is_armed(); /// Is the interrupt unmasked? bool is_unmasked(); </code></pre>