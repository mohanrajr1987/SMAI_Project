<p><strong><em>Question background:</em></strong></p>  <p>Yesterday I watched Scott Meyers talk about <a href="https://www.youtube.com/watch?v=J-tA17slViE" rel="nofollow">Support for Embedded Programming in C++11 and C++14</a>. He pointed out five features introduced in C++11 and two features introduced in C++14 especially interesting for the embedded developers however he elaborated only about <code>auto</code> and <code>constexpr</code> in this talk.</p>  <p><strong>Features especially interesting for the embedded developers according to Scott Meyers.</strong></p>  <p><strong>C++11:</strong></p>  <ul> <li>alignment control</li> <li><code>constexpr</code></li> <li><code>std::array</code></li> <li>underlying types for enums</li> <li><code>std::function</code></li> </ul>  <p><strong>C++14 features:</strong></p>  <ul> <li>relaxed rules for <code>constexpr</code> functions</li> <li>binary literals</li> </ul>  <p><strong><em>Question:</em></strong></p>  <p>My question to you is about alignment control. <strong>What are the real life use cases making this feature really nice to have with emphasize to embedded systems?</strong></p>  <p>I understand that we will concentrate on <a href="http://en.cppreference.com/w/cpp/memory/align" rel="nofollow"><code>std::align</code></a> and <a href="http://en.cppreference.com/w/cpp/types/aligned_storage" rel="nofollow"><code>std::aligned_storage</code></a>. I imagine that this feature might be very useful when we allocate big collection of POD objects and we want to read and write them fast with native data transfer for the given CPU architecture (e.g. 4 bytes for x86). Right? What other useful use cases we have for this feature? <strong>I would love to see some real life examples.</strong></p>