<p>As the title may suggest, I'm currently short on SRAM in my program and I can't find a way to reduce my global variables. Is it possible to bring global variables over to flash memory? Since these variables are frequently read and written, would it be bad for the <code>nand flash</code> because they have limited number of read/write cycle?</p>  <p>If the flash cannot handle this, would <code>EEPROM</code> be a good alternative?</p>  <p>EDIT: Sorry for the ambiguity guys. I'm working with Atmel AVR ATmega32HVB which has:   2K bytes of SRAM,    1K bytes of EEPROM    32K bytes of FLASH</p>  <p>Compiler: AVR C/C++</p>  <p>Platform: IAR Embedded AVR</p>  <p>The global variables that I want to get rid of are:</p>  <pre><code>uint32_t capacityInCCAccumulated[TOTAL_CELL]; </code></pre>  <p>and</p>  <pre><code>int32_t AccumulatedCCADCvalue[TOTAL_CELL];  </code></pre>  <p>Code snippets:</p>  <pre><code>  int32_t AccumulatedCCADCvalue[TOTAL_CELL];     void CCGASG_AccumulateCCADCMeasurements(int32_t ccadcMeasurement, uint16_t slowRCperiod) {      uint8_t cellIndex;     // Sampling period dependant on configuration of CCADC sampling..     int32_t temp = ccadcMeasurement * (int32_t)slowRCperiod;      bool polChange = false;     if(temp &lt; 0) {         temp = -temp;         polChange = true;     }      // Add 0.5*divisor to get proper rounding     temp += (1&lt;&lt;(CCGASG_ACC_SCALING-1));     temp &gt;&gt;= CCGASG_ACC_SCALING;      if(polChange) {         temp = -temp;     }     for (cellIndex = 0; cellIndex &lt; TOTAL_CELL; cellIndex++)     {         AccumulatedCCADCvalue[cellIndex] += temp;     }      // If it was a charge, update the charge cycle counter     if(ccadcMeasurement &lt;= 0) {         // If it was a discharge, AccumulatedCADCvalue can be negative, and that         // is "impossible", so set it to zero         for (cellIndex = 0; cellIndex &lt; TOTAL_CELL; cellIndex++)         {             if(AccumulatedCCADCvalue[cellIndex] &lt; 0)              {                 AccumulatedCCADCvalue[cellIndex] = 0;             }         }     }    } </code></pre>  <p>And this</p>  <pre><code>uint32_t capacityInCCAccumulated[TOTAL_CELL]; void BATTPARAM_InitSramParameters() {         uint8_t cellIndex;         // Active current threshold in ticks     battParams_sram.activeCurrentThresholdInTicks = (uint16_t) BATTCUR_mA2Ticks(battParams.activeCurrentThreshold);          for (cellIndex = 0; cellIndex &lt; TOTAL_CELL; cellIndex++)          {     // Full charge capacity in CC accumulated             battParams_sram.capacityInCCAccumulated[cellIndex] = (uint32_t) CCGASG_mAh2Acc(battParams.fullChargeCapacity);     }     // Terminate discharge limit in CC accumulated     battParams_sram.terminateDischargeLimit = CCGASG_mAh2Acc(battParams.terminateDischargeLimit);      // Values for remaining capacity calibration     GASG_CalculateRemainingCapacityValues(); } </code></pre>