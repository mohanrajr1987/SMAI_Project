<p>my task is to program a game with <code>128*128 px</code>. So I started to prepare the Game Java Framework and everything is fine: I've got a <code>JFrame</code> and inside of it is a Canvas where I can draw. But I can't set the sizes correctly. I <strong>have to</strong> work with <code>128*128 px</code> but if the frame would be the same size it would be way too small so I need to scale it up. </p>  <p>But If I scale the size of the Frame up, the Canvas is too small and doesn't fill it anymore. If I'd simply give it the same size as the Frame then I wouldn't work with <code>128*128 px</code> anymore. So how can I draw everything like normal onto my small canvas and scale it up afterwards?</p>  <pre><code>package de.gaminggears.communitygame;  import java.awt.Color; import java.awt.Graphics; import java.awt.Graphics2D; import java.awt.image.BufferStrategy;  import de.gaminggears.communitygame.display.Display;  public class Game implements Runnable{  private Display display; public int width, height; public String title;  private boolean running = false; private Thread thread;  private BufferStrategy bs; private Graphics g;   public Game(String title,int width, int height){     this.height = height;     this.width = width;     this.title = title;  }  private void init(){     display = new Display(title, width, height); }  private void tick(){  }  private void render(){     bs = display.getCanvas().getBufferStrategy();     if(bs == null){         display.getCanvas().createBufferStrategy(3);         return;     }     g = bs.getDrawGraphics();     Graphics2D g2d = (Graphics2D) g;     //Clear Screen     g2d.clearRect(0, 0, width, height);     //Draw Here!      g2d.setColor(Color.RED);     g2d.fillRect(10, 50, 50, 70);     g2d.fillRect(0, 0, 10, 10);      //End Drawing      g2d.scale(5, 5);     bs.show();     g.dispose(); }  public void run(){      init();      while(running){         tick();         render();     }     stop(); }   public synchronized void start(){     if(running)         return;     running = true;     thread = new Thread(this);     thread.start(); }  public synchronized void stop(){     if(!running)         return;     running = false;     try {         thread.join();     } catch (InterruptedException e) {         e.printStackTrace();     } }  } </code></pre>