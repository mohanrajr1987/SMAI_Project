<p>We have a neo4j graph database with around 60 million nodes and an equivalent relationships.</p>  <p>We have been facing consistent packet drops and delays in processing and a complete hung server after 2 hours. We had to shutdown and restart our servers every time this happens and we are having trouble understanding where we went wrong with our configuration.</p>  <p><strong>We are seeing the following kind of exceptions in the console.log file -</strong> </p>  <blockquote>   <ol>   <li>java.lang.IllegalStateException: s=DISPATCHED i=true a=null   o.e.jetty.server.HttpConnection - HttpConnection@609c1158{FILLING}</li>   <li>java.lang.IllegalStateException: s=DISPATCHED i=true a=null   o.e.j.util.thread.QueuedThreadPool</li>   <li>java.lang.IllegalStateException: org.eclipse.jetty.util.SharedBlockingCallback$BlockerTimeoutException</li>   <li>o.e.j.util.thread.QueuedThreadPool - Unexpected thread death: org.eclipse.jetty.util.thread.QueuedThreadPool$3@59d5a975 in   qtp1667455214{STARTED,14&lt;=21&lt;=21,i=0,q=58}</li>   <li>org.eclipse.jetty.server.Response - Committed before 500 org.neo4j.server.rest.repr.OutputFormat$1@39beaadf</li>   <li>o.e.jetty.servlet.ServletHandler - /db/data/cypher java.lang.IllegalStateException: Committed     at   org.eclipse.jetty.server.Response.resetBuffer(Response.java:1253)   ~[jetty-server-9.2.</li>   <li>org.eclipse.jetty.server.HttpChannel - /db/data/cypher java.lang.IllegalStateException: Committed     at   org.eclipse.jetty.server.Response.resetBuffer(Response.java:1253)   ~[jetty-server-9.2.</li>   <li>org.eclipse.jetty.server.HttpChannel - Could not send response error 500: java.lang.IllegalStateException: Committed   o.e.jetty.server.ServerConnector - Stopped</li>   <li>o.e.jetty.servlet.ServletHandler - /db/data/cypher org.neo4j.graphdb.TransactionFailureException: Transaction was marked   as successful, but unable to commit transaction so rolled back.</li>   </ol> </blockquote>  <p>We are using <strong>neo4j enterprise edition 2.2.5 server in SINGLE/NON CLUSTER mode</strong> on Azure D series 8 core CPU,56 GB RAM  UBUNTU 14.04 LTS machine with an attached 500GB data disk.</p>  <p><strong>Here is a snapshot of the sizes of neostore files</strong></p>  <blockquote>   <ul>   <li>8.5G Oct  2 15:48 neostore.propertystore.db</li>   <li>15G Oct  2 15:48 neostore.relationshipstore.db</li>   <li>2.5G Oct  2 15:48 neostore.nodestore.db</li>   <li>6.9M Oct  2 15:48 neostore.relationshipgroupstore.db</li>   <li>3.7K Oct  2 15:07 neostore.schemastore.db</li>   <li>145 Oct  2 15:07 neostore.labeltokenstore.db</li>   <li>170 Oct  2 15:07 neostore.relationshiptypestore.db</li>   </ul> </blockquote>  <p><strong>The Neo4j configuration is as follows -</strong> </p>  <blockquote>   <ol>   <li>Allocated 30GB to file buffer cache (dbms.pagecache.memory=30G)</li>   <li>Allocated 20GB to JVM heap memory (wrapper.java.initmemory=20480, wrapper.java.maxmemory=20480) </li>   <li>Using the default hpc(High performance) type cache.</li>   <li>Forcing the RULE planner by default (dbms.cypher.planner=RULE)</li>   <li>Maximum threads processing queries is 16(twice the number of cores) -  org.neo4j.server.webserver.maxthreads=16</li>   <li>Transaction timeout of 60 seconds - org.neo4j.server.transaction.timeout=60</li>   <li>Guard Timeout if query execution time is greater than 10 seconds - org.neo4j.server.webserver.limit.executiontime=10000</li>   </ol>      <p>Rest of the settings are default</p> </blockquote>  <p>We actually want to setup a cluster of 3 nodes but before that we want to be sure if our basic configuration is correct. Please help us</p>  <hr>  <p><strong>EDITED to ADD code Sample</strong></p>  <p>Typically our cypher query frequency is 18K queries in an hour with an average of roughly 5-6 queries a second. There are also times when there are about 80 queries per second.</p>  <p><strong>Our Typical Queries look like the ones below</strong></p>  <p><code>match (a:TypeA {param:{param}})-[:RELA]-&gt;(d:TypeD) with distinct d,a skip {skip} limit 100 optional match (d)-[:RELF]-&gt;(c:TypeC)&lt;-[:RELF]-(b:TypeB)&lt;-[:RELB]-(a) with distinct d,a,collect(distinct b.bid) as bids,collect(distinct c.param3) as param3Coll optional match (d)-[:RELE]-&gt;(p:TypeE)&lt;-[:RELE]-(b1:TypeB)&lt;-[:RELB]-(a)  with distinct d as distD,bids+collect(distinct b1.bid) as tbids,param3Coll,collect(distinct p.param4) as param4Coll optional match (distD)-[:RELC]-&gt;(f:TypeF) return id(distD),distD.param5,exists((distD)&lt;-[:RELG]-()) as param6, tbids,param3Coll,param4Coll,collect(distinct id(f)) as fids</code></p>  <p><code>match (a:TypeA {param:{param}})-[:RELB]-&gt;(b) return count(distinct b)</code></p>  <p><code>MATCH (a:TypeA{param:{param}})-[r:RELD]-&gt;(a1)-[:RELH]-&gt;(h) where r.param1=true with a,a1,h match (m)-[:RELL]-&gt;(d:TypeI) where (d.param2/2)%2=1 optional match (a)-[:RELB]-(b)-[:RELM {param3:true}]-&gt;(c)  return a1.param,id(a1),collect(b.bid),c.bPhoto</code></p>  <p><code>match (a:TypeA {param:{param}}) match (a)-[:RELB]-&gt;(b) with distinct b,a skip {skip} limit 100 match (a)-[:RELH]-&gt;(h1:TypeH) match (b)-[:RELF|RELE]-&gt;(x)&lt;-[:RELF|RELE]-(h2:TypeH)&lt;-[:RELH]-(a1) optional match (a1)&lt;-[rd:RELD]-(a) with distinct a1,a,h1,b,h2,rd.param1 as param2,collect(distinct x.param3) as param3s,collect(distinct x.param4) as param4s optional match (a1)-[:RELB]-&gt;(b1) where b1.param7 in [0,1] and exists((b1)-[:RELF|RELE]-&gt;()&lt;-[:RELF|RELE]-(h1)) with distinct a1,a,b,h2,param2,param3s,param4s,b1,case when param2 then false else case when ((a1.param5 in [2,3] or length(param3s)&gt;0) or (a1.param5 in [1,3] or length(param4s)&gt;0)) then case when b1.param7=0 then false else true end else false end end as param8 MERGE (a)-[r2:RELD]-&gt;(a1) on create set r2.param6=true on match set r2.param6=case when param8=true and r2.param9=false then true else false end MERGE (b)-[r3:RELM]-&gt;(h2) SET r2.param9=param8, r3.param9=param8</code></p>  <p><code>MATCH (a:TypeA {param:{param}})-[:RELI]-&gt;(g:TypeG {type:'type1'}) match (g)&lt;-[r:RELI]-(a1:TypeA)-[:RELJ]-&gt;(j)-[:RELK]-&gt;(g) return distinct g, collect(j.displayName), collect(r.param1), g.gid, collect(a1.param),collect(id(a1))</code></p>  <p><code>match (a:TypeA {param:{param}})-[r:RELD {param2:true}]-&gt;(a1:TypeA)-[:RELH]-&gt;(b:TypeE) remove r.param2 return id(a1),b.displayName, b.firstName,b.lastName</code> <code>match (a:TypeA {param:{param}})-[:RELA]-&gt;(b:TypeB) return a.param1,count(distinct id(b))</code></p>  <p><code>MATCH (a:TypeA {param:{param}}) set a.param1=true;</code></p>  <p><code>match (a:TypeE)&lt;-[r:RELE]-(b:TypeB) where a.param4 in {param4s} delete r return count(b);</code></p>  <p><code>MATCH (a:TypeA {param:{param}}) return id(a);</code></p>