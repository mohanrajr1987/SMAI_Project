<p>I wrote some simple java code and I encountered some bad performances with SDN4 that I didn't have with SDN3. I suspect the find repositories methods depth parameter to not work exactly in the way it should be. Let me explain the problem:</p>  <p>Here are my java classes(it's just an example) in which I removed getters, setters, contructors, ...</p>  <p>First class is 'Element' :</p>  <pre><code>@NodeEntity public class Element {  @GraphId private Long id;  private int age;  private String  uuid;  @Relationship(type = "HAS_VALUE", direction = Relationship.OUTGOING) private Set&lt;Value&gt; values = new HashSet&lt;Value&gt;(); </code></pre>  <p>Second one is 'Attribute'</p>  <pre><code>@NodeEntity public class Attribute { @GraphId private Long id;  @Relationship(type = "HAS_PROPERTIES", direction = Relationship.OUTGOING) private Set&lt;HasInterProperties&gt; properties; </code></pre>  <p>The 'value' class allow my user to add a value on an Element for a specific attribute :</p>  <pre><code>@RelationshipEntity(type = "HAS_VALUE") public class Value {  @GraphId private Long id;  @StartNode Element element;  @EndNode Attribute attribute;  private Integer value;  private String uuid;  public Value() { }  public Value(Element element, Attribute attribute, Integer value) {     this.element = element;     this.attribute = attribute;     this.value = value;     this.element.getValues().add(this);     this.uuid = UUID.randomUUID().toString(); } </code></pre>  <p>'Element' classe really need to know its values but 'Attribute' class do not care at all about values.</p>  <p>An attribute has references on InternationalizedProperties class which is like that :</p>  <pre><code>@NodeEntity public class InternationalizedProperties { @GraphId private Long id;  private String name; </code></pre>  <p>The relationship entity between an attribute and it InternationalizedProperties is like the following : </p>  <pre><code>@RelationshipEntity(type = "HAS_PROPERTIES") public class HasInterProperties {  @GraphId private Long id;  @StartNode private Attribute attribute;  @EndNode private InternationalizedProperties properties;  private String locale; </code></pre>  <p>I then created a little main method to create two attributes and 10000 elements. All my elements have a specific value for the first attribute but no values for the second one (no relation between them). Both attributes hav two differents internationalizedProperties. Here is a sample :</p>  <pre><code>public static void main(String[] args) {     ApplicationContext context = new ClassPathXmlApplicationContext("spring/*.xml");      Session session = context.getBean(Session.class);     session.query("START n=node(*) OPTIONAL MATCH n-[r]-() WHERE ID(n) &lt;&gt; 0 DELETE n,r", new HashMap&lt;String, Object&gt;());     ElementRepository elementRepository = context.getBean(ElementRepository.class);     AttributeRepository attributeRepository = context.getBean(AttributeRepository.class);     InternationalizedPropertiesRepository internationalizedPropertiesRepository = context.getBean(InternationalizedPropertiesRepository.class);     HasInterPropertiesRepository hasInterPropertiesRepository = context.getBean(HasInterPropertiesRepository.class);      //Creation of an attribute object with two internationalized properties     Attribute att = new Attribute();     attributeRepository.save(att);     InternationalizedProperties p1 = new InternationalizedProperties();     p1.setName("bonjour");     internationalizedPropertiesRepository.save(p1);     InternationalizedProperties p2 = new InternationalizedProperties();     p2.setName("hello");     internationalizedPropertiesRepository.save(p2);     hasInterPropertiesRepository.save(new HasInterProperties(att, p1, "fr"));     hasInterPropertiesRepository.save(new HasInterProperties(att, p2, "en"));     LOGGER.info("First attribut id is {}", att.getId());      //Creation of 1000 elements having a differnt value on a same attribute      for(int i = 0; i&lt; 10000; i++) {         Element elt = new Element();         new Value(elt, att, i);         elementRepository.save(elt);         if(i%50 == 0) {             LOGGER.info("{} elements created. Last element created with id {}", i+1, elt.getId());         }     }      //Another attribut without any values from element.     Attribute att2 = new Attribute();     attributeRepository.save(att2);     InternationalizedProperties p12 = new InternationalizedProperties();     p12.setName("bonjour");     internationalizedPropertiesRepository.save(p12);     InternationalizedProperties p22 = new InternationalizedProperties();     p22.setName("hello");     internationalizedPropertiesRepository.save(p22);     hasInterPropertiesRepository.save(new HasInterProperties(att2, p12, "fr"));     hasInterPropertiesRepository.save(new HasInterProperties(att2, p22, "en"));     LOGGER.info("Second attribut id is {}", att2.getId()); </code></pre>  <p>Finally, in another main method, I try to get several times the first attribute and the second one :</p>  <pre><code>private static void getFirstAttribute(AttributeRepository attributeRepository) {     StopWatch st = new StopWatch();     st.start();     Attribute attribute = attributeRepository.findOne(25283L, 1);     LOGGER.info("time to get attribute (some element have values on it) is {}ms", st.getTime()); }  private static void getSecondAttribute(AttributeRepository attributeRepository) {     StopWatch st = new StopWatch();     st.start();     Attribute attribute2 = attributeRepository.findOne(26286L, 1);     LOGGER.info("time to get attribute (no element have values on it) is {}ms", st.getTime()); }  public static void main(String[] args) {     ApplicationContext context = new ClassPathXmlApplicationContext("spring/*.xml");      AttributeRepository attributeRepository = context.getBean(AttributeRepository.class);      getFirstAttribute(attributeRepository);     getSecondAttribute(attributeRepository);      getFirstAttribute(attributeRepository);     getSecondAttribute(attributeRepository);      getFirstAttribute(attributeRepository);     getSecondAttribute(attributeRepository);      getFirstAttribute(attributeRepository);     getSecondAttribute(attributeRepository); } </code></pre>  <p>Here are the logs of this execution :</p>  <pre><code>time to get attribute (some element have values on it) is 2983ms time to get attribute (no element have values on it) is 4ms      time to get attribute (some element have values on it) is 1196ms time to get attribute (no element have values on it) is 2ms      time to get attribute (some element have values on it) is 1192ms time to get attribute (no element have values on it) is 3ms      time to get attribute (some element have values on it) is 1194ms time to get attribute (no element have values on it) is 3ms      </code></pre>  <p>Getting the second attribut (and its internationalized properties thanks to depth=1) is very quick but to get the first one remains very slow. I know that there are many relations (10000 exactly) which are pointing on the first attribute, but when I want to get an attribute with its internationalized properties I clearly do not want to get all the values which are pointing on it. (since Set is not specified on Attribute class). </p>  <p>That's why I think there is a performance problem here. Or may be I do something wrong ? </p>  <p>Thanks for your help</p>