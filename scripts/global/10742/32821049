<p>I have an <code>Image</code> model with an <code>ImageField</code> plus some meta information fields. This <code>ImageField</code> uses a custom storage which stores the images remotely using some API. All the required methods are implemented, including <code>delete</code>. However, when I check the "clear" checkbox next to the field in the Django Admin, the storage's <code>delete</code> method is not called, and the image is not deleted from the storage service. In order to solve this, I've overwritten the image's <code>save</code> method:</p>  <pre><code>def save(self, *args, **kwargs):     if self.pk:         old_self = Image.objects.get(pk=self.pk)         if old_self.image != self.image:             old_self.image.delete()     super(Image, self).save(*args, **kwargs) </code></pre>  <p>But it kind of bothers me that I hit the database again. I put a breakpoint in the admin form's <code>is_valid</code> method and saw that at this point I have access to the old instance. I know it may sound like a premature and unreasonable optimization, but it seems really stupid that I had access to it but then by the time I get to the Model.save I've lost it and have to hit the database again to have it back.</p>  <p>It seems weird to me that Django doesn't provide any easy way to delete the file from the storage. Perhaps a parameter to the File/ImageField? It seems that the only way to not lose this old instance would involve a lot of non-standard Django hackingâ€¦ or am I missing something?</p>  <p>Thanks</p>