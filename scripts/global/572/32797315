<p>Could somebody help or give some direction of how I can understand the fmap function in following implementation.</p>  <pre><code>data Rose a = a :&gt; [Rose a] deriving (Eq, Show) instance Functor Rose where fmap f (x :&gt; xs) = (f x) :&gt; fmap (fmap f) xs  tree :: Rose Int tree = 1 :&gt; [2:&gt;[]] </code></pre>  <p>The part which I don't understand the (fmap f), why does it again go in recursion, but it only takes 1 parameter. How is this possible, because it needs to 2.</p>  <p>The second part is that I don't undestand why this not works:</p>  <pre><code>fmap f (x :&gt; xs) = (f x) :&gt; fmap f xs </code></pre>  <p>I hope that someone could give me some direction of how understand this.</p>