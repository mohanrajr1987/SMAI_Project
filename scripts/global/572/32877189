<p>I have trouble understanding these functions:</p>  <pre><code>(define (list-&gt;tree elements)   (car (partial-tree elements (length elements))))  (define (partial-tree elts n)   (if (= n 0)     (cons '() elts)     (let ((left-size (quotient (- n 1) 2)))       (let ((left-result (partial-tree elts left-size)))         (let ((left-tree (car left-result))             (non-left-elts (cdr left-result))             (right-size (- n (+ left-size 1))))         (let ((this-entry (car non-left-elts))               (right-result (partial-tree (cdr non-left-elts)                                           right-size)))           (let ((right-tree (car right-result))                 (remaining-elts (cdr right-result)))             (cons (make-tree this-entry left-tree right-tree)                   remaining-elts)))))))) </code></pre>  <p>I guess <code>partial-tree</code> divides the whole list into half, and recursively makes subtrees of each half. But I am totally lost with all the <code>car</code>/<code>cdr</code> involved. Specifically:</p>  <ol> <li><p>Why is <code>car</code> needed in <code>(car (partial-tree elements (length elements)))</code>?</p></li> <li><p>Why does the <code>left-result</code> in <code>(let ((left-result (partial-tree elts left-size)))</code> take the whole list <code>elts</code> instead of half of it?</p></li> <li><p>What is <code>remaining-elts</code> in this:</p>  <pre><code>(cons (make-tree this-entry left-tree right-tree)       remaining-elts)))) </code></pre></li> </ol>  <p>I tried to use a test case <code>'(1 3 5 7 9)</code>, but when I see the recursive call <code>(partial-tree elts left-size)</code>, I am totally confused and don't know what the <code>left-result</code>, <code>left-tree</code>, <code>right-result</code> would be.</p>  <p>I would really appreciate hints on how to think about this.</p>