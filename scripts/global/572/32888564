<p>I am trying to speed up the following function:</p>  <pre><code>{-# LANGUAGE BangPatterns #-}  import Data.Word import Data.Bits import Data.List (foldl1') import System.Random import qualified Data.List as L  data Tree a = AB (Tree a) (Tree a) | A (Tree a) | B (Tree a) | C !a     deriving Show  merge :: Tree a -&gt; Tree a -&gt; Tree a merge (C x) _               = C x merge _ (C y)               = C y merge (A ta) (A tb)         = A (merge ta tb) merge (A ta) (B tb)         = AB ta tb merge (A ta) (AB tb tc)     = AB (merge ta tb) tc merge (B ta) (A tb)         = AB tb ta merge (B ta) (B tb)         = B (merge ta tb) merge (B ta) (AB tb tc)     = AB tb (merge ta tc) merge (AB ta tb) (A tc)     = AB (merge ta tc) tb merge (AB ta tb) (B tc)     = AB ta (merge tb tc) merge (AB ta tb) (AB tc td) = AB (merge ta tc) (merge tb td) </code></pre>  <p>In order to stress its performance, I've implemented sort using <code>merge</code>:</p>  <pre><code>fold ab a b c list = go list where     go (AB a' b') = ab (go a') (go b')     go (A a')     = a (go a')     go (B b')     = b (go b')     go (C x)      = c x  mergeAll :: [Tree a] -&gt; Tree a mergeAll = foldl1' merge  foldrBits :: (Word32 -&gt; t -&gt; t) -&gt; t -&gt; Word32 -&gt; t foldrBits cons nil word = go 32 word nil where     go 0 w !r = r     go l w !r = go (l-1) (shiftR w 1) (cons (w.&amp;.1) r)  word32ToTree :: Word32 -&gt; Tree Word32 word32ToTree w = foldrBits cons (C w) w where     cons 0 t = A t     cons 1 t = B t  toList = fold (++) id id (\ a -&gt; [a])  sort = toList . mergeAll . map word32ToTree  main = do     is &lt;- mapM (const randomIO :: a -&gt; IO Word32) [0..500000]     print $ sum $ sort is </code></pre>  <p>The performance came up quite good from the go, around 2.5x slower than <code>Data.List</code>'s <code>sort</code>. Nothing that I did sped that up further, though: inlining several functions, bang annotations in many places, <code>UNPACK</code> on <code>C !a</code>. Is there any way to speed this function up? </p>