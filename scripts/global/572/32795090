<p>My Node Class:</p>  <pre><code>import java.util.ArrayList;  public class Tree&lt;T&gt; {      private Node&lt;T&gt; root;      public Tree(Node&lt;T&gt; root) {         this.root = root;     }      public boolean isEmpty() {         return (root == null) ? true : false;     }      public Node&lt;T&gt; getRoot() {         return root;     }      public void setRoot(Node&lt;T&gt; root) {         this.root = root;     }      public boolean exists(T key) {         return find(root, key);     }      public int getNumberOfNodes() {         return getNumberOfDescendants(root) + 1;     }      public int getNumberOfDescendants(Node&lt;T&gt; node) {         int n = node.getChildren().size();         for (Node&lt;T&gt; child : node.getChildren())             n += getNumberOfDescendants(child);          return n;      }      private boolean find(Node&lt;T&gt; node, T keyNode) {         boolean res = false;         if (node.getData().equals(keyNode))             return true;          else {             for (Node&lt;T&gt; child : node.getChildren())                 if (find(child, keyNode))                     res = true;         }          return res;     }      private Node&lt;T&gt; findNode(Node&lt;T&gt; node, T keyNode)     {         if(node == null)             return null;         if(node.getData().equals(keyNode))             return node;         else         {             Node&lt;T&gt; cnode = null;             for (Node&lt;T&gt; child : node.getChildren())                 if ((cnode = findNode(child, keyNode)) != null)                     return cnode;         }         return null;              }       public ArrayList&lt;Node&lt;T&gt;&gt; getPreOrderTraversal() {         ArrayList&lt;Node&lt;T&gt;&gt; preOrder = new ArrayList&lt;Node&lt;T&gt;&gt;();         buildPreOrder(root, preOrder);         return preOrder;     }      public ArrayList&lt;Node&lt;T&gt;&gt; getPostOrderTraversal() {         ArrayList&lt;Node&lt;T&gt;&gt; postOrder = new ArrayList&lt;Node&lt;T&gt;&gt;();         buildPostOrder(root, postOrder);         return postOrder;     }      private void buildPreOrder(Node&lt;T&gt; node, ArrayList&lt;Node&lt;T&gt;&gt; preOrder) {         preOrder.add(node);         for (Node&lt;T&gt; child : node.getChildren()) {             buildPreOrder(child, preOrder);         }     }      private void buildPostOrder(Node&lt;T&gt; node, ArrayList&lt;Node&lt;T&gt;&gt; postOrder) {         for (Node&lt;T&gt; child : node.getChildren()) {             buildPostOrder(child, postOrder);         }         postOrder.add(node);     }      public ArrayList&lt;Node&lt;T&gt;&gt; getLongestPathFromRootToAnyLeaf() {         ArrayList&lt;Node&lt;T&gt;&gt; longestPath = null;         int max = 0;         for (ArrayList&lt;Node&lt;T&gt;&gt; path : getPathsFromRootToAnyLeaf()) {             if (path.size() &gt; max) {                 max = path.size();                 longestPath = path;             }         }         return longestPath;     }      public int getMaxDepth()     {         return getLongestPathFromRootToAnyLeaf().size();     }      public ArrayList&lt;ArrayList&lt;Node&lt;T&gt;&gt;&gt; getPathsFromRootToAnyLeaf() {         ArrayList&lt;ArrayList&lt;Node&lt;T&gt;&gt;&gt; paths = new ArrayList&lt;ArrayList&lt;Node&lt;T&gt;&gt;&gt;();         ArrayList&lt;Node&lt;T&gt;&gt; currentPath = new ArrayList&lt;Node&lt;T&gt;&gt;();         getPath(root, currentPath, paths);          return paths;     }      private void getPath(Node&lt;T&gt; node, ArrayList&lt;Node&lt;T&gt;&gt; currentPath,             ArrayList&lt;ArrayList&lt;Node&lt;T&gt;&gt;&gt; paths) {         if (currentPath == null)             return;          currentPath.add(node);          if (node.getChildren().size() == 0) {             // This is a leaf             paths.add(clone(currentPath));         }         for (Node&lt;T&gt; child : node.getChildren())             getPath(child, currentPath, paths);          int index = currentPath.indexOf(node);         for (int i = index; i &lt; currentPath.size(); i++)             currentPath.remove(index);     }      private ArrayList&lt;Node&lt;T&gt;&gt; clone(ArrayList&lt;Node&lt;T&gt;&gt; list) {         ArrayList&lt;Node&lt;T&gt;&gt; newList = new ArrayList&lt;Node&lt;T&gt;&gt;();         for (Node&lt;T&gt; node : list)             newList.add(new Node&lt;T&gt;(node));          return newList;     } } </code></pre>  <p>My Tree Class:</p>  <pre><code>import java.util.ArrayList; import java.util.List;  public class Node&lt;T&gt; {     private T data;     private List&lt;Node&lt;T&gt;&gt; children;     private Node&lt;T&gt; parent;      public Node(T data) {         this.data = data;         this.children = new ArrayList&lt;Node&lt;T&gt;&gt;();     }      public Node(Node&lt;T&gt; node) {         this.data = (T) node.getData();         children = new ArrayList&lt;Node&lt;T&gt;&gt;();     }      public void addChild(Node&lt;T&gt; child) {         child.setParent(this);         children.add(child);     }      public void addChildAt(int index, Node&lt;T&gt; child) {         child.setParent(this);         this.children.add(index, child);     }      public void setChildren(List&lt;Node&lt;T&gt;&gt; children) {         for (Node&lt;T&gt; child : children)             child.setParent(this);          this.children = children;     }      public void removeChildren() {         this.children.clear();     }      public Node&lt;T&gt; removeChildAt(int index) {         return children.remove(index);     }       public void removeThisIfItsAChild(Node&lt;T&gt; childToBeDeleted)     {         List &lt;Node&lt;T&gt;&gt; list = getChildren();         list.remove(childToBeDeleted);     }      public T getData() {         return this.data;     }      public void setData(T data) {         this.data = data;     }      public Node&lt;T&gt; getParent() {         return this.parent;     }      public void setParent(Node&lt;T&gt; parent) {         this.parent = parent;     }      public List&lt;Node&lt;T&gt;&gt; getChildren() {         return this.children;     }      public Node&lt;T&gt; getChildAt(int index) {         return children.get(index);     }      @Override     public boolean equals(Object obj) {         if (null == obj)             return false;          if (obj instanceof Node) {             if (((Node&lt;?&gt;) obj).getData().equals(this.data))                 return true;         }          return false;     }      @Override     public String toString() {         return this.data.toString();     }  } </code></pre>  <p>How would I go about, after creating a tree, randomly select a node from said tree (root included). After selecting a random node from the tree, I need to be able to delete that node and replace it with a new subtree.</p>  <p>What would be the best way to do this? Thanks.</p>