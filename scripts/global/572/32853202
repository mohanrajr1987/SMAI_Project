<p>I made what I'm calling a <code>TreePruner</code>. Its purpose: given a hierarchy starting at a list of root level nodes, return a new hierarchy where the new root nodes are the highest level nodes that meet a certain condition. Here is my class.</p>  <pre><code>public class BreadthFirstPruner&lt;TResource&gt; {     private IEnumerable&lt;TResource&gt; originalList;     private IEnumerable&lt;TResource&gt; prunedList;     private Func&lt;TResource, ICollection&lt;TResource&gt;&gt; getChildren;      public BreadthFirstPruner(IEnumerable&lt;TResource&gt; list, Func&lt;TResource, ICollection&lt;TResource&gt;&gt; getChildren)     {         this.originalList = list;         this.getChildren = getChildren;     }      public IEnumerable&lt;TResource&gt; GetPrunedTree(Func&lt;TResource,bool&gt; condition)     {         this.prunedList = new List&lt;TResource&gt;();         this.Prune(this.originalList, condition);         return this.prunedList;     }      private void Prune(IEnumerable&lt;TResource&gt; list, Func&lt;TResource,bool&gt; condition)     {         if (list.Count() == 0)         {             return;         }          var included = list.Where(condition);         this.prunedList = this.prunedList.Union(included);         var excluded = list.Except(included);         this.Prune(excluded.SelectMany(this.getChildren), condition);     } } </code></pre>  <p>The class does what it's supposed to, but it does so slowly, and I can't figure out why. I've used this on very small hierarchies where the complete hierarchy is already in memory (so there should be no linq-to-sql surprises). But regardless of how eager or lazy I try to make things, the first line of code to actually evaluate the results of a linq expression winds up taking 3-4 seconds to execute.</p>  <p>Here is the code that's currently consuming the pruner:</p>  <pre><code>Func&lt;BusinessUnitLabel, ICollection&lt;BusinessUnitLabel&gt;&gt; getChildren = l =&gt; l.Children; var hierarchy = scope.ToList(); var pruner = new BreadthFirstPruner&lt;BusinessUnitLabel&gt;(hierarchy, getChildren); Func&lt;BusinessUnitLabel, bool&gt; hasBusinessUnitsForUser = l =&gt;     l.BusinessUnits.SelectMany(bu =&gt; bu.Users.Select(u =&gt; u.IDGUID)).Contains(userId); var labels = pruner.GetPrunedTree(hasBusinessUnitsForUser).ToList(); </code></pre>  <p>As I stated previously, the dataset that I'm working with when this executes is quite small. It's only a few levels deep with only one node on most levels. As it's currently written, the slowness will occur on the first <em>recursive</em> call to <code>Prune</code> when I call <code>list.Count()</code>, because that's when the second level of the hierarchy (<code>excluded.SelectMany(this.getChildren)</code>) is being evaluated.</p>  <p>If, however, I add a <code>.ToList</code> call like so:</p>  <pre><code>var included = list.Where(condition).ToList() </code></pre>  <p>Then the slowness will occur at that point.</p>  <p>What do I need to do to make this thing go fast?</p>  <p><strong>Update</strong></p>  <p>After someone prompted me to reevaluate my condition more carefully, I realized that those associations in <code>hasBusinessUnitsForUser</code> were not being eager loaded. That there was the problem.</p>