<p>The question link is: <a href="http://codeforces.com/problemset/problem/431/C" rel="nofollow">http://codeforces.com/problemset/problem/431/C</a></p>  <blockquote>   <p>Quite recently a creative student Lesha had a lecture on trees. After   the lecture Lesha was inspired and came up with the tree of his own   which he called a k-tree.</p>      <p>A k-tree is an infinite rooted tree where:</p>      <ul>   <li>each vertex has exactly k children;</li>   <li>each edge has some weight;</li>   <li>if we look at the edges that goes from some vertex to its children (exactly   k edges), then their weights will equal 1, 2, 3, ..., k.</li>   </ul>      <p>The picture below shows a part of a 3-tree.</p>      <p><a href="http://i.stack.imgur.com/tnwCU.png" rel="nofollow"><img src="http://i.stack.imgur.com/tnwCU.png" alt="enter image description here"></a></p>      <p>As soon as Dima, a good friend of Lesha, found out about the tree, he   immediately wondered: "How many paths of total weight n (the sum of   all weights of the edges in the path) are there, starting from the   root of a k-tree and also containing at least one edge of weight at   least d?". Help Dima find an answer to his question. As the number of   ways can be rather large, print it modulo 1000000007 (10^9 + 7). (Open   the question link above for a picture of the mentioned tree)</p>      <p><strong>Input</strong><br>   A single line contains three space-separated integers: n, k and   d (1 ≤ n, k ≤ 100; 1 ≤ d ≤ k).</p>      <p><strong>Output</strong><br>   Print a single integer — the answer to the problem modulo   1000000007 (10^9 + 7).</p> </blockquote>  <p>So, I tried to develop a recursive solution for the same. However, I am not able to add the constraint to make sure the edge of weight atleast <code>d</code> should be present. How can I do that? Here is my recursive function: </p>  <pre><code>void calc(int present, int total,int k) // Here, present is initialised to 0.                                         // total is equal to n that is reqd.                                         // k is the value in the question {     if (total == present)     {         ans++;         ans = ans%val;         return;     }     else     {         for ( int i = 1; i &lt;= k; i++ )         {             if (present+i &lt;= total)                 return calc(present+i,total,k);         }     } } </code></pre>