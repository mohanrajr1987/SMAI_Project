<p>Assuming the following two SQL tables.</p>  <p><strong>db.Fruits</strong></p>  <pre><code>ID  Name F1  Apple F2  Orange F3  Melon </code></pre>  <p><strong>db.Attributes</strong></p>  <pre><code>ID  Fruits_ID   AttributeType   AttributeValue A1  F1          Color           Red A2  F3          Size            Large A3  F2          Size            Small A4  F1          Size            Small A6  F3          Color           Brown </code></pre>  <p>How do I use a LINQ query to search for the fruit I want with multiple nullable conditions WITHOUT multiplying the results due to a JOIN? For example, the following query produces multiple results if <code>condition</code> is null.</p>  <pre><code>var q = from f in db.Fruits         join a in db.Attributes         on f.ID equals a.Fruits_ID         where string.IsNullOrEmpty(condition) || fa.AttributeValue.Contains(conditon)         select FruitResult         {             // ...         } </code></pre>  <p>In any case, I have also looked into <code>INTO</code> but that's not working for me.</p>  <pre><code>var q = from f in db.Fruits         join a in db.Attributes         on f.ID equals a.Fruits_ID         into FruitsAttributes          from fa in FruitsAttributes         where string.IsNullOrEmpty(condition) || fa.AttributeValue.Contains(conditon)         select FruitResult         {             // ...         } </code></pre>  <p>The above still returns multiple/joined results when <code>condition</code> is null or empty.</p>  <p><strong>TL;DR:</strong> How do I use a one-to-many <code>.Contains</code> check in my query such that, if the conditions are null, returns individual "unjoined" rows?</p>