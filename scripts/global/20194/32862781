<p>I'm creating feature tests. I prepared Scenario Outlines for covering different scenarios. I use the same step in two of them because it is exactly the same.</p>  <pre><code>Scenario Outline: Scenario 1 When I set &lt;value&gt;   And I do smth Then I get result  Examples: values | value |  | 1 | | 2 |  Scenario Outline: Scenario 2 When I set &lt;value&gt;  #the same step And I do smth else Then I get other result  Examples: values | value |  | 1 | | 2 | </code></pre>  <p>In case of scenario 1 - all steps, and whole scenario passes. In case of scenario 2 (using debuger) I go into the step definition in code, I pass whole method (as below) to the caller which is <code>public Object invoke(Object obj, Object... args)</code> and I can see proper values of args, and updated object in line <code>return ma.invoke(obj, args);</code>, but next step in debuger jump to nowhere. I can see the proces is working, I see also the test process in Windows Task Manager. The process made by this step is also proper.</p>  <pre><code>@When("^I set \"([^\"]*)\"$") public void i_set(String value) throws Throwable {   // processing   staticVal = value + "processed data"; } </code></pre>  <p>Additionally - In step definition class I keep one value as static (result from one step to use it in next step - I know it is against testing approach, but for now I'm forced to do it in such way).</p>  <p>The question is - why it passes always for the Scenario 1, and in Scenario 2 even when it leaves the step it hangs? How can I check what is cause of such behaviour? Where the code jump after that?</p>  <p><strong>Update:</strong> Removing the static field makes no difference in behaviour.</p>  <p><strong>Update:</strong> Adding new method for scenario 2, which do exactly the same as in scenario 1 still cause the same problem. <code>i_setabc(String value)</code> added.</p>