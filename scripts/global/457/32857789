<p>I'm trying to build a small tool for comparing types in a bunch of assemblies. For this purpose I created two subfolders and put the respective dlls there:</p>  <ul> <li><code>..\Dlls\v1.1</code></li> <li><code>..\Dlls\v1.2</code></li> </ul>  <p>where <code>..</code> is the application folder</p>  <p>I also created a proxy object:</p>  <pre><code>public class ProxyDomain : MarshalByRefObject {     public Assembly LoadFile(string assemblyPath)     {         try         {             //Debug.WriteLine("CurrentDomain = " + AppDomain.CurrentDomain.FriendlyName);             return Assembly.LoadFile(assemblyPath);         }         catch (FileNotFoundException)         {             return null;         }     } } </code></pre>  <p>and used it for loading in the following routine that should load an dll and get all types declared in it:</p>  <pre><code>private static HashSet&lt;Type&gt; LoadAssemblies(string version) {     _currentVersion = version;      var path = Path.Combine(Environment.CurrentDirectory, Path.Combine(_assemblyDirectory, version));      var appDomainSetup = new AppDomainSetup     {         ApplicationBase = Environment.CurrentDirectory,          };      var evidence = AppDomain.CurrentDomain.Evidence;     var appDomain = AppDomain.CreateDomain("AppDomain" + version, evidence, appDomainSetup);                 var proxyDomainType = typeof(ProxyDomain);     var proxyDomain = (ProxyDomain)appDomain.CreateInstanceAndUnwrap(proxyDomainType.Assembly.FullName, proxyDomainType.FullName);     _currentProxyDomain = proxyDomain;      var assemblies = new HashSet&lt;Type&gt;();      var files = Directory.GetFiles(path, "*.dll");      foreach (var file in files)     {         try         {             var assembly = proxyDomain.LoadFile(file);             if (assembly != null)             {                 assemblies.UnionWith(assembly.DefinedTypes.Where(t =&gt; t.IsPublic));             }         }         catch (Exception)         {         }     }     return assemblies; } </code></pre>  <p>So far nothing unusual... but it didn't work like that in this case (probably because of the subfolders) so I searched a bit and found that a settting in the <code>app.config</code> might help so I tried to add two probing paths:</p>  <pre><code>&lt;runtime&gt;   &lt;assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1"&gt;     &lt;probing privatePath="Dlls\v1.1;Dlls\v1.2" /&gt;   &lt;/assemblyBinding&gt; &lt;/runtime&gt; </code></pre>  <p>Now there wasn't any <code>FileNotFoundExpection</code>s anymore but as the dlls have the same names it loaded only dlls from the first subdirectory (<code>v1.1</code>) into both domains so I removed it and instead tried to implement the <code>AppDomain.CurrentDomain.AssemblyResolve</code> event handler like that:</p>  <pre><code>AppDomain.CurrentDomain.AssemblyResolve += (sender, e) =&gt; {     var path = Path.Combine(Environment.CurrentDirectory, Path.Combine(_assemblyDirectory, _currentVersion));     path = Path.Combine(path, e.Name.Split(',').First());     path = path + ".dll";     var assembly = _currentProxyDomain.LoadFile(path);     return assembly; }; </code></pre>  <p>But unfortunatelly with this event handler I created an infinite loop and it <em>calls itself</em> each time it tries to load a dll it cannot find. I have no more ideas what else I could try.</p>  <hr>  <h2>UPDATE-1</h2>  <p>As @SimonMourier suggested I tried to use a custom <code>.config</code> for my new AppDomains and created two more <code>*.config</code>s like:</p>  <pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;configuration&gt;   &lt;startup&gt;     &lt;supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.5" /&gt;   &lt;/startup&gt;   &lt;runtime&gt;     &lt;assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1"&gt;       &lt;probing privatePath="Dlls\v1.1" /&gt;     &lt;/assemblyBinding&gt;   &lt;/runtime&gt; &lt;/configuration&gt; </code></pre>  <p>I named them <code>v1.1.config</code> and <code>v1.2.config</code>. Then I set the <em>new</em> <code>ConfigurationFile</code> property:</p>  <pre><code>var appDomainSetup = new AppDomainSetup {     ApplicationBase = Environment.CurrentDirectory,     ConfigurationFile = Path.Combine(Environment.CurrentDirectory, string.Format("{0}.config", version)),         }; </code></pre>  <p><em>I've set the option <code>Copy to Output Directory</code> to <code>Copy always</code> ;-)</em></p>  <p>It didn't work so I googled and tried another suggestion:</p>  <pre><code>AppDomain.CurrentDomain.SetData("APP_CONFIG_FILE", appDomainSetup.ConfigurationFile); </code></pre>  <p>but this didn't help either. Still <code>FileNotFoundException</code> like my custom configs weren't there.</p>  <p>Using the <code>SetConfigurationBytes</code> method instead had also no effect:</p>  <pre><code>var domainConfig = @"     &lt;configuration&gt;         &lt;startup&gt;             &lt;supportedRuntime version=""v4.0"" sku="".NETFramework,Version=v4.5"" /&gt;         &lt;/startup&gt;         &lt;runtime&gt;             &lt;assemblyBinding xmlns=""urn:schemas-microsoft-com:asm.v1""&gt;               &lt;probing privatePath=""Dlls\{0}"" /&gt;             &lt;/assemblyBinding&gt;         &lt;/runtime&gt;     &lt;/configuration&gt;";  domainConfig = string.Format(domainConfig, version).Trim(); var probingBytes = Encoding.UTF8.GetBytes(domainConfig); appDomainSetup.SetConfigurationBytes(probingBytes); </code></pre>  <p>However if I call the <code>GetData</code> method the new appdomain uses the custom .config:</p>  <pre><code>Debug.WriteLine("Current config: " + AppDomain.CurrentDomain.GetData("APP_CONFIG_FILE")); </code></pre>  <p>It outputs the path that I set via <code>ConfigurationFile</code></p>  <hr>  <h2>UPDATE-2</h2>  <p>This is really confusing. The Stack Trace reveals that despite of what the <code>GetData</code> returs the <code>Assembly.LoadFile</code> still uses the original .config:</p>  <blockquote>   <p>=== LOG: This bind starts in default load context. LOG: Using application configuration file:</p>      <p>C:[...]\bin\Debug\MyApp.exe.Config</p>      <p>LOG: Using host configuration file:  LOG: Using machine configuration file from</p>      <p>C:\Windows\Microsoft.NET\Framework\v4.0.30319\config\machine.config.</p> </blockquote>  <hr>  <h2>UPDATE-3</h2>  <p>OK, I did some more experimenting and found out that by implementing @SimonMourier suggestion it indeed worked. The <code>FileNotFoundException</code> wasn't thrown by the <code>LoadFile</code> method in the <code>ProxyDomain</code> class but in the <code>Main</code> method of my app. I gues the assembly and the types are allowed to live only within the <code>ProxyDomain</code> context and cannot be transfered into the main domain as I have tried.</p>  <pre><code>public IEnumerable&lt;Type&gt; LoadFile(string assemblyPath) {     //try     {         // does't throw any exceptions         var assembly = Assembly.LoadFile(assemblyPath);         // returning the assembly itself or its types will throw an exception in the main application         return assembly.DefinedTypes;     }     //catch (FileNotFoundException)     {       //  return null;     } } </code></pre>  <p>Method in the main domain:</p>  <pre><code>private static HashSet&lt;Type&gt; LoadAssemblies(string version) {     // omitted      foreach (var file in files)     {         //try         {              // the exception occurs here, when transfering types between domains:             var types = proxyDomain.LoadFile(file);                      assemblies.UnionWith(types.Where(t =&gt; t.IsPublic));         }     }      // omitted } </code></pre>  <p>I'll need to rewrite the comparison algorithm now by at least the assemblies can be loaded ;-)</p>