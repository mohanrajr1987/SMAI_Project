<p>I'm using the latest version of <code>Xamarin.iOS</code> (8.10.5.26). While developing a cross-platform library which heavily uses async/await methods, I found that it works fine with Android, Mono, Microsoft CLR but it crashes on iOS. Narrowing the issue down has lead to what I suspect to be a bug in CLR implementation on iOS.</p>  <p>If you have a class <code>MyNetworkStream</code> derived from <code>NetworkStream</code> which overrides its methods, iOS version may call <code>MyNetworkStream's</code> <code>EndRead</code> when the caller assumes that <code>base.EndRead</code> should be called. This happens in this scenario:</p>  <pre><code>int bytesRead = await Task.Factory.FromAsync&lt;int&gt;(base.BeginRead(buffer, 0, count, null, null), base.EndRead); </code></pre>  <p>All other platforms but iOS call <code>base.EndRead</code> (<code>NetworkStream.EndRead</code>). Is it indeed a bug in iOS version of CLR or am I missing something?</p>  <p><strong>The entire sample:</strong></p>  <pre><code>public class MyNetworkStream : NetworkStream {     public MyNetworkStream(Socket sock) : base(sock)     {     }      public override IAsyncResult BeginRead(byte[] buffer, int offset, int size, AsyncCallback callback, object state)     {         throw new InvalidOperationException("BeginRead ERROR");         return base.BeginRead(buffer, offset, size, callback, state);     }      public override int EndRead(IAsyncResult asyncResult)     {         int x = 0;         throw new InvalidOperationException("EndRead ERROR");         return base.EndRead(asyncResult);     }      public override int Read(byte[] buffer, int offset, int count)     {         throw new InvalidOperationException("Read ERROR");         return base.Read(buffer, offset, count);     }      public override async Task&lt;int&gt; ReadAsync(byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken)     {         int bytesRead = await Task.Factory.FromAsync&lt;int&gt;(base.BeginRead(buffer, 0, count, null, null), base.EndRead);         return bytesRead;     } }   // Put this in a button click handler or something like that. using (TcpClient client = new TcpClient("mail.afterlogic.com", 143)) {     MyNetworkStream mns = new MyNetworkStream(client.Client);     byte[] b = new byte[1024];     await mns.ReadAsync(b, 0, b.Length); } </code></pre>  <p>iOS version causes <code>InvalidOperationException</code> with "EndRead ERROR" message, other versions don't as they never get into <code>MyNetworkStream.EndRead</code> (or any <code>MyNetworkStream</code> methods at all). Interestingly that <code>base.BeginRead</code> is OK, only <code>base.EndRead</code> is a problem. I.e. <code>Task.Factory.FromAsync</code> picks the correct value for Begin method but not for End counterpart (as the first one is just <code>IAsyncResult</code> while second one is Func). So the problem is with Func, I suppose.</p>