<p>I am currently working on a iOS game using SpriteKit and Objective-C. I've recently been trying to optimize my draw calls, but I've run into an issue where I am either misunderstand the batch draw operation and/or I am receiving some unexpected results. Additionally I have read the Apple documentation regarding batch drawing, I'm just afraid I may have misinterpreted some of the guidelines. </p>  <p>So here is the rundown: (assume that all atlases are preloaded and that self is a SKScene)</p>  <p>This works as you would expect. The first touch adds +1 to both the node and draw count. Subsequent touches add to the node count but not the draw count. </p>  <pre><code>/*Code Block 1:*/ -(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event {  [super touchesBegan:touches withEvent:event];  UITouch *touch = [touches anyObject]; CGPoint location = [touch locationInNode:self]; SKNode *node = [self nodeAtPoint:location];  SKSpriteNode *touch1 = [SKSpriteNode spriteNodeWithTexture:[[SKTextureAtlas atlasNamed:@"TouchAtlas1"] textureNamed:@"texture1"]]; [touch1 setPosition:location]; [self addChild:enemyTouch]; } </code></pre>  <p>When I start adding two sprites from different atlases to the parent I start to get too many draw calls. What I expected: on the first touch I would get +2 nodes and +2 draw calls and subsequent touches produce +2 nodes and +0 draw calls. What I got: on the first touch I got +2 nodes and +2 draw calls and subsequent touches produced +2 nodes and +2 draw calls. </p>  <pre><code>/*Code Block 2:*/ -(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event {  [super touchesBegan:touches withEvent:event];  UITouch *touch = [touches anyObject]; CGPoint location = [touch locationInNode:self]; SKNode *node = [self nodeAtPoint:location];  SKSpriteNode *touch1 = [SKSpriteNode spriteNodeWithTexture:[[SKTextureAtlas atlasNamed:@"TouchAtlas1"] textureNamed:@"texture1"]]; [touch1 setPosition:location]; [self addChild:touch1];  SKSpriteNode *touch2 = [SKSpriteNode spriteNodeWithTexture:[[SKTextureAtlas atlasNamed:@"TouchAtlas2"] textureNamed:@"texture2"]]; [touch2 setPosition:location]; [self addChild:touch2]; } </code></pre>  <p>I tried one additional step of adding a child SKNode *extraLayer to the scene and adding one sprite to the scene and one sprite to the extraLayer. This produced the desired results of +2 nodes and +0 draw calls I wanted above. </p>  <pre><code>/*Code Block 3:*/ -(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event {  [super touchesBegan:touches withEvent:event];  UITouch *touch = [touches anyObject]; CGPoint location = [touch locationInNode:self]; SKNode *node = [self nodeAtPoint:location];  SKSpriteNode *touch1 = [SKSpriteNode spriteNodeWithTexture:[[SKTextureAtlas atlasNamed:@"TouchAtlas1"] textureNamed:@"texture1"]]; [touch1 setPosition:location]; [self addChild:touch1];  SKSpriteNode *touch2 = [SKSpriteNode spriteNodeWithTexture:[[SKTextureAtlas atlasNamed:@"TouchAtlas2"] textureNamed:@"texture2"]]; [touch2 setPosition:location]; [self.extraLayer addChild:touch2]; } </code></pre>  <p><strong>The question:</strong> Is this in fact the way batching draw calls needs to be handled? All sprites whose textures come from common atlases need to be children of the same parent, but additionally that parent has no children who's textures come from a different atlas? Or is there a way of making the method of block 2 batch correctly?</p>