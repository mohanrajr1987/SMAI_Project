<p>I'm trying to specialise a templatised function inside a templatised class. It works fine until I add the specialisation: then it doesn't compile anymore.</p>  <p>Here's a simplified example of what kind of thing I'm trying to do:</p>  <pre><code>template &lt;typename TString, typename TStringStream, typename TChar&gt; class TestClass { public:     template &lt;typename T&gt;     static T convert(const TChar* text); };   //This specialisation doesn't compile template &lt;typename TString, typename TStringStream, typename TChar&gt; template &lt;&gt; inline bool TestClass&lt;TString, TStringStream, TChar&gt;::convert(const TChar* text) {     return strcmp(text, "true"); }   template &lt;typename TString, typename TStringStream, typename TChar&gt; template &lt;typename T&gt; T TestClass&lt;TString, TStringStream, TChar&gt;::convert(const TChar* text) {     TStringStream textStream(text);     T result;     textStream &gt;&gt; result;     return result; }   void main() {     TestClass&lt;RString, RStringstream, char&gt;::convert&lt;bool&gt;("0"); } </code></pre>  <p>This is the compiler error Visual Studio 2010 returns when I try to compile this:</p>  <pre><code>error C2244: 'TestClass&lt;TString,TStringStream,TChar&gt;::convert' : unable to match function definition to an existing declaration     definition     'bool TestClass&lt;TString,TStringStream,TChar&gt;::convert(const TChar *)'     existing declarations     'T TestClass&lt;TString,TStringStream,TChar&gt;::convert(const TChar *)' </code></pre>  <p>What am I doing wrong here?</p>  <p>(This question is different from <a href="http://stackoverflow.com/questions/15911890/overriding-return-type-in-function-template-specialization">this one</a> because in that link they are trying to return a different type from what the template is, a very special case that I am not trying to do here.)</p>