<p>See the following code:</p>  <pre><code>#include &lt;vector&gt;  template class std::vector&lt;int&gt;; extern template class std::vector&lt;int&gt;;  int main() {} </code></pre>  <p>While GCC 5.2 compiles fine, clang 3.6 gives the following error message:</p>  <pre><code>main.cpp:4:28: error: explicit instantiation declaration (with 'extern') follows explicit instantiation definition (without 'extern') extern template class std::vector&lt;int&gt;                            ^ main.cpp:3:21: note: explicit instantiation definition is here template class std::vector&lt;int&gt;                     ^ 1 error generated. </code></pre>  <p>Still, for the following code</p>  <pre><code>template &lt;typename T&gt; void f() {}  template void f&lt;int&gt;(); extern template void f&lt;int&gt;();  int main() {} </code></pre>  <p>Both GCC and clang errored out. The message for GCC is</p>  <pre><code>main.cpp:5:29: error: duplicate explicit instantiation of 'void f() [with T = int]' [-fpermissive]  extern template void f&lt;int&gt;(); </code></pre>  <p>and the one for clang is</p>  <pre><code>main.cpp:5:22: error: explicit instantiation declaration (with 'extern') follows explicit instantiation definition (without 'extern') extern template void f&lt;int&gt;();                      ^ main.cpp:4:15: note: explicit instantiation definition is here template void f&lt;int&gt;();               ^ 1 error generated. </code></pre>  <p>What's going on with the two guys? Does the standard forbid an explicit template instantiation declaration to be preceded by an explicit definition? It makes little sense to me. After all, what harm could it be to define first and then declare? Just think about the case with non-template functions.</p>