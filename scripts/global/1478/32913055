<p>I'd like to define a function for template class with an integer template parameter so that the number of function arguments depends on the template parameter. Here's an example:</p>  <pre><code>template&lt; class Coord, int dim &gt; class Point {     Coord mCoords[ dim ]; public:     void Set( /* I want exactly dim Coord arguments here. */ ); }; </code></pre>  <p>I'd like this code to compile:</p>  <pre><code>Point&lt;double,2&gt; pt2d; pt2d.Set( 25, 32 ); Point&lt;double,3&gt; pt3d; pt3d.Set( 25, 32, 100 ); </code></pre>  <p>and this code to fail:</p>  <pre><code>Point&lt;double,2&gt; pt2d; pt2d.Set( 25, 32, 100 );  // Too many arguments Point&lt;double,3&gt; pt3d; pt3d.Set( 25, 32 );       // Too few arguments </code></pre>  <p>Now, I can manually specialize <code>Point</code> in smaller dimensions to have unrelated <code>Set</code> functions, but I find the practice of essentially repeating the same code un-C++-ish. Furthermore, I shouldn't have to specialize for every possible value of the int template parameter.</p>  <p>Is it possible to implement <code>Point&lt;Coord,dim&gt;::Set()</code> function that would take exactly <code>dim</code> arguments of type <code>Coord</code> without writing specialization code for each value of <code>dim</code>?</p>