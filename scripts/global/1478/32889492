<p><em>Sorry for how complicated the title of this question is; I tried to describe the minimal SSCCE I constructed for this problem.</em></p>  <p>I have the following code:</p>  <pre><code>#include &lt;iostream&gt;  namespace fizz {     template&lt;typename... Ts&gt;     class bar     {     public:         template&lt;int I, typename... Us&gt;         friend auto foo(const bar&lt;Us...&gt; &amp;);      private:         int i = 123;     };      template&lt;int I, typename... Ts&gt;     auto foo(const bar&lt;Ts...&gt; &amp; b)     {         return b.i;     } }  int main() {     std::cout &lt;&lt; fizz::foo&lt;1&gt;(fizz::bar&lt;int, float&gt;{}); } </code></pre>  <p>This code <a href="http://coliru.stacked-crooked.com/a/7d45c79e8f9ba902">compiles with GCC 5.2</a> and <a href="http://coliru.stacked-crooked.com/a/b9735ebd213a4840">doesn't with Clang 3.7</a>:</p>  <pre><code>main.cpp:19:18: error: 'i' is a private member of 'fizz::bar&lt;int, float&gt;'         return b.i;                  ^ main.cpp:25:24: note: in instantiation of function template specialization 'fizz::foo&lt;1, int, float&gt;' requested here     std::cout &lt;&lt; fizz::foo&lt;1&gt;(fizz::bar&lt;int, float&gt;{});                        ^ main.cpp:13:13: note: declared private here         int i = 123;             ^ </code></pre>  <p>However, if you change the code slightly (although in a way that is not exactly useful for me, since in the real code this would introduce tons of boilerplate):</p>  <pre><code>#include &lt;iostream&gt;  namespace fizz {     template&lt;typename... Ts&gt;     class bar     {     public:         template&lt;int I, typename... Us&gt;         friend int foo(const bar&lt;Us...&gt; &amp;);      private:         int i = 123;     };      template&lt;int I, typename... Ts&gt;     int foo(const bar&lt;Ts...&gt; &amp; b)     {         return b.i;     } }  int main() {     std::cout &lt;&lt; fizz::foo&lt;1&gt;(fizz::bar&lt;int, float&gt;{}); } </code></pre>  <p>it suddenly <a href="http://coliru.stacked-crooked.com/a/2f2b259d0fc6d494">works with that Clang 3.7</a>.</p>  <p>The difference is that in the version of the code that doesn't compile with Clang, the friend function template uses C++14 <code>auto</code> return type deduction, while the working one plainly says it returns <code>int</code>. The same problem also happens with other variants of <code>auto</code> return type deduction, like <code>auto &amp;&amp;</code> or <code>const auto &amp;</code>.</p>  <p>Which compiler is right? Please provide some standard quotes to support the answer, since it is quite possible that a bug will need to be filed for one (...hopefully not both) compilers... or a standard defect, if both are right (which wouldn't be the first time).</p>