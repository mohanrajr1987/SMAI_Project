<p>The code should call back a function by extracting arguments from a string. However, the order changes as follows: (Visual Studio 2013 AND 2015! express)</p>  <p>"1 2 3 4"  int, double, string, int ->  3 2 4 1</p>  <p>"1 2 3 4"  int, double, float, int ->  4 3 2 1</p>  <p>Edit : It <a href="http://cpp.sh/3o2a" rel="nofollow">works properly in gcc</a> and is a <a href="https://connect.microsoft.com/VisualStudio/feedback/details/1075443/c-order-of-evaluation-of-expressions-in-a-braced-initializer-list-is-wrong-in-the-context-of-a-constructor-call" rel="nofollow">MS Visual C++ compiler bug</a> - Tested for VS2013 and VS2015. Does anyone knows a work around ? (Maybe using some C++14 feature? )</p>  <p>Edit2: I solved it adding indices to the parameters and removed the tuple too  <a href="http://cpp.sh/9jc5" rel="nofollow">http://cpp.sh/9jc5</a></p>  <p>Here the sample:</p>  <pre><code>void one(int i, double d, string s, int ii) {     std::cout &lt;&lt; "function one(" &lt;&lt; i &lt;&lt; ", " &lt;&lt; d &lt;&lt; ", " &lt;&lt; s &lt;&lt; ", " &lt;&lt; ii &lt;&lt; ");\n"; }  int main() {     RegisterRPC&lt;int, double, string, int&gt;("test1", one);     DataSource* data=new DataSource("1 2 3 4");     functionarray["test1"](data);     system("pause");     return 0; } </code></pre>  <p>And the complete code:</p>  <pre><code>#include &lt;stdlib.h&gt; #include &lt;functional&gt; #include &lt;tuple&gt; #include &lt;map&gt; #include &lt;iostream&gt;  #include &lt;istream&gt; #include &lt;sstream&gt; #include &lt;string&gt;  // ------------- UTILITY--------------- template&lt;int...&gt; struct index_tuple{};  template&lt;int I, typename IndexTuple, typename... Types&gt; struct make_indexes_impl;  template&lt;int I, int... Indexes, typename T, typename ... Types&gt; struct make_indexes_impl&lt;I, index_tuple&lt;Indexes...&gt;, T, Types...&gt; {     typedef typename make_indexes_impl&lt;I + 1, index_tuple&lt;Indexes..., I&gt;, Types...&gt;::type type; };  template&lt;int I, int... Indexes&gt; struct make_indexes_impl&lt;I, index_tuple&lt;Indexes...&gt; &gt; {     typedef index_tuple&lt;Indexes...&gt; type; };  template&lt;typename ... Types&gt; struct make_indexes : make_indexes_impl&lt;0, index_tuple&lt;&gt;, Types...&gt; {};  // ----------UNPACK TUPLE AND APPLY TO FUNCTION ---------  using namespace std;  template&lt;class Ret, class... Args, int... Indexes &gt; Ret apply_helper(Ret(*pf)(Args...), index_tuple&lt; Indexes... &gt;, tuple&lt;Args...&gt;&amp;&amp; tup) {     return pf(forward&lt;Args&gt;(get&lt;Indexes&gt;(tup))...); }  template&lt;class Ret, class ... Args&gt; Ret apply(Ret(*pf)(Args...), const tuple&lt;Args...&gt;&amp;  tup) {     return apply_helper(pf, typename make_indexes&lt;Args...&gt;::type(), tuple&lt;Args...&gt;(tup)); }  template&lt;class Ret, class ... Args&gt; Ret apply(Ret(*pf)(Args...), tuple&lt;Args...&gt;&amp;&amp;  tup) {     return apply_helper(pf, typename make_indexes&lt;Args...&gt;::type(), forward&lt;tuple&lt;Args...&gt;&gt;(tup)); } // --- make tuple ---  template &lt;typename T&gt; T read(std::istream&amp; is) {     T t; is &gt;&gt; t; cout &lt;&lt; t &lt;&lt; endl; return t; }  template &lt;typename... Args&gt; std::tuple&lt;Args...&gt; parse(std::istream&amp; is) {     return std::make_tuple(read&lt;Args&gt;(is)...); }  template &lt;typename... Args&gt; std::tuple&lt;Args...&gt; parse(const std::string&amp; str) {     std::istringstream ips(str);     return parse&lt;Args...&gt;(ips); };  // ---- RPC stuff  class DataSource {     std::string data; public:     DataSource(std::string s) { data = s; };     template&lt;class...Ts&gt; std::tuple&lt;Ts...&gt; get() {  return parse&lt;Ts...&gt;(data);  }; };  std::map&lt;std::string, std::function&lt;void(DataSource*)&gt; &gt; functionarray;  template&lt;typename... Args, class F&gt; void RegisterRPC(std::string name, F f) {     functionarray[name] = [f](DataSource* data){apply(f, data-&gt;get&lt;Args...&gt;()); }; }  // --------------------- TEST ------------------  void one(int i, double d, string s, int ii) {     std::cout &lt;&lt; "function one(" &lt;&lt; i &lt;&lt; ", " &lt;&lt; d &lt;&lt; ", " &lt;&lt; s &lt;&lt; ", " &lt;&lt; ii &lt;&lt; ");\n"; }  int main() {     RegisterRPC&lt;int, double, string, int&gt;("test1", one);     DataSource* data=new DataSource("1 2 3 4");     functionarray["test1"](data);     system("pause");     return 0; }  // --------------------- TEST ------------------ </code></pre>  <p>References used</p>  <p><a href="http://stackoverflow.com/questions/687490/how-do-i-expand-a-tuple-into-variadic-template-functions-arguments">How do I expand a tuple into variadic template function&#39;s arguments?</a></p>  <p><a href="http://stackoverflow.com/questions/10014713/build-tuple-using-variadic-templates">build tuple using variadic templates</a></p>