<p>the following code produces</p>  <blockquote>   <p>"error: invalid operands of types '' and 'const size_t {aka const long unsigned int}' to binary 'operator&lt;'"   (gcc-4.9.1)</p> </blockquote>  <p>I just want a lookup function for default values of different types. Is this supposed to work at all? </p>  <pre><code>#include &lt;iostream&gt; #include &lt;string&gt; #include &lt;tuple&gt;  // IDs enum class ID : size_t {     AAA, // 0     BBB, // 1     CCC, // 2     DDD  // 3 };  // default values for each ID const auto defaultValsForIDs = std::make_tuple(         int(1),             // 0         std::string("bbb"), // 1          double(3.5),        // 2         int(-5)             // 3 );   //------------------------------------------------------ // HERE IS WHERE IT GETS MESSY: //------------------------------------------------------ // default values for each deviceID template&lt;typename EnumT&gt; using underlayingEnumT = typename std::underlying_type&lt;EnumT&gt;::type;  template&lt;typename EnumT&gt; constexpr underlayingEnumT&lt;EnumT&gt; to_underlying(EnumT e)  {     return static_cast&lt;underlayingEnumT&lt;EnumT&gt;&gt;(e); }  template&lt;typename EnumT&gt; auto getDefaultValue(const EnumT e)  -&gt; decltype(std::get&lt;to_underlying&lt;EnumT&gt;(e)&gt;(defaultValsForIDs)) // &lt;- THIS WON'T WORK {     return std::get&lt;to_underlying&lt;EnumT&gt;(e)&gt;(defaultValsForIDs); }   //------------------------------------------------------ // THIS DOES NOT COMPILE AS WELL //------------------------------------------------------ template&lt;&gt; auto getDefaultValue(const size_t xx)  -&gt; decltype(std::get&lt;xx&gt;(defaultValsForIDs)) // &lt;- THIS WON'T WORK {     return std::get&lt;xx&gt;(defaultValsForIDs); }  int main(int , char** ) {     std::cout &lt;&lt; getDefaultValue(ID::AAA) &lt;&lt; std::endl;      return 0; } </code></pre>  <p>Am I missing a <code>template</code> somewhere? see <a href="http://stackoverflow.com/questions/610245/where-and-why-do-i-have-to-put-the-template-and-typename-keywords?lq=1">Where and why do I have to put the &quot;template&quot; and &quot;typename&quot; keywords?</a> or <a href="http://stackoverflow.com/questions/15693815/compile-error-unresolved-overloaded-function-type">Compile error: unresolved overloaded function type</a></p>  <p>$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$<br> EDIT as suggested by Piotr:</p>  <p>changed:</p>  <pre><code>template&lt;typename EnumT, EnumT e&gt; auto getDefaultValue()  -&gt; decltype(std::get&lt;to_underlying&lt;EnumT&gt;(e)&gt;(defaultValsForIDs)) {     return std::get&lt;to_underlying&lt;EnumT&gt;(e)&gt;(defaultValsForIDs); } </code></pre>  <p>and added instance for ID:</p>  <pre><code>template&lt;ID id&gt; auto getDefaultValForID()  -&gt; decltype(getDefaultValue&lt;ID, id&gt;()) {     return getDefaultValue&lt;ID,id&gt;(); } </code></pre>  <p>then:</p>  <pre><code>int main() {     std::cout &lt;&lt; getDefaultValForID&lt;ID::BBB&gt;() &lt;&lt; std::endl;      return 0; } </code></pre>  <p>works like a charm.</p>