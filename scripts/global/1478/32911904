<p>In the following snippit, is the <code>template&lt;&gt;</code> optional for the specialization? Is there any difference whether I include it or not? My first instinct was to include it as it more-or-less signifies that it is a specialization. It compiles both ways under both g++ 4.9.2 and Intel 16</p>  <pre><code>#include &lt;vector&gt; #include &lt;iostream&gt;  template&lt;typename T&gt; struct PrintMe {     static void Print(const T &amp; t)     {         std::cout &lt;&lt; "In general templated struct: " &lt;&lt; t &lt;&lt; "\n";     }    };         template&lt;&gt; // &lt;--- optional? template&lt;typename T&gt; struct PrintMe&lt;std::vector&lt;T&gt;&gt; {        static void Print(const std::vector&lt;T&gt; &amp; t)     {            std::cout &lt;&lt; "In general specialization for vector: " &lt;&lt; t.size() &lt;&lt; "\n";         for(const auto &amp; it : t)             std::cout &lt;&lt; "        " &lt;&lt; it &lt;&lt; "\n";     }  };   int main(void) {        PrintMe&lt;int&gt;::Print(5);        PrintMe&lt;double&gt;::Print(5);         PrintMe&lt;std::vector&lt;float&gt;&gt;::Print({10,20,30,40});      return 0; } </code></pre>  <p>Note: Out of curiosity, I tried adding multiple <code>template&lt;&gt;</code>. Ie,</p>  <pre><code>template&lt;&gt; template&lt;&gt; template&lt;&gt; template&lt;typename T&gt; struct PrintMe&lt;std::vector&lt;T&gt;&gt; </code></pre>  <p>This still compiles with Intel, but not with g++. Not sure what that means, but it's interesting.</p>  <p>Note 2: Wow, this is very similar to a question of mine from 5 years ago: <a href="http://stackoverflow.com/questions/4189945/templated-class-specialization-where-template-argument-is-a-template">Templated class specialization where template argument is a template</a> . There it was mentioned as redundant syntax.</p>