<p>I have found a lot of information about template deduction (eg <a href="http://stackoverflow.com/questions/31563580/c-templated-function-overloading-rules">C++ templated function overloading rules</a>) but it does not help me understand the behaviour of template deduction for an overloaded recursive function. In the following code, I do not really understand how the compiler managed to deduce that it should use the <code>vector&lt;T&gt;</code> function two times for <code>vectvect</code> and the <code>pair&lt;T,U&gt;</code> two times for <code>pairpair</code> - but it can. Thus, I do not understand why it can not deduce that it should use both <code>vector&lt;T&gt;</code> and <code>pair&lt;T,U&gt;</code> function for <code>vectpair</code> ?</p>  <p>Is this something to do with why the <code>const</code> keyword leads to increase the conversion and thus make the <code>T</code> function better ? (But how do the two other examples can work in this case ?)</p>  <p>Is the two first deduction only possible because the current function is tested first for the template deduction in a recursive call ?</p>  <pre><code>#include &lt;iostream&gt; #include &lt;sstream&gt; #include &lt;vector&gt;  using namespace std;  template&lt;class T&gt; string print(const T&amp; t){     ostringstream s;     s &lt;&lt; t;     return s.str(); }  template&lt;class T&gt; string print(const vector&lt;T&gt;&amp; t){     ostringstream s;     s &lt;&lt; '[';     for(int i=0;i&lt;(int)t.size();i++)         s &lt;&lt; print(t[i]) &lt;&lt; ' ';     s &lt;&lt; ']';     return s.str(); }  template&lt;class T,class U&gt; string print(const pair&lt;T,U&gt;&amp; t){     ostringstream s;     s &lt;&lt; '(' &lt;&lt; print(t.first) &lt;&lt; ',' &lt;&lt; print(t.second) &lt;&lt; ')';     return s.str(); }  int main ( int argc, char **argv ) {     vector&lt;vector&lt;double&gt; &gt; vectvect(4,vector&lt;double&gt;(4));     for(int i=0;i&lt;(int)4;i++)         for(int j=0;j&lt;(int)4;j++)             vectvect[i][j] = i*4+j;     pair&lt;int,pair&lt;string,double&gt; &gt; pairpair = make_pair(10, make_pair("foo",0.5));     vector&lt;pair&lt;int,string&gt; &gt; vectpair(1,make_pair(42,"bar"));      ///template deduction     cout &lt;&lt; print(vectvect) &lt;&lt; endl;     cout &lt;&lt; print(pairpair) &lt;&lt; endl;      ///template deduction failure     //====&gt; here is the problem      //cout &lt;&lt; print(vectpair) &lt;&lt; endl;      return 0; } </code></pre>  <p>Currently, I am just trying to understand, but if somebody knows how to do it without introducing large source overhead, I am interested.</p>  <p>Thank you.</p>