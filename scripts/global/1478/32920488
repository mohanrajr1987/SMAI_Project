<p>I accidentally found that g++ (5.2.0) compiles the following</p>  <pre><code>template&lt;typename T&gt; struct A {     int x;     struct B {         void foo() {             x = 1;         }     }; }; </code></pre>  <p>even istantiating <code>A</code> and <code>A::B</code>, provided the member <code>B::foo</code> is not used. You reasonably get instead a compile error for <code>x</code> being a non-static member of <code>A</code> even by just compiling the no-op statement <code>&amp;A&lt;int&gt;::B::foo;</code>.</p>  <p>clang (3.6.2) however refuses the template even if <code>A</code> is not instantiated at all because it says that the non-static member name <code>x</code> cannot be used inside <code>B</code> while just reading the template definition.</p>  <p>Is this a bug in g++ or clang is being too strict about template members that are not instantiated?</p>