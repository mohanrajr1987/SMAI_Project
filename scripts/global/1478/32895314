<p>Well, I think I just get extremely confused by explicit template instantiation ~>_&lt;~</p>  <ol> <li>Could an explicit instantiation declaration exploit an implicit instantiation definition?</li> <li>What if both explicit and implicit instantiation definitions exist in a program? Will they ultimately collapse into a single one?</li> <li>Does an explicit instantiation declaration have any effect when placed after an implicit instantiation definition?</li> </ol>  <p>Also, see the following code:</p>  <pre><code>#include &lt;iostream&gt; #include &lt;vector&gt;  std::vector&lt;int&gt; a;  // Implicit instantiation definition.  // Explicit instantiation declaration. extern template class std::vector&lt;int&gt;;   int main() {   std::cout &lt;&lt; std::vector&lt;int&gt;().size();  // So what? } </code></pre>  <p>It causes the link error </p>  <pre><code>/tmp/ccQld7ol.o: In function `_GLOBAL__sub_I_a': main.cpp:(.text.startup+0x6e): undefined reference to `std::vector&lt;int, std::allocator&lt;int&gt; &gt;::~vector()' collect2: error: ld returned 1 exit status </code></pre>  <p>with GCC 5.2, but builds fine with clang 3.6. Which one is correct according to the standard?</p>  <p>I hope there is an insightful way to understand explicit template instantiation so that answers to all the questions above can be logically deduced and explained.</p>