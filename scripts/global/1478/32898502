<p>I'm making a simple <code>max</code> function to experiment with template metaprogramming in C++.  I expect to see "integral" to display when I call the function with an int but it isn't and I don't know why:</p>  <pre><code>#include &lt;iostream&gt;  template&lt;class...   &gt; struct make_void { typedef void type; }; template&lt;class... Ts&gt; using void_t = typename make_void&lt;Ts...&gt;::type;  #include &lt;type_traits&gt;  template &lt; class T, class = void_t &lt; typename std::is_integral&lt;T&gt;::value &gt; &gt;     T max(T x, T y) {     std::cout &lt;&lt; "integral" &lt;&lt; std::endl;     return x &gt; y ? x : y; }  template&lt;class T, class = void&gt;     T max(const T&amp; x, const T&amp; y) {     std::cout &lt;&lt; "class" &lt;&lt; std::endl;     return x &gt; y ? x : y; }  int main() {     int x = 5,y = 3;     std::cout &lt;&lt; "int: ";     max(x,y);     struct str{bool operator&gt;(const str&amp;other)const{return true;}} a, b;     std::cout &lt;&lt; "blank struct: ";     max(a,b); } </code></pre>  <p>In both cases it prints out class which worries me since I thought that SFINAE would select the better option more often.  I don't understand what's happening.</p>