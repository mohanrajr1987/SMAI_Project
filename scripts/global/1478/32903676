<p>I have this function</p>    <pre class="lang-cpp prettyprint-override"><code>template&lt;class A, class B&gt; std::shared_ptr&lt;A&gt; Foo(const B&amp; obj) { ... } </code></pre>  <p>And I want to provide a convenient function that also gets smart pointer (<code>shared_ptr</code> or <code>unique_ptr</code>) instead of references. Something like this:</p>  <pre class="lang-cpp prettyprint-override"><code>template&lt;class A, class B&gt; std::shared_ptr&lt;A&gt; Foo(const std::shared_ptr&lt;B&gt;&amp; obj) {   return Foo&lt;A&gt;(const_cast&lt;const B&amp;&gt;(*obj)); } </code></pre>  <p>It only works like that if I overload <code>Foo</code> to get <code>shared_ptr</code> as a parameter. However, I want to write it as a partial specialization. I also tried </p>  <pre class="lang-cpp prettyprint-override"><code>template&lt;class A&gt; template&lt;class B&gt; std::shared_ptr&lt;A&gt; Foo(const std::shared_ptr&lt;B&gt;&amp; obj) { ... } </code></pre>  <p>What is the correct syntax for this partial specialization?</p>