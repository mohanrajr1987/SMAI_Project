<p><strong>What I need:</strong> I need a verifiable time stamp on a file called <code>notes</code>, on my Ubuntu computer using <code>openssl</code>.</p>  <p><strong>What my problem is:</strong> I can get a signed timestamp from <a href="http://timestamp.globalsign.com/scripts/timstamp.dll" rel="nofollow">http://timestamp.globalsign.com/scripts/timstamp.dll</a> but I can't verify it.  When I run</p>  <pre><code>openssl ts -verify -data notes -in test.tsr </code></pre>  <p>I get the two-line output (extra line breaks inserted for readability)</p>  <pre><code>Verification: FAILED  3073500860:error:2F06D064:time stamp routines: TS_VERIFY_CERT:certificate verify error:ts_rsp_verify.c:246: Verify error:unable to get local issuer certificate </code></pre>  <p><em>I think what this means</em> is that I need a certificate named "GlobalSign TSA for Standard - G2" (see "output of script" section below), but I have no idea where to find it.  I <code>grep</code>'d my <code>/usr</code>, <code>/etc</code>, and <code>/home</code> directories for that string, so I'm pretty confident I actually don't have it.  I can't find it on the google. <strong>Does anybody know where to get this certificate, or maybe I'm doing something else wrong?</strong>  And also, why is this so difficult?  I see lots of people talking about using this server on various stack exchanges, but I seem to be the only one with this problem.</p>  <hr>  <p><strong>More info</strong></p>  <p>I am using the default <code>openssl</code> config file at <code>/etc/ssl/openssl.cnf</code>.</p>  <p>I use the following short script to generate a time stamp query <code>test.tsq</code>, then send it to the time stamp server, receive a time stamp reply <code>test.tsr</code>, then try to validate it.</p>  <pre><code>#!/bin/bash #make time stamp query openssl ts -query -data notes -sha256 -cert -out test.tsq  #write query to stdout in text format openssl ts -query -in test.tsq -text  echo ""  #use tsget to get the request, since I don't know how to do it with curl tsget -h http://timestamp.globalsign.com/scripts/timstamp.dll test.tsq  #write the reply to stdout in text form openssl ts -reply -in test.tsr -text  echo ""  #verify the timestamp openssl ts -verify -data notes -in test.tsr </code></pre>  <p>The <code>perl</code> script <code>tsget</code> came with the <code>openssl</code> package I think, and I found it at <code>/usr/lib/ssl/misc/tsget</code>, but I'll include it here for troubleshooting:</p>  <pre><code>#!/usr/bin/perl -w # Written by Zoltan Glozik &lt;zglozik@stones.com&gt;. # Copyright (c) 2002 The OpenTSA Project.  All rights reserved. $::version = '$Id: tsget,v 1.3 2009/09/07 17:57:18 steve Exp $';  use strict; use IO::Handle; use Getopt::Std; use File::Basename; use WWW::Curl::Easy;  use vars qw(%options);  # Callback for reading the body. sub read_body {     my ($maxlength, $state) = @_;     my $return_data = "";     my $data_len = length ${$state-&gt;{data}};     if ($state-&gt;{bytes} &lt; $data_len) {     $data_len = $data_len - $state-&gt;{bytes};     $data_len = $maxlength if $data_len &gt; $maxlength;     $return_data = substr ${$state-&gt;{data}}, $state-&gt;{bytes}, $data_len;     $state-&gt;{bytes} += $data_len;     }     return $return_data; }  # Callback for writing the body into a variable. sub write_body {     my ($data, $pointer) = @_;     ${$pointer} .= $data;     return length($data); }  # Initialise a new Curl object. sub create_curl {     my $url = shift;      # Create Curl object.     my $curl = WWW::Curl::Easy::new();      # Error-handling related options.     $curl-&gt;setopt(CURLOPT_VERBOSE, 1) if $options{d};     $curl-&gt;setopt(CURLOPT_FAILONERROR, 1);     $curl-&gt;setopt(CURLOPT_USERAGENT, "OpenTSA tsget.pl/" . (split / /, $::version)[2]);      # Options for POST method.     $curl-&gt;setopt(CURLOPT_UPLOAD, 1);     $curl-&gt;setopt(CURLOPT_CUSTOMREQUEST, "POST");     $curl-&gt;setopt(CURLOPT_HTTPHEADER,         ["Content-Type: application/timestamp-query",         "Accept: application/timestamp-reply,application/timestamp-response"]);     $curl-&gt;setopt(CURLOPT_READFUNCTION, \&amp;read_body);     $curl-&gt;setopt(CURLOPT_HEADERFUNCTION, sub { return length($_[0]); });      # Options for getting the result.     $curl-&gt;setopt(CURLOPT_WRITEFUNCTION, \&amp;write_body);      # SSL related options.     $curl-&gt;setopt(CURLOPT_SSLKEYTYPE, "PEM");     $curl-&gt;setopt(CURLOPT_SSL_VERIFYPEER, 1);   # Verify server's certificate.     $curl-&gt;setopt(CURLOPT_SSL_VERIFYHOST, 2);   # Check server's CN.     $curl-&gt;setopt(CURLOPT_SSLKEY, $options{k}) if defined($options{k});     $curl-&gt;setopt(CURLOPT_SSLKEYPASSWD, $options{p}) if defined($options{p});     $curl-&gt;setopt(CURLOPT_SSLCERT, $options{c}) if defined($options{c});     $curl-&gt;setopt(CURLOPT_CAINFO, $options{C}) if defined($options{C});     $curl-&gt;setopt(CURLOPT_CAPATH, $options{P}) if defined($options{P});     $curl-&gt;setopt(CURLOPT_RANDOM_FILE, $options{r}) if defined($options{r});     $curl-&gt;setopt(CURLOPT_EGDSOCKET, $options{g}) if defined($options{g});      # Setting destination.     $curl-&gt;setopt(CURLOPT_URL, $url);      return $curl; }  # Send a request and returns the body back. sub get_timestamp {     my $curl = shift;     my $body = shift;     my $ts_body;     local $::error_buf;      # Error-handling related options.     $curl-&gt;setopt(CURLOPT_ERRORBUFFER, "::error_buf");      # Options for POST method.     $curl-&gt;setopt(CURLOPT_INFILE, {data =&gt; $body, bytes =&gt; 0});     $curl-&gt;setopt(CURLOPT_INFILESIZE, length(${$body}));      # Options for getting the result.     $curl-&gt;setopt(CURLOPT_FILE, \$ts_body);      # Send the request...     my $error_code = $curl-&gt;perform();     my $error_string;     if ($error_code != 0) {         my $http_code = $curl-&gt;getinfo(CURLINFO_HTTP_CODE);     $error_string = "could not get timestamp";     $error_string .= ", http code: $http_code" unless $http_code == 0;     $error_string .= ", curl code: $error_code";     $error_string .= " ($::error_buf)" if defined($::error_buf);     } else {         my $ct = $curl-&gt;getinfo(CURLINFO_CONTENT_TYPE);     if (lc($ct) ne "application/timestamp-reply"         &amp;&amp; lc($ct) ne "application/timestamp-response") {         $error_string = "unexpected content type returned: $ct";         }     }     return ($ts_body, $error_string);  }  # Print usage information and exists. sub usage {      print STDERR "usage: $0 -h &lt;server_url&gt; [-e &lt;extension&gt;] [-o &lt;output&gt;] ";     print STDERR "[-v] [-d] [-k &lt;private_key.pem&gt;] [-p &lt;key_password&gt;] ";     print STDERR "[-c &lt;client_cert.pem&gt;] [-C &lt;CA_certs.pem&gt;] [-P &lt;CA_path&gt;] ";     print STDERR "[-r &lt;file:file...&gt;] [-g &lt;EGD_socket&gt;] [&lt;request&gt;]...\n";     exit 1; }  # ---------------------------------------------------------------------- #   Main program # ----------------------------------------------------------------------  # Getting command-line options (default comes from TSGET environment variable). my $getopt_arg =  "h:e:o:vdk:p:c:C:P:r:g:"; if (exists $ENV{TSGET}) {     my @old_argv = @ARGV;     @ARGV = split /\s+/, $ENV{TSGET};     getopts($getopt_arg, \%options) or usage;     @ARGV = @old_argv; } getopts($getopt_arg, \%options) or usage;  # Checking argument consistency. if (!exists($options{h}) || (@ARGV == 0 &amp;&amp; !exists($options{o}))     || (@ARGV &gt; 1 &amp;&amp; exists($options{o}))) {     print STDERR "Inconsistent command line options.\n";     usage; } # Setting defaults. @ARGV = ("-") unless @ARGV != 0; $options{e} = ".tsr" unless defined($options{e});  # Processing requests. my $curl = create_curl $options{h}; undef $/;   # For reading whole files. REQUEST: foreach (@ARGV) {     my $input = $_;     my ($base, $path) = fileparse($input, '\.[^.]*');     my $output_base = $base . $options{e};     my $output = defined($options{o}) ? $options{o} : $path . $output_base;      STDERR-&gt;printflush("$input: ") if $options{v};     # Read request.     my $body;     if ($input eq "-") {     # Read the request from STDIN;     $body = &lt;STDIN&gt;;     } else {     # Read the request from file.         open INPUT, "&lt;" . $input         or warn("$input: could not open input file: $!\n"), next REQUEST;         $body = &lt;INPUT&gt;;         close INPUT         or warn("$input: could not close input file: $!\n"), next REQUEST;     }      # Send request.     STDERR-&gt;printflush("sending request") if $options{v};      my ($ts_body, $error) = get_timestamp $curl, \$body;     if (defined($error)) {     die "$input: fatal error: $error\n";     }     STDERR-&gt;printflush(", reply received") if $options{v};      # Write response.     if ($output eq "-") {     # Write to STDOUT.         print $ts_body;     } else {     # Write to file.         open OUTPUT, "&gt;", $output         or warn("$output: could not open output file: $!\n"), next REQUEST;         print OUTPUT $ts_body;         close OUTPUT         or warn("$output: could not close output file: $!\n"), next REQUEST;     }     STDERR-&gt;printflush(", $output written.\n") if $options{v}; } $curl-&gt;cleanup(); WWW::Curl::Easy::global_cleanup(); </code></pre>  <p><strong>Output of Script</strong></p>  <pre><code>Version: 1 Hash Algorithm: sha256 Message data:     0000 - a8 31 60 9c a3 fe 14 74-05 f1 be 78 89 5c a6 a5   .1`....t...x.\..     0010 - d3 b7 4a 7d 18 b9 d0 f9-39 fc a8 d6 e2 be 2e 27   ..J}....9......' Policy OID: unspecified Nonce: 0x533AC264C90C4EEE Certificate required: yes Extensions:  Undefined subroutine &amp;WWW::Curl::Easy::global_cleanup called at /usr/local/bin/tsget line 196. Status info: Status: Granted. Status description: unspecified Failure info: unspecified  TST info: Version: 1 Policy OID: 1.3.6.1.4.1.4146.2.2 Hash Algorithm: sha256 Message data:     0000 - a8 31 60 9c a3 fe 14 74-05 f1 be 78 89 5c a6 a5   .1`....t...x.\..     0010 - d3 b7 4a 7d 18 b9 d0 f9-39 fc a8 d6 e2 be 2e 27   ..J}....9......' Serial number: 0x3A668E2441A3707CB495191DC3EF2D717C49DD30 Time stamp: Sep 25 16:55:34 2015 GMT Accuracy: unspecified Ordering: no Nonce: 0x533AC264C90C4EEE TSA: DirName:/C=SG/O=GMO GlobalSign Pte Ltd/CN=GlobalSign TSA for Standard - G2 Extensions:  Verification: FAILED 3073967804:error:2F06D064:time stamp routines:TS_VERIFY_CERT:certificate verify error:ts_rsp_verify.c:246:Verify error:unable to get local issuer certificate </code></pre>