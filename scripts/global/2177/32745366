<p>We're making an example of use of the ForkJoin class example, and the exercise was to split a Strings array into two forks, and then show which strings of the array each fork computed.</p>  <p>As we were making a first, simple example, we just provided each fork half the array:</p>  <pre><code>  invokeAll(                     new Tarea(data,0, data.length/2-1, true),                     new Tarea(data,data.length/2, data.length, true)             ); </code></pre>  <p>Each fork uses the following simple method:</p>  <pre><code>  private void extract(int[]data){      long begin = System.currentTimeMillis();         for(int i=start;i&lt;end;i++){             System.out.println(Thread.currentThread().getName()+" \t Value "+i+":\t "+data[i]);        long end = System.currentTimeMillis() - begin;       System.out.println("Elapsed time: "+end); </code></pre>  <p>}         }</p>  <p>The program runs perfectly fine and each fork does its job. But there's a problem with the elapsed time: usually it's the same on both forks, sometimes it differs, and sometimes, one of the forks has an elapsed time of 0. This fork is always the one which died first.</p>  <p>This happens too when setting methods as synchronized and when using double.</p>  <p>Didn't test with an auxiliar class to hold on the numbers in a synchronized scope, but my doubt is all about why does this happen.</p>  <p>Any idea on why we have these anomalies?</p>  <p>The PC where we're getting the trouble uses Windows 8.1, is a modern PC and uses jdk 1.7.</p>  <p>edit: For big arrays, it doesn't show up 0, but anyways when computing a few hundreds of elements, I HIGHLY doubt it takes less than one millisecond. Maybe currentTimeMillis() doesn't have enough precission?</p>