<p>In class we're currently working with a "clockwise" modulus function - that is to say, a function which essentially works the same as Math.floorMod(int a, int b). </p>  <p>For class, I cannot use Math.floorMod(), and I have written this after researching the topic: </p>  <pre><code> /**  * Computes {@code a} mod {@code b} as % should have been defined to work.  *  * @param a  *            the number being reduced  * @param b  *            the modulus  * @return the result of a mod b, which satisfies 0 &lt;= {@code mod} &lt; b  * @requires b &gt; 0  * @ensures  *   *          &lt;pre&gt;  * 0 &lt;= mod  and  mod &lt; b  and  * there exists k: integer (a = k * b + mod)  *          &lt;/pre&gt;  */ public static int mod(int a, int b) {     assert b &gt; 0 : "Violation of: b &gt; 0";     return (((a % b) + b) % b); } </code></pre>  <p>Here's my issue. This function passes every case I throw at it, except one, where a = 2 and b = INTEGER.MAX_VALUE. </p>  <p>That should return 2, as floorMod does, however it returns 0. Is there anyway I can fix this without using floorMod? </p>  <p>Thanks in advance.</p>