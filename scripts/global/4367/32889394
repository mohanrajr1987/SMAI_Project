<p>so here are the four scripts I am using to go live on paypal. Everything works in sandbox but when I change credentials to live I get this error: link <a href="http://www.cyclos.org/documentation/cyclos-scripting/paypal" rel="nofollow">http://www.cyclos.org/documentation/cyclos-scripting/paypal</a></p>  <blockquote>   <p>Error compiling script CustomScript#2: Buy units with PayPal, function: DEFAULT</p> </blockquote>  <p>This is the code I'm using:</p>  <pre><code>    def result = paypal.createPayment(user, formParameters.amount,  returnUrl)        def link = result.links.find {it.rel == "approval_url"}     if (link) {     return link.href + "&amp;useraction=commit"     } else {     throw new IllegalStateException("No approval url returned from    PayPal")     }       import org.cyclos.entities.users.UserRecord     import org.cyclos.model.ValidationException      def recordId = request.parameters.recordId as Long     def payerId = request.parameters.PayerID      // No record?     if (recordId == null) {     return "[ERROR] " + (scriptParameters.'error.invalidRequest' ?:     "Invalid request") }     // Find the corresponding record    UserRecord userRecord =    record.find(applicationHandler.idMask.remove(recordId))    if (userRecord == null) {     return "[ERROR] " + (scriptParameters.'error.transactionNotFound' ?:      "Transaction not found")     }     def wrapped = scriptHelper.wrap(userRecord)      if (request.parameters.cancel) {     // The operation has been canceled. Remove the record and send a    message.     record.remove(userRecord)     return "[WARN]" + scriptParameters.'message.canceled' ?: "You have    cancelled the operation.\nFeel free to start again if needed."     } else {     // Execute the payment     try {         def json = paypal.execute(payerId, userRecord)         if (json.state == 'approved') {             return scriptParameters.'message.done' ?: "You have    successfully completed the payment. Thank you."         } else {             return "[ERROR] " + scriptParameters.'error.notApproved' ?:          "The payment was not approved"         }     } catch (Exception e) {         return "[ERROR] " + scriptParameters.'error.payment' ?: "There      was an error while processing the payment. Please, try again."       }     }        # Settings for the access token record type     auth.recordType = paypalAuth     auth.clientId = clientId     auth.clientSecret = clientSecret     auth.token = token     auth.tokenExpiration = tokenExpiration      # Settings for the payment record type     payment.recordType = paypalPayment     payment.paymentId = paymentId     payment.amount = amount     payment.transaction = transaction      # Settings for PayPal     mode = live     currency = USD     paymentDescription = Buy Cyclos units      # Settings for the Cyclos payment     amountMultiplier = 105     accountType = debitUnits     paymentType = paypalCredits      # Messages     error.invalidRequest = Invalid request     error.transactionNotFound = Transaction not found     error.transactionAlreadyApproved = The transaction was already  approved     error.payment = There was an error while processing the payment.    Please, try again.     error.notApproved = The payment was not approved     message.canceled = You have cancelled the operation.\nFeel freeto    start again if needed.     message.done = You have successfully completed the payment. Thank     you.# Settings for the         import static groovyx.net.http.ContentType.*      import static groovyx.net.http.Method.*      import groovyx.net.http.HTTPBuilder       import java.util.concurrent.CountDownLatch       import org.apache.commons.codec.binary.Base64      import org.cyclos.entities.banking.PaymentTransferType      import org.cyclos.entities.banking.SystemAccountType      import org.cyclos.entities.users.RecordCustomField      import org.cyclos.entities.users.SystemRecord      import org.cyclos.entities.users.SystemRecordType      import org.cyclos.entities.users.User      import org.cyclos.entities.users.UserRecord      import org.cyclos.entities.users.UserRecordType      import org.cyclos.impl.banking.PaymentServiceLocal      import org.cyclos.impl.system.ScriptHelper      import org.cyclos.impl.users.RecordServiceLocal      import org.cyclos.impl.utils.IdMask      import org.cyclos.impl.utils.persistence.EntityManagerHandler      import org.cyclos.model.EntityNotFoundException      import org.cyclos.model.banking.accounts.SystemAccountOwner      import org.cyclos.model.banking.transactions.PaymentVO      import org.cyclos.model.banking.transactions.PerformPaymentDTO      import org.cyclos.model.banking.transfertypes.TransferTypeVO      import org.cyclos.model.users.records.RecordDataParams      import org.cyclos.model.users.records.UserRecordDTO       /**      * Class used to store / retrieve the authentication information for      PayPal      * A system record type is used, with the following fields: client    id (string), client secret (string), access token (string) and      token expiration (date)     */     class PayPalAuth {        String recordTypeName        String clientIdName        String clientSecretName        String tokenName        String tokenExpirationName      SystemRecordType recordType     SystemRecord record     Map&lt;String, Object&gt; wrapped      public PayPalAuth(Object binding) {         def params = binding.scriptParameters         recordTypeName = params.'auth.recordType' ?: 'paypalAuth'         clientIdName = params.'auth.clientId' ?: 'clientId'         clientSecretName = params.'auth.clientSecret' ?: 'clientSecret'         tokenName = params.'auth.token' ?: 'token'         tokenExpirationName = params.'auth.tokenExpiration' ?:    'tokenExpiration'          // Read the record type and the parameters for field internal names         recordType =   binding.entityManagerHandler.find(SystemRecordType,    recordTypeName)         // Should return the existing instance, of a single form type.    Otherwise it would be an error        record = binding.recordService.newEntity(new    RecordDataParams(recordTypeId: recordType.id))        if (!record.persistent) throw new IllegalStateException("No   instance of system record ${recordType.name} was found")        wrapped = binding.scriptHelper.wrap(record, recordType.fields)        }          public String getClientId() {         wrapped[clientIdName]        }         public void setClientId(String clientId) {         wrapped[clientIdName] = clientId        }         public String getClientSecret() {         wrapped[clientSecretName]        }         public void setClientSecret(String clientSecret) {         wrapped[clientSecretName] = clientSecret        }         public String getToken() {         wrapped[tokenName]        }         public void setToken(String token) {         wrapped[tokenName] = token        }         public Date getTokenExpiration() {         wrapped[tokenExpirationName]         }         public void setTokenExpiration(Date tokenExpiration) {         wrapped[tokenExpirationName] = tokenExpiration          }         }          /**         * Class used to store / retrieve PayPal payments as user records in Cyclos         */        class PayPalRecord {        String recordTypeName        String paymentIdName        String amountName        String transactionName         UserRecordType recordType        Map&lt;String, RecordCustomField&gt; fields;         private EntityManagerHandler entityManagerHandler        private RecordServiceLocal recordService        private ScriptHelper scriptHelper         public PayPalRecord(Object binding) {          def params = binding.scriptParameters          recordTypeName = params.'payment.recordType' ?: 'paypalPayment'          paymentIdName = params.'payment.paymentId' ?: 'paymentId'          amountName = params.'payment.amount' ?: 'amount'          transactionName = params.'payment.transaction' ?: 'transaction'          entityManagerHandler = binding.entityManagerHandler         recordService = binding.recordService         scriptHelper = binding.scriptHelper         recordType = binding.entityManagerHandler.find(UserRecordType, recordTypeName)         fields = [:]         recordType.fields.each {f -&gt; fields[f.internalName] = f}         }          /**         * Creates a payment record, for the given user and JSON, as   returned from PayPal's create payment REST method         */         public UserRecord create(User user, Number amount) {         RecordDataParams newParams = new RecordDataParams([userId: user.id, recordTypeId: recordType.id])         UserRecordDTO dto =  recordService.getDataForNew(newParams).getDTO()         Map&lt;String, Object&gt; wrapped = scriptHelper.wrap(dto,   recordType.fields)         wrapped[amountName] = amount          // Save the record DTO and return the entity         Long id = recordService.save(dto)         return entityManagerHandler.find(UserRecord, id)         }          /**         * Finds the record by id         */         public UserRecord find(Long id) {         try {         UserRecord userRecord = entityManagerHandler.find(UserRecord, id)         if (userRecord.type != recordType) {             return null         }         return userRecord         } catch (EntityNotFoundException e) {         return null            }         }          /**         * Removes the given record, but only if it is of the expected type and hasn't been confirmed         */         public void remove(UserRecord userRecord) {         if (userRecord.type != recordType) {         return         }         Map&lt;String, Object&gt; wrapped = scriptHelper.wrap(userRecord, recordType.fields)         if (wrapped[transactionName] != null) {         return         }         entityManagerHandler.remove(userRecord)            }         }          /**         * Class used to interact with PayPal services         */         class PayPalService {           String mode           String baseUrl           String currency           String paymentDescription            String accountTypeName           String paymentTypeName           double multiplier           SystemAccountType accountType          PaymentTransferType paymentType           private ScriptHelper scriptHelper          private PaymentServiceLocal paymentService          private IdMask idMask          private PayPalAuth auth;          private PayPalRecord record           public PayPalService(Object binding, PayPalAuth auth,   PayPalRecord record) {          this.auth = auth;          this.record = record;           scriptHelper = binding.scriptHelper          paymentService = binding.paymentService          idMask = binding.applicationHandler.idMask           def params = binding.scriptParameters           mode = params.mode ?: 'live'          if (mode != 'live' &amp;&amp; mode != 'live') throw new    IllegalArgumentException("Invalid PayPal parameter 'mode': ${mode}. Should be either sandbox or live")          baseUrl = mode == 'live' ?  'https://api.paypal.com'           currency = params.currency          if (currency == null || currency.empty) throw new IllegalArgumentException("Missing PayPal parameter 'currency'")           EntityManagerHandler emh = binding.entityManagerHandler          accountTypeName = params.accountType          if (accountTypeName == null || accountTypeName.empty) throw new IllegalArgumentException("Missing PayPal parameter 'accountType'")          paymentTypeName = params.paymentType          if (paymentTypeName == null || paymentTypeName.empty) throw new IllegalArgumentException("Missing PayPal parameter 'paymentType'")          accountType = emh.find(SystemAccountType, accountTypeName)          if (!accountType.currency.transactionNumber?.used) {          throw new IllegalStateException("Currency " +  accountType.currency + " doesn't have transaction number enabled")          }          paymentType = emh.find(PaymentTransferType, paymentTypeName,   accountType)           multiplier = Double.parseDouble(params.amountMultiplier ?: "1")          paymentDescription = params.paymentDescription ?: ""          }           /**          * Creates a payment in PayPal and the corresponding user record          */          public Object createPayment(User user, Number amount, String   callbackUrl) {           // Create the UserRecord for this payment          UserRecord userRecord = record.create(user, amount)           Long maskedId = idMask.apply(userRecord.id)          String returnUrl = "${callbackUrl}?succes=true&amp;recordId=${maskedId}"          String cancelUrl = "${callbackUrl}?cancel=true&amp;recordId=${maskedId}"          def jsonBody = [         intent: "sale",         redirect_urls: [             return_url: returnUrl,             cancel_url: cancelUrl         ],         payer: [             payment_method: "paypal"         ],         transactions: [             [                 description: paymentDescription,                 amount: [                     total: amount,                     currency: currency                 ]             ]           ]         ]         // Create the payment in PayPal         Object json = postJson("${baseUrl}/v1/payments/payment", jsonBody)         // Update the payment id        def wrapped = scriptHelper.wrap(userRecord)        wrapped[record.paymentIdName] = json.id         return json        }         /**        * Executes a PayPal payment, and creates the payment in Cyclos        */        public Object execute(String payerId, UserRecord userRecord) {        Object wrapped = scriptHelper.wrap(userRecord)        String paymentId = wrapped[record.paymentIdName]        BigDecimal amount = wrapped[record.amountName]        BigDecimal finalAmount = amount * multiplier         // Execute the payment in PayPal        Object json = postJson("${baseUrl}/v1/payments/payment/${paymentId}/execute", [payer_id: payerId])          if (json.state == 'approved') {         // Perform the payment in Cyclos         PerformPaymentDTO dto = new PerformPaymentDTO()         dto.from = SystemAccountOwner.instance()         dto.to = userRecord.user         dto.amount = finalAmount         dto.type = new TransferTypeVO(paymentType.id)         PaymentVO vo = paymentService.perform(dto)          // Update the record, setting the linked transaction         wrapped[record.transactionName] = vo         userRecord.lastModifiedDate = new Date()         }         return json         }          /**         * Performs a synchronous request, posting and accepting JSON         */         private postJson(url, jsonBody) {         def http = new HTTPBuilder(url)         CountDownLatch latch = new CountDownLatch(1)         def responseJson = null         def responseError = []          // Check if we need a new token         if (auth.token == null || auth.tokenExpiration &lt; new Date()) {         refreshToken()         }          // Perform the request         http.request(POST, JSON) {         headers.'Authorization' = "Bearer ${auth.token}"          body = jsonBody          response.success = { resp, json -&gt;             responseJson = json             latch.countDown()         }          response.failure = { resp -&gt;             responseError &lt;&lt; resp.statusLine.statusCode             responseError &lt;&lt; resp.statusLine.reasonPhrase             latch.countDown()         }         }          latch.await()         if (!responseError.empty) {         throw new RuntimeException("Error making PayPal request to   ${url}, got error code ${responseError[0]}: ${responseError[1]}");         }         return responseJson;         }          /**         * Refreshes the access token         */         private void refreshToken() {         def http = new HTTPBuilder("${baseUrl}/v1/oauth2/token")          CountDownLatch latch = new CountDownLatch(1)         def responseJson = null         def responseError = []          http.request(POST, JSON) {         String auth = Base64.encodeBase64String((auth.clientId + ":" +  auth.clientSecret).getBytes("UTF-8"))         headers.'Accept-Language' = 'en_US'         headers.'Authorization' = "Basic: ${auth}"          send URLENC, [             grant_type: "client_credentials"         ]          response.success = { resp, json -&gt;             responseJson = json             latch.countDown()         }          response.failure = { resp -&gt;             responseError &lt;&lt; resp.statusLine.statusCode             responseError &lt;&lt; resp.statusLine.reasonPhrase             latch.countDown()         }         }          latch.await()         if (!responseError.empty) {         throw new RuntimeException("Error getting PayPal token, got error code ${responseError[0]}: ${responseError[1]}");         }           // Update the authentication data         auth.token = responseJson.access_token         auth.tokenExpiration = new Date(System.currentTimeMillis() +    ((responseJson.expires_in - 30) * 1000));         }         }          // Instantiate the objects         PayPalAuth auth = new PayPalAuth(binding)         PayPalRecord record = new PayPalRecord(binding)         PayPalService paypal = new PayPalService(binding, auth, record) </code></pre>  <p>How can I resolve this error?</p>