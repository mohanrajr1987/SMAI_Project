<p>I have an algorithm that can simulate converting a binary number to a decimal number by hand. What I mean by this is that each number is represented as an array of digits (from least-to-most-significant) rather than using a language's int or bigint type.</p>  <p>For example, 42 in base-10 would be represented as [2, 4], and 10111 in base-2 would be [1, 1, 1, 0, 1].</p>  <p>Here it is in Python.</p>  <pre class="lang-py prettyprint-override"><code>def double(decimal):     result = []     carry = 0     for i in range(len(decimal)):         result.append((2 * decimal[i] + carry) % 10)         carry = floor((2 * decimal[i] + carry) / 10)     if carry != 0:         result.append(carry)     return result  def to_decimal(binary):     decimal = []     for i in reversed(range(len(binary))):         decimal = double(decimal)         if binary[i]:             if decimal == []:                 decimal = [1]             else:                 decimal[0] += 1     return decimal </code></pre>  <p>This was part of an assignment I had with an algorithms class a couple of semesters ago, and he gave us a challenge in his notes claiming that we should be able to derive from this algorithm a new one that could convert a number from base-2^k to binary. I dug this up today and it's been bothering me (read: making me feel really rusty), so I was hoping someone would be able to explain how I would write a <code>to_binary(number, k)</code> function based on this algorithm.</p>