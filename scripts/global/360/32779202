<p>I am trying to streamLine queries to SQLITE3. I use it for financial price modelling and so am re-using the same basic query alot, but have to keep changing the hard coding to get out different column queries each time. So I want a generic query where I just write in what I want once, then it spits out the columns as lists. This is a basic version of what I want but basically still hard coded so you can see what I am trying to create.</p>  <pre><code>dbName = 'NASDAQ_Equities' ticker = 'AAPL'  def pullDataTest(dbPathName, ticker, *args):    datep = []    openp = []    highp = []     db = sqlite3.connect(dbPathName + '.mydb', detect_types=sqlite3.PARSE_DECLTYPES | sqlite3.PARSE_COLNAMES, timeout=3) cursor = db.cursor()     cursor.execute('''SELECT   ''' + str(args) + '''  FROM ''' + ticker)    for row in cursor:        datep.append(row[0])        openp.append(row[1])        highp.append(row[2])    pullData(dbName, ticker, 'datep', 'openp', 'highp') </code></pre>  <p>At the moment I am lost on how to enter an *args into the select statement as it rejects it because of the () brackets. Also what will be an issue is creating empty lists and appending to those lists from from an *args. Would it be better to create a order dict to append to, then brake that into lists at the end somehow? On returning values for use later down the track I was thinking of making them globals? Any suggestions? Thanks</p>