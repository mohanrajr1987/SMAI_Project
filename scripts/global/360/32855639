<p>The following C# program produces unexpected output.  I would expect to see:</p>  <blockquote>   <p>Value1: 25, Value2: 10</p>      <p>Value1: 10, Value2: 25</p> </blockquote>  <p>but instead I see</p>  <blockquote>   <p>Value1: 0, Value2: 10</p>      <p>Value1: 10, Value2: 25</p> </blockquote>  <pre><code>namespace ConsoleApplication4 {     class Program     {         static void Main(string[] args)         {             DoWork().Wait();              Console.ReadLine();         }          private async static Task DoWork()         {             SomeClass foo = new SomeClass()             {                 MyValue = 25.0f             };              PrintTwoValues(foo.MyValue, await GetValue());             PrintTwoValues(await GetValue(), foo.MyValue);         }          static void PrintTwoValues(float value1, float value2)         {             Console.WriteLine("Value1: {0}, Value2: {1}", value1, value2);         }          static Task&lt;float&gt; GetValue()         {             return Task.Factory.StartNew(() =&gt;                 {                     return 10.0f;                 });         }          class SomeClass         {             private float myValue;              public float MyValue             {                 get                 {                     return this.myValue;                 }                 set                 {                     this.myValue = value;                 }             }         }     } } </code></pre>  <p>Can somebody explain to me why it is that using the "await" operator in the expression for the second argument to the <code>PrintTwoValues</code> method seems to be affecting the value of the first argument?</p>  <p>My guess is that it must have something to do with the fact that the argument list is evaluated left-to-right.  In the first call to <code>PrintTwoValues</code> I'm guessing that the return value from <code>SomeClass.MyValue</code> gets pushed onto the stack.  Then execution continues into <code>GetValue</code> which just starts the Task and exits.  Then <code>DoWork</code> exits and schedules a continuation that will call <code>PrintTwoValues</code> but when that continuation runs the value that had originally gotten pushed on the stack is somehow lost and reverted back to its default value.</p>  <p>While there are simple ways to workaround this problem, like storing the arguments in temporary variables before passing them to the <code>PrintTwoValues</code> method, I'm mostly just curious why this behavior is occurring.</p>  <p>Note:  I'm using Visual Studio 2013, Update 5.  I'm building a console application that is targeting .NET Framework 4.5 and running on Windows 10 Enterprise.</p>