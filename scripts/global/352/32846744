<p>I'm trying to register multiple named components for 2 different NHibernate sessions in my castle windsor container and depending on different interfaces (IRepository, IReadOnlyRepository) inject the appropriate NHibernate session.</p>  <p>I am using an AbstractFacility to register my ISession's and ISessionFactory's:</p>  <pre><code>public class PersistenceFacility : AbstractFacility {     private const string DBCONNECTFACTORY = "dbconnectfactory";     private const string ODSCONNECTFACTORY = "odsconnectfactory";     private const string DBCONNECT = "dbconnect";     private const string ODSCONNECT = "odsconnect";      protected override void Init()     {         Kernel.Register(             Component.For&lt;ISessionFactory&gt;()                 .UsingFactoryMethod(CreateDBConnectSessionFactory)                 .LifeStyle                 .Singleton                 .Named(DBCONNECTFACTORY),              Component.For&lt;ISessionFactory&gt;()                 .UsingFactoryMethod(CreateODSConnectSessionFactory)                 .LifeStyle                 .Singleton                 .Named(ODSCONNECTFACTORY)         );          Kernel.Register(             //Nhibernate session             Component.For&lt;ISession&gt;()                 .UsingFactoryMethod(kernel =&gt; kernel.Resolve&lt;ISessionFactory&gt;(DBCONNECTFACTORY).OpenSession())                 .LifeStyle                 .PerWebRequest                 .Named(DBCONNECT),              Component.For&lt;ISession&gt;()                 .UsingFactoryMethod(kernel =&gt; kernel.Resolve&lt;ISessionFactory&gt;(ODSCONNECTFACTORY).OpenSession())                 .LifeStyle                 .PerWebRequest                 .Named(ODSCONNECT)         );     }      private static ISessionFactory CreateDBConnectSessionFactory()     {         return Fluently.Configure()             .Database(NhOracleConfiguration.Dialect.ConnectionString(x =&gt; x.FromConnectionStringWithKey("DBConnect")))             .Mappings(m =&gt; m.FluentMappings.AddFromAssembly(Assembly.GetAssembly(typeof(StudentMapping))))             .BuildSessionFactory();     }      private static ISessionFactory CreateODSConnectSessionFactory()     {         return Fluently.Configure()             .Database(NhOracleConfiguration.Dialect.ConnectionString(x =&gt; x.FromConnectionStringWithKey("ODSConnect")))             .Mappings(m =&gt; m.FluentMappings.AddFromAssembly(Assembly.GetAssembly(typeof(ReadOnlyStudentMapping))))             .BuildSessionFactory();     } } </code></pre>  <p>The above works great for a single ISession, but I am in need of multiple now so that is my attempt.</p>  <p>I am registering my repositories as follows:</p>  <pre><code>public void Install(IWindsorContainer container, IConfigurationStore store) {     container.Kernel.ComponentRegistered += Kernel_ComponentRegistered;      container.AddFacility(new PersistenceFacility());      // Register all controllers     container.Register(         // Unitofwork interceptor         Component.For&lt;NhUnitOfWorkInterceptor&gt;().LifeStyle.PerWebRequest,          // All validators         Classes.FromAssembly(Assembly.GetAssembly(typeof(StudentValidator))).BasedOn(typeof(IValidator&lt;&gt;)).WithService.Base().LifestyleTransient(),          // All repositories         Classes.FromAssembly(Assembly.GetAssembly(typeof(NhStudentRepository)))             .InSameNamespaceAs&lt;NhStudentRepository&gt;()             .WithService.DefaultInterfaces()             .LifestyleTransient(),          // All services         Classes.FromAssembly(Assembly.GetAssembly(typeof(StudentService))).InSameNamespaceAs&lt;StudentService&gt;().WithService.DefaultInterfaces().LifestyleTransient()          ); } </code></pre>  <p>The above code is registering all repositories (IRepository and IReadOnlyRepository) as they live in the same namespace.</p>  <p>How can I make sure the appropriate ISession is injected into the correct repository? (IRepository, IReadOnlyRepository)</p>  <p>Am I even going in the right direction with my approach? I'm certainly open to completely reworking how I am registering components and dependencies.</p>