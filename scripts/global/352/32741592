<p>here are my parent class mappings:</p>  <pre><code>public class Result : BaseEntity&lt;long, Result&gt; {     public virtual string Stuff { get; set; }     public virtual Iesi.Collections.Generic.ISet&lt;ResultRequestParam&gt; Request { get; set; }     public virtual Iesi.Collections.Generic.ISet&lt;ResultResponseParam&gt; Response { get; set; }     public Result()     {         Request = new HashedSet&lt;Request&gt;();         Response = new HashedSet&lt;Response&gt;();     } }  public class ResultMap : ClassMapping&lt;Result&gt; {     public ResultMap()     {         Id(x =&gt; x.Id, map =&gt; map.Generator(Generators.Identity));          Property(x =&gt; x.Stuff, map =&gt; { map.NotNullable(false); map.Length(256); });          Set(x =&gt; x.Request, map =&gt;         {             map.Key(x =&gt; x.Column("ResultId"));             map.Cascade(Cascade.Persist | Cascade.Remove | Cascade.DeleteOrphans);             map.Inverse(true);         },         m =&gt; m.OneToMany());          Set(x =&gt; x.Response, map =&gt;         {             map.Key(x =&gt; x.Column("ResultId"));             map.Cascade(Cascade.Persist | Cascade.Remove | Cascade.DeleteOrphans);             map.Inverse(true);         },         m =&gt; m.OneToMany());     } } </code></pre>  <p>here is my child class mapping:</p>  <pre><code>public enum ResultParamType {     Request = 0,     Response = 1 }  public abstract class ResultParam : BaseEntity&lt;long, ResultParam&gt; {     public virtual string ParamKey { get; set; }     public virtual string ParamValue { get; set; }     public virtual Result Result { get; set; } }  public class ResultParamMap : ClassMapping&lt;ResultParam&gt; {     public ResultParamMap()     {         Table("ResultParam");          Id(x =&gt; x.Id, map =&gt; map.Generator(Generators.Identity));          Discriminator(x =&gt;         {             x.Column("ParmType");             x.Type(NHibernateUtil.String);             x.Length(20);             x.Force(true);             x.NotNullable(true);         });          Property(x =&gt; x.ParamKey, map =&gt;         {             map.Length(1000);             map.NotNullable(true);         });          Property(x =&gt; x.ParamValue, map =&gt;         {             map.Length(3000);             map.NotNullable(false);         });          ManyToOne(x =&gt; x.Result, map =&gt;         {             map.Column("ResultId");             map.NotNullable(true);         });     } }  public class ResultRequestParam : ResultParam { }  public class ResultRequestParamMap : SubclassMapping&lt;ResultRequestParam&gt; {     public ResultRequestParamMap()     {         DiscriminatorValue(ResultParamType.Request.ToString());     } }  public class ResultResponseParam : ResultResponseParam { }  public class ResultResponseParamMap : SubclassMapping&lt;ResultResponseParam&gt; {     public ResultResponseParamMap()     {         DiscriminatorValue(ResultParamType.Response.ToString());     } } </code></pre>  <p>Now In my provider I want to start my query with Result and then add restrictions for the child set. Similar to this query: </p>  <pre><code>SELECT     * FROM      [Result] a      JOIN [ResultParam] b on b.ResultId = a.Id WHERE     b.ParamKey = 'hello' or b.ParamValue = 'hello' </code></pre>  <p>But there's really no clear way to do this from what I've found. It seems everyone just starts with the child and works up to the parent. This wont work for me as I have two virtually mapped child entities via a discriminator value... </p>