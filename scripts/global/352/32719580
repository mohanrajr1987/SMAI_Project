<p>I have a "bookmark" entity that has tags which are strings.  In C#, the bookmark Poco is similar to:</p>  <pre><code>public class BookmarkEntity {     public virtual Guid Id { get; set; }     public virtual ISet&lt;string&gt; Tags { get; set; } } </code></pre>  <p>I've automapped the entity with this override:</p>  <pre><code>public class BookmarkEntityMappingOverride : IAutoMappingOverride&lt;BookmarkEntity&gt; {     public void Override(AutoMapping&lt;BookmarkEntity&gt; mapping)     {         mapping.HasManyToMany(x =&gt; x.Tags).AsSet().Element("Value").Not.LazyLoad();     } } </code></pre>  <p>This generates these two tables:</p>  <pre class="lang-sql prettyprint-override"><code>create table "BookmarkEntity" (     Id UNIQUEIDENTIFIER not null,     primary key (Id) )  create table Tags (     BookmarkEntity_id UNIQUEIDENTIFIER not null,     Value TEXT,     constraint FK9061CD2928F7F2F9 foreign key (BookmarkEntity_id)                                   references "BookmarkEntity" ) </code></pre>  <p>Now, I'd like to be able to get the unique set of tags from the SQLite-backed database.  Currently I'm executing this query:</p>  <pre class="lang-sql prettyprint-override"><code>SELECT DISTINCT Value FROM Tags ORDER BY Value </code></pre>  <p>This does what I want, but I'd like to use the Criteria API to get it a little more strongly typed.  I started with this effort:</p>  <pre><code>Session.CreateCriteria&lt;BookmarkEntity&gt;()        .SetProjection(             Projections.Distinct(Projections.Property&lt;BookmarkEntity&gt;(b =&gt; b.Tags)))        .AddOrder(Order.Asc(Projections.Property("Value")))        .List&lt;string&gt;(); </code></pre>  <p>But this doesn't work because it's trying to query over the Bookmarks table.  What do I need to do to get this to be similar to my hardcoded SQL query?</p>