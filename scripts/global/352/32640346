<p>We're utilizing NHibernate to map to dynamic database tables. Each mapping file is stored in a client-specific assembly that also houses the classes for each mapping file. As these client-specific assemblies are generated and stored outside of the /bin folder, we are using an assembly resolution event handler which is set towards the beginning of the application's initialization.</p>  <pre><code>AppDomain.CurrentDomain.AssemblyResolve += new ResolveEventHandler(ClassLoaderUtil.MyAssemblyResolver); </code></pre>  <p>The point at which NHibernate is throwing the exception occurs when we attempt to add a resource to an NHibernate Configuration (cfg):</p>  <pre><code>string assemblyName = DataServiceUtil.ClientDataModelAssemblyName; string resourceName = string.Format("{0}.Mappings.{1}.{2}.hbm.xml", DataServiceUtil.ClientDataModelNamespace, dinfo.subns, attSet.Name); System.Reflection.Assembly assembly = ClassLoaderUtil.LoadAssembly(assemblyName); cfg.AddResource(resourceName, assembly); </code></pre>  <p>We're using our assembly resolver classes to load the assembly that gets passed into cfg.AddResource. NHibernate then finds the mapping resource inside the assembly and then attempts to load the class specified in the mapping file. However, when NHibernate calls System.Type.GetType, an exception is thrown:</p>  <pre><code>The located assembly"s manifest definition does not match the assembly reference. (Exception from HRESULT: 0x80131040) Stack Trace:   at System.RuntimeTypeHandle.GetTypeByName(String name, Boolean throwOnError, Boolean ignoreCase, Boolean reflectionOnly, StackCrawlMarkHandle stackMark, IntPtr pPrivHostBinder, Boolean loadTypeFromPartialName, ObjectHandleOnStack type)   at System.RuntimeTypeHandle.GetTypeByName(String name, Boolean throwOnError, Boolean ignoreCase, Boolean reflectionOnly, StackCrawlMark&amp; stackMark, IntPtr pPrivHostBinder, Boolean loadTypeFromPartialName)   at System.Type.GetType(String typeName)   at NHibernate.Util.ReflectHelper.TypeFromAssembly(AssemblyQualifiedTypeName name, Boolean throwOnError)   at NHibernate.Cfg.XmlHbmBinding.Binder.ClassForFullNameChecked(String fullName, String errorMessage) </code></pre>  <p>I believe the issue is that the system is failing to call our assembly resolver and so it simply can't find the assembly (which is already loaded). I verified that the manifest definition matches the assembly being passed into NHibernate, so it isn't failing due to a mismatch. When I enabled fusion logging, I saw it only tried looking in the bin folder and in the temporary Asp.net folders but didn't use any of the custom folders that our assembly resolver checks in. Am I incorrect in assuming that System.Type.GetType should still use the assembly resolver when being called by NHibernate? </p>