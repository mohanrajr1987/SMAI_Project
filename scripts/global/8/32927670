<p>I'm trying to code a CUDA program that, for each point, obtain the mean of its 4 neighbors, repeating this process L times (don't know how to do this yet). Since each point is in 4 different neighborhoods, I trying to make use of some shared memory. This is my code so far:</p>  <pre><code>#include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #include &lt;math.h&gt; #include &lt;sys/time.h&gt; #include &lt;cuda.h&gt;  static void HandleError( cudaError_t err, const char *file, int line ) {        if (err != cudaSuccess)     {            printf( "%s in %s at line %d\n", cudaGetErrorString( err ), file, line );         exit( EXIT_FAILURE );     } }  #define HANDLE_ERROR( err ) (HandleError( err, __FILE__, __LINE__ ))  #define WALL 100 #define ITER 50  #define BLOCK_SIZE 32 #define GRID_SIZE (int)ceil((WALL+1) / BLOCK_SIZE)  __global__ void distributeTemperature( float * t, int n, int l ) {                int ti = threadIdx.y;         int tj = threadIdx.x;         // Map from threadIdx/BlockIdx to point position         int i = blockIdx.y * blockDim.y + ti;         int j = blockIdx.x * blockDim.x + tj;         int x, y;          __shared__ float m[(BLOCK_SIZE+2) * (BLOCK_SIZE+2)];          // Interior          m[(ti+1)*(BLOCK_SIZE+2)+(tj+1)] = t[i * n + j]         __syncthreads();          // A ints just for debug purposes          if (i &gt; 0 &amp;&amp; i &lt; n &amp;&amp; j &gt; 0 &amp;&amp; j &lt; n)        {             int a = m[ti*(BLOCK_SIZE+2)+(tj+1)];             int b = m[(ti+1)*(BLOCK_SIZE+2)+tj];             int c = m[(ti+1)*(BLOCK_SIZE+2)+(tj+2)];             int d = m[(ti+2)*(BLOCK_SIZE+2)+(tj+1)];             t[i*n + j] = (a+b+c+d)/(float)4;       } }  int main( int argc, char* argv[] ) {         // Auxiliaries         int i, j, k;         struct timeval  start, end;         double diff;          // Host input vector         float * h;         // Device input vector         float * d;          // Comparison vector         float * c;          // Size, in bytes, of each vector         size_t bytes = (WALL+1) * (WALL+1) * sizeof(float);          // Allocate memory for vector on host         h = (float *) malloc (bytes);         c = (float *) malloc (bytes);         // Allocate memory for vector on GPU         HANDLE_ERROR( cudaMalloc((void**)&amp;d, bytes) );          // Initializing host vector         for (i = 0; i &lt; WALL+1; i++)         {                 for (j = 0; j &lt; WALL+1; j++)                 {                         if (i*(WALL+1) + j &lt; WALL+1 || i*(WALL+1) + j &gt;= ((WALL+1)*(WALL+1)) - (WALL+1) || (i*(WALL+1) + j) % (WALL+1) == 0 || (i*(WALL+1) + j+1) % (WALL+1) == 0)                         {                                 h[i*(WALL+1) + j] = 80;                                 if (i*(WALL+1) + j &gt;= i*(WALL+1) + 10 &amp;&amp; i*(WALL+1) + j &lt;= i*(WALL+1) + 30)                                         h[i*(WALL+1) + j] = 150;                         }                         else                                 h[i*(WALL+1) + j] = 0;                         c[i*(WALL+1) + j] = h[i*(WALL+1) + j];                 }         }          // Copy host vector to device         HANDLE_ERROR( cudaMemcpy(d, h, bytes, cudaMemcpyHostToDevice) );          // Execute the kernel         dim3 dimBlock( BLOCK_SIZE, BLOCK_SIZE );         dim3 dimGrid( GRID_SIZE, GRID_SIZE );         gettimeofday( &amp;start, 0 );          distributeTemperature&lt;&lt;&lt;dimGrid, dimBlock&gt;&gt;&gt;( d, WALL+1, ITER );          gettimeofday(&amp;end, 0);         diff = (1000000.0*(end.tv_sec-start.tv_sec) + end.tv_usec-start.tv_usec) / 1000000.0;         printf( "Amount of time: %lf ms\n", diff);          // Copy array back to host         HANDLE_ERROR( cudaMemcpy(h, d, bytes, cudaMemcpyDeviceToHost) );          for (k = 0; k &lt; ITER; k++)         {                 for (i = 1; i &lt;= WALL; i++)                 {                         for (j=1; j &lt;= WALL; j++)                         {                                 c[i*(WALL+1) + j] = ( c[i*(WALL+1) + j-1] + c[i*(WALL+1) + j+1] + c[(i-1)*(WALL+1) + j] + c[(i+1)*(WALL+1) + j] )/4.0;                         }                 }         }          // Result         for (i = 0; i &lt; WALL+1; i++)         {                 for (j = 0; j &lt; WALL+1; j++)                 {                         if (abs(c[i*(WALL+1) + j] - h[i*(WALL+1) + j]) &gt; 0.000001)                                 printf("diff %d %d %f %f\n", i, j, c[i*(WALL+1) + j], h[i*(WALL+1) + j]);                  }         }          // Release device memory         cudaFree( d );          // Release host memory         free( h );          return 0; } </code></pre>  <p>Once I do this, I obtain the desired result, except for the indices >= 95. I figure out that I'm launching a 3 x 3 grid. I would need at least 4. If I do this, though:</p>  <pre><code>    #define GRID_SIZE (int)ceil((WALL+1) / (float)BLOCK_SIZE)      __global__ void distributeTemperature( float * t, int n, int l ) {         int ti = threadIdx.y;         int tj = threadIdx.x;         // Map from threadIdx/BlockIdx to point position         int i = blockIdx.y * blockDim.y + ti;         int j = blockIdx.x * blockDim.x + tj;          __shared__ float m[(BLOCK_SIZE+2) * (BLOCK_SIZE+2)];           // Interior          if (i == 0 || i &gt;= n || j == 0 || j &gt;= n)         {                 m[(ti+1)*(BLOCK_SIZE+2)+(tj+1)] = 0;         }         else         {                 m[(ti+1)*(BLOCK_SIZE+2)+(tj+1)] = t[i * n + j];         }         __syncthreads();          if (i == 0 || i &gt;= n || j == 0 || j &gt;= n) return;          int a = m[ti*(BLOCK_SIZE+2)+(tj+1)];         int b = m[(ti+1)*(BLOCK_SIZE+2)+tj];         int c = m[(ti+1)*(BLOCK_SIZE+2)+(tj+2)];         int d = m[(ti+2)*(BLOCK_SIZE+2)+(tj+1)];         t[i*n + j] = (a+b+c+d)/(float)4; } </code></pre>  <p>All the output values for the interior are 0.</p>  <p>What is the correct way to do this?</p>  <p>Thank you.</p>