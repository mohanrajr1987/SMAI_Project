<p>We have timer service with schedule method: <code>@Schedule(second = "0", minute = "*", hour = "*", dayOfMonth = "*",   persistent = true)</code>. When this method transaction commits, entity T is saved to database.  There is a listener on entity which has three methods and every method is getting BeanManager:</p>  <pre><code>@PrePersist public void prePersist(T entity) {     ..     InitialContext initialContext = new InitialContext();     return (BeanManager)  initialContext.lookup("java:comp/BeanManager");     .. }  @PreUpdate public void preUpdate(T entity) {     ..     InitialContext initialContext = new InitialContext();     return (BeanManager)  initialContext.lookup("java:comp/BeanManager");     .. }  @PreRemove public void preRemove(T entity) {     ..     InitialContext initialContext = new InitialContext();     return (BeanManager)  initialContext.lookup("java:comp/BeanManager");     .. } </code></pre>  <p>The problem is that BeanManager is always null and exception is thrown: <code>javax.naming.NamingException: Lookup failed for 'java:comp/BeanManager' in SerialContext</code></p>  <p>However, if we lookup for BeanManager in timer method, when transaction is not in commit process yet, everything is okay, BeanManager is not null. If we call from timer service another method which has </p>  <pre><code>@TransactionAttribute(TransactionAttributeType.REQUIRES_NEW) </code></pre>  <p>when this transaction commits, BeanManager is also present and not null</p>  <p>So the question is why timer transaction on commit can't see BeanManager?</p>  <p>Server is glassfish 3.1.2.1.</p>