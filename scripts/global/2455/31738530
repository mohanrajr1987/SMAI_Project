<p>I'm trying to transform y into something which can be appended to x, where x is a sequence of some sorts.</p>  <pre><code>scala&gt; def foo[U &lt;: Seq[T], T](x: U, y: T): U = x :+ y &lt;console&gt;:7: error: type mismatch;  found   : Seq[T]  required: U        def foo[U &lt;: Seq[T], T](x: U, y: T): U = x :+ y                                                   ^ </code></pre>  <p>I have the following solutions:</p>  <pre><code>def foo[T]( x : Seq[T], y:T) = x :+ y def foo[T]( x : Seq[T], y:T) : Seq[T] = x :+ y def foo[U &lt;: Seq[T], T](x: U, y: T): U = (x :+ y).asInstanceOf[U] </code></pre>  <p>But my doubt is why the original one didn't work. It looks like if I apply an operator (<code>:+</code> in this case) defined in the super class then it returns the super class? i.e if <code>U</code> is a <code>Vector</code>, <code>foo</code> returns <code>Seq</code>, so I'm getting error <code>required "U" but found "Seq[T]"</code>.</p>  <p>Can anyone enlighten me why this behavior is seen?</p>