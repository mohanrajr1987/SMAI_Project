<p>It seems to be a commonplace that accesses to lexical scope can be worked out at compile time (or by a static analyzer, since my example is in Python) based simply on location in the source code.</p>  <p>Here is a very simple example where one function has two closures with different values for <code>a</code>.</p>  <pre><code>def elvis(a):   def f(s):     return a + ' for the ' + s   return f  f1 = elvis('one') f2 = elvis('two') print f1('money'), f2('show') </code></pre>  <p>I have no problem with the idea that when we are reading the code for the function <code>f</code>, when we see <code>a</code>, it is not defined in <code>f</code>, so we pop up to the enclosing function and find one there, and that is what the <code>a</code> in <code>f</code> refers to.  Location in the source code is enough to tell me that <code>f</code> gets a value for <code>a</code> from an enclosing scope.</p>  <p>But as described <a href="http://www.composingprograms.com/pages/16-higher-order-functions.html#defining-functions-iii-nested-definitions" rel="nofollow">here</a>, when a function is called, its local frame extends its parent environment.  So doing environment lookups at runtime is no problem.  But what I am unsure of is that a static analyzer could always work out <em>which</em> closure is referred to at compile time, before the code is ever run.  In the example above it is obvious that <code>elvis</code> has two closures and it is easy to keep track of them, but other cases will not be so simple.  Intuitively I am nervous that an attempt at static analysis could run into a halting problem in general.</p>  <p>So does lexical scoping really have a dynamic aspect to it, where location in the source code tells us that an enclosing scope is involved but not necessarily which closure is referred to?  Or is this a solved problem in compilers, and all references within functions to their closures really can be worked out in detail statically?</p>  <p>Or does the answer depend on the programming language -- in which case lexical scoping is not as strong a concept as I thought it was?</p>  <p>[EDIT @comments:</p>  <p>In terms of my example I can restate my question: I read claims like "Lexical resolution can be determined at compile time," yet wondered how references to the value of <code>a</code> in <code>f1</code> and <code>f2</code> could be worked out statically/at compile time (in general).</p>  <p>The solution is, lexical scoping does not claim so much.  L.S. can tell us, at compile time, that <em>something</em> called <code>a</code> will be defined whenever I am in <code>f</code> (and this clearly can be worked out statically; this is the definition of lexical scope), but determining what <em>value</em> it actually takes (or, which closure is active) is 1) beyond the L.S. concept, 2) done at runtime (not statically) so is dynamic in a sense, yet of course 3) uses a rule different from dynamic scoping.</p>  <p>The takeaway message, to quote @PatrickMaupin, is "Some dynamic work still has to be done." ]</p>