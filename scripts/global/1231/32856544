<p>I have a long-running PHP process which is handling signals. The signals are handled at the end of each "iteration" using <a href="http://php.net/pcntl_signal_dispatch" rel="nofollow"><code>pcntl_signal_dispatch()</code></a>, along with some other tasks. Some of these tasks run command line operations, such as <code>find</code>.</p>  <p>As soon as the process receives a <code>SIGINT</code> (with <kbd>Ctrl</kbd>+<kbd>C</kbd>), whether before or after the signal handling by the process, all the command line operations start failing and return exit code 2.</p>  <p>What's going on? I doubt there is any way to fix it, but I would like to understand what is causing this issue.</p>  <p><strong><em>Edit:</em></strong> Here is a code sample to reproduce the issue:</p>  <pre><code>echo "START\n";  $run = true; pcntl_signal(SIGINT, function() use ($run) {     $run = false; });  while ($run) {     $command = 'sleep 1 &amp;&amp; find . -name "*.md"';     exec($command, $result, $exitCode);      if ($exitCode !== 0 || !isset($result[0])) {         throw new \RuntimeException("Command failed with exit code '{$exitCode}'.");     }      pcntl_signal_dispatch(); }  echo "END\n"; die; </code></pre>  <p>I am completely unable to get even this small script to end properly (with <code>echo "END\n"; die;</code>); it always ends with the <code>RuntimeException</code>.</p>  <p>It's as if the signals were also interrupting the commands launched from the process. Maybe the signals are being sent to the process as well as all its current and future children?</p>  <p>If that is the case, is there anything I can do to handle this situation better? I could set some kind of "global" variable indicating that a signal has been caught and that commands shouldn't be run from that point, but that's a bit messy and wouldn't work for the commands that are run during the interval between the signal and my call to <code>pcntl_signal_dispatch()</code>.</p>