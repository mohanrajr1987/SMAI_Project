<p>The <a href="http://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html" rel="nofollow">oracle Java 8 documentation</a> defines 4 types of method references you can use instead of Lambda Expressions. What I am trying to understand is the kind of method reference described as: "Reference to an instance method of an arbitrary object of a particular type  " which is written as <code>ContainingType::methodName</code>.</p>  <p>I am not sure if I am missing something, but to me it seems more like: "Reference to the <strong>first</strong> parameter of the abstract method of the Functional Interface, assuming it is of type <code>ContainingType</code>". I tried to come up with examples where this 'arbitrary object' is the second parameter, but of course it does not compile.</p>  <p>Is there an official reference how this object is resolved by the compiler? Am I correct in my understanding that:</p>  <ol> <li>The arbitrary object has to be the <strong>1st parameter</strong> of the abstract method of the functional interface.</li> <li>The signature of the method reference <strong>must be the same as that of the abstract method of the functional interface, without the first parameter</strong>. </li> </ol>  <p>So a functional interface with abstract method <code>A method(B b, C c, D d)</code> can only be passed instance method references <code>x::methodImpl</code> or <code>B::methodImpl</code>. There is no way I can pass <code>C::methodImpl</code> for example, where it would be an instance of class <code>C</code> with its signature <code>A methodImpl(B b, D d)</code>.</p>  <p>Are there any other cases I am missing, which might be the reason why Oracle wrote this in such an ambiguous way? </p>