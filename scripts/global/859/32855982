<p>I have a simple Branch and Bound algorithm that works on a variant of the Traveling Salesman problem and I thought it would be fun to try and convert it to use the Java 8 Stream API. I'm having a difficult time figuring out how to do it without relying on side effects, however.</p>  <p><strong>Initial Code</strong></p>  <pre><code>int bound = Integer.MAX_VALUE; List&lt;Location&gt; bestPath = null;  while(!queue.isEmpty()) {     Node curr = queue.poll();     //bound exceeds best, bail     if (curr.getBound() &gt;= bound) {          return bestPath;     }     //have a complete path, save it     if(curr.getPath().size() == locations.size()) {         bestPath = curr.getPath();         bound = curr.getBound();         continue;     }     //incomplete path - add all possible next steps     Set&lt;Location&gt; unvisited = new HashSet&lt;&gt;(locations);     unvisited.removeAll(curr.getPath());     for (Location l : unvisited) {         List&lt;Location&gt; newPath = new ArrayList&lt;&gt;(curr.getPath());         newPath.add(l);         Node newNode = new Node(newPath, getBoundForPath(newPath));         if (newNode.getBound() &lt;= bound){             queue.add(newNode);         }     } } </code></pre>  <p>I took a first shot at converting it to the Stream API and came up with the following:</p>  <p><strong>Java 8 Version</strong></p>  <pre><code>Consumer&lt;Node&gt; nodeConsumer = node -&gt; {     if(node.getPath().size() == locations.size() ) {         bestPath = node.getPath();         bound = node.getBound();     } else {         locations.stream()             .filter(l -&gt; !node.getPath().contains(l))             .map(l -&gt; {                 List&lt;Location&gt; newPath = new ArrayList&lt;&gt;(node.getPath());                 newPath.add(s);                 return new Node(newPath, getBoundForPath(newPath));             })             .filter(newNode -&gt; newNode.getBound() &lt;= bound)             .forEach(queue::add);     } };  Stream.generate(() -&gt; queue.poll())     .peek(nodeConsumer)     .filter(s -&gt; s.getBound() &gt; bound)     .findFirst();  return bestPath; </code></pre>  <p>The main problem is that the nodeConsumer has to reference bestPath and bound, which are not final variables. I could make them final AtomicReference variables to work around this, but I feel like this sort of violates the spirit of the stream API. Can anyone help me distill the initial algorithm into a more idiomatic implementation?</p>