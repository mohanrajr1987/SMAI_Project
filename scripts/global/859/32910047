<p>I'm working with SharePoint CSOM. This uses a query language based on expressions to specify what data to retrieve. The system I am working on makes several different queries, but they all need to include certain data for security checking. For example:</p>  <pre><code>using (ClientContext context = new ClientContext(weburl)) {     var subwebs = context.Web.GetSubwebsForCurrentUser(new SubwebQuery());     context.Load(subwebs,         webs =&gt; webs.Include(             // BEGIN security-related boilerplate             web =&gt; web.RoleAssignments.Include(                 ra =&gt; ra.Member,                 ra =&gt; ra.RoleDefinitionBindings.Include(                     rdb =&gt; rdb.BasePermissions,                     rdb =&gt; rdb.RoleTypeKind                 )             ),             // END security-related boilerplate             web =&gt; web.Title,             web =&gt; web.ServerRelativeUrl));      context.ExecuteQuery(); } </code></pre>  <p>I'm trying to avoid having to copy/paste the security-related expressions every place that they are needed. Examination of the <code>Include</code> method shows that it takes a list of expressions as arguments:</p>  <pre><code>IQueryable&lt;TSource&gt; Include&lt;TSource&gt;(     this IQueryable&lt;TSource&gt; clientObjects,      params Expression&lt;Func&lt;TSource, object&gt;&gt;[] retrievals)      where TSource : ClientObject </code></pre>  <p>So I created an extension method that returns the required expression:</p>  <pre><code>public static Expression&lt;Func&lt;T, object&gt;&gt; GetSecurityExpression&lt;T&gt;(this ClientObjectCollection&lt;T&gt; list)      where T : SecurableObject {     return x =&gt; x.RoleAssignments.Include(         ra =&gt; ra.Member,         ra =&gt; ra.RoleDefinitionBindings.Include(             rdb =&gt; rdb.BasePermissions,             rdb =&gt; rdb.RoleTypeKind         )     ); } </code></pre>  <p>And the query is rewritten like this:</p>  <pre><code>using (ClientContext context = new ClientContext(weburl)) {     var subwebs = context.Web.GetSubwebsForCurrentUser(new SubwebQuery());     context.Load(subwebs,         webs =&gt; webs.Include(             subwebs.GetSecurityExpression(),             web =&gt; web.Title,             web =&gt; web.ServerRelativeUrl));      context.ExecuteQuery(); } </code></pre>  <p>This compiles fine, but at runtime it throws a <code>Microsoft.SharePoint.Client.InvalidQueryExpressionException</code>:</p>  <blockquote>   <p>The query expression   'value(Microsoft.SharePoint.Client.WebCollection).GetSecurityExpression()'   is not supported.</p> </blockquote>  <p>If I understand the exception correctly, the compiler is not calling <code>subwebs.GetSecurityExpression()</code>, but is creating an expression from it and passing that to <code>Include</code>.</p>  <p>The workaround I've found is to write the calling code like this:</p>  <pre><code>using (ClientContext context = new ClientContext(weburl)) {     var subwebs = context.Web.GetSubwebsForCurrentUser(new SubwebQuery());     var securityExpression = subwebs.GetSecurityExpression();     context.Load(subwebs,         webs =&gt; webs.Include(             securityExpression,             web =&gt; web.Title,             web =&gt; web.ServerRelativeUrl));      context.ExecuteQuery(); } </code></pre>  <p>This works, but is not as succinct as I'd like it to be. Is there any way to get the first approach to work?</p>