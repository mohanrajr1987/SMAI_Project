<p>I have this class:  </p>  <pre><code>class LevelParser   {       private:         int tileSize;         std::vector&lt;Tileset&gt;* pTilesets;          typedef LayerABC* (*pFunc)();          std::unordered_map&lt;std::string, pFunc&gt; layerFactory;          template &lt;typename T&gt;         void registerLayer(std::string layerName);          LayerABC* createLayer(std::string layerName); };  template &lt;typename T&gt; void LevelParser::registerLayer(std::string layerName) {     auto Iterator = layerFactory.find(layerName);      if(Iterator != layerFactory.cend())     {         return;     }      layerFactory[layerName] = [&amp;] () -&gt; LayerABC* {return new T(tileSize, pTilesets); }; } </code></pre>  <p>It compiles okay, but when it comes to creating a layer via factory, the program brakes and IDE points me to the line with lambda of the 'registerLayer' function.  </p>  <p>The LevelParser class variables 'tileSize' and 'pTilesets' get initialised later during the parsing process and before the layer creation happens, that is why they are captured by reference, and that is why lambda should work, but it does not.  </p>  <p>Does anyone have idea what is wrong?  </p>  <p>P.S.<br> There is a solution to avoid passing parameters to the layer constructor like this:  </p>  <pre><code>layerFactory[layerName] = [] () -&gt; LayerABC* {return new T(); }; </code></pre>  <p>and initialise the object after construction via an 'init(int, std::vector&lt;Tileset&gt;*)' function that will actually duplicate the initialisation job that is done by the constructors - but this is the second resort.</p>