<p>How can I make the haxe Lambda.filter work with a typed iterable? The next code refuses to compile because of a bad type:</p>  <p><code>Iterator&lt;Int&gt; should be Iterable&lt;Unknown&lt;0&gt;&gt; { next : Void -&gt; Int, hasNext : Void -&gt; Bool } should be Iterable&lt;Unknown&lt;0&gt;&gt;</code></p>  <p>Code example:</p>  <pre><code>import Lambda; import openfl.events.KeyboardEvent;  class KeyBoard {     private var keys:Map&lt;Int,Bool&gt;;     public function new() keys = new Map();     public function key_handler(key:KeyboardEvent) {         if (key.type == KeyboardEvent.KEY_DOWN) keys.set(key.keyCode, true);         if (key.type == KeyboardEvent.KEY_UP) keys.remove(key.keyCode);     }     public function keys_down() {         return Lambda.filter(keys.keys(), function(k:Int) { return keys.exists(k);});         // The comprehension working alternative:         //return [for (k in keys.keys()) if (keys.exists(k)) k];      } } </code></pre>  <p>I am aware it <a href="http://stackoverflow.com/questions/20299483/how-to-filter-a-map-using-lambda">has been asked before</a> but the answer gave an alternative implementation which I can find by myself rather than an accurate answer about its usage. I find the Lambda constructs a basic component for functional programming, especially at time to create lazy compositions using map/reduce, and I understand that the list comprehensions don't replace them.</p>  <p>If the Lambda constructs really have to disappear, and list comprehensions are really the way to go in Haxe 3, why the Lambda module is still there and how can they be used to achieve laziness or unlimited levels of better composition?</p>  <p>Edit: A way to make it work is to expand the iterable into an array which for sure is not an actual solution (looping twice the same sequence!): </p>  <pre><code>Lambda.filter([for (i in keys.keys()) i], function(k:Int) { return keys.exists(k); }); </code></pre>