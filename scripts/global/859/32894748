<p>Consider the simple program:</p>  <pre><code>int i = 0; int&amp; j = i;  auto lambda = [=]{     std::cout &lt;&lt; &amp;j &lt;&lt; std::endl; //odr-use j }; </code></pre>  <p>According to [expr.prim.lambda], the closure member variable <code>j</code> should have type <code>int</code>:</p>  <blockquote>   <p>An entity is <em>captured by copy</em> if it is implicitly captured and the <em>capture-default</em> is <code>=</code> or if it is explicitly captured with a capture that is not of the form <em>&amp; identifier</em> or <em>&amp; identifier initializer</em>. For each entity captured by copy, an unnamed non-static data member is declared in the closure type. The declaration order of these members is unspecified. <strong>The type of such a data member</strong> is the type of the corresponding captured entity if the entity is not a reference to an object, <strong>or the referenced type otherwise</strong>.</p> </blockquote>  <p>So what I'm printing is the address of some <code>int</code> unrelated to the outer-scope <code>i</code> or <code>j</code>. This is all well and good. However, when I throw in <code>decltype</code>:</p>  <pre><code>auto lambda = [j] {     std::cout &lt;&lt; &amp;j &lt;&lt; std::endl;     static_assert(std::is_same&lt;decltype(j), int&gt;::value, "!"); // error: ! }; </code></pre>  <p>That fails to compile because <code>decltype(j)</code> evaluates as <code>int&amp;</code>. Why? <code>j</code> in that scope should refer to the data member, should it not?</p>  <p>As a related followup, if the lambda capture were instead an <em>init-capture</em> with <code>[j=j]{...}</code>, <em>then</em> clang would report <code>decltype(j)</code> as <code>int</code> and not <code>int&amp;</code>. Why the difference? </p>