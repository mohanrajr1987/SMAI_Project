<p>I'm having trouble with std::functions created from lambdas if the function returns a reference but the return type isn't explicitly called out as a lambda. It seems that the std::function is created fine with no warnings, but upon calling it, a value is returned when a reference is expected, causing things to blow up. Here's a very contrived example:</p>  <pre><code>#include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;functional&gt;  int main(){    std::vector&lt;int&gt; v;    v.push_back(123);    std::function&lt;const std::vector&lt;int&gt;&amp;(const std::vector&lt;int&gt;&amp;)&gt; callback =       [](const std::vector&lt;int&gt; &amp;in){return in;};    std::cout &lt;&lt; callback(v).at(0) &lt;&lt; std::endl;    return 0; } </code></pre>  <p>This prints out garbage, however if the lambda is modified to explicitly return a const reference it works fine. I can understand the compiler thinking the lambda is return-by-value without the hint (when I originally ran into this problem, the lambda was directly returning the result from a function that returned a const reference, in which case I would think that the const reference return of the lambda would be deducible, but apparently not.) What I am surprised by is that the compiler lets the std::function be constructed from the lambda with mismatched return types. Is this behavior expected? Am I missing something in the standard that allows this mismatch to occur? I'm seeing this with g++ (GCC) 4.8.2, haven't tried it with anything else.</p>  <p>Thanks!</p>