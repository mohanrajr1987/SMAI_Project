<p>I have a list of object <code>Ob</code> defined as</p>  <pre><code>class Ob {    private String type;    private List&lt;String&gt; attire;    // standard getter and setters     public Ob (String type){         this.type=type;     }      public Ob addAttrire(String att){         if(attire == null){             attire = new ArrayList&lt;&gt;();         }         attire.add(att);         return this;     } } </code></pre>  <p>I receive objects as </p>  <pre><code>[{ "type" : "upper" attires : [{"t1","t2"}] }, { "type" : "upper" attires : ["t3","t4"] }, { "type" : "lower" attires : ["l1","l2"] }] </code></pre>  <p>which I have to combine as </p>  <pre><code>[{ "type" : "upper" attires : ["t1","t2","t3","t4"] },{ "type" : "lower" attires : ["l1","l2"] }] </code></pre>  <p>How can I use stream to do that. Does reduce help? The stream one can use is</p>  <pre><code>List&lt;Ob&gt; coll = new ArrayList&lt;&gt;();    coll.add(new Ob("a").addAttrire("1").addAttrire("2").addAttrire("3"));         coll.add(new Ob("a").addAttrire("1").addAttrire("2").addAttrire("3"));         coll.add(new Ob("a").addAttrire("1").addAttrire("2").addAttrire("3"));         coll.add(new Ob("b").addAttrire("1").addAttrire("2").addAttrire("3"));         coll.add(new Ob("b").addAttrire("1").addAttrire("2").addAttrire("3"));         coll.add(new Ob("b").addAttrire("1").addAttrire("2").addAttrire("3"));    Collection&lt;Ob&gt; values = coll.stream()                 .collect(toMap(Ob::getType, Function.identity(), (o1, o2) -&gt; {                     o1.getAttire().addAll(o2.getAttire());                     return o1;                 })).values(); </code></pre>  <p>Updated the question with solution of Ruben. There is no requirement to remove duplicates, but it can be done using set in Ob for attire. The current solution worked flawlessly.</p>