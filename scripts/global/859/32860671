<p>I have a scenario where I dynamically create a WHERE clause from a client-side grid's configuration. The client sends some json to the server which I then parse and subsequently convert into an expression so it can be passed into the repository as a where clause.</p>  <p>For the moment I'm struggling with creating expressions for complex property types, like this one:</p>  <pre><code>public partial class Resource {   public string DisplayName { get; set; }   public virtual ResourceType ResourceType { get; set; } } </code></pre>  <p>The code below that does the translation to an expression works well for simple types like the Displayname property. The expression will be something like:</p>  <pre><code>x =&gt; x.DisplayName == "ValueEnteredByUserInTheUI" </code></pre>  <p>However, when a value is entered in the grid for the ResourceType property, the expression will ultimately be something like:</p>  <pre><code>x =&gt; x.ResourceType == "ValueEnteredByUserInTheUI" </code></pre>  <p>I'm missing one step to convert into this: </p>  <pre><code> x =&gt; x.ResourceType.Name == "ValueEnteredByuserInTheUI" </code></pre>  <p>Anyone can point me in the right direction here?</p>  <pre><code>public Expression&lt;Func&lt;T, bool&gt;&gt; GetExpression&lt;TEntity&gt;(string field, string operation, object value, string ignoreCase) {  Expression&lt;Func&lt;T, bool&gt;&gt; whereClause = default(Expression&lt;Func&lt;T, bool&gt;&gt;);  // Define lambda ParameterExpression param = Expression.Parameter(typeof(T), "x");      MemberExpression member = Expression.Property(param, field);   // Get property type   Type propertyType = member.Type;    // Get converter for type    TypeConverter converter = TypeDescriptor.GetConverter(propertyType);     // Convert property to type    var result = converter.ConvertFrom(value.ToString());     // Convert value to constant value    ConstantExpression constant = Expression.Constant(result);      Expression comparingExpression = default(BinaryExpression);     switch (operation)     {       case "like":            comparingExpression = Expression.Equal(member, Expression.Convert(constant, member.Type));            break;                   default:            break;    }    var lambda = Expression.Lambda&lt;Func&lt;T, bool&gt;&gt;(comparingExpression, param);    whereClause = whereClause == default(Expression&lt;Func&lt;T, bool&gt;&gt;) ? lambda : NewPredicateBuilder.And(whereClause, lambda);         return whereClause;   } </code></pre>