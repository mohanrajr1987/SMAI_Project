<p>We have a custom class that inherits from <code>ConfigurationElement</code> called <code>SignalConfigurationElement</code> and defines a bunch of properties using the <code>ConfigurationProperty</code> attribute. </p>  <p>The <code>SignalConfigurationElement</code> class is part of a much larger hierarchy of configuration elements and does not have a constructor. I'm able to retrieve the entire configuration through the <code>ConfigurationManager.GetSection()</code> call, providing the root element's name which is <code>SystemConfiguration</code>, which is defined in the <code>&lt;configSections&gt;</code> of the app.config file.</p>  <p>I don't have control over the custom configuration elements so I can't alter them to provide constructors. I also can't modify the app.config because it's used by a much larger application. </p>  <p>Is it possible to create instances or collections of <code>SignalConfigurationElement</code> given an XML string of <code>&lt;signals&gt;</code> entries? The class doesn't have a constructor so I'm assuming the <code>ConfigurationManager.GetSection</code> call used by our other applications to retrieve the <em>entire</em> configuration (not what I want) uses reflection to create its instances.</p>  <p>Code (Can't change any of this at all.):</p>  <p><strong>App.Config</strong></p>  <pre><code>&lt;configSections&gt;     &lt;section name="SystemConfiguration" type="Fully.Qualified.Namespace.SystemConfiguration, SystemConfiguration"/&gt; &lt;/configSections&gt;  &lt;SystemConfiguration id="System1" name="System 1"&gt;     &lt;equipments&gt;       &lt;clear /&gt;       &lt;add id="Equipment11" equipmentType="EQ"&gt;         &lt;signals&gt;           &lt;clear /&gt;           &lt;add id="EQ11Signal1" signalId="EQ11Signal1" type="Version" /&gt;           &lt;add id="EQ11Signal2" signalId="EQ11Signal2" type="Status" /&gt;           &lt;add id="EQ11Signal3" signalId="EQ11Signal3" type="Status" /&gt;         &lt;/signals&gt;       &lt;/add&gt;       &lt;add id="Equipment21" equipmentType="EQ"&gt;         &lt;signals&gt;           &lt;clear /&gt;           &lt;add id="EQ21Signal1" signalId="EQ21Signal1" type="Version" /&gt;           &lt;add id="EQ21Signal2" signalId="EQ21Signal2" type="Status" /&gt;           &lt;add id="EQ21Signal3" signalId="EQ21Signal3" type="Status" /&gt;         &lt;/signals&gt;       &lt;/add&gt;      &lt;/equipments&gt; &lt;!-- And a whole lot more. Somewhere in the avenue of 30,000 &lt;signals&gt; entries.--&gt; &lt;/SystemConfiguration&gt; </code></pre>  <p><strong>Classes:</strong></p>  <pre><code>public class SystemConfigurationSection : ConfigurationSection { /// &lt;summary&gt; /// Determines the XML tag that will contain this Configuration Section in an .config file. /// &lt;/summary&gt; public const string SystemConfigurationSectionName = "SystemConfiguration";  /// &lt;summary&gt; /// Instance factory method for an instance of the Configuration Section creation. /// &lt;/summary&gt; /// &lt;returns&gt; /// Instance of the System Configuration section created based on the .config file of the application. /// &lt;/returns&gt; public static SystemConfigurationSection GetSystemConfigurationSection() {     SystemConfigurationSection result =         (SystemConfigurationSection) ConfigurationManager.GetSection(SystemConfigurationSectionName);     return result; }  /// &lt;summary&gt; /// Represents the XML attribute used to store ID of the System. /// &lt;/summary&gt; [ConfigurationProperty(IdConfigurationElementName, IsRequired = true)] public string Id {     get { return (string) this[IdConfigurationElementName]; }     set { this[IdConfigurationElementName] = value; } }  /// &lt;summary&gt; /// Determines name of the XML attribute that will contain ID of the System. /// &lt;/summary&gt; public const string IdConfigurationElementName = "id";  /// &lt;summary&gt; /// Represents the XML attribute used to store Name of the System. /// &lt;/summary&gt; [ConfigurationProperty(NameConfigurationElementName, IsRequired = true)] public string Name {     get { return (string) this[NameConfigurationElementName]; }     set { this[NameConfigurationElementName] = value; } }  /// &lt;summary&gt; /// Determines name of the XML attribute that will contain Name of the System. /// &lt;/summary&gt; public const string NameConfigurationElementName = "name";  /// &lt;summary&gt; /// Represents the XML attribute used to store Description of the System /// &lt;/summary&gt; [ConfigurationProperty(DescriptionConfigurationElementName, IsRequired = false, DefaultValue = "")] public string Description {     get { return (string) this[DescriptionConfigurationElementName]; }     set { this[DescriptionConfigurationElementName] = value; } }  /// &lt;summary&gt; /// Determines name of the XML attribute that will contain Name of the System. /// &lt;/summary&gt; public const string DescriptionConfigurationElementName = "description";  /// &lt;summary&gt; /// Represents the collection of the System's Equipments as they are described in the .config file. /// &lt;/summary&gt; [ConfigurationProperty(EquipmentsConfigurationElementCollectionName, IsDefaultCollection = false)] [ConfigurationCollection(typeof (EquipmentConfigurationElementCollection), AddItemName = "add",     ClearItemsName = "clear", RemoveItemName = "remove")] public EquipmentConfigurationElementCollection Equipments {     get { return (EquipmentConfigurationElementCollection) base[EquipmentsConfigurationElementCollectionName]; } }  /// &lt;summary&gt; /// Determines name of the XML tag that will contain collection of the System's Equipments. /// &lt;/summary&gt; public const string EquipmentsConfigurationElementCollectionName = "equipments";  } </code></pre>  <p>&nbsp;</p>  <pre><code>/// &lt;summary&gt; /// Extends the standard .Net ConfigurationElementCollection re-definind commectio manipulation members and making them strongly-typed. /// &lt;/summary&gt; /// &lt;typeparam name="TElementType"&gt;Type of the Configuration Elements that can be included into the collection.&lt;/typeparam&gt; public class ConfigurationElementCollectionBase&lt;TElementType&gt; : ConfigurationElementCollection, IEnumerable&lt;TElementType&gt; where TElementType : ConfigurationElement, new() { /// &lt;summary&gt; /// Makes the addition operation public. /// &lt;/summary&gt; /// &lt;param name="customElement"&gt;Configuration element to add to the collection.&lt;/param&gt; public virtual void Add(TElementType customElement) {     BaseAdd(customElement); }  /// &lt;summary&gt; /// Overrides the base implementation of the overloaded method masking an exception throwing. /// &lt;/summary&gt; /// &lt;param name="element"&gt;Configuration element to add.&lt;/param&gt; protected override void BaseAdd(ConfigurationElement element) {     BaseAdd(element, false); }  /// &lt;summary&gt; /// Overrides the base property hardcoding the returned value. /// &lt;/summary&gt; public override ConfigurationElementCollectionType CollectionType {     get { return ConfigurationElementCollectionType.AddRemoveClearMap; } }  /// &lt;summary&gt; /// Overrides the base implementation of the instance factory method. /// &lt;/summary&gt; /// &lt;returns&gt;A new instance of the Configuration Element type determined by the type parameter.&lt;/returns&gt; protected override ConfigurationElement CreateNewElement() {     return new TElementType(); }  /// &lt;summary&gt; /// Overrides the base implementation of the method determining the indexing algorithm used in the collection. /// &lt;/summary&gt; /// &lt;param name="element"&gt;The configuration element to get index of.&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; protected override object GetElementKey(ConfigurationElement element) {     return ((TElementType)element); }  /// &lt;summary&gt; /// Collection's element accessor by index property. /// &lt;/summary&gt; /// &lt;param name="index"&gt;Index of the desired element in the collection.&lt;/param&gt; /// &lt;returns&gt;The requested collection element if exists.&lt;/returns&gt; public TElementType this[int index] {     get { return (TElementType)BaseGet(index); }     set     {         if (BaseGet(index) != null)         {             BaseRemoveAt(index);         }         BaseAdd(index, value);     } }  /// &lt;summary&gt; /// Overrides the collection's element accessor by key property. /// &lt;/summary&gt; /// &lt;param name="id"&gt;Key of the desired collection element.&lt;/param&gt; /// &lt;returns&gt;The requested collection element if exists&lt;/returns&gt; public new TElementType this[string id] {     get { return (TElementType)BaseGet(id); } }  /// &lt;summary&gt; /// Implements a standard collection method looking for an element in the collection and returning the element's index if found. /// &lt;/summary&gt; /// &lt;param name="element"&gt;The element to look for.&lt;/param&gt; /// &lt;returns&gt;Index of the element in the collection if exists.&lt;/returns&gt; public int GetIndexOf(TElementType element) {     return BaseIndexOf(element); }  /// &lt;summary&gt; /// Implements a standard collection method removing an element from the collection. /// &lt;/summary&gt; /// &lt;param name="url"&gt;The element to be removed from the collection.&lt;/param&gt; public void Remove(TElementType url) {     if (BaseIndexOf(url) &gt;= 0)         BaseRemove(url); }  /// &lt;summary&gt; /// Implements the standard collection member removing an element from the collection by the element's index. /// &lt;/summary&gt; /// &lt;param name="index"&gt;Index of the element to be removed from the collection.&lt;/param&gt; public void RemoveAt(int index) {     BaseRemoveAt(index); }  /// &lt;summary&gt; /// Implements a standard collection method removing an element by the element's key. /// &lt;/summary&gt; /// &lt;param name="id"&gt;Key of the element to be removed from the collection.&lt;/param&gt; public void Remove(string id) {     BaseRemove(id); }  /// &lt;summary&gt; /// Implements the standard collection method that clears the collection. /// &lt;/summary&gt; public void Clear() {     BaseClear(); }   public new IEnumerator&lt;TElementType&gt; GetEnumerator() {     for (int i = 0; i &lt; Count; i++)     {         yield return this[i];     } } </code></pre>  <p>&nbsp;</p>  <pre><code>public class EquipmentConfigurationElement : ConfigurationElement {     /// &lt;summary&gt;     /// Represents the collection of the Equipment Unit's Signals as they are described in the .config file.     /// &lt;/summary&gt;     [ConfigurationProperty(signalsConfigurationElementCollectionName, IsDefaultCollection = false)]     [ConfigurationCollection(typeof(SignalConfigurationElementCollection), AddItemName = "add", ClearItemsName = "clear", RemoveItemName = "remove")]     public SignalConfigurationElementCollection Signals     {         get         {             return (SignalConfigurationElementCollection)base[signalsConfigurationElementCollectionName];         }     }     /// &lt;summary&gt;     /// Determines name of the XML tag that will contain collection of the Equipment Unit's Signals.     /// &lt;/summary&gt;     private const string signalsConfigurationElementCollectionName = "signals";  } </code></pre>  <p>&nbsp;</p>  <pre><code>/// &lt;summary&gt; /// Represents a type-safe collection of Equipment Unit Configuration Elements. /// &lt;/summary&gt; public class EquipmentConfigurationElementCollection : ConfigurationElementCollectionBase&lt;EquipmentConfigurationElement&gt; { } </code></pre>  <p>&nbsp;</p>  <pre><code>/// &lt;summary&gt; /// Represensts a Signal's configuration element /// &lt;/summary&gt; /// &lt;remarks&gt; /// As the class is derived from ConfigurationElementBase, a Signal's configuration element will expect "is", "name", and "description" XML attributes defined in the configuration file. /// &lt;/remarks&gt; public sealed class SignalConfigurationElement : ConfigurationElement {      /// &lt;summary&gt;     /// Represents an XML attribute used to determine type of the Signal.     /// &lt;/summary&gt;     /// &lt;remarks&gt;     /// The attribute is expected to have a string value which is equal to one of SignalType enumeration member names: "Status" or "Command".     /// &lt;/remarks&gt;     [ConfigurationProperty(typeConfigurationElementName, IsRequired = false, DefaultValue = "status")]     public string Type     {         get { return (string) this[typeConfigurationElementName]; }         set { this[typeConfigurationElementName] = value; }     }      /// &lt;summary&gt;     /// Determines name of the XML attribute that will contain type of the Signal.     /// &lt;/summary&gt;     private const string typeConfigurationElementName = "type"; } </code></pre>  <p>&nbsp;</p>  <pre><code>/// &lt;summary&gt; /// Represents a type-safe collection of Signal Configuration Elements. /// &lt;/summary&gt; public class SignalConfigurationElementCollection : ConfigurationElementCollectionBase&lt;SignalConfigurationElement&gt; { } </code></pre>