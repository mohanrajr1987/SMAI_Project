<p>I was expecting following code to throw some kind of Initialization or Circular dependency exception but it seems to work. I can <code>@Autowire</code> <code>SomeOtherBean</code> in other classes and I checked that it wasn't <code>null</code>.</p>  <pre><code>import org.springframework.beans.factory.annotation.Autowired; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class MyConfig {      @Autowired     private MyBean myBean;      @Bean     public MyBean  createMyBean() {     return new MyBean();     }      @Bean     public SomeOtherBean createSomeOtherBean() {         return new SomeOtherBean(this.myBean);     } } </code></pre>  <p><a href="http://docs.spring.io/spring/docs/3.0.x/spring-framework-reference/html/beans.html#d0e2299" rel="nofollow">3.4.1.3 Dependency resolution process</a> says,</p>  <p><em>You can generally trust Spring to do the right thing. It detects configuration problems, such as references to non-existent beans and circular dependencies, at container load-time. Spring sets properties and resolves dependencies as late as possible, when the bean is actually created. This means that a Spring container which has loaded correctly can later generate an exception when you request an object if there is a problem creating that object or one of its dependencies.</em></p>  <p>I'm not sure how this applies to my code. Can someone help me understand this better?</p>  <p>Thanks in advance.</p>