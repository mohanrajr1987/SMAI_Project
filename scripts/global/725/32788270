<p>I've got a working Unity container configured from code. I have to move to xml configuration, but can't make it correctly. I don't know what I am missing - maybe somebody is out there who knows the solution and can help me out!</p>  <p>My solution is about layering my FIX protocol library correctly, to handle different vendor specific messages differently, but to have a good robust backing API for that. I have two interfaces:</p>  <pre><code>public interface ICriteria {     bool AreMet(Message message); }  public interface IConsumer {     ICriteria Criteria { get; }     void HandleMessage(Message message); } </code></pre>  <p>There is a default abstract implementation for the consumers:</p>  <pre><code>namespace Fix.MessageHandling {     public abstract class Consumer : IConsumer     {         private readonly ICriteria criteria;         protected readonly IProcessor Processor;          public ICriteria Criteria         {             get { return this.criteria; }         }          protected Consumer(IProcessor processor, ICriteria criteria)         {            //...         }     } } </code></pre>  <p>Then I've got some abstract implementations for different FIX message types: each Consumer abstraction has its own Criteria abstraction. (referenced in the constructor as well) e.g.</p>  <pre><code>namespace Fix.MessageHandling.ExecutionReport {     public abstract class Consumer : MessageHandling.Consumer     {         protected Consumer(IProcessor processor, Criteria  criteria)             : base(processor, criteria)         {            // ...         }     }     public abstract class Criteria : ICriteria     {         // ...     } } </code></pre>  <p>I register the ICriteria instances from code:</p>  <pre><code>container.RegisterType&lt;ICriteria, Vendor.Criteria.Spot&gt;("SpotCriteria"); container.RegisterType&lt;ICriteria, Vendor.Criteria.Swap&gt;("SwapCriteria"); // etc. </code></pre>  <p>After that I register the IConsumer insatnces, which are in this case ExecutionReportConsumer instances, but I am mapping to IConsumer:</p>  <pre><code>container.RegisterType&lt;             IConsumer,             Vendor.Consumer.Spot&gt;("SpotConsumer",             new InjectionConstructor(                 container.Resolve&lt;IProcessor&gt;(),                 container.Resolve&lt;ICriteria&gt;("SpotCriteria"))); // etc. </code></pre>  <p>When I resolve IConsumer-s, I can get all my registered Consumers from the UnityContainer:</p>  <pre><code>container.ResolveAll&lt;IConsumer&gt;(); </code></pre>  <p>This is how I tried to do this with xml after defining all the aliases:</p>  <pre><code>&lt;register type="ICriteria" mapTo="ForwardCriteria" name="ForwardCriteria" /&gt; &lt;register type="IConsumer" mapTo="ForwardConsumer" name="ForwardConsumer"&gt;   &lt;constructor&gt;     &lt;param name="processor" dependencyType="IProcessor" /&gt;     &lt;param name="criteria" dependencyType="ExecutionReportCriteria" dependencyName="ForwardCriteria" /&gt;   &lt;/constructor&gt; &lt;/register&gt; </code></pre>  <p>If I use the xml configuration and I call ResolveAll for IConsumers, I've got an exception</p>  <p>Resolution of the dependency failed, type = "Fix.MessageHandling.IConsumer", name = "ForwardConsumer". Exception occurred while: while resolving.</p>  <h2>Exception is: InvalidOperationException - The type Criteria does not have an accessible constructor.</h2>  <p>At the time of the exception, the container was:</p>  <p>Resolving Fix.Vendor.Consumer.Forward,ForwardConsumer (mapped from Fix.MessageHandling.IConsumer, ForwardConsumer)   Resolving parameter "criteria" of constructor Fix.Vendor.Consumer.Forward(Fix.MessageHandling.IProcessor processor, Fix.MessageHandling.ExecutionReport.Criteria criteria)     Resolving Fix.MessageHandling.ExecutionReport.Criteria,ForwardCriteria</p>