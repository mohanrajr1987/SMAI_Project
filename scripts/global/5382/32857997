<p>Having an file with adjacency list of a <code>Graph G</code> like:</p>  <pre><code>0 -&gt; 13,16,20,22,4,5 1 -&gt; 12,13,16,17,19,22,23,24,25,3,4 10 -&gt; 13,14,17,20,23,24 11 -&gt; 12,19,20,22,23 12 -&gt; 15,20,24 13 -&gt; 20,21,22 15 -&gt; 23 17 -&gt; 25 19 -&gt; 20,25 2 -&gt; 16,19,3,7 20 -&gt; 22,23 21 -&gt; 22,23,24 22 -&gt; 25 24 -&gt; 25 3 -&gt; 15,21,4 4 -&gt; 10,12,14,15,16,17,18,19,21,23,5 5 -&gt; 11,16,17,20,23,8,9 6 -&gt; 12,14,18,22 7 -&gt; 14,17,22 8 -&gt; 21,24 9 -&gt; 12,14 </code></pre>  <p>I want to get it's topological ordering, <code>Graph G</code> is a Directed Acyclic Graph. </p>  <p>First of all I want to parse the txt file and put all in a dictionary. However I am having some issues, first when reading the file I am missing something thatI miss first element after <code>-&gt;</code>:  </p>  <pre><code>f = open('topo.txt', 'r')     line_list = f.readlines()     G = {int(line.split('-&gt;')[0]): [int(val) for val in line.split(',')[1:] if val] for line in line_list if line} </code></pre>  <p>I would get: </p>  <pre><code>('G:', {0: [16, 20, 22, 4, 5], 1: [13, 16, 17, 19, 22, 23, 24, 25, 3, 4], 2: [19, 3, 7], 3: [21, 4], 4: [12, 14, 15, 16, 17, 18, 19, 21, 23, 5], 5: [16, 17, 20, 23, 8, 9], 6: [14, 18, 22], 7: [17, 22], 8: [24], 9: [14], 10: [14, 17, 20, 23, 24], 11: [19, 20, 22, 23], 12: [20, 24], 13: [21, 22], 15: [], 17: [], 19: [25], 20: [23], 21: [23, 24], 22: [], 24: []}) [16, 20, 22, 4, 5] </code></pre>  <p>For each line I am missing one element, for instance 0 would be: <code>[13, 16, 20, 22, 4, 5]</code> not <code>[16, 20, 22, 4, 5]</code> it misses the <code>13</code></p>  <p>Then when using the function <code>dfs</code> I get error:</p>  <blockquote>   <p>for v in G[s]: # for every edge (s, v) KeyError: 16</p> </blockquote>  <pre><code>"""Performs a depth first search in graph G starting from vertex s     Input: G - the input graph in the adjacency list representation via a dictionary     s - the starting vertex     explored - a set of explored vertices     distance - a dictionary representing the topological order of the vertices     current_label - the current order of the topological order, disguised as a mutable list""" def dfs(G, s, explored, distance, current_label):     explored.add(s)     #print G[s]     for v in G[s]: # for every edge (s, v)         if v not in explored:             dfs(G, v, explored, distance, current_label)     distance[current_label[0]] = s     current_label[0] -= 1  """Performs and outputs a topological sort of graph G using dfs     Input: G - the input graph in the adjacency list representation via a dictionary     distance - a dictionary representing the topological order of the vertices""" def topological_sort(G, distance):     explored = set()     current_label = [len(G)]     for v in G.keys():         if v not in explored:             dfs(G, v, explored, distance, current_label)  def main():     f = open('topo.txt', 'r')     line_list = f.readlines()     G = {int(line.split('-&gt;')[0]): [int(val) for val in line.split(',')[1:] if val] for line in line_list if line}     print("G:", G)     distance = dict()     topological_sort(G, distance)     topo = iter(sorted(distance.items()))     print("A topological order of G is:")     for _, vertex in topo:         print( vertex + " ")     print()  if __name__ == '__main__':     main() </code></pre>  <p>How would correct code look like? Output should be </p>  <pre><code>1, 0, 2, 6, 3, 7, 4, 5, 18, 10, 11, 16, 8, 9, 13, 17, 19, 12, 14, 21, 15, 20, 24, 23, 22, 25 </code></pre>