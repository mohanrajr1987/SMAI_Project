<p>I have been working on an own implementation of a Vector for unsigned ints to learn more about how defining own constuctors for example works. I'm also not using any of the standard library just to learn more about how to make a vector from scratch. </p>  <p>I have now written after som research some constructors that in my opinion should be correct but I'm getting some wierd errors that I can't seem to figure out why they appear. Might it be that I have misinterpreted how the constructor is supposed to look like? </p>  <p>All help you can give me would be mostly appriciated!</p>  <p><strong>Here's the constructor that I think is causing the error when it's defined:</strong></p>  <pre><code>UIntVector&amp; UIntVector::operator=(UIntVector&amp;&amp; other){ if (this != &amp;other) {     unsigned int * begin = allocate(sizeof(unsigned int)*other.vsize);     unsigned int * end = (other.vAddress + (sizeof(unsigned int)*other.vsize));     copyV(other.vAddress, end, begin);     deleteV(other.vAddress, end);      vAddress = begin;     vsize = other.vsize;      other.vAddress = nullptr;     other.vsize = 0; } return *this; } </code></pre>  <p><strong>These are the errors I'm getting in visual studio (the constructor above is at line 48)</strong>:</p>  <pre><code>uintvector.cpp(48): error C2059: syntax error: 'if'  uintvector.cpp(48): error C2143: syntax error: missing ';' before '{'  uintvector.cpp(48): error C2447: '{': missing function header (old-style formal list?)  uintvector.cpp(60): error C2059: syntax error: 'return'  uintvector.cpp(61): error C2059: syntax error: '}'  uintvector.cpp(61): error C2143: syntax error: missing ';' before '}'  uintvector.cpp(69): error C2143: syntax error: missing ';' before '{'  uintvector.cpp(69): error C2447: '{': missing function header (old-style formal list?) </code></pre>  <p><strong>The complete code of UintVector.hpp</strong></p>  <pre><code>#include &lt;iostream&gt;  class UIntVector { private:     size_t vsize;     unsigned int * vAddress;      // Will allocate memory for the vector     unsigned int * allocate(size_t size);     // Will copy the range of the      void copyV(unsigned int * begin, unsigned int * end, unsigned int * dest);     // Will delete reserved memory.     void deleteV(unsigned int * begin, unsigned int * end);      void reset(void);     std::size_t size() const;     unsigned int * getAddress();  public:      // If UIntVector is called without parameter it should have 0 elements.     UIntVector();      // A constructor that just takes a single argument and then we create a vector with 7 containers.     UIntVector(std::size_t length);      // A copy constuctor.     // Probably have to be explicit due to otherwise converting, don't know though     UIntVector(const UIntVector&amp; original);      // Should be a deconstructor.     ~UIntVector();      // Should be a move constructor     UIntVector(UIntVector&amp;&amp; other);      // initializer_list     UIntVector(std::initializer_list&lt;int&gt; list);      // a copy-assignment, and a move-assignment, operator taking another UIntVector (potentially of a different size), and;     UIntVector&amp; operator=(UIntVector&amp; other);      /*     – overloads of operator[] that makes it possible to access/modify elements at a desired index.         ? The first element of the container shall be at index 0.         ? An exception of type std::out_of_range shall be thrown if a user tries             to access an index out-of-bounds     */     unsigned int&amp; operator[](size_t index) const; }; </code></pre>  <p><strong>The complete code of UIntVector.cpp:</strong></p>  <pre><code>#include &lt;iostream&gt; #include "UIntVector.hpp"   // If UIntVector is called without parameter it should have 0 elements. UIntVector::UIntVector() {     vAddress = allocate(0);     vsize = 0;     // should create just an empty vector }  // A constructor that just takes a single argument and then we create a vector with 7 containers. UIntVector :: UIntVector(std::size_t length) {     // should take length and create a vector with 7 containers.     vAddress = allocate(length);     vsize = length; }  // A copy constuctor. // Probably have to be explicit due to otherwise converting, don't know though UIntVector::UIntVector(const UIntVector&amp; original) {     std::size_t originalsize = original.size();     vAddress = allocate(originalsize);     vsize = originalsize;     unsigned int a = originalsize*(sizeof(unsigned int));     unsigned int * end = original.vAddress + a;     copyV(original.vAddress, end, vAddress); } // Should be a deconstructor UIntVector::~UIntVector() {     deleteV(vAddress, vAddress + (sizeof(unsigned int)*vsize)); }  // Should be a move constructor UIntVector::UIntVector(UIntVector&amp;&amp; other) {     vAddress = other.getAddress();     vsize = other.size();     other.vsize = 0;     other.vAddress = nullptr; }  // Should be a constructor with initializer_list UIntVector::UIntVector(std::initializer_list&lt;int&gt; list) {     // std::initializer_list }   // a copy-assignment, and a move-assignment, operator taking another UIntVector (potentially of a different size), and; UIntVector&amp; UIntVector::operator=(UIntVector&amp; other){     if (this != &amp;other) {         unsigned int * begin = allocate(sizeof(unsigned int)*other.vsize);         unsigned int * end = (other.vAddress + (sizeof(unsigned int)*other.vsize));         copyV(other.vAddress, end, begin);         deleteV(other.vAddress, end);          vAddress = begin;         vsize = other.vsize;          other.vAddress = nullptr;         other.vsize = 0;     }     return *this; }   /* – overloads of operator[] that makes it possible to access/modify elements at a desired index. ? The first element of the container shall be at index 0. ? An exception of type std::out_of_range shall be thrown if a user tries to access an index out-of-bounds */ unsigned int&amp; UIntVector::operator[](size_t index) const {     try {         unsigned int * indexadress = vAddress + (sizeof(unsigned int)*index);         return *indexadress;     }     catch (std::out_of_range&amp; e) {         std::cout &lt;&lt; "Out of range: " &lt;&lt; e.what() &lt;&lt; "\n";     }     catch (std::exception&amp; e) {         std::cout &lt;&lt; "Some other exception: " &lt;&lt; e.what() &lt;&lt; "\n";     } }   // Will allocate memory for the vector unsigned int * UIntVector :: allocate(size_t size) {     vsize = size;     return (unsigned int *)malloc(sizeof(unsigned int) * size); }  // Will copy the range of the  void UIntVector :: copyV(unsigned int * begin, unsigned int * end, unsigned int * dest) {     while (begin != end){         *dest = *begin;         begin += sizeof(unsigned int);         dest += sizeof(unsigned int);     } }  void UIntVector :: deleteV(unsigned int * begin, unsigned int * end) {     while (begin != end){         free(begin);         begin += sizeof(unsigned int);     } }  void UIntVector::reset(void) {      unsigned int * address = getAddress();     unsigned int a = {};     for (int i = 0; i &lt; size(); i++) {         *address = a;         address += sizeof(unsigned int);     }  }  std::size_t UIntVector :: size(void) const {     return vsize; }  unsigned int * UIntVector::getAddress(void){     return vAddress; } </code></pre>