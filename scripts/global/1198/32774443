<p>As a tutoring exercise I implemented the Knights Tour algorithm in CS and worked fine, after trying to port it to F# I cannot go past the part where I aggregate the resulting sequences of the Knight's path to return to the caller. </p>  <p>The code is this:</p>  <pre><code>let offsets = [|(-2,-1);(-2,1);(-1,-2);(-1,2);(1,-2);(1,2);(2,-1);(2,1)|];  let squareToPair sqr =      (sqr % 8, sqr / 8)  let pairToSquare (col, row) =      row * 8 + col  // Memoizing function taken from Don Syme (http://blogs.msdn.com/b/dsyme/archive/2007/05/31/a-sample-of-the-memoization-pattern-in-f.aspx) let memoize f =     let cache = ref Map.empty     fun x -&gt;         match (!cache).TryFind(x) with         | Some res -&gt; res         | None -&gt;              let res = f x              cache := (!cache).Add(x,res)              res  let getNextMoves square =      let (col, row) = squareToPair square     offsets      |&gt; Seq.map    (fun (colOff, rowOff) -&gt; (col + colOff, row + rowOff))     |&gt; Seq.filter (fun (c, r) -&gt; c &gt;= 0 &amp;&amp; c &lt; 8 &amp;&amp; r &gt;= 0 &amp;&amp; r &lt; 8) // make sure we don't include squares out of the board     |&gt; Seq.map    (fun (c, r) -&gt; pairToSquare (c, r))  let getNextMovesMemoized = memoize getNextMoves  let squareToBoard square =      1L &lt;&lt;&lt; square  let squareToBoardMemoized = memoize squareToBoard  let getValidMoves square board =     getNextMovesMemoized square      |&gt; Seq.filter (fun sqr -&gt; ((squareToBoardMemoized sqr) &amp;&amp;&amp; board) = 0L)  // gets all valid moves from a particular square and board state sorted by moves which have less next possible moves let getValidMovesSorted square board =     getValidMoves square board     |&gt; Seq.sortBy (fun sqr -&gt; (getValidMoves sqr board) |&gt; Seq.length )   let nextMoves = getValidMovesSorted let sqrToBoard = squareToBoardMemoized  let findPath square =      let board = sqrToBoard square     let rec findPathRec brd sqr sequence = seq {         match brd with              | -1L -&gt; yield sequence             |   _ -&gt; for m in nextMoves sqr do yield! findPathRec (brd ||| (sqrToBoard m)) m m::sequence     }      findPathRec board square [square]  let solution = findPath ((4,4) |&gt; pairToSquare) |&gt; Seq.take 1 </code></pre>  <p>I am getting the following error:</p>  <pre><code>The type '(int64 -&gt; seq&lt;int&gt;)' is not a type whose values can be enumerated with this syntax, i.e. is not compatible with either seq&lt;_&gt;, IEnumerable&lt;_&gt; or IEnumerable and does not have a GetEnumerator method (using external F# compiler) </code></pre>  <p>I could probably be misunderstanding how this work, but I would expect the results of nextMoves to be seq&lt;_>. Is there a better way of doing this? Am I missing something? Any recommended patterns?</p>  <p>Thanks in advance!</p>