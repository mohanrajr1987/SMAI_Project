<p>Firstly, obtain a schema and parse:</p>    <pre class="lang-ml prettyprint-override"><code>type desc = JsonProvider&lt; """[{"name": "", "age": 1}]""", InferTypesFromValues=true &gt; let json = """[{"name": "Kitten", "age": 322}]""" let typedJson = desc.Parse(json) </code></pre>  <p>Now we can access <code>typedJson.[0]</code> .Age and .Name properties, however, I'd like to pattern match on them at compile-time to get an error if the schema is changed.</p>  <p>Since those properties are erased and we cannot obtain them at run-time:</p>  <pre class="lang-ml prettyprint-override"><code>let ``returns false``() =    typedJson.[0].GetType()     .FindMembers(MemberTypes.All, BindingFlags.Public ||| BindingFlags.Instance,                   MemberFilter(fun _ _ -&gt; true), null)    |&gt; Array.exists (fun m -&gt; m.ToString().Contains("Age")) </code></pre>  <p>...I've made a runtime-check version using active patterns:</p>  <pre class="lang-ml prettyprint-override"><code>let (|Name|Age|) k =    let toID = NameUtils.uniqueGenerator NameUtils.nicePascalName   let idk = toID k   match idk with   | _ when idk.Equals("Age") -&gt; Age   | _ when idk.Equals("Name") -&gt; Name   | ex_val -&gt; failwith (sprintf "\"%s\" shouldn't even compile!" ex_val)  typedJson.[0].JsonValue.Properties() |&gt; Array.map (fun (k, v) -&gt;       match k with      | Age -&gt; v.AsInteger().ToString() // ...      | Name -&gt; v.AsString()) // ...  |&gt; Array.iter (printfn "%A") </code></pre>  <p>In theory, if <code>FSharp.Data</code> wasn't OS I wouldn't be able to implement <code>toID</code>. Generally, the whole approach seems wrong and redoing the work.</p>  <p>I know that discriminated unions can't be generated using type providers, but maybe there's a better way to do all this checking at compile-time?</p>