<p>I'm building a relational language/library that is similar to j/kdb+/tutorialD in spirit. </p>  <p>The idea is that the end-user will: Load data (in memory, from anywhere), Perform queries, do join(s), agregates, etc. So, is like to have LINQ everywhere, <a href="http://www.try-alf.org/blog/2013-10-21-relations-as-first-class-citizen" rel="nofollow">as a first-class citizen</a> of the language.</p>  <p>A relation is composed of:</p>  <p>1- A heading with a list of pair of name * type 2- A body with a list of rows, where each row must conform with the heading</p>  <p>So, is like a table.</p>  <p>Something like this:</p>  <pre><code>type ExprC =     | BoolC of bool     | DecC of decimal     | Str16C of string #And others! and   ColumnC = {name:string; colType:ExprC} and   HeaderC = ColumnC array and   RelC = {header:array&lt;string&gt;; data:array&lt;array&lt;ExprC&gt;&gt;} </code></pre>  <p>So, I need to implement the full relational operators. PROJECTION (select) &amp; RESTRICTION (where) are easy but JOIN look tricky. This is because I need to traverse both columns (and ordering them?) to compute the join, then remove the duplicate column used for the join, then yield the result.</p>  <p>Do each thing separately is kind of easy, but I think is a lot of waste potential. I found that is claimed that <a href="https://en.wikipedia.org/wiki/Sort-merge_join" rel="nofollow">merge-sort-join</a> is the way to go, but don't know how apply to this situation where I'm interpreting.</p>  <p>I could change anything currently.. my only requirement is that the solution not hinder badly the implementation of the full relational model and the performance is "ok".</p>