<p>Let's take a <em>type augmentation abusive</em> F# script below:</p>  <pre><code>type AugmentMe = val _i : int type AugmentMe with member i.I = i._i type AugmentMe with new(i) = { _i = i } printfn "AugmentMe instance: %i" (AugmentMe(42).I)      </code></pre>  <p>that, when being interpreted as a whole, yields the expected <code>Fsi</code> output:</p>  <pre><code>&gt;  AugmentMe instance: 42  type AugmentMe =   class     new : i:int -&gt; AugmentMe     val _i: int     member I : int   end val it : unit = () </code></pre>  <p></p>  <p>Now, if we reset <code>Fsi</code> session and interpret the same script, but this time line-by-line, then <code>Fsi</code> fails to add the type constructor with the following diagnostics for the last two script lines:</p>  <pre><code>&gt;  type AugmentMe =   class     val _i: int   end &gt;  type AugmentMe with   member I : int &gt;   ~vs7894.fsx(3,30): warning FS0073: internal error: pop on empty stack during code generation, methodName = AugmentMe..ctor, m = C:\Users\gene\AppData\Local\Temp\~vs7894.fsx(3,29)-(3,39)  type AugmentMe with   new : i:int -&gt; AugmentMe &gt;   ~vs7894.fsx(4,35): error FS0039: The value or constructor 'AugmentMe' is not defined </code></pre>  <p>After some googling the <a href="http://stackoverflow.com/questions/5559699/cyclic-function-type-dependency-in-f">following mentioning</a> circa 2011 has popped up, but apparently the artifact still has place.</p>  <p>What gives? Should I report it to fsbugs? Thank you. </p>