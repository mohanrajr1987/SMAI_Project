<p>So we know that</p>  <pre><code>// This doesn't affect anything  /* This doesn't affect anything either */  /* /* /* /* This doesn't affect anything */ This does because comments aren't recursive  /* /* This doesn't affect anything */ */ This throws an error because the second * / is unmatched since comments aren't recursive </code></pre>  <p>I've heard that the reason they aren't recursive is because they would <a href="http://programmers.stackexchange.com/questions/81072/why-do-most-programming-languages-not-nest-block-comments">slow down the compiler</a>, and I guess that makes sense. However nowadays when I'm parsing c++ code in a higher level language (say Python), I can simply use the regular expression</p>  <pre><code>"\/[\/]+((?![\n])[\s\S])*\r*\n" </code></pre>  <p>to match <code>// single line comments</code>, and use</p>  <pre><code>"\/\*((?!\*\/)[\s\S])*\*\/" </code></pre>  <p>to match <code>/* multiline comments */</code>, then loop through all single line comments, remove them, then loop through all multi-line comments and remove them. Or vice versa. But that's where I'm stuck. It seems that doing one or the other isn't sufficient, because:</p>  <pre><code>// /* An error is thrown because the /* is ignored */  /* This doesn't affect things because of mysterious reasons // */ </code></pre>  <p>and</p>  <pre><code>/* This throws an error because the second * / is unmatched // */ */ </code></pre>  <p>What is the reason for this behavior? Is it also an artifact of the way the compilers parse things?  To be clear I don't want to change the behavior of c++, I would just like to know the reasoning behind the second set of examples behaving they way they do.</p>  <p>Edit:</p>  <p>So yes, to be more explicit, my question is why the following three (seemingly reasonable) ways of explaining this behavior don't work:</p>  <ol> <li><p>Simply ignore all characters on a line after // regardless of whether they are /* or * /, even if you are in a multiline comment.</p></li> <li><p>Allow a / * or */ followed by a // to still have effect. </p></li> <li><p>Both of the above.</p></li> </ol>  <p>I understand why nested comments aren't allowed, because they would require a stack and arbitrarily high amounts of memory. But these three cases would not.</p>  <p>Edit again:</p>  <p>If anyone is interested, here is the following code to extract comments of a c/c++ file in python following the correct commenting rules discussed here:</p>  <pre><code>import re commentScanner = re.Scanner([   (r"\/[\/]+((?![\n])[\s\S])*\r*(\n{1})?", lambda scanner, token: ("//", token)),   (r"\/\*((?!\*\/)[\s\S])*\*\/", lambda scanner, token: ("/* ... */", token)),   (r"[\s\S]", lambda scanner, token: None) ]) commentScanner.scan("fds a45fsa//kjl fds4325lkjfa/*jfds/\nk\lj\/*4532jlfds5342a  l/*a/*b/*c\n//fdsafa\n\r\n/*jfd//a*/fd// fs54fdsa3\r\r//\r/*\r\n2a\n\n\nois") </code></pre>