<p>I have a simple User and Roles entities with One to Many mapping. One user with Many roles. I am getting an error when I try to save the user entity. I am setting the Role object User before calling persist. </p>  <p>Below are the snap shot of entities. </p>  <p>User: </p>  <pre><code>package com.petpe.ejbadmin.entity;  import java.io.Serializable; import java.util.Date; import java.util.Set;  import javax.annotation.Generated; import javax.persistence.Basic; import javax.persistence.CascadeType; import javax.persistence.Column; import javax.persistence.Entity; import javax.persistence.FetchType; import javax.persistence.GeneratedValue; import javax.persistence.GenerationType; import javax.persistence.Id; import javax.persistence.NamedQueries; import javax.persistence.NamedQuery; import javax.persistence.OneToMany; import javax.persistence.Table; import javax.persistence.Temporal; import javax.persistence.TemporalType; import javax.validation.constraints.NotNull; import javax.validation.constraints.Size; import javax.xml.bind.annotation.XmlRootElement; import javax.xml.bind.annotation.XmlTransient;   @Entity @Table(name = "users") @XmlRootElement @NamedQueries({     @NamedQuery(name = "User.findAll", query = "SELECT u FROM User u"),     @NamedQuery(name = "User.findByUsernameandPassword", query = "SELECT u FROM User u WHERE u.username = :username AND u.password = :password"),     @NamedQuery(name = "User.findByUserfirstname", query = "SELECT u FROM User u WHERE u.userfirstname = :userfirstname"),     @NamedQuery(name = "User.findByUserlastname", query = "SELECT u FROM User u WHERE u.userlastname = :userlastname"),     @NamedQuery(name = "User.findByPhonenumber", query = "SELECT u FROM User u WHERE u.phonenumber = :phonenumber"),     @NamedQuery(name = "User.findByEmail", query = "SELECT u FROM User u WHERE u.email = :email"),     @NamedQuery(name = "User.findByErpid", query = "SELECT u FROM User u WHERE u.erpid = :erpid"),     @NamedQuery(name = "User.findByBuyerid", query = "SELECT u FROM User u WHERE u.buyerid = :buyerid"),     @NamedQuery(name = "User.findByCreatedDate", query = "SELECT u FROM User u WHERE u.createdDate = :createdDate"),     @NamedQuery(name=  "User.findByfirstletter",query="SELECT u FROM User u join fetch u.RoleSet ur WHERE LOWER(u.userfirstname) LIKE :firstname"),     @NamedQuery(name=  "User.findallusers",query="From User u join fetch u.RoleSet ur")}) public class User implements Serializable {     private static final long serialVersionUID = 1L;     @Id     @GeneratedValue(strategy=GenerationType.IDENTITY)     @Basic(optional = true)     @Column(name = "USER_ID")     private Integer userId;     @Size(max = 120)     @Column(name = "USERNAME")     private String username;     @Size(max = 60)     @Column(name = "USERFIRSTNAME")     private String userfirstname;     @Size(max = 60)     @Column(name = "USERLASTNAME")     private String userlastname;     @Size(max = 50)     @Column(name = "PASSWORD")     private String password;     @Size(max = 20)     @Column(name = "PHONENUMBER")     private String phonenumber;     // @Pattern(regexp="[a-z0-9!#$%&amp;'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&amp;'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?", message="Invalid email")//if the field contains email address consider using this annotation to enforce field validation     @Size(max = 50)     @Column(name = "EMAIL")     private String email;     @Size(max = 250)     @Column(name = "ERPID")     private String erpid;     @Size(max = 250)     @Column(name = "BUYERID")     private String buyerid;     @Basic(optional = false)     @NotNull     @Column(name = "CREATED_DATE")     @Temporal(TemporalType.DATE)     private Date createdDate;     @OneToMany(cascade = CascadeType.ALL, mappedBy = "user", fetch = FetchType.LAZY)     private Set&lt;Role&gt; RoleSet;      public User() {     }      public User(Integer userId) {         this.userId = userId;     }      public User(Integer userId, Date createdDate) {         this.userId = userId;         this.createdDate = createdDate;     }      public Integer getUserId() {         return userId;     }      public void setUserId(Integer userId) {         this.userId = userId;     }      public String getUsername() {         return username;     }      public void setUsername(String username) {         this.username = username;     }      public String getUserfirstname() {         return userfirstname;     }      public void setUserfirstname(String userfirstname) {         this.userfirstname = userfirstname;     }      public String getUserlastname() {         return userlastname;     }      public void setUserlastname(String userlastname) {         this.userlastname = userlastname;     }      public String getPassword() {         return password;     }      public void setPassword(String password) {         this.password = password;     }      public String getPhonenumber() {         return phonenumber;     }      public void setPhonenumber(String phonenumber) {         this.phonenumber = phonenumber;     }      public String getEmail() {         return email;     }      public void setEmail(String email) {         this.email = email;     }      public String getErpid() {         return erpid;     }      public void setErpid(String erpid) {         this.erpid = erpid;     }      public String getBuyerid() {         return buyerid;     }      public void setBuyerid(String buyerid) {         this.buyerid = buyerid;     }      public Date getCreatedDate() {         return createdDate;     }      public void setCreatedDate(Date createdDate) {         this.createdDate = createdDate;     }      @XmlTransient     public Set&lt;Role&gt; getRoleSet() {         return RoleSet;     }      public void setRoleSet(Set&lt;Role&gt; RoleSet) {         this.RoleSet = RoleSet;     }      @Override     public int hashCode() {         int hash = 0;         hash += (userId != null ? userId.hashCode() : 0);         return hash;     }      @Override     public boolean equals(Object object) {         // TODO: Warning - this method won't work in the case the id fields are not set         if (!(object instanceof User)) {             return false;         }         User other = (User) object;         if ((this.userId == null &amp;&amp; other.userId != null) || (this.userId != null &amp;&amp; !this.userId.equals(other.userId))) {             return false;         }         return true;     }      @Override     public String toString() {         return "[ userId=" + userId + " ]";     }  } </code></pre>  <p>Role:</p>  <p>/*  * To change this license header, choose License Headers in Project Properties.  * To change this template file, choose Tools | Templates  * and open the template in the editor.  */</p>  <pre><code>package com.petpe.ejbadmin.entity;  import java.io.Serializable;  import javax.persistence.Basic; import javax.persistence.Column; import javax.persistence.Entity; import javax.persistence.FetchType; import javax.persistence.GeneratedValue; import javax.persistence.GenerationType; import javax.persistence.Id; import javax.persistence.JoinColumn; import javax.persistence.ManyToOne; import javax.persistence.NamedQueries; import javax.persistence.NamedQuery; import javax.persistence.Table; import javax.validation.constraints.NotNull; import javax.validation.constraints.Size; import javax.xml.bind.annotation.XmlRootElement;   @Entity @Table(name = "user_roles") @XmlRootElement public class Role implements Serializable {     private static final long serialVersionUID = 1L;     @Id     @GeneratedValue(strategy=GenerationType.IDENTITY)     @Basic(optional = false)     @Column(name = "ROLEID")     private Integer roleid;     @Basic(optional = false)     @NotNull     @Size(min = 1, max = 30)     @Column(name = "ROLENAME")     private String rolename;     @JoinColumn(name = "USER_ID", referencedColumnName = "USER_ID")     @ManyToOne( fetch = FetchType.LAZY)     private User user;      public Role() {     }      public Role(String rolename) {         this.rolename = rolename;     }      public Role(Integer roleid, String rolename) {         this.roleid = roleid;         this.rolename = rolename;     }      public User getUser() {         return user;     }      public void setUser(User user) {         this.user = user;     }      public Integer getRoleid() {         return roleid;     }      public void setRoleid(Integer roleid) {         this.roleid = roleid;     }      public String getRolename() {         return rolename;     }      public void setRolename(String rolename) {         this.rolename = rolename;     }        @Override     public int hashCode() {         int hash = 0;         hash += (roleid != null ? roleid.hashCode() : 0);         return hash;     }      @Override     public boolean equals(Object object) {         // TODO: Warning - this method won't work in the case the id fields are not set         if (!(object instanceof Role)) {             return false;         }         Role other = (Role) object;         if ((this.roleid == null &amp;&amp; other.roleid != null) || (this.roleid != null &amp;&amp; !this.roleid.equals(other.roleid))) {             return false;         }         return true;     }      @Override     public String toString() {         return "[ roleid=" + roleid + " ]";     }  } </code></pre>  <p>Error:</p>  <pre><code>1.Cannot insert the value NULL into column 'USER_ID', table 'pedb.pedb.user_roles'; column does not allow nulls. INSERT fails. 2.could not insert: [com.petpe.ejbadmin.entity.Role] 3.org.hibernate.exception.ConstraintViolationException: could not insert: [com.petpe.ejbadmin.entity.Role] 4.javax.persistence.PersistenceException: org.hibernate.exception.ConstraintViolationException: could not insert: [com.petpe.ejbadmin.entity.Role] </code></pre>  <p>Setting and Persisting code:</p>  <pre><code>public boolean AddorModifyUser(UserAdminDTO udato) {          User usr=this.populateUserobj(udato);         pet_em.persist(usr);          return true;     }  public User populateUserobj(UserAdminDTO udto)     {         User usr=new User();          usr.setBuyerid(udto.getbuyerid());         usr.setCreatedDate(new Date());         usr.setEmail(udto.getEmail());         usr.setErpid(udto.geterpid());         usr.setPassword(udto.getPassword());         usr.setPhonenumber(udto.getPhoneNumber());         usr.setUserfirstname(udto.getFirstName());         usr.setUserlastname(udto.getLastName());         usr.setUsername(udto.getUserName());         for(Role r: udto.getRole())         {             Set&lt;Role&gt; RoleSet=new HashSet&lt;&gt;();             RoleSet.add(r);                  usr.setRoleSet(RoleSet);         }         return usr;     } </code></pre>  <p>Layout of table:</p>  <p><a href="http://i.stack.imgur.com/2vlJf.png" rel="nofollow"><img src="http://i.stack.imgur.com/2vlJf.png" alt="enter image description here"></a></p>