<p>I have a simple MySQL wrapper class which will run a query and return results. </p>  <pre><code>class Rsql   def initialize(db)     @client = Mysql2::Client     @db = db   end    def execute_query()     client = @client.new(@db)     client.query("select 1")   end  end </code></pre>  <p>I want to test some stuff involving the results of the query, but I don't want to actually connect to a database to get the results. I tried this test, but it doesn't work:</p>  <pre><code>RSpec.describe Rsql do    it "does it" do     mock_database = double     rsql = Rsql.new(mock_database)      mock_mysql_client = double     allow(mock_mysql_client).to receive(:query).and_return({"1" =&gt; 1})      allow_any_instance_of(Mysql2::Client).to receive(:new).and_return(mock_mysql_client)     expect(rsql.execute_query).to eq({"1" =&gt; 1})   end  end </code></pre>  <p>Replacing "allow_any_instance_of" with "allow" works. I was under the impression that allow_any_instance_of() was some kind of a global "pretend this class behaves in this way across the entire program" whereas allow() is for specific instances of a class. </p>  <p>Can someone explain this behavior to me? I'm new to Rspec, so I apologize if this answer is blatantly obvious. I tried searching for the answer, but I couldn't come up with the right search string to find one. Maybe I don't know enough to know when I've found it.</p>  <p>Thanks!</p>