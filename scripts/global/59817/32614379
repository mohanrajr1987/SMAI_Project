<p>I have currently 2 buttons, Audi TT RS and Audi R8 when the user clicks on button TT RS it plays a mp3, when user clicks on button R8 it opens a different mp3 file.</p>  <p>This works, however... if the user clicks on one of them, and then clicks on the other. both mp3 files will open and it will sound terrible. </p>  <p>those are my functions :</p>  <pre><code>async void Audir8_Click(object sender, RoutedEventArgs e)         {             MediaElement mediaplayer = new MediaElement();             if (mediaplayer.CurrentState == MediaElementState.Playing)             {                 mediaplayer.Stop();             }             // get folder app is installed to             var installFolder = Windows.ApplicationModel.Package.Current.InstalledLocation;             // get folders mp3 files are installed to.             var resourcesFolder = await installFolder.GetFolderAsync("Resources");             var mp3FilesFolder = await resourcesFolder.GetFolderAsync("mp3Files");             // open the mp3 file async             var audioFile = await mp3FilesFolder.GetFileAsync("audir8.mp3");             // var stream = await audioFile.OpenAsync(Windows.Storage.FileAccessMode.Read);             using (var stream = await audioFile.OpenAsync(Windows.Storage.FileAccessMode.Read))             {                 // play dat funky music              //   MediaElement mediaplayer = new MediaElement();                 mediaplayer.SetSource(stream, audioFile.ContentType);                  var tcs = new TaskCompletionSource&lt;bool&gt;();                 mediaplayer.CurrentStateChanged += (_, __) =&gt;                 {                     if (mediaplayer.CurrentState != MediaElementState.Opening &amp;&amp;                         mediaplayer.CurrentState != MediaElementState.Playing &amp;&amp;                         mediaplayer.CurrentState != MediaElementState.Buffering)                     // mediaplayer.CurrentState != MediaElementState.AcquiringLicense)                     {                         // Any other state should mean we're done playing                         tcs.TrySetResult(true);                     }                 };                 mediaplayer.Play();                 await tcs.Task; // Asynchronously wait for media to finish             }         } </code></pre>  <p>and the other one, actually the same..</p>  <pre><code> async void Audittrs_Click(object sender, RoutedEventArgs e)         {             MediaElement mediaplayer = new MediaElement();             if (mediaplayer.CurrentState == MediaElementState.Playing)             {                 mediaplayer.Stop();             }             // get folder app is installed to             var installFolder = Windows.ApplicationModel.Package.Current.InstalledLocation;             // get folders mp3 files are installed to.             var resourcesFolder = await installFolder.GetFolderAsync("Resources");             var mp3FilesFolder = await resourcesFolder.GetFolderAsync("mp3Files");             // open the mp3 file async             var audioFile = await mp3FilesFolder.GetFileAsync("ttrs.mp3");             // var stream = await audioFile.OpenAsync(Windows.Storage.FileAccessMode.Read);             using (var stream = await audioFile.OpenAsync(Windows.Storage.FileAccessMode.Read))             {                 // play dat funky music               //  MediaElement mediaplayer = new MediaElement();                 mediaplayer.SetSource(stream, audioFile.ContentType);                  var tcs = new TaskCompletionSource&lt;bool&gt;();                 mediaplayer.CurrentStateChanged += (_, __) =&gt;                 {                     if (mediaplayer.CurrentState != MediaElementState.Opening &amp;&amp;                         mediaplayer.CurrentState != MediaElementState.Playing &amp;&amp;                         mediaplayer.CurrentState != MediaElementState.Buffering)                     // mediaplayer.CurrentState != MediaElementState.AcquiringLicense)                     {                         // Any other state should mean we're done playing                         tcs.TrySetResult(true);                     }                 };                 mediaplayer.Play();                 await tcs.Task; // Asynchronously wait for media to finish             }         } </code></pre>  <p>I thought this should not happen since I am using </p>  <pre><code>MediaElement mediaplayer = new MediaElement();             if (mediaplayer.CurrentState == MediaElementState.Playing)             {                 mediaplayer.Stop();             } </code></pre>