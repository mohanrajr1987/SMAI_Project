<p>I started implementing a sample server (in netty) to support 100 continue. I got some confusion when I go thrugh the <a href="http://www.faqs.org/rfcs/rfc2616.html" rel="nofollow">RCF2616</a> section 8.2.3. It says </p>  <blockquote>   <p>Upon receiving a request which includes an Expect request-header           field with the "100-continue" expectation, an origin server MUST           either respond with 100 (Continue) status and continue to read           from the input stream, or respond with a final status code. The           origin server MUST NOT wait for the request body before sending           the 100 (Continue) response. If it responds with a final status           code, it MAY close the transport connection or it MAY continue           to read and discard the rest of the request.  It MUST NOT           perform the requested method if it returns a final status code.</p> </blockquote>  <p>What does it mean by <em>The origin server MUST NOT wait for the request body before sending the 100 (Continue) response.</em>  Should my server first validate the headers and then send the 100 (continue) status code or Immediately send the 100 status code ?</p>  <p>Please clarify me the actual behavior of a http server to support 100 continue </p>  <p>Currently this is my <code>channelRead</code></p>  <pre><code>@Override public void channelRead(ChannelHandlerContext ctx, Object msg) {     if (msg instanceof HttpRequest) {         HttpRequest req = (HttpRequest) msg;          request = req;         if (req.getMethod() != HttpMethod.POST) {             FullHttpResponse response = new DefaultFullHttpResponse(HTTP_1_1, METHOD_NOT_ALLOWED);             ctx.write(response).addListener(ChannelFutureListener.CLOSE);         } else {              boolean valid = false;             for (Map.Entry&lt;String, String&gt; header : req.headers()) {                 if (header.getKey().equals("my-special-header")) {                     valid = true;                     break;                 }             }             if (!valid) {                 FullHttpResponse resp = new DefaultFullHttpResponse(HTTP_1_1, BAD_REQUEST);                 ctx.write(resp).addListener(ChannelFutureListener.CLOSE);              } else {                 if (HttpHeaders.is100ContinueExpected(request)) {                     ctx.write(new DefaultFullHttpResponse(HTTP_1_1, CONTINUE));                 }             }          }      } else if (msg instanceof LastHttpContent &amp;&amp; msg != LastHttpContent.EMPTY_LAST_CONTENT) {         DefaultLastHttpContent content = (DefaultLastHttpContent) msg;          System.out.println("content read");         FullHttpResponse response = new DefaultFullHttpResponse(HTTP_1_1, OK, content.content());         response.headers().set(CONTENT_TYPE, "text/plain");         response.headers().set(CONTENT_LENGTH, response.content().readableBytes());          boolean keepAlive =HttpHeaders.isKeepAlive(request);         if (!keepAlive) {             ctx.write(response).addListener(ChannelFutureListener.CLOSE);         } else {             response.headers().set(CONNECTION, Values.KEEP_ALIVE);             ctx.write(response);         }     } } </code></pre>