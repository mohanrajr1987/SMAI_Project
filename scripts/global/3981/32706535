<p>This is a homework assignment that I believe I am close to getting, but I cannot figure out what is wrong with my memory allocation. The runtime error occurs with the lw in the if statement, and I haven't fixed preserving my parameters (I have this noted in my code in the towers function). I feel that I need to fix this "Runtime exception at 0x00400018: address out of range 0x00000000" error first before moving forward. (Note: I have commented out the final step of undoing the space on the stack just so the code would assemble and run because I still am not crystal clear on how to make space on the stack so I planned on returning to that later)</p>  <p>Can anyone tell me where or how my memory allocation is going wrong? I am very new to MIPS and am finding it hard to read/reason through. **I now realize that the error is not occurring with the lw, but rather with the beq</p>  <pre><code># towers.s - Solve the Towers of Hanoi puzzle. # Print each move and return the total number # of moves needed to solve the puzzle. #  .text  .globl towers   # Preconditions:     #   1st parameter (a0) numDiscs, number of discs to move #   2nd parameter (a1) start, starting peg. if you move start you need to look up where it was moved #   3rd parameter (a2) goal, ending peg # Postconditions: #   result (v0) steps, total number of steps required to solve puzzle  towers:     add $sp, $sp, -32   # make space on stack ***             sw $s0, ($sp)       # preserve registers used by this function ***         #** preserve parameters # find a callee-saved, unused place for "start", then refer to the safe place for start in everything else             sw $ra, 4($sp)      # preserve return address ***             addi $t2, $zero, 2  # assign temporary register value 2  if:     slt $t1, $a0, $t1   # numDiscs &lt; 2  (if true, t1 = 1, if false  t1 = 0)          beq $t1, $zero, else    # if not, go to else           lw $a0, ($a1)       # 1st parameter = start **correct address         lw $a1, ($a2)       # 2nd parameter = goal **correct address         syscall         # call print function          addi $ra, $zero, 1      # return value = 1          j endif         # jump past else   else:   addi $s1, $zero, 6  # s1 = peg = 6         sub $s1, $s1, $a1   # peg = peg - start         sub $s1, $s1, $a2   # peg = peg - goal = 6 - start - goal          sub $a0, $a0, 1     # 1st parameter = numDiscs - 1         add $a1, $a1, $zero # 2nd parameter = start **correct address         add $a2, $s1, $zero # 3rd parameter = peg **correct address         jal towers      # recursive call to towers          add $s0, $zero, $v0 # s0 = steps = result          addi $a0, $zero, 1  # 1st parameter = 1         add $a1, $a1, $zero # 2nd parameter = start . copy it out of somewhere else, whenever you use the value of start                              # you refer to the place where you copied it to         add $a2, $a2, $zero # 3rd parameter = goal         jal towers      # recursive call to towers          add $v0, $v0, $s0       # steps = steps + result           sub $a0, $a0, 1     # 1st parameter = numDiscs - 1         add $a1, $s1, $zero # 2nd parameter = peg         add $a2, $a2, $zero # 3rd parameter = goal         jal towers      # recursive call to towers          add $v0, $v0, $s0       # return value = steps + result  endif:  #lw #registers used     # restore registers used by this function         #lw $ra     # restore return address          #lw $sp     # restore stack pointer          jr $ra      # return  </code></pre>