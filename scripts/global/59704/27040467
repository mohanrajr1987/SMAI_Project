<p>I'm defining a class 'function' and two others classes 'polynomial' and 'affine' that inherit from 'function'.</p>  <pre><code>    class function {      public:         function(){};         virtual function* clone()const=0;         virtual float operator()(float x)const=0; //gives the image of a number by the function         virtual function* derivative()const=0;         virtual float inverse(float y)const=0;          virtual ~function(){}      };      class polynomial : public function {     protected:         int degree;     private:         float *coefficient;     public:          polynomial(int d);         virtual~polynomial();         virtual function* clone()const;         int get_degree()const;         float operator[](int i)const; //reads coefficient number i         float&amp; operator[](int i); //updates coefficient number i         virtual float operator()(float x)const;          virtual function* derivative()const;         virtual float inverse(float y)const;       };      class affine : public polynomial {         int a;          int b;          //ax+b public:         affine(int d,float a_, float b_);         function* clone()const;         float operator()(float x)const;         function* derivative()const;         float inverse(float y)const;         ~affine(){}     }; </code></pre>  <p>I implemented all the methods relating to 'polynomial' and would like to test them. For the derivative method, I'm using the affine constructor in the case the instance's degree is equal to 0. So I have to define this constructor before running tests. </p>  <pre><code>polynomial::polynomial(int d) {     assert(d&gt;=0);     degree=d;     coefficient=new float [d+1]; }  polynomial::~polynomial() {     delete[] coefficient; } function* polynomial::derivative()const {     if(degree==0)     {         return new affine(0,0,0);     }     polynomial* deriv=new polynomial(degree-1);     for(int i=0;i&lt;degree;i++)         deriv[i]=(i+1)*coefficient[i+1];        return deriv; }  affine::affine(int d,float a_, float b_):polynomial(d) {      assert(d==0 || d==1);     degree=d;     a=a_;     b=b_; } </code></pre>  <p>My first test is :</p>  <pre><code>#include "function.h"  int main(int argc, const char * argv[]) {     //p=x^3     polynomial p(3);      for(int i=0;i&lt;=2;i++) p[i]=0;     p[3]=1;     cout&lt;&lt;"21^(1/3)="&lt;&lt;p.inverse(21);        return 0; } </code></pre>  <p>When I run it, I get a link error :</p>  <pre><code>Undefined symbols for architecture x86_64:   "vtable for affine", referenced from:       affine::affine(int, float, float) in polynomial.o   NOTE: a missing vtable usually means the first non-inline virtual member function has no definition. ld: symbol(s) not found for architecture x86_64 clang: error: linker command failed with exit code 1 (use -v to see invocation) </code></pre>  <p>I can't find out why. </p>