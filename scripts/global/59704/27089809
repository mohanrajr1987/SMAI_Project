<p>I wrote a c++ program that computes the values of polynomials and trigonometric functions and their derivatives using inheritance. The parent class is <em>function</em></p>  <pre><code>class function { public:     function* integral; public:     function(){integral=0;}     //void set_integral(function* m){integral=m;}     virtual function* clone()const=0;     virtual double operator()(double x)const; //returns the value of a trigonometric function's derivative for a double x     virtual function* derivative()const=0;     virtual double inverse(double y)const=0;      virtual ~function(){}  };    class polynomial : public function { protected:     int degree; private:     double *coefficient; public:     polynomial(int d);     virtual~polynomial(); //virtual because I'm using polynomial as a parent class for another class     virtual function* clone()const;     int get_degree()const;     double operator[](int i)const; //reads the coefficient number i     double&amp; operator[](int i); //updates the coefficient number i     virtual double operator()(double x)const;      virtual function* derivative()const;     virtual double inverse(double y)const;   };  class trigo : public function{     string name; public:     trigo(string n);     function* clone()const;     double operator()(double x)const;     function* derivative()const;     double inverse(double y)const;     ~trigo(){} }; </code></pre>  <p>The method <em>derivative</em> is implemented differently in <em>polynomial</em> and <em>trigo</em>. For <em>polynomial</em>, I'm returning a pointer on an instance of <em>polynomial</em>, but for <em>trigo</em>, I'm returning a pointer on an instance of <em>function</em>. </p>  <pre><code>function* polynomial::derivative()const {     if(degree==0)     {         return new affine(0,0,0);     }     polynomial* deriv=new polynomial(degree-1);     for(int i=0;i&lt;degree;i++)         deriv-&gt;coefficient[i]=(i+1)*coefficient[i+1];      deriv-&gt;integral=clone();     return deriv; }  function* trigo::derivative()const {      function* deriv=clone(); //This specific initialization does not impact the computed outputs, I think we can put anything. It's the attribute integral that matters.      deriv-&gt;integral=clone();     return deriv; } </code></pre>  <p>For this, I wrote twice the method <em>inverse</em>, one for <em>polynomial</em>, and another for <em>trigo</em>. </p>  <pre><code>double polynomial::inverse(double y)const {     int i=0;     double x0=1;     function* deriv=derivative();     double x1=x0+(y-(*this)(x0))/(*deriv)(x0);     while(i&lt;=250 &amp;&amp; std::abs(x1-x0)&gt;1e-5)     {         x0=x1;         x1=x0+(y-(*this)(x0))/(*deriv)(x0);         i++;     }      if(std::abs(x1-x0)&lt;=1e-5)      {         return x1;        }      else         {         cout&lt;&lt;"Maximum iteration reached in polynomial method 'inverse'"&lt;&lt;endl;         return rand();     } }     double trigo::inverse(double y)const {     int i=0;     double x0=1; //Inital value of x0 is crucial, if we begin with x0=2, the code fails.      function* deriv=derivative();     double x1=x0+(y-(*this)(x0))/(deriv-&gt;function::operator()(x0));         while(i&lt;=400 &amp;&amp; abs(x1-x0)&gt;1e-5)     {         x0=x1;         x1=x0+(y-(*this)(x0))/(deriv-&gt;function::operator()(x0));         i++;     }      if(abs(x1-x0)&lt;=1e-5)      {         return x1;        }      else         {         cout&lt;&lt;"Maximum iteration reached in trigo method 'inverse'"&lt;&lt;endl;         return rand();     } }   double function::operator()(double x)const //computes the value of a trigo's derivative for a double x {     if(integral==0)      {         cout&lt;&lt;"function::operator() error"&lt;&lt;endl;         return rand();     }     return ((*integral)(x+1e-05)-(*integral)(x-1e-05))/(2e-05); } </code></pre>  <p>I would like to implement method <em>inverse</em> in <em>function</em> juste once, and not twice in child classes.  <em>polynomial::inverse</em> and <em>trigo::inverse</em> above are similar, there's just the update of x1 that uses different operator (). When I change the operator used in one of these methods, the program doesn't return the right values. For example, when I put  <code>double x1=x0+(y-(*this)(x0))/(deriv-&gt;function::operator()(x0));</code>  instead of  <code>double x1=x0+(y-(*this)(x0))/(*deriv)(x0);</code>  in <em>polynomial::inverse</em>, I get "Maximum iteration reached" error when I test the code with the polynomial X^3 (computing 27^(1/3))</p>