<p>i want to get the x and y of the circle with the lowest distance to my special circle. I am creating 25 circles with a timer and need to check every drawn circle on the field. What I already have is this:</p>  <pre><code>protected void onDraw (android.graphics.Canvas canvas){      //If arrow-button was clicked, do ... get the circle with the lowest distance to viking circle     if (buttonClicked == true) {         //distance of the current circle from the viking         int tempCircleDistance = 0;          //the minimum distance we have found so far in our loop         int minCircleDistance = 0;          //index of the min circle we have found so far         int indexOfNearest=0;         for(int i = 0; i&lt;circlesOnTheField; i++)          {             //help me Phytagoras             tempCircleDistance = (int) (Math.sqrt((viking.getX() - circles.get(i).getX())*                     (viking.getX() - circles.get(i).getX())+                     (viking.getY() - circles.get(i).getY())*                     (viking.getY() - circles.get(i).getY()))-                     (viking.getR() + circles.get(i).getR()));           //first cycle or did we find the nearest circle? If so update our variables             if(i==0||tempCircleDistance&lt;minCircleDistance)             {                        indexOfNearest=i;                    minCircleDistance=tempCircleDistance;             }         }         if(circles.get(indexOfNearest).getIsDrawn() == true) {              //draw the line with the given index of the nearest circle             //At this point, nearest circle is calculated and we draw a line from viking to that circle             canvas.drawLine(viking.getX(), viking.getY(),                              circles.get(indexOfNearest).getX(),                              circles.get(indexOfNearest).getY(),                              pgoal);             //Here we delete the circle and increase our variable frags for one more killed opponent.             deleteCircle(circles.get(indexOfNearest));             circlesOnTheField--;             frags++;             buttonClicked = false;         }      }     //END      //This is where the circles are drawn     for(int k = 0; k&lt;circlesOnTheField; k++) {             canvas.drawCircle(circles.get(k).getX(), circles.get(k).getY(), circles.get(k).getR(), p3);             circles.get(k).setIsDrawn(true);     } }  </code></pre>  <p>So I store my circles in the array called <code>circles[]</code> and have my fixed second circle <code>viking</code> to calculate the distance to. The variable <code>arrowCircle</code> should store the name of the nearest circle. Then I want to draw a line between the nearest circle to the viking circle.</p>  <p>Any ideas what's wrong?</p>  <p>Thanks in advance I think the part with <code>if(i&gt;=1) {...</code> might be incorrect. </p>  <p>Edited 21.09.15:</p>  <p>This is what happens on <code>deleteCircle()</code>:</p>  <pre><code>    public static void deleteCircle(Circle circle) {     circles.remove(circle);     circlesOnTheField--; } </code></pre>  <p>And the <code>addCircle()</code>:</p>  <pre><code>    public static void addCircle() {     if(circlesOnTheField &gt;= 25) {         circlesOnTheField = 25;     }     else{     circlesOnTheField++;     } } </code></pre>  <p>I have one timer which executes <code>addCircle()</code> and another one with <code>moveCircle()</code>:</p>  <pre><code>public static void moveCircle() {     for(int i=0; i&lt;circlesOnTheField; i++) {         //Move circles downwards         circles.get(i).setY(circles.get(i).getY()+5);          //Check if the circle collides with the viking         if(detectCollision(viking, circles.get(i))) {             deleteCircle(circles.get(i));             circles.get(i).setIsDrawn(false);             life--;         }          //Check if the circle intersects the goal line and recreate it if yes         if(intersects(circles.get(i).getX(), circles.get(i).getY(), circles.get(i).getR(), 0, 750, 500, 760)) {             deleteCircle(circles.get(i));             circles.get(i).setIsDrawn(false);             circlesInGoal++;         }     } } </code></pre>  <p>And finally, this is what is executed in the constructor:</p>  <pre><code>public static void createNewCircleOnCanvas() {     //Collision Detection     circles.clear();     int createdCircles = 0;      outer: while (createdCircles &lt; 25) {         int randomX = r.nextInt(500);         int randomY = r.nextInt(300);        candidate = new Circle(randomX, randomY, 33, "Circle"+createdCircles, false);         inner: for (int z = 0; z&lt;createdCircles;z++) {             //If new created circle collides with any already created circle or viking, continue with outer               if (detectCollision(candidate, circles.get(z))) continue outer;         }        circles.add(candidate);        createdCircles++;     } </code></pre>