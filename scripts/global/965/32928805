<p>Have been pulling my hair trying to get this working for almost a week. Have solve several issues and now I'm down to this new error when I try to convert IntPtr to a DSP_DESCRIPTION structure. </p>  <p>Could anyone please shine some light? Thanks in advanced, you guys are awesome! </p>  <p>Do I need to switch to unsafe mode because the FMOD DSP_STRUCTURE is not blittable? I'm putting the definition of the structure at the end. </p>  <pre><code>**ArgumentException: The specified structure must be blittable or have layout information.** </code></pre>  <p>I'm getting the IntPtr from a call to a Static Library Function. </p>  <p><strong>Static Library Code (C++):</strong></p>  <pre><code>extern "C" {         F_DECLSPEC F_DLLEXPORT int F_STDCALL AigooGetDSPDescription2(FMOD_DSP_DESCRIPTION **ppFmodDesc)     {          // defines the user interface, maximum distance knob         static float distance_mapping_values[] = { 0, 1, 5, 20, 100, 500, 10000 };         static float distance_mapping_scale[] = { 0, 1, 2, 3, 4, 4.5, 5 };          FMOD_DSP_INIT_PARAMDESC_FLOAT_WITH_MAPPING(p_max_distance,         "Max Dist4", "", "Distance at which bandpass stops narrowing. 0 to 1000000000. Default = 100",AIGOO_SIMPLE_PLUGIN_PARAM_MAX_DISTANCE_DEFAULT, distance_mapping_values,         distance_mapping_scale);           // defines the 3D location attributes         FMOD_DSP_INIT_PARAMDESC_DATA(p_3d_attributes,       "3D Attributes", "",    "",                                                                           FMOD_DSP_PARAMETER_DATA_TYPE_3DATTRIBUTES);          FMOD_DSP_DESCRIPTION* Aigoo_Simple_Plugin_DescPtr = new FMOD_DSP_DESCRIPTION ();               Aigoo_Simple_Plugin_DescPtr-&gt;pluginsdkversion = FMOD_PLUGIN_SDK_VERSION;             strcpy(Aigoo_Simple_Plugin_DescPtr-&gt;name,"AigooSimplePlugin6");             Aigoo_Simple_Plugin_DescPtr-&gt;version = 0x00010000;     // plug-in version             Aigoo_Simple_Plugin_DescPtr-&gt;numinputbuffers = 1;      // number of input buffers to process             Aigoo_Simple_Plugin_DescPtr-&gt;numoutputbuffers = 1;     // number of output buffers to process             Aigoo_Simple_Plugin_DescPtr-&gt;create = Aigoo_Simple_Plugin_dspcreate;             Aigoo_Simple_Plugin_DescPtr-&gt;release = Aigoo_Simple_Plugin_dsprelease;             Aigoo_Simple_Plugin_DescPtr-&gt;reset = Aigoo_Simple_Plugin_dspreset;             Aigoo_Simple_Plugin_DescPtr-&gt;read = Aigoo_Simple_Plugin_dspread;             Aigoo_Simple_Plugin_DescPtr-&gt;process = 0;             Aigoo_Simple_Plugin_DescPtr-&gt;setposition = 0;             Aigoo_Simple_Plugin_DescPtr-&gt;numparameters = AIGOO_SIMPLE_PLUGIN_NUM_PARAMETERS;             Aigoo_Simple_Plugin_DescPtr-&gt;paramdesc = Aigoo_Simple_Plugin_dspparam;             Aigoo_Simple_Plugin_DescPtr-&gt;setparameterfloat = Aigoo_Simple_Plugin_dspsetparamfloat;             Aigoo_Simple_Plugin_DescPtr-&gt;setparameterint = 0, // Aigoo_Simple_Plugin_dspsetparamint;             Aigoo_Simple_Plugin_DescPtr-&gt;setparameterbool = 0, // Aigoo_Simple_Plugin_dspsetparambool;             Aigoo_Simple_Plugin_DescPtr-&gt;setparameterdata = Aigoo_Simple_Plugin_dspsetparamdata;             Aigoo_Simple_Plugin_DescPtr-&gt;getparameterfloat = Aigoo_Simple_Plugin_dspgetparamfloat;             Aigoo_Simple_Plugin_DescPtr-&gt;getparameterint = 0, // Aigoo_Simple_Plugin_dspgetparamint;             Aigoo_Simple_Plugin_DescPtr-&gt;getparameterint = 0, // Aigoo_Simple_Plugin_dspgetparambool;             Aigoo_Simple_Plugin_DescPtr-&gt;getparameterdata = Aigoo_Simple_Plugin_dspgetparamdata;             Aigoo_Simple_Plugin_DescPtr-&gt;shouldiprocess = Aigoo_Simple_Plugin_shouldiprocess;             Aigoo_Simple_Plugin_DescPtr-&gt;userdata = 0;       // userdata             Aigoo_Simple_Plugin_DescPtr-&gt;sys_register = Aigoo_Simple_Plugin_sys_register;             Aigoo_Simple_Plugin_DescPtr-&gt;sys_deregister = Aigoo_Simple_Plugin_sys_deregister;             Aigoo_Simple_Plugin_DescPtr-&gt;sys_mix = Aigoo_Simple_Plugin_sys_mix;          *ppFmodDesc = Aigoo_Simple_Plugin_DescPtr;           return 9291983;     } } </code></pre>  <p><strong>Application (C#):</strong></p>  <p>I'm coding on Unity3d (C#) and generating iOS project. Using static library (*.a) for iOS. </p>  <pre><code>public class FMOD_Listener : MonoBehaviour  { ...     void LoadPlugins()     {         //cchacon         uint mmdsp_handle; //handler for the plugin          FMOD.System sys = null;         ERRCHECK(FMOD_StudioSystem.instance.System.getLowLevelSystem(out sys));         int plugin_result = 0;          if (Application.platform == RuntimePlatform.IPhonePlayer) {              IntPtr FmodDescIntPtr;             plugin_result = FMODPlugInHandler.AigooGetDSPDescription2(out FmodDescIntPtr);             myLog = "plugin_result = " + plugin_result + " FmodDescIntPtr: " + FmodDescIntPtr;              Camera.main.backgroundColor = Color.blue;              if (FmodDescIntPtr != IntPtr.Zero)             {                 plugin_result = 838383;                 myLog = "plugin_result = " + plugin_result  + " FmodDescIntPtr: " + FmodDescIntPtr ;                  Camera.main.backgroundColor = Color.yellow;                  DSP_DESCRIPTION FmodDesc = (DSP_DESCRIPTION)Marshal.PtrToStructure(FmodDescIntPtr, typeof(DSP_DESCRIPTION));                  plugin_result = 889911;                 myLog = "plugin_result = " + plugin_result ;                  Camera.main.backgroundColor = Color.gray;                  ERRCHECK(sys.registerDSP(ref FmodDesc, out mmdsp_handle));                  plugin_result = 123456;                 myLog = "plugin_result = " + plugin_result ;                  Camera.main.backgroundColor = Color.green;              }             else                 Console.WriteLine("FmodDescPtr is IntPtr.Zero");          }          if (Application.platform == RuntimePlatform.IPhonePlayer &amp;&amp; pluginPaths.Length != 0)         {             FMOD.Studio.UnityUtil.LogError("DSP Plugins not currently supported on iOS, contact support@fmod.org for more information");             return;         }          foreach (var name in pluginPaths)         {             var path = pluginPath + "/" + GetPluginFileName(name);              FMOD.Studio.UnityUtil.Log("Loading plugin: " + path);  #if !UNITY_METRO             if (!System.IO.File.Exists(path))             {                 FMOD.Studio.UnityUtil.LogWarning("plugin not found: " + path);             } #endif              uint handle;             ERRCHECK(sys.loadPlugin(path, out handle));          }     }     ...  } </code></pre>  <p>Here is the definition of the structure:</p>  <pre><code>[StructLayout(LayoutKind.Sequential)] public struct DSP_DESCRIPTION {     public uint pluginsdkversion;                          /* [w] The plugin SDK version this plugin is built for.  set to this to FMOD_PLUGIN_SDK_VERSION defined above. */     [MarshalAs(UnmanagedType.ByValArray, SizeConst = 32)]     public char[]                      name;               /* [w] Name of the unit to be displayed in the network. */     public uint                        version;            /* [w] Plugin writer's version number. */     public int                         numinputbuffers;    /* [w] Number of input buffers to process.  Use 0 for DSPs that only generate sound and 1 for effects that process incoming sound. */     public int                         numoutputbuffers;   /* [w] Number of audio output buffers.  Only one output buffer is currently supported. */     public DSP_CREATECALLBACK          create;             /* [w] Create callback.  This is called when DSP unit is created.  Can be null. */     public DSP_RELEASECALLBACK         release;            /* [w] Release callback.  This is called just before the unit is freed so the user can do any cleanup needed for the unit.  Can be null. */     public DSP_RESETCALLBACK           reset;              /* [w] Reset callback.  This is called by the user to reset any history buffers that may need resetting for a filter, when it is to be used or re-used for the first time to its initial clean state.  Use to avoid clicks or artifacts. */     public DSP_READCALLBACK            read;               /* [w] Read callback.  Processing is done here.  Can be null. */     public DSP_PROCESS_CALLBACK        process;            /* [w] Process callback.  Can be specified instead of the read callback if any channel format changes occur between input and output.  This also replaces shouldiprocess and should return an error if the effect is to be bypassed.  Can be null. */     public DSP_SETPOSITIONCALLBACK     setposition;        /* [w] Setposition callback.  This is called if the unit wants to update its position info but not process data.  Can be null. */      public int                         numparameters;      /* [w] Number of parameters used in this filter.  The user finds this with DSP::getNumParameters */     public IntPtr                      paramdesc;          /* [w] Variable number of parameter structures. */     public DSP_SETPARAM_FLOAT_CALLBACK setparameterfloat;  /* [w] This is called when the user calls DSP.setParameterFloat. Can be null. */     public DSP_SETPARAM_INT_CALLBACK   setparameterint;    /* [w] This is called when the user calls DSP.setParameterInt.   Can be null. */     public DSP_SETPARAM_BOOL_CALLBACK  setparameterbool;   /* [w] This is called when the user calls DSP.setParameterBool.  Can be null. */     public DSP_SETPARAM_DATA_CALLBACK  setparameterdata;   /* [w] This is called when the user calls DSP.setParameterData.  Can be null. */     public DSP_GETPARAM_FLOAT_CALLBACK getparameterfloat;  /* [w] This is called when the user calls DSP.getParameterFloat. Can be null. */     public DSP_GETPARAM_INT_CALLBACK   getparameterint;    /* [w] This is called when the user calls DSP.getParameterInt.   Can be null. */     public DSP_GETPARAM_BOOL_CALLBACK  getparameterbool;   /* [w] This is called when the user calls DSP.getParameterBool.  Can be null. */     public DSP_GETPARAM_DATA_CALLBACK  getparameterdata;   /* [w] This is called when the user calls DSP.getParameterData.  Can be null. */     public DSP_SHOULDIPROCESS_CALLBACK shouldiprocess;     /* [w] This is called before processing.  You can detect if inputs are idle and return FMOD_OK to process, or any other error code to avoid processing the effect.  Use a count down timer to allow effect tails to process before idling! */     public IntPtr                      userdata;           /* [w] Optional. Specify 0 to ignore. This is user data to be attached to the DSP unit during creation.  Access via DSP::getUserData. */ } </code></pre>  <p>And here the definition of some of the callbacks, for reference. </p>  <pre><code>public delegate RESULT DSP_CREATECALLBACK           (ref DSP_STATE dsp_state); public delegate RESULT DSP_RELEASECALLBACK          (ref DSP_STATE dsp_state); public delegate RESULT DSP_RESETCALLBACK            (ref DSP_STATE dsp_state); public delegate RESULT DSP_SETPOSITIONCALLBACK      (ref DSP_STATE dsp_state, uint pos); public delegate RESULT DSP_READCALLBACK             (ref DSP_STATE dsp_state, IntPtr inbuffer, IntPtr outbuffer, uint length, int inchannels, ref int outchannels); public delegate RESULT DSP_SHOULDIPROCESS_CALLBACK  (ref DSP_STATE dsp_state, bool inputsidle, uint length, CHANNELMASK inmask, int inchannels, SPEAKERMODE speakermode); public delegate RESULT DSP_PROCESS_CALLBACK         (ref DSP_STATE dsp_state, uint length, ref DSP_BUFFER_ARRAY inbufferarray, ref DSP_BUFFER_ARRAY outbufferarray, bool inputsidle, DSP_PROCESS_OPERATION op); public delegate RESULT DSP_SETPARAM_FLOAT_CALLBACK  (ref DSP_STATE dsp_state, int index, float value); public delegate RESULT DSP_SETPARAM_INT_CALLBACK    (ref DSP_STATE dsp_state, int index, int value); public delegate RESULT DSP_SETPARAM_BOOL_CALLBACK   (ref DSP_STATE dsp_state, int index, bool value); public delegate RESULT DSP_SETPARAM_DATA_CALLBACK   (ref DSP_STATE dsp_state, int index, IntPtr data, uint length); public delegate RESULT DSP_GETPARAM_FLOAT_CALLBACK  (ref DSP_STATE dsp_state, int index, ref float value, IntPtr valuestr); public delegate RESULT DSP_GETPARAM_INT_CALLBACK    (ref DSP_STATE dsp_state, int index, ref int value, IntPtr valuestr); public delegate RESULT DSP_GETPARAM_BOOL_CALLBACK   (ref DSP_STATE dsp_state, int index, ref bool value, IntPtr valuestr); public delegate RESULT DSP_GETPARAM_DATA_CALLBACK   (ref DSP_STATE dsp_state, int index, ref IntPtr data, ref uint length, IntPtr valuestr); </code></pre>