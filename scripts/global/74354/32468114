<p>I have a Many to Many relationship setup like this:</p>  <p>Person &lt;-> PersonField &lt;-> Field</p>  <p>Now I want to query not only all the fields of a Person (I can do that), but a joined version of PersonField with Field of a Person. (I want to query/retrieve the Information in the Pivot/Intermediate Table "PersonField" as well!)</p>  <p>Person:</p>  <pre><code>case class Person(id: Long, name: String) {    def fields =    {        person &lt;- Persons.all.filter(_.id === this.id)        field &lt;- person.fields    } yield field }  class Persons(tag: Tag) extends Table[Person](tag, "persons") {     def id = column[Long]("id", O.PrimaryKey, O.AutoInc)     def name = column[String]("name")      def * = (id, name) &lt;&gt; (Person.tupled, Person.unapply)     def fields = PersonFields.all.filter(_.personID === id).flatMap(_.fieldFK) }  object Persons {     lazy val all = TableQuery[Persons] } </code></pre>  <p>Field:</p>  <pre><code>case class Field(id: Long, name: String, description: Option[String])  class Fields(tag: Tag) extends Table[Field](tag, "fields") {     def id = column[Long]("id", O.PrimaryKey, O.AutoInc)     def name = column[String]("name")     def description = column[Option[String]]("description")      def * = (id, name, description) &lt;&gt; (Field.tupled, Field.unapply) }  object Fields {     lazy val all = TableQuery[Fields] } </code></pre>  <p>PersonField:</p>  <pre><code>case class PersonField(id: Long, personID: Long, fieldID: Long, value: String)  // TODO add constraint to make (personID, fieldID) unique class PersonFields(tag: Tag) extends Table[PersonField](tag, "person_field") {   def id = column[Long]("id", O.PrimaryKey, O.AutoInc)   def personID = column[Long]("person_id")   def fieldID = column[Long]("field_id")   def value = column[String]("value")    def * = (id, personID, fieldID, value) &lt;&gt; (PersonField.tupled, PersonField.unapply)    def personFK = foreignKey("person_fk", personID, Persons.all)(_.id)   def fieldFK = foreignKey("field_fk", fieldID, Fields.all)(_.id) }  object PersonFields {   lazy val all = TableQuery[PersonFields] } </code></pre>  <p>Now to query all the fields of a Person I have a little helper-class:</p>  <pre><code>def getFields(p: Person): Future[Seq[Field]] = {     val query = p.fields     db.run(query.result) } </code></pre>  <p>So I can do</p>  <p>val personX ...</p>  <pre><code>personX.onSuccess {     case p: Person =&gt;     {         val fields = helper.getFields(p)         fields.onSuccess         {             case f: Seq[Field] =&gt; f foreach println          }       } } </code></pre>  <p>Now each field of personX gets printed to the console. Works like a charm.</p>  <p>The thing is, I want to get the PersonField as well (with the Field)!</p>  <p>So I tried the following changes (among others that didn't work, which I can't remember)</p>  <p>In <strong>Person</strong>:</p>  <pre><code>def fields = {     for     {         person &lt;- Persons.all.filter(_.id === this.id)         field &lt;- person.fields join Fields.all on (_.fieldID === _.id)     } yield field } </code></pre>  <p>In <strong>PersonS</strong></p>  <p><code>def fields = PersonFields.all.filter(_.personID === id)</code> // No flatMap here!</p>  <p>then getFields(p: Person) looks like this:</p>  <pre><code>def getFields(p: Person): Future[Seq[(PersonField, Field)]] </code></pre>  <p>but</p>  <pre><code>personX.onSuccess {     case p: Person =&gt;     {         val fields = helper.getFields(p)         fields.onSuccess         {             case f: Seq[(PersonField, Field)] =&gt; f map(f =&gt; println(f._1)}          }       } } </code></pre>  <p>gives me nothing, so I guess my join must be wrong. But what exactly am I doing wrong?</p>