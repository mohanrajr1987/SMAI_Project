<p>Working with example from this page: </p>  <p><a href="https://www.playframework.com/documentation/2.4.x/ScalaOAuth" rel="nofollow">https://www.playframework.com/documentation/2.4.x/ScalaOAuth</a></p>  <p>and suddenly this sort of popped out at me:</p>  <pre><code>  def sessionTokenPair(implicit request: RequestHeader): Option[RequestToken] = {     for {       token &lt;- request.session.get("token")       secret &lt;- request.session.get("secret")     } yield {       RequestToken(token, secret)     }   } </code></pre>  <p>As I understood a generator (for comprehension) the second entry was based on the results of the first generator. </p>  <p>e.g.: <code>secret &lt;- request.session.get("secret")</code> would have come from something out of <code>token &lt;- request.session.get("token")</code> </p>  <p>Yet clearly when you look at what the outcome is <code>RequestToken(token, secret)</code> that would not be the case. </p>  <p>How/why is this construct superior to simply doing: </p>  <pre><code>RequestToken(request.session.get("token"), request.session.get("secret")) </code></pre>  <p>Ah - I think i might be answering this myself as I ask the question (but it still doesn't explain the "equalness?" of the two lines versus one line leading to the next...)</p>  <p>The output of this is an <code>Option</code> as it comes from a mapping process whereas if we jumped directly in the constructor we have no way to deal with a <code>None</code> situation. </p>  <p>So can anyone clarify why this works if <code>secret</code> is NOT related to the generator for <code>token</code>? </p>