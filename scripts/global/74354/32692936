<p>In my project(play 2.4 with slick 3.0), I have a setup: using MySQL for production and H2 for unit testing(start to feel that it is a horrible idea). To do that, I have to import <code>slick.driver.JdbcProfile</code> instead of any specific driver (e.g. <code>slick.driver.MySQLDriver</code>) and import its <code>api._</code> in my DAO class, like this:</p>  <pre><code>class SomeDAO(val context: MyContext){   import context.profile.api._   import context.SOME_TYPE    def invoke(para: SOME_TYPE) = { ... }    // other DBIO...  } </code></pre>  <p>Everything is OK so far, however, I have a service class that requires this DAO, and a type in context as a parameter:</p>  <pre><code>class MyService(val context: MyContext){     val someDAO = new SomeDAO(context)    import someDAO.context.SOME_TYPE  // it works    // import context.SOME_TYPE   // Type mismatch! But how to avoid it???     def invokeDAOMethod(para: SOME_TYPE) = someDAO.invoke(para) // where mismatch occurred    // expect: MyService.this.someDao.context.SOME_TYPE    // actual: MyService.this.context.SOME_TYPE  } </code></pre>  <p>Problem heppens when I try to import a type from exact the same <code>context</code> instance, intuitively speaking, I'm using the "<strong>Same</strong>" type here, right?</p>  <p>Can someone explain this kind of behaviour and give hint about patterns to cut this kind of 'non-sense' I wrote?</p>