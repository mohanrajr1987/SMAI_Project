<p>I am deleting a row from a UITableView that receives its information from CoreData. Currently, I have it figured out to where it can remove the CoreData info, but it's not wiping out the row in the UITableView. Most methods I've employed have resulted in crashes. Here is the raw code (credit: blog.revivalx.com)</p>  <pre><code>var peopleArray: NSMutableArray = [People]() //People is CoreData entity  @IBOutlet weak var contactTable: UITableView!  let appDel: AppDelegate = (UIApplication.sharedApplication().delegate as! AppDelegate)             let context: NSManagedObjectContext = appDel.managedObjectContext!             context.deleteObject(peopleArray[indexPath.row] as! NSManagedObject)             peopleArray.removeAtIndex(indexPath.row)             context.save(nil) </code></pre>  <p>I've tried inserting:</p>  <pre><code>contactTable.deleteRowsAtIndexPaths([indexPath.row ], withRowAnimation: UITableViewRowAnimation.Automatic) </code></pre>  <p>into this code and have been met with errors. A plethora of sources have not turned up an answer for me on how to perform both removals simultaneously. </p>  <p>How do I remove the row from the UITableView and it's corresponding entry in CoreData at the same time in Swift?</p>  <p>Thanks</p>  <p>Edit:</p>  <p>Here is the function in its entirety:</p>  <pre><code>func tableView(tableView: UITableView, commitEditingStyle editingStyle: UITableViewCellEditingStyle, forRowAtIndexPath indexPath: NSIndexPath) {     if editingStyle == UITableViewCellEditingStyle.Delete {      let appDel: AppDelegate = (UIApplication.sharedApplication().delegate as! AppDelegate)     let context: NSManagedObjectContext = appDel.managedObjectContext!      context.deleteObject(peopleArray[indexPath.row] as NSManagedObject)     peopleArray.removeAtIndex(indexPath.row)      contactTable.deleteRowsAtIndexPaths([indexPath], withRowAnimation: UITableViewRowAnimation.Automatic)     context.save(nil)     contactTable.reloadData() } } </code></pre>