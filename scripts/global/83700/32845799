<p>When we load a Laravel Eloquent model with it's relations, like this:</p>  <pre><code>$user = User::with('Interest')-&gt;find(1); </code></pre>  <p>It queries MySQL as follows:</p>  <pre><code>100 Prepare   select * from `users` where `users`.`id` = ? limit 1 100 Execute   select * from `users` where `users`.`id` = '1' limit 1 100 Close stmt         100 Prepare   select `interest_id`, `user_interests`.`user_id` as `pivot_user_id`, `user_interests`.`interest_id` as `pivot_interest_id` from `interests` inner join `user_interests` on `interests`.`id` = `user_interests`.`interest_id` where `user_interests`.`user_id` in (?) 100 Execute   select `interest_id`, `user_interests`.`user_id` as `pivot_user_id`, `user_interests`.`interest_id` as `pivot_interest_id` from `interests` inner join `user_interests` on `interests`.`id` = `user_interests`.`interest_id` where `user_interests`.`user_id` in ('1') 100 Close stmt  100 Quit </code></pre>  <p>On the next line I want to access the loaded <code>Interest</code> model, which in my opinion was already eager-loaded by the <code>::with</code> statement. However when I try to access the <code>interest_id</code> like so:</p>  <pre><code>$user-&gt;interest-&gt;interest_id; </code></pre>  <p>I see another database lookup appear in MySQL query logging accessing the same already pre-loaded relation:</p>  <pre><code>100 Prepare   select `interest_id`, `user_interests`.`user_id` as `pivot_user_id`, `user_interests`.`interest_id` as `pivot_interest_id` from `interests` inner join `user_interests` on `interests`.`id` = `user_interests`.`interest_id` where `user_interests`.`user_id` = ? 100 Execute   select `interest_id`, `user_interests`.`user_id` as `pivot_user_id`, `user_interests`.`interest_id` as `pivot_interest_id` from `interests` inner join `user_interests` on `interests`.`id` = `user_interests`.`interest_id` where `user_interests`.`user_id` = '1' 100 Close stmt         100 Quit </code></pre>  <p>I expected Laravel to provide me with the already loaded relation, but instead it queried MySQL again. I saw that when I use <code>getRelation('Interest')</code>, that it does return the relation already loaded on the <code>User::with('Interest')</code> and not query MySQL again, like so:</p>  <pre><code>$user-&gt;getRelation("Interest")-&gt;interest_id; </code></pre>  <p>I was wondering if this is the way to go and if my expectations of eager-loading with <code>::with</code> are completely wrong? Or maybe there are other best practices to access the preloaded relations instead of quering MySQL again. It seems to me that querying the database several times for the same information is more expensive.</p>  <p><strong>User Model</strong></p>  <pre><code>&lt;?php namespace App\Models;  use Illuminate\Auth\Authenticatable; use Illuminate\Database\Eloquent\Model; use Illuminate\Auth\Passwords\CanResetPassword; use Illuminate\Contracts\Auth\Authenticatable as AuthenticatableContract; use Illuminate\Contracts\Auth\CanResetPassword as CanResetPasswordContract; use App\Models;  class User extends Model implements AuthenticatableContract, CanResetPasswordContract {      use Authenticatable, CanResetPassword;      protected $table = 'users';      protected $fillable = ['name', 'email', 'password'];      protected $hidden = ['password', 'remember_token', 'created_at', 'updated_at'];      public function Interest()     {         return $this-&gt;belongsToMany('App\Models\Interest', 'user_interests', 'user_id', 'interest_id')-&gt;select(array('interest_id'));     }  } </code></pre>  <p><strong>Interest Model</strong></p>  <pre><code>&lt;?php namespace App\Models;  use Illuminate\Database\Eloquent\Model;  class Interest extends Model {     protected $table = 'interests';      protected $fillable = ['description', 'parent_id'];      protected $hidden = ['created_at', 'updated_at'];  }     </code></pre>