<p>I tried to solve the problem below by Python programming:</p>  <blockquote>   <p><a href="http://i.stack.imgur.com/TK8zK.png" rel="nofollow"><img src="http://i.stack.imgur.com/TK8zK.png" alt="enter image description here"></a></p> </blockquote>  <p>But just generating a single valid table makes me stuck. I was expecting the program to display a valid matrix, but in <code>getPossibleMatrix</code> a <code>MemoryError</code> appeared. I couldn't figure out the source of this error. Line #77 should be fixed, but how?</p>  <p>My code:</p>  <pre><code>from pprint import pprint import sys  sys.setrecursionlimit(10000)  def isValidMatrix(matrix):     '''Checks if a matrix is valid as an answer.'''     # see if each row contains 1 thru 6     rows=[[matrix[y][x] for x in range(5)]           for y in range(5)] # lists of x-axises      for row in rows:         row.sort()         if not (row == [1,2,3,4,5,6]):             return False # stop checking for the last one if it's already      false!!      # see if each column contains 1 thru 6     columns=[[matrix[x][y] for y in range(5)]              for x in range(5)] # lists of y-axises      for col in columns:         col.sort()         if not (col == [1,2,3,4,5,6]):             return False # stop checking for the last one if it's already false!!     return True  def getPossiblesForSquare(sqx,sqy,matrix):     '''Gets the possible entries of matrix[sqy][sqx]. Assumes it equals 0.'''     assert matrix[sqy][sqx]==0     # get the row that it is on     rowon=matrix[sqy]     # columns are a little trickier     colon=[matrix[row][sqx] for row in range(5)]      # find the possibilities!     possibles=list(range(1,6))      for item in list(set(rowon+colon)): # remove duplicates         if not (item == 0) and (item in possibles):             del possibles[possibles.index(item)]      return possibles  def getPossiblesForMatrix(matrix):     '''Gets all the possible squares for a matrix.'''     possiblesdict={}     for y in range(6):         for x in range(6):             if matrix[y][x]==0:                 possiblesdict[(y,x)]=getPossiblesForSquare(x,y,MATRIX)     return possiblesdict  def flattenList(matrix):     result=[]     for i in matrix:         if not isinstance(i,list):             result+=[i]         else:             result+=flattenList(i)     return result  def getPossibleMatrix(startMatrix):     if 0 not in flattenList(startMatrix):         return startMatrix     else:         # find&amp;fill in the first blank one         ind=flattenList(startMatrix).index(0)         y=ind//6         x=ind%6         possibles=getPossiblesForSquare(x,y,startMatrix)         if len(possibles)==0:             startMatrix[y][x]=0         else:             startMatrix[y][x]=possibles[0]         return getPossibleMatrix(startMatrix) # &lt;&lt;BUG   MATRIX=[[1,2,3,4,5,6],         [2,0,0,0,0,5],         [3,0,0,0,0,4],         [4,0,0,0,0,3],         [5,0,0,0,0,2],         [6,5,4,3,2,1]]  result=getPossibleMatrix(MATRIX) pprint(result) </code></pre>