<p>I have a pandas DataFrame like the following:</p>  <pre><code>df = pandas.DataFrame({'A' : ['foo', 'foo', 'foo', 'foo', 'bar', 'bar', \                                'bar', 'bar', 'baz', 'baz', 'baz', 'baz'],\                         'B' : ['one', 'one', 'two', 'two', 'one', 'one', \                                'two', 'two', 'one', 'one', 'two', 'two'],\                         'C' : pandas.np.random.randn(12)})  df      A    B         C 0   foo  one -0.241101 1   foo  one -0.658436 2   foo  two  0.300752 3   foo  two -0.589445 4   bar  one  1.775511 5   bar  one  0.068603 6   bar  two -0.464550 7   bar  two -0.621055 8   baz  one -1.469311 9   baz  one  0.490963 10  baz  two -0.606491 11  baz  two -0.006323 </code></pre>  <p>What I want to do is to filter those values in C which are smaller than the mean of the group (A,B). </p>  <p>The grouping works:</p>  <pre><code>groups = df.groupby([df.A, df.B]) upper_bound = groups.C.mean() upper_bound  A    B   bar  one    0.922057      two   -0.542803 baz  one   -0.489174      two   -0.306407 foo  one   -0.449768      two   -0.144346 Name: C, dtype: float64 </code></pre>  <p>But how do I filter now so that (in this example) row <code>1   foo  one -0.658436</code> would be removed</p>  <p>I tried the following things:</p>  <pre><code>df_ = df.loc[df.C &lt;= upper_bound.loc[df.A, df.B]] </code></pre>  <p>But that says</p>  <pre><code>'None of [0     foo\n1     foo\n2     foo\n3     foo\n4     bar\n5     bar\n6     bar\n7     bar\n8     baz\n9     baz\n10    baz\n11    baz\nName: A, dtype: object] are in the [index]' </code></pre>  <p>And I tried:</p>  <pre><code>df_ = df.loc[df.C &lt;= upper_bound[df.A, df.B]] </code></pre>  <p>and that gives me:</p>  <pre><code>pandas/index.pyx in pandas.index.IndexEngine.get_loc (pandas/index.c:3824)() pandas/index.pyx in pandas.index.IndexEngine.get_loc (pandas/index.c:3492)() TypeError:  </code></pre>  <p>The reason I am trying it this way is because I already (at least I think that) managed to do the 'same' thing but with one-level groups:</p>  <pre><code>groups = df.groupby([df.A]) upper_bound = groups.C.mean() df_ = df.loc[df.C &lt;= upper_bound.loc[df.A] </code></pre>  <p>And that actually gets rid of everyhing in df where C is below upper_bound.</p>  <p>Any ideas in what I am doing wrong?</p>