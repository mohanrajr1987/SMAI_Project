<p>Here is an excerpt of my domain model, the text version of which is "I have Contracts, Clients, Clients on Contracts, and Invoices.  Invoices can either be linked directly to a Client, or to a Contract". </p>  <pre><code>&lt;class name="Invoice"&gt;   &lt;many-to-one class="Contract" /&gt;   &lt;many-to-one class="Client" /&gt; &lt;/class&gt;  &lt;class name="Contract"&gt;   &lt;set table="ContractClient" fetch="select" lazy="true"&gt;     &lt;one-to-many class="ContractClient" /&gt;   &lt;/set&gt; &lt;/class&gt;  &lt;class name="ContractClient"&gt;   &lt;many-to-one class="Contract" fetch="select" /&gt;   &lt;many-to-one class="Client" cascade="none" fetch="select" /&gt; &lt;/class&gt;  &lt;class name="Client"&gt;   &lt;set table="ContractClient" fetch="select" lazy="true"&gt;     &lt;one-to-many class="ContractClient" /&gt;   &lt;/set&gt; &lt;/class&gt; </code></pre>  <p>I am interested in obtaining the list of Invoices belonging to a Client, including both the directly linked Invoices, and those on Contracts on which the Client is a party.   I have the following (which works): </p>  <pre><code>return getCurrentSession().createCriteria(Invoice.class)     .createAlias("contract", "contract", JoinType.LEFT_OUTER_JOIN)     .createAlias("contract.contractClients", "contractClient", JoinType.LEFT_OUTER_JOIN)     .add(Restrictions.or(         Restrictions.eq("client.id", id),         Restrictions.eq("contractClient.client.id", id)))     .setResultTransformer(Criteria.DISTINCT_ROOT_ENTITY)     .list(); } </code></pre>  <p>However, there's big performance issues with the generated SQL, as (not shown) Contract has a number of 1:1 tables and lots of fetch=join lookups. Also, the OR sort of kills it.  So, I'm already taking the approach of separate queries for the two types (Invoices directly linked to Clients, and Invoices linked to Clients through the Contract).  I'm having trouble coming up with the second piece. </p>  <p>I'd like to avoid joining through Contract because of the explosion in JOINS and selected columns. If I were writing this in SQL myself, I'd use:  </p>  <pre><code>SELECT      * FROM     Invoice i         LEFT OUTER JOIN ContractClient c ON i.contractId=c.contractId  WHERE      c.clientId=? </code></pre>  <p>But, I don't have a Hibernate mapping between Invoice and ContractClient, so I either have to go through Contract (which I don't want), or do this (which produces a sub-select): </p>  <pre><code>DetachedCriteria detachedCriteria = DetachedCriteria.forClass(ContractClient.class)     .add(Restrictions.eq("client.id", id))     .setProjection(Projections.property("contract")); return getCurrentSession().createCriteria(Invoice.class)     .add(Property.forName("contract").in(detachedCriteria))     .list(); </code></pre>  <p>producing: </p>  <pre><code>SELECT     * FROM     Invoice this_  WHERE     this_.contractId IN (   SELECT                             this_.contractId AS y0_                          FROM                             ContractClient this_                          WHERE                             this_.contractClientId=?) </code></pre>  <p>Is there a way to get Hibernate to generate the more direct JOIN? </p>