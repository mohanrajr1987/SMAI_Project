<p>Apologies for the <em>really</em> long title!</p>  <p>I am really having an issue with my project establishing a connection to the hub if there are a number of methods attached to them (20+).  Example of the timings:</p>  <pre><code>[20:44:06 GMT+0100 (GMT Daylight Time)] SignalR: serverSentEvents transport connected. Initiating start request.  [20:44:09 GMT+0100 (GMT Daylight Time)] SignalR: The start request    succeeded. Transitioning to the connected state </code></pre>  <p>Here is what I have tried</p>  <ul> <li>Checked dependencies on hubs to make sure they are not holding it up</li> <li>Created a test hub with dependencies from another hub  <ul> <li>Ensured that methods were called from all the dependencies but within the one method</li> </ul></li> <li>Dev machine is Windows 7 so Websockets isn't available to me and the server it will be deployed to is 2008 R2 (which I think doesn't support websockets) but I have tried different variations of the transport to see if I can improve performance in anyway but ultimately concluded that I would leave it down to the SignalR client to deal with</li> <li>Proxy file is about 160kb</li> </ul>  <p>The next step for me is to try and break down the hubs to see if this improves how it performs but wondered if anyone else has any ideas on how I can avoid doing this?  Is SignalR not designed to work in this way? Let me know if you need me to clarify any points</p>  <p>Thanks, Matt</p>  <p>Edit:</p>  <p>It doesn't appear to be down to the number of methods as I initially thought.</p>  <p>I use a <code>for</code> look to add a knockout viewmodel to the bindings when an element (by ID) exists:</p>  <pre><code>for (var i = 0; i &lt; arguments.length; i++) {     var viewModel = new arguments[i](connection);     var element = elements[i];     console.info("ViewModel: " + viewModel.constructor.name);     ko.applyBindings(viewModel, element);     viewModels.push(viewModel); } </code></pre>  <p>Once the connection has been established, I then call a 'constructor' method <code>init()</code></p>  <pre><code>connection.start().done(function () {     for (var j = 0; j &lt; viewModels.length; j++) {         console.info("Starting ViewModel: " + viewModels[j].constructor.name);         if (viewModels[j].init != undefined) {             setTimeout(viewModels[j].init(), 0);             //viewModels[j].init()         }     } }); </code></pre>  <p>As the number of ViewModels increase, so does the connect time...</p>