<p>I would like to parse a string with a given map values (e.g </p>  <pre><code>val m = Map("foo" -&gt; StringConstant("\"FOO\""),"bar" -&gt; StringConstant("\"BAR\"")) </code></pre>  <p>The problem is the escape characters . since I am getting this map from external source as a parameter I cannot enforce that the value will be written like </p>  <blockquote>   <p>"\"FOO\" and not "FOO"</p> </blockquote>  <p><strong>. is there anyway to do it ?</strong></p>  <p>this is my code (simply )</p>  <pre><code>import scala.util.parsing.combinator.{JavaTokenParsers, PackratParsers}  sealed abstract class AST sealed abstract class BooleanExpression extends AST sealed abstract class Constant extends AST case class BooleanOperation(op: String, lhs: BooleanExpression, rhs:BooleanExpression) extends BooleanExpression case class LRComparison[T &lt;: Constant](lhs:T, op:String, rhs:T) extends BooleanExpression case class StringConstant(value: String) extends Constant case class Variable(name: String) extends Constant {   def eval(env: Map[String, Constant]) = env(name)   override def toString = name  }  object ConditionParser extends JavaTokenParsers with PackratParsers {   val comparisonOperator : PackratParser[String] = literal("==") | literal("!=")   val variable = ident ^^ {s=&gt;Variable(s)}   val constant : PackratParser[Constant] =  stringLiteral ^^ StringConstant   val comparison : PackratParser[BooleanExpression] =  (variable ~ comparisonOperator ~ constant) ^^ { case lhs ~ op ~ rhs =&gt; LRComparison(lhs, op, rhs) }   lazy val p1 : PackratParser[BooleanExpression] = comparison }  object Evaluator {   val m = Map("foo" -&gt; StringConstant("\"FOO\""),"bar" -&gt; StringConstant("\"BAR\""))   def evaluate(expression:BooleanExpression) : Boolean = expression match {     case LRComparison(v:Variable, "==", StringConstant(r)) =&gt;  v.eval(m) match{       case StringConstant(l) =&gt; l == r       case _ =&gt; false     }       case LRComparison(v:Variable, "!=", StringConstant(r)) =&gt;  v.eval(m) match{       case StringConstant(l) =&gt; l != r       case _ =&gt; false     }     } }  object Test1 extends App {   def parse(text:String) :Option[BooleanExpression] = {     import ConditionParser.{Error,Success,Failure}     val res = ConditionParser.parseAll(ConditionParser.p1, text)     res match {       case Success(r, n) =&gt; Some(r)       case Failure(msg, n) =&gt;         println("Failure"+msg)         None        case Error(msg, n) =&gt;         println("Error"+msg)         None      }   }    val p = parse(" foo == \"FOO\" ").map(Evaluator.evaluate)   println("p2 = "+p.get)//true   } </code></pre>