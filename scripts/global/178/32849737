<p>I'm currently writing an android app which consists of ... an alarm manager. The alarm is started - via an AlarmManager - as a background service and loops a sound by using a "SoundPool". Everything works fine, even if the background service was stopped or when the app is closed.</p>  <p>But one combination of actions in one fixed order, the SoundPool crashes and stops playing the sound:</p>  <ul> <li>start the alarm manager</li> <li>wait until alarm is playing</li> <li>stop alarm manager</li> <li>exit application</li> </ul>  <p>In only this exact order, the error occurs.</p>  <p>I don't know exactly, where the problem is located, but I guess that there is a problem with the Context!</p>  <p>Here are the relevant code parts (simplified version):</p>  <p>(class MyAlarmManager extends Service ...)</p>  <pre><code>// Starts the background service "MyAlarmManager" via the AlarmManager static void start( final Context context ) {     new Thread( new Runnable()     {         @Override         public void run()         {             final Intent intent = new Intent( context, MyAlarmManager.class );             final PendingIntent operation = PendingIntent.getService( context, 0, intent, 0 );              // the last part is just for debugging purposes             final long interval = Integer.parseInt( getInterval( context ) ) * ( BuildConfig.DEBUG ? 1000L : 60000L );              final Calendar calendar = Calendar.getInstance();             calendar.setTimeInMillis( System.currentTimeMillis() + interval );              getAlarmManager( context ).setRepeating( AlarmManager.RTC_WAKEUP, calendar.getTimeInMillis(), interval, operation );             MyAlarmManager.operation = operation;             setActive( context, true );         }     } ).start(); }  // Stops the background service "MyAlarmManager" via the AlarmManager static void stop( final Context context ) {     getAlarmManager( context ).cancel( operation );     setActive( context, false ); }  @Override public void onCreate() {     super.onCreate();      if ( soundManager == null )     {         soundManager = new SoundManager( this, 1, AudioManager.STREAM_ALARM );         soundManager.load( SOUND, R.raw.sound );     } else     {         soundManager.setContext( this );     } }  @Override public int onStartCommand( final Intent intent, final int flags, final int startId ) {     if ( !isActive( this ) )     {         stopSelf();         return START_NOT_STICKY;     }      if ( hasScheduleBegun( this ) &amp;&amp; !isScheduleOver( this ) )     {         setAlarmActive( true );         // plays the alarm sound SOUND with volume 2f in a loop         soundManager.play( SOUND, 2f, true );     }      stopSelf();     return START_STICKY; } </code></pre>  <p>So how can I make the SoundPool work, even if one executes the mentioned steps and what is actually the problem?</p>  <p>PS. No, MyAlarmManager doesn't extend AlarmManager, it's a service!</p>