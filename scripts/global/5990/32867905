<pre><code># init libs &lt;- c("tm", "plyr", "class", "RTextTools", "randomForest") lapply(libs, require, character.only = TRUE)  # set options options(stringsAsFactors = FALSE)  # set parameters labels &lt;- read.table('labels.txt') path &lt;- paste(getwd(), "/data", sep="")  # clean text cleanCorpus &lt;- function(corpus) {   corpus.tmp &lt;- tm_map(corpus, removePunctuation)   corpus.tmp &lt;- tm_map(corpus.tmp, removeNumbers)   corpus.tmp &lt;- tm_map(corpus.tmp, stripWhitespace)   corpus.tmp &lt;- tm_map(corpus.tmp, content_transformer(tolower))   corpus.tmp &lt;- tm_map(corpus.tmp, stemDocument, language = "english")   corpus.tmp &lt;- tm_map(corpus.tmp, removeWords, stopwords("english"))   corpus.tmp &lt;- tm_map(corpus.tmp, function(x) iconv(x, "latin1", "ASCII", sub=""))   corpus.tmp &lt;- tm_map(corpus.tmp, PlainTextDocument)   return(corpus.tmp) }  # build TDM generateTDM &lt;- function(label, path) {   s.dir &lt;- sprintf("%s/%s", path, label)   s.cor &lt;- Corpus(DirSource(directory = s.dir), readerControl = list(language = "en"))   s.cor.cl &lt;- cleanCorpus(s.cor)   s.tdm &lt;- TermDocumentMatrix(s.cor.cl)   s.tdm &lt;- removeSparseTerms(s.tdm, 0.7)   return(list(name = label, tdm = s.tdm)) }  tdm &lt;- lapply(labels, generateTDM, path = path)  # attach name bindLabelToTDM &lt;- function(tdm) {   s.mat &lt;- t(data.matrix(tdm[["tdm"]]))   s.df &lt;- as.data.frame(s.mat, stringsAsFactors = FALSE)   s.df &lt;- cbind(s.df, rep(tdm[["name"]], nrow(s.df)), row.names = NULL)   colnames(s.df)[ncol(s.df)] &lt;- "targetlabel"   return(s.df)  }  labelTDM &lt;- lapply(tdm, bindLabelToTDM)  # stack tdm.stack &lt;- do.call(rbind.fill, labelTDM) tdm.stack[is.na(tdm.stack)] &lt;- 0  # hold-out train.idx &lt;- sample(nrow(tdm.stack), ceiling(nrow(tdm.stack) * 0.7)) test.idx &lt;- (1:nrow(tdm.stack)) [- train.idx]  tdm.lab &lt;- tdm.stack[, "targetlabel"] tdm.stack.nl &lt;- tdm.stack[, !colnames(tdm.stack) %in% "targetlabel"]  train &lt;- tdm.stack[train.idx, ] test &lt;- tdm.stack[test.idx, ]  train$targetlabel &lt;- as.factor(train$targetlabel) label.rf &lt;- randomForest(targetlabel ~ ., data = train, ntree = 5000, mtry = 15, importance = TRUE) </code></pre>  <p>I am trying multi class classfication for text files using randomForest algorithms. I have 212 text files distributed in the directories inside /data. These directories are named as the class values.  The error I get is probably because of the last line.</p>  <pre><code>Error in model.frame.default(terms(reformulate(attributes(Terms)$term.labels)),  :        invalid type (special) for variable 'function' </code></pre>  <p>tdm.stack contains columns with names as words found in the document and their cell values as their frequency. The last column contains the class value.</p>  <p>I was getting another error earlier <a href="http://stackoverflow.com/questions/32864307/randomforest-in-r-object-not-found-error">randomForest in R object not found error</a> but that got solved after I added code to remove to remove non-ASCII characters in the clean corpus function. But now this error comes up.</p>  <p>I have tried everything I cant figure out the problem. Please help</p>  <p>This is the output of str(train)</p>  <pre><code>str(train) 'data.frame':   4611 obs. of  689 variables:  $ abl         : num  10 0 1 3 0 6 10 1 0 0 ...  $ abov        : num  1 1 1 1 3 3 3 2 4 2 ...  $ abstract    : num  1 1 1 0 1 1 1 0 1 10 ...  $ accept      : num  0 0 1 3 10 0 1 0 0 0 ...  $ access      : num  16 26 0 3 0 7 0 0 0 21 ...  $ accord      : num  0 1 1 6 9 1 7 4 0 1 ...  $ account     : num  1 0 0 3 1 3 3 1 0 0 ...  $ accur       : num  0 0 5 0 0 2 3 2 0 0 ...  $ achiev      : num  0 7 10 13 2 8 12 1 0 1 ...  $ acknowledg  : num  0 0 0 0 1 0 2 0 0 0 ...  $ acm         : num  9 8 0 1 1 2 3 0 0 7 ...  $ across      : num  0 1 0 1 0 13 0 0 0 3 ...  $ action      : num  1 0 0 0 0 1 2 0 0 1 ...  $ activ       : num  4 9 8 13 0 2 3 0 0 0 ...  $ actual      : num  5 0 0 1 0 0 18 2 0 1 ...  $ adapt       : num  0 5 0 2 1 0 2 0 0 2 ...  $ add         : num  1 8 1 0 0 6 0 2 2 1 ...  $ addit       : num  6 8 3 1 1 9 12 3 1 2 ...  $ address     : num  2 2 5 5 0 2 5 1 0 3 ...  $ adopt       : num  0 1 2 0 0 4 4 1 0 0 ...  $ advanc      : num  0 1 0 0 1 2 1 1 0 0 ...  $ advantag    : num  2 0 3 0 0 2 1 0 0 0 ...  $ affect      : num  0 1 1 3 0 1 14 0 0 0 ...  $ aim         : num  0 3 1 5 1 5 0 1 0 2 ...  $ algorithm   : num  1 27 0 34 2 35 49 24 2 0 ...  $ allow       : num  1 2 4 2 5 4 9 0 0 8 ...  $ almost      : num  0 1 0 0 0 0 2 0 0 0 ...  $ along       : num  0 0 0 0 1 4 2 1 2 0 ...  $ alreadi     : num  3 3 0 1 0 4 2 0 0 1 ...  $ also        : num  13 12 16 2 23 16 20 0 7 5 ...  $ altern      : num  1 0 0 0 2 4 2 0 0 0 ...  $ although    : num  2 0 5 1 2 3 3 0 0 0 ...  $ alway       : num  1 2 0 1 0 2 1 0 4 1 ...  $ among       : num  0 0 1 2 1 2 4 1 4 1 ...  $ amount      : num  1 0 0 0 3 2 20 1 0 0 ...  $ analysi     : num  0 1 2 4 0 12 14 4 0 0 ...  $ analyz      : num  2 1 0 1 0 4 4 1 0 0 ...  $ ani         : num  5 4 8 4 9 12 10 1 9 6 ...  $ anoth       : num  3 12 2 0 12 2 4 2 0 1 ...  $ answer      : num  0 0 0 0 0 0 3 0 0 0 ...  $ appear      : num  0 2 7 1 1 1 6 0 0 0 ...  $ appli       : num  6 2 4 3 1 8 5 2 2 3 ...  $ applic      : num  3 14 0 0 1 0 17 3 4 33 ...  $ approach    : num  5 1 23 8 2 20 2 2 0 12 ...  $ appropri    : num  0 1 1 0 0 0 2 0 0 0 ...  $ approxim    : num  0 0 5 1 0 3 2 1 0 0 ...  $ arbitrari   : num  1 0 0 1 1 0 0 0 0 0 ...  $ architectur : num  20 4 10 1 0 0 4 0 0 5 ...  $ area        : num  1 2 0 4 0 0 5 43 0 3 ...  $ around      : num  0 1 2 1 0 1 6 1 0 0 ...  $ arxivv      : num  1 1 1 0 1 1 1 0 1 0 ...  $ aspect      : num  1 0 2 0 2 2 4 0 0 0 ...  $ assign      : num  0 0 8 0 2 0 0 0 0 1 ...  $ associ      : num  1 1 2 6 2 6 3 0 0 14 ...  $ assum       : num  5 0 2 2 11 8 17 0 4 0 ...  $ assumpt     : num  0 0 0 0 2 3 1 1 0 0 ...  $ attempt     : num  0 0 0 0 0 0 4 0 0 2 ...  $ author      : num  3 0 1 3 1 0 1 4 1 1 ...  $ autom       : num  0 1 0 0 0 0 1 1 0 0 ...  $ automat     : num  1 8 0 0 0 0 1 0 0 0 ...  $ avail       : num  0 0 4 2 0 9 7 0 0 1 ...  $ averag      : num  0 24 4 9 0 12 7 0 0 4 ...  $ avoid       : num  0 1 0 0 0 1 3 0 0 0 ...  $ back        : num  0 0 0 0 0 0 3 0 0 0 ...  $ background  : num  2 0 0 0 0 1 2 0 0 0 ...  $ base        : num  16 16 6 14 3 11 34 10 0 5 ...  $ basic       : num  2 2 0 0 1 4 5 0 0 1 ...  $ becaus      : num  4 14 2 4 2 1 11 0 0 1 ...  $ becom       : num  0 1 0 2 0 3 8 1 0 0 ...  $ befor       : num  1 3 0 0 0 3 3 1 0 1 ...  $ begin       : num  0 2 0 0 0 0 2 0 0 0 ...  $ behavior    : num  3 6 0 1 1 1 3 0 0 3 ...  $ believ      : num  0 1 3 0 0 0 0 0 0 0 ...  $ belong      : num  0 2 2 3 2 3 0 0 0 0 ...  $ benefit     : num  1 3 1 0 1 9 1 0 0 1 ...  $ best        : num  0 4 1 0 2 4 5 1 0 1 ...  $ better      : num  1 6 4 1 3 1 7 0 0 1 ...  $ binari      : num  0 0 0 0 0 0 1 0 0 0 ...  $ block       : num  12 1 0 0 19 1 0 0 0 0 ...  $ bound       : num  0 0 1 0 0 1 1 0 0 0 ...  $ build       : num  0 4 1 0 1 46 5 0 0 1 ...  $ calcul      : num  3 0 0 3 0 7 13 7 0 0 ...  $ call        : num  1 9 1 5 0 1 9 0 7 1 ...  $ can         : num  21 32 29 15 39 58 88 17 9 19 ...  $ capabl      : num  2 0 1 0 0 3 2 0 0 17 ...  $ captur      : num  0 6 3 0 1 0 11 0 0 0 ...  $ case        : num  11 5 17 5 17 38 27 3 1 2 ...  $ caus        : num  0 2 0 0 0 0 19 0 0 0 ...  $ center      : num  0 0 0 0 0 0 3 0 0 0 ...  $ certain     : num  1 2 0 0 1 4 4 1 1 5 ...  $ challeng    : num  0 0 1 0 0 0 3 0 0 1 ...  $ chang       : num  0 4 2 3 1 5 32 1 1 3 ...  $ character   : num  0 2 0 0 0 1 0 2 0 1 ...  $ characterist: num  0 4 0 0 1 0 5 2 0 0 ...  $ check       : num  0 5 0 1 7 0 4 0 0 0 ...  $ chen        : num  0 3 1 0 0 0 2 2 0 0 ...  $ choic       : num  0 0 2 4 2 9 0 0 0 0 ...  $ choos       : num  0 1 5 0 0 3 2 0 0 0 ...  $ chosen      : num  0 0 0 0 0 6 0 0 0 0 ...   [list output truncated] </code></pre>