<p>I have an ImageView and a surfaceView in my Activity. I want to move (drag) and resize the imageView using multi-touch. So, this is the touchListener class:</p>  <pre><code>private final class MyTouchListener implements View.OnTouchListener {       private static final int NONE = 0;     private static final int DRAG = 1;     private static final int ZOOM = 2;      private static final float MIN_ZOOM = 0.5f;     private static final float MAX_ZOOM = 5f;      private Matrix matrix;     private Matrix savedMatrix = new Matrix();      private PointF start = new PointF();     private PointF mid = new PointF();      private int mode = NONE;     private float oldDistance = 1f;      private float dx; // postTranslate X distance     private float dy; // postTranslate Y distance     private float[] matrixValues = new float[9];     float matrixX = 0; // X coordinate of matrix inside the ImageView     float matrixY = 0; // Y coordinate of matrix inside the ImageView     float width = 0; // width of drawable     float height = 0; // height of drawable     private MyTouchListener (Matrix m){         this.matrix = m;     }     public boolean onTouch(View view, MotionEvent event) {         ImageView imageView = (ImageView)view;          switch(event.getAction() &amp; MotionEvent.ACTION_MASK) {              case MotionEvent.ACTION_DOWN:                 savedMatrix.set(matrix);                 start.set(event.getX(), event.getY());                 mode = DRAG;                 break;              case MotionEvent.ACTION_POINTER_DOWN:                 oldDistance = spacing(event);                 if(oldDistance &gt; 10f) {                     savedMatrix.set(matrix);                     midPoint(mid, event);                     mode = ZOOM;                 }                  break;              case MotionEvent.ACTION_UP:             case MotionEvent.ACTION_POINTER_UP:                 mode = NONE;                 break;              case MotionEvent.ACTION_MOVE:                 if(mode == DRAG) {                     matrix.set(savedMatrix);                     matrix.getValues(matrixValues);                     matrixX = matrixValues[2];                     matrixY = matrixValues[5];                     width = matrixValues[0] * (((ImageView) view).getDrawable()                             .getIntrinsicWidth());                     height = matrixValues[4] * (((ImageView) view).getDrawable()                             .getIntrinsicHeight());                      dx = event.getX() - start.x;                     dy = event.getY() - start.y;                      //if image will go outside left bound                     if (matrixX + dx &lt; 0){                         dx = -matrixX;                     }                     //if image will go outside right bound                     if(matrixX + dx + width &gt; view.getWidth()){                         dx = view.getWidth() - matrixX - width;                     }                     //if image will go oustside top bound                     if (matrixY + dy &lt; 0){                         dy = -matrixY;                     }                     //if image will go outside bottom bound                     if(matrixY + dy + height &gt; view.getHeight()){                         dy = view.getHeight() - matrixY - height;                     }                     matrix.postTranslate(dx, dy);                 }                 else if(mode == ZOOM) {                     float newDistance = spacing(event);                     if(newDistance &gt; 10f) {                         matrix.set(savedMatrix);                         float scale = newDistance / oldDistance;                         float[] values = new float[9];                         matrix.getValues(values);                         float currentScaleX = values[Matrix.MSCALE_X];                         float currentScaleY = values[Matrix.MSCALE_X];                         if(scale * currentScaleX &gt; MAX_ZOOM)                              scale = MAX_ZOOM / currentScaleX;                         else if (scale * currentScaleX &lt; MIN_ZOOM)                             scale = MIN_ZOOM / currentScaleX;                          matrix.postScale(scale, scale, mid.x, mid.y);                      }                 }                 break;         }              imageView.setImageMatrix(matrix);          return true;     }      private float spacing(MotionEvent event) {         float x = event.getX(0) - event.getX(1);         float y = event.getY(0) - event.getY(1);         return (float) Math.sqrt(x * x + y * y);     }      private void midPoint(PointF point, MotionEvent event) {         point.set((event.getX(0) + event.getX(1)) / 2, (event.getY(0) + event.getY(1)) / 2);     } } </code></pre>  <p>The problem is when I resize the image, there is no imitation and it goes bigger my screen size.</p>