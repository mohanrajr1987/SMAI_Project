<p>Consider the following scenario: </p>  <p>I want to design a discount calculator which gets me the discount that can be applied to an order. There are two types of order: Online and In-Store. Based on type of the order and total amount of the order, a discount calculator calculates the discount.</p>  <p>I programmed to demonstrate the scenario in C# but the problem is language independent. In the below code, <code>DiscountCalculator</code> class calculates the discount by examining the actual type of input parameter.</p>  <p>I feel checking the actual type of <code>IOrder</code> argument in <code>GetDiscount</code> method is code smell; because I hid the implementation details behind the interface <code>IOrder</code>, then I somehow bring out of the box what was meant to be hidden.</p>  <pre><code>    interface IOrder     {         int GetTotalPrice();     }      class InStoreOrder : IOrder     {         public int GetTotalPrice() { // returns the price of order }     }      class OnlineOrder : IOrder     {         public int GetTotalPrice() { // returns the price of order }     }      class DiscountCalculator     {         public int GetDiscount(IOrder order)         {             Type orderType = order.GetType();             if (orderType == typeof(OnlineOrder))             {                 if (order.GetTotalPrice() &lt; 100)                     return 2;                 else                     return 5;             }             if (orderType == typeof(InStoreOrder))             {                 if (order.GetTotalPrice() &lt; 100)                     return 3;                 else                     return 6;             }             else                 throw new Exception("Unknown order type:" + orderType.Name);         }     } </code></pre>  <p><strong>Any idea?</strong></p>  <p><strong>Update:</strong></p>  <p>I really appreciate people collaborating on this. All of the solutions were not only enlightening but also brought an elegant way on the table. </p>  <p>BTW, since the time all of the answers assured me that the solution is not good, I was thinking to myself that <code>Abstract Factory</code> may be a good alternative. Why? Because we are dealing with a family of related objects: <code>Order</code> and <code>DiscountCalculator</code>.</p>  <p>Something like this:</p>  <pre><code>Factory f = new FactoryRepo ("Online"); IOrder order = f.CreateItem(); IDiscountCalculator discounter = f.CreateDiscountCalculator(); .... </code></pre>  <p>This way, I think for future changes, as @Dhruv Rai Puri pointed out, Decorator pattern may be easily applied.</p>  <p><strong>Any Idea?</strong></p>