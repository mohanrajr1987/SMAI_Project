<p>Suppose the situation that for example we have an instance of some <code>SQL Server</code> (it is not the case what it is). And we have a <code>Java</code> applications that is using the <code>Spring</code> stack. </p>  <p>There are queries that are already <em>optimized</em> but they are still slow due to complex logic of aggregating that data. </p>  <p>I have several approaches in mind (those are short-terms for now):</p>  <ol> <li>Proceed with tuning (like creating views) and implement jobs to recalculate these data right in the <code>SQL server</code> for example every <em>5 minutes</em> and store it in separate table. (Yes it is not so good solution but still).</li> <li>Implement some kind of mechanism to count / aggregate that data in background. Probably implement one part of <a href="http://lambda-architecture.net/" rel="nofollow">Lambda-architecture</a>. I've already looked at <a href="http://spark.apache.org/" rel="nofollow">Apache Spark</a> and others.</li> </ol>  <p><em>Under <strong>optimized</strong> it means that those queries are using the correct indexes and everything is 'tuned'.</em></p>  <p>I know that this is not kind of question as more proposals / discussions. But still I'm questioned.</p>  <p><strong>What is the better way to handle situation like this based on the above?</strong></p>  <hr>  <h3>UPDATE #1</h3>  <p>Based on <a href="http://www.brentozar.com/archive/2013/11/what-you-can-and-cant-do-with-indexed-views/" rel="nofollow">What you can and can't do with Indexed views</a> for MS SQL Server the Indexed view are not the way to go as they do not support <em>COUNT, MIN, MAX, TOP, outer joins, or a few other keywords or elements. You canâ€™t modify the underlying tables and columns. The view is created with the WITH SCHEMABINDING option.</em></p>