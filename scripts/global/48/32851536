<p>There is a good example taken <a href="http://stackoverflow.com/a/3931726/2444725">here</a>:</p>  <blockquote>   <p>CRUD x Business logic interface. Suppose that you are working with Invoices. Each invoice consists of an InvoiceHeader and one or more InvoiceLine. If you use a CRUD interface for invoice you will first call CreateInvoiceHeader operation to create InvoiceHeader and then several AddInvoiceLine operations to add all InvoiceLines - that is low level CRUD approach. But if you implement business logic on the service side you will call single CreateInvoice and pass a complex object graph (header with all lines) to the service to create and add what is needed.</p> </blockquote>  <p>Why a perfectly legal method composition</p>  <pre><code>var Invoice =      Service.CreateInvoice(         Service.CreateInvoiceHeader(...),         {             Service.CreateInvoiceLine(...),             Service.CreateInvoiceLine(...)         }     ) </code></pre>  <ol> <li>is absolutely awful from performance point of view when used in SOA?</li> <li>can't be translated automatically into a single Service call?</li> </ol>  <p>Why must one instead create a complex object graph and send it to the service method</p>  <pre><code>var InvoiceDTO = new InvoiceDTO(     new InvoiceHeaderDTO(...),     {          new InvoiceLineDTO(...),          new InvoiceLineDTO(...)     } )  var Invoice = Service.Create(InvoiceDTO) </code></pre>  <p>and the Service must traverse the whole graph and call just the same Service methods to assemble the resulting Invoice?</p>  <p>Is there any way to use method composition to create complex results without using complex object graphs as data transport?</p>