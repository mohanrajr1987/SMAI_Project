<p>I am working in the domain of industrial automation. This software will control several pieces of industrial equipment using serial connections and protocols designed by the manufacturer of each piece of equipment. I have created Value Objects for common parameters such as Distance, Voltage, etc., however, each piece of equipment expects a different representation of the value and the UI still another.</p>  <p>As an example, suppose I need to adjust the location of an object by 1 centimeter. Equipment #1 expects distances to be in meters, Equipment #2 expects distances to be in microns, and the UI expects centimeters. I plan to use the MKS system so my Distance Value Object stores the quantity in meters.</p>  <p>From the book <em>Implementing Domain Driven Design</em> by Vaughn Vernon, my value objects seem as though they should satisfy the characteristics of a Value Object as he describes, namely:</p>  <ol> <li>It measures, quantifies, or describes a thing in the domain.</li> <li>It can be maintained as immutable.</li> <li>It models a conceptual whole by composing related attributes as an integral unit.</li> <li>It is completely replaceable when the measurement or description changes.</li> <li>It can be compared with others using Value equality.</li> <li>It supplies its collaborators with Side-Effect-Free Behavior</li> </ol>  <p><strong>Thought 1:</strong> Add the twelve common metric prefixes to each Value Object class.</p>  <pre><code>public class Distance {     private readonly double quantity; // in meters      public Distance(double distance)     {         quantity = distance;     }      public double AsCentimeters()     {         return quantity * 100;     } } </code></pre>  <p>This approach seems incorrect since the calculations based on the prefixes will not change and will have to be duplicated in several Value Objects.</p>  <p><strong>Thought 2:</strong> Introduce an enumeration with the metric prefixes and a base class with the calculations. </p>  <pre><code>public enum SIPrefix {     None, Centi  };  public class SIUnitBase {     protected readonly double quantity;      public double Value(SIPrefix prefix)     {         switch (prefix)         {             case SIPrefix.Centi:                 return quantity * 100;                 break;             default:                 return quantity;                 break;         }     } }  public class Distance : SIUnitBase {     public Distance(double distance)     {         quantity = distance;     } }  // ... in code ... Distance d = new Distance(1.0, SIPrefix.None); Equipment.Move(d.Value(SIPrefix.Centi)); </code></pre>  <p>This approach seems both verbose and error prone.</p>  <p><strong>Thought 3:</strong> Create a set of extension methods to add the required functionality. </p>  <pre><code>public static class DistanceExtensions {     public static double AsCentimeters(this Distance distance)     {         return distance * 100;     } } </code></pre>  <p>This approach seems almost as verbose as <strong>Thought 1</strong>, but I could only implement the conversions I need for the specific application.</p>  <p><strong>How should I model this architecture so that I can provide each Domain Object and UI the Value Object in the representation it expects?</strong></p>  <p>A search for previous value object questions only revealed <a href="https://stackoverflow.com/questions/2489701/value-object-getter">one thread</a> similar to my issue. </p>