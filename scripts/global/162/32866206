<p>In Windows, consider this javascript snippet:</p>  <pre><code>for ( var i = 0; i &lt; 32; i++ ) {     var xml_file_name = "charcode_" + i + ".xml";     var xmlDoc = new ActiveXObject("Msxml2.DOMDocument.6.0");     xmlDoc.async = false;     xmlDoc.loadXML("&lt;root&gt;&lt;/root&gt;");     root = xmlDoc.selectSingleNode("root");     root.setAttribute("attribute_name", String.fromCharCode(i));     xmlDoc.save(xml_file_name);      var try_to_load = new ActiveXObject("Msxml2.DOMDocument.6.0");     try_to_load.async = false;     try_to_load.load(xml_file_name);     if (try_to_load.parseError.errorCode != 0) {         var myErr = try_to_load.parseError;         WScript.StdOut.Write("char code=" + i + ": ERROR " + myErr.reason);     } else {         WScript.Echo("char code=" + i + ": OK");     } } </code></pre>  <p>save it as <code>bug.js</code> and execute it from the command line with: </p>  <pre><code>cscript bug.js </code></pre>  <p>On my system the script prints this output:</p>  <pre><code>Microsoft (R) Windows Script Host Version 5.8 Copyright (C) Microsoft Corporation. All rights reserved.  char code=0: OK char code=1: ERROR An invalid character was found in text content. char code=2: ERROR An invalid character was found in text content. char code=3: ERROR An invalid character was found in text content. char code=4: ERROR An invalid character was found in text content. char code=5: ERROR An invalid character was found in text content. char code=6: ERROR An invalid character was found in text content. char code=7: ERROR An invalid character was found in text content. char code=8: ERROR An invalid character was found in text content. char code=9: OK char code=10: OK char code=11: ERROR An invalid character was found in text content. char code=12: ERROR An invalid character was found in text content. char code=13: OK char code=14: ERROR An invalid character was found in text content. char code=15: ERROR An invalid character was found in text content. char code=16: ERROR An invalid character was found in text content. char code=17: ERROR An invalid character was found in text content. char code=18: ERROR An invalid character was found in text content. char code=19: ERROR An invalid character was found in text content. char code=20: ERROR An invalid character was found in text content. char code=21: ERROR An invalid character was found in text content. char code=22: ERROR An invalid character was found in text content. char code=23: ERROR An invalid character was found in text content. char code=24: ERROR An invalid character was found in text content. char code=25: ERROR An invalid character was found in text content. char code=26: ERROR An invalid character was found in text content. char code=27: ERROR An invalid character was found in text content. char code=28: ERROR An invalid character was found in text content. char code=29: ERROR An invalid character was found in text content. char code=30: ERROR An invalid character was found in text content. char code=31: ERROR An invalid character was found in text content. </code></pre>  <p>I observe that <code>IXMLDOMElement::setAttribute</code> behaves in a different way depending on its second argument.</p>  <p>In particular if the second argument contains one of these characters</p>  <ol> <li><code>'\x00'</code></li> <li><code>'\x09'</code></li> <li><code>'\x0A'</code></li> <li><code>'\x0D'</code> </li> </ol>  <p>then the string in the XML will be properly escaped, respectively:</p>  <ol> <li>the empty string <code>""</code></li> <li>a string containing a tab <code>'\t'</code></li> <li>a string containing these characters <code>'&amp;'</code>, <code>'#'</code>, <code>'x'</code>, <code>'A'</code>, <code>';'</code></li> <li>a string containing these characters <code>'&amp;'</code>, <code>'#'</code>, <code>'x'</code>, <code>'A'</code>, <code>';'</code></li> </ol>  <p>On the other hand, if the second argument contains one of these characters <code>'\x01'</code>, <code>'\x02'</code>, etc then:</p>  <ol> <li><code>IXMLDOMElement::setAttribute</code> will return <code>S_OK</code></li> <li>the string in the XML will contain invalid characters</li> <li>the resulting XML will be invalid and trying to load it will fail.</li> </ol>  <p>I cannot explain this behavior, I would have expected the following behavior: if the second argument of <code>IXMLDOMElement::setAttribute</code> contains some invalid XML characters then the call to <code>setAttribute</code> will fail <strong>or</strong> the call to <code>setAttribute</code> will succeed and the resulting XML will be valid.</p>  <p>Now, in order to use <code>IXMLDOMElement::setAttribute</code> I can check by myself the validity of its second argument but I do not like this approach, is there any alternative?</p>  <p>After reading <a href="https://support.microsoft.com/en-us/kb/315580" rel="nofollow">PRB: Error Message When an XML Document Contains Low-Order ASCII Characters</a></p>  <blockquote>   <p>Versions 2.6 and earlier of the MSXML parser permit XML documents to   contain low-order non-printable ASCII characters that fall outside the   W3C valid XML character ranges. However, the design of versions 3.0   and later of the MSXML parser has been changed to strictly enforce the   valid XML character ranges that are defined in the W3C XML language   specification.</p> </blockquote>  <p>it seems to me that maybe what I see is a bug of MSXML6, am I wrong?</p>