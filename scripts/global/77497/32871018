<p>In my WebApi based application I have a Ninject binding for injecting the current user in to things ...</p>  <pre><code>Bind&lt;User&gt;().ToMethod((context) =&gt; {     User result = new User { UserName = "Guest" };      if (HttpContext.Current.User.Identity.IsAuthenticated)     {         var service = Kernel.Get&lt;IUserService&gt;();         var user = service.GetAll().FirstOrDefault(u =&gt; u.UserName == HttpContext.Current.User.Identity.Name);         return user;     }      return result; }); </code></pre>  <p>Pretty straightforward right?</p>  <p>I then have a webApi controller that has a service class injected to its ctor, which in turn has the current user injected in to it, the stack looks something like this ...</p>  <pre><code>class SomethingController : ApiController {      public SomethingController(ISomethingService service) { ... } }  class SomethingService : ISomethingService {      public SomethingService(User user) { ... } } </code></pre>  <p>Frustratingly for some odd reason when i inject the current user in to the service constructor the user is not authenticated yet. </p>  <p>It appears that the stack is being constructed before the authentication provider (aspnet identity) has done its work and confirmed who the user is.</p>  <p>Later when the actual service call is made from the controller the user is authenticated and the user object I have been given is for a guest not the actual user that made the call.</p>  <p>My understanding was that a controller was not constructed until authentication and determining the request / user details was done.</p>  <p>How can I ensure that the current, authenticated user is passed to my business services correctly every time (only after authentication has taken place)?</p>  <p>EDIT:   </p>  <p>I think I found the problem: dotnetcurry.com/aspnet/888/aspnet-webapi-message-lifecycle it looks like the controller and all its dependencies are created before any auth logic is run. I guess the question then becomes ... can I force the AuthoriseFilter to run and confirm the users identity before the controller is constructed.</p>  <p>This changes my question somewhat to become:</p>  <p>How do I ensure authentication occurs before the controller and all its dependencies are constructed?</p>  <hr>  <p>EDIT 2: An Answer - Not ideal but an answer ... </p>  <p>Can someone with more rep unlock this question please, this is not a duplicate of the other question, the OP is asking about the basica usage of Ninject I am asking about WebApi lifecycle and how to get session related context prior to the session being known for the current request.</p>  <hr>  <p>Ok I don't like this answer but its a solution.</p>  <p>If anyone else has a better one I would love to hear it ...</p>  <p>If I update my service constructor to this ...</p>  <pre><code>class SomethingService : ISomethingService {      public SomethingService(IKernel kernel) { ... } } </code></pre>  <p>... and I drop the kernel in to a local field, when I come to run my service code ...</p>  <pre><code>  public void Foo() {       var user = kernel.Get&lt;User&gt;();   } </code></pre>  <p>... What this means ...</p>  <p>I get the user at the point of the request lifecycle where authentication and authorisation has taken place, and the stack is correctly constructed. </p>  <p>Now if I ask for the user, when the rule runs the HttpContext is correctly showing the right user details.</p>  <p>It works but ...</p>  <p>This is very much DI antipattern type behaviour, I don't like it and would prefer to find a solution that meant I could Authenticate the user there and then if it hadn't already happened yet but it would basically mean replicating code that the WebApi stack already has (that could mean its easier though) and will take place anyway basically resulting in the Authentication process happening twice.</p>  <p>In the absence of such a solution ... this is a "semi" reasonable workaround.</p>