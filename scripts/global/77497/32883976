<p>There's an issue with nullable types and model validation, which I implemented a solution for here: <a href="http://stackoverflow.com/questions/32861365/modelstate-isvalid-is-false-when-i-have-a-nullable-parameter">ModelState.IsValid is false when I have a nullable parameter</a></p>  <p>When I did this as an attribute on the parameter, i.e. <code>[ModelBinder(typeof(NullableIntModelBinder))]int? something = null)</code> it worked great.</p>  <p>I wanted to make it global for all <code>int?</code>s, so I added this code:</p>  <pre><code>var nullableIntModelBinderProvider = new SimpleModelBinderProvider(typeof(int?), new NullableIntModelBinder()); config.Services.Insert(typeof(ModelBinderProvider), 0, nullableIntModelBinderProvider); </code></pre>  <p>I put a breakpoint in, and sure enough, it fires. I step through the code, and it ends up running the code inside this If:</p>  <pre><code>// Provided but with no value if (rawvalue == string.Empty) {     bindingContext.Model = null;     return true; } </code></pre>  <p>Which is exactly the same as when it was an attribute on the parameter directly.</p>  <p>However, after this, the same model validation I had before runs, and ModelState.IsValid is false, with the original error <code>"A value is required but was not present in the request."</code></p>  <p>There must be some subtle difference involved here.</p>  <p>I can sort of fix it by using <code>bindingContext.ValidationNode.SuppressValidation = true;</code> however that removes it from the ModelState entirely which is not what I want, because the ModelState should reflect the complete model.</p>  <p>Any ideas why it is functioning differently?</p>