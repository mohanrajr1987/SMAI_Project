<h2>Problem</h2>  <p>I am currently working on a plugin-library, where one should be able to not only import C-Linkage symbols, but all imported things.</p>  <p>Thus far it works, though the problem is, that gcc screws member-function calls up.</p>  <p>If I export the following:</p>  <pre><code>static member_function(Class* c) { c-&gt;method();} </code></pre>  <p>it works fine an I can access the class-members. But if I do the following:</p>  <pre><code>void (Class ::*p)() = import("Class::method"); (x.*p)(); </code></pre>  <p>i get the right pointer and also am able to call the function and the passed arguments, but the this pointer is pointing into nirvana. I think gcc is taking it from the wrong position of the stack or something like that.</p>  <p>It works just fine with MSVC.</p>  <p>I am using mingw-w64 5.1.</p>  <p>Does anyone have an idea what the error could be?</p>  <h2>Simple example:</h2>  <h3>plugin.cpp</h3>  <pre><code>#include &lt;iostream&gt;      namespace space { class __declspec(dllexport) SomeExportThingy {     int i = 42;   public:     virtual void __declspec(dllexport) Method(int*) const     {          using namespace std;          cout &lt;&lt; "Calling Method" &lt;&lt; endl;          cout &lt;&lt; pi &lt;&lt; endl;          cout &lt;&lt; *pi &lt;&lt; endl;          cout &lt;&lt; this &lt;&lt; endl;          cout &lt;&lt; this-&gt;i &lt;&lt; endl;     } } } </code></pre>  <h3>loader.cpp</h3>  <pre><code>namespace space { class SomeExportThingy { ///dummy to have some data in the address     int dummy[20]; };  int main() {     auto h = LoadLibrary("plugin.dll");     auto p = GetProcAddress(h, "_ZNK5space16SomeExportThingy6MethodEPi");      typedef void (space::SomeExportThingy::*mptr)(int*) const;      ///used because posix passed void*     auto fp = *reinterpret_cast&lt;mptr*&gt;(&amp;p);      space::SomeExportThingy st;     int value = 22;      cout &lt;&lt; "ValueLoc: " &lt;&lt; &amp;value &lt;&lt; endl;     cout &lt;&lt; "StLoc: " &lt;&lt; &amp;st &lt;&lt; endl;       (st.*fp)(&amp;value);  } </code></pre>  <h2>Results</h2>  <p>Now what happens is, that the function is called and the pointer to pi is passed correctly. However, the this pointer is completly screwed up. Again: it works with MSVC, which get's the this pointer correctly, but gcc get's this wrong. I have no idea why this happens, and removing the virtual from the method doesn't change that either. I have no idea what causes this, so maybe someone has an idea what the ABI is doing here.</p>