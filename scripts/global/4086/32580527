<p><strong>BACKGROUND</strong> -- We develop <code>C++11</code> code and write unit tests using gtest/gmock.  This is built on a Windows server using SCons and <code>g++</code> in <code>MinGW</code>.  We started having occasional problems when executing unit tests: silent exits, expectation errors, exception pop-ups... with no obvious pattern or commonality and not easily reproduceable.  Eventually, a colleague narrowed it down to a case when apparently a thread was joined without even starting to execute its payload function.  In this case, there were no exceptions or alike.  The test simply failed due to expectation not being met.  I then made a further simpler test case involving neither our codebase nor gtest/gmock.</p>  <p><strong>BRIEF QUESTION</strong> -- Consider the following code snippet:</p>  <pre><code>bool flag(false); std::thread worker( [&amp;] () { flag = true; } ); worker.join(); assert(flag); </code></pre>  <p>When executed <strong>once</strong>, this appears to work <strong>fine</strong>.  By "once" I mean once in the test executable.  This executable is then run repeatedly many times from a command file.</p>  <p>However, when executed <strong>repeatedly</strong> within the test itself, the above assertion would often <strong>fail</strong>; sometimes on the very second repetition, other times after many thousands repetitions.</p>  <p>It appears g++ <code>std::thread</code> does not behave well under MinGW (4.8.0/32)  --  Thread is successfully (i.e. no exceptions) created, it is joinable, and it can be joined.  However, in some cases its payload function in never executed.  --  I know MinGW does not have full POSIX pthreads and I already looked at <a href="http://stackoverflow.com/questions/6727796/using-threads-with-mingw">Using threads with MinGW?</a>, <a href="http://stackoverflow.com/questions/16605925/pthread-create-not-enough-space">pthread_create not enough space</a>, <a href="http://stackoverflow.com/questions/15718904/mingw-and-stdthread">MinGW and std::thread</a>, and alike to no avail.  We do use static linking (for a different reason) and I also found <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=57740" rel="nofollow">https://gcc.gnu.org/bugzilla/show_bug.cgi?id=57740</a>.</p>  <p>It all kind of points to a race condition in thread implementation.  Making both boolean flags in the test <code>volatile</code> and turning optimization off (<code>-O0</code>) made no difference.</p>  <p>We currently use <strong>g++</strong> in <strong>32-bit MinGW version 4.8.0</strong> (out-of-the-box from QT5.1 installation) and are now considering move to a different toolchain (e.g. gcc/g++ on a Linux box) or at least upgrading to later MinGW if there is an indication that this problem might have been fixed.</p>  <p><em>Is this a known problem with std::thread on MinGW?</em>  <em>Are there any fixes or work-arounds?</em>  (I mean <em>general</em> fixes.  I already implemented some case-by-case- work-arounds that seem to work but I do not like them.)</p>  <p><strong>FULL DETAILS</strong> -- Executing the code below we note that:</p>  <p><strong>[A]</strong> Running the code below (so far) execution never fails test at <strong>#2</strong>.  [Expected]</p>  <p><strong>[B]</strong> However, test at <strong>#4</strong> quite frequently fails (after different number of repetition, including just two(!) repetitions; though sometimes it takes thousands before the test fails).  [Unexpected]</p>  <p><strong>[C]</strong> Exclusively enabling wait at <strong>#1</strong> results in <strong>more</strong> failures of condition at <strong>#4</strong> (test at <strong>#2</strong> still does not fail).  [Unexpected]</p>  <p><strong>[D]</strong> Exclusively enabling wait at <strong>#3</strong> makes tests at both <strong>#2</strong> and <strong>#4</strong> succeed.  [Hmm...]</p>  <p>With [D] "fix" and after <strong>many thousands</strong> repetition, I have seen (twice so far) dreaded R6016 (-not enough space for thread data).  (In a way, this is understandable and perhaps not so worrying as long as thread resources are recovered periodically between tests and tests are not run back-to-back.)</p>  <p>Note that the "waits" at #1 and #3 are only to illustrate - they don't have time-out and could possibly hang.</p>  <pre><code>#include &lt;cassert&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;thread&gt;  int main(int, char *[]) {    bool flag1(false);    assert(not flag1);     std::thread worker1( [&amp;] () { flag1 = true; } );    assert(worker1.joinable());  // while (not flag1) { std::this_thread::yield(); } // #1: MAKES #4 FAIL MORE OFTEN     worker1.join();    if (not flag1) // #2: DOES NOT FAIL    {       puts("Oops on first!");       exit(EXIT_FAILURE);    }     bool flag2(false);    assert(not flag2);     std::thread worker2( [&amp;] () { flag2 = true; } );    assert(worker2.joinable());  // while (not flag2) { std::this_thread::yield(); } // #3: MAKES #4 SUCCEED     worker2.join();    if (not flag2) // #4: SOMETIMES FAILS    {       puts("Oops on second!");       exit(EXIT_FAILURE);    }     puts("Both OKAY");    return EXIT_SUCCESS; } </code></pre>  <p>Compiled into test.exe, the above test can be run repeatedly using:</p>  <pre><code>@ECHO OFF FOR /L %%i IN (1,1,1000000) DO (    ECHO __ %%i ________________________________________________________________________________ %%i __    test.exe    IF ERRORLEVEL 1 GOTO gameover ) :gameover </code></pre>  <p><strong>EDIT</strong></p>  <ul> <li>As @TC pointed out, using bool is not correct.  Originally, I used <code>atomic_bool</code> with the same behavior as described above.  I then wrongly "simplified" the example to bool.</li> <li>BTW using only <code>yield</code> without checking the flag at #1 and #3 is <strong>not</strong> sufficient.</li> </ul>