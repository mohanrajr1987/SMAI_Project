<p>Given the following code, GCC handles fine. Visual C++ 2010-2015, however, gives the following error message indicating that it's treating the iterator member of reverse_iterator as it's base type, not it's derived type:</p>  <p>"Error  1   error C2039: 'get' : is not a member of 'std::iterator&lt;std::random_access_iterator_tag,element_type,ptrdiff_t,element_type *,element_type &amp;&gt;'"</p>  <p>Obviously the code is a cut-down example to illustrate the situation and does not relate to the original context, which we will not be addressing here. The only question to be answered is the one in the title.</p>  <pre><code>#include &lt;iostream&gt; #include &lt;iterator&gt;   template &lt;class element_type&gt; class container { public:     class iterator : public std::iterator&lt;std::random_access_iterator_tag, element_type, std::ptrdiff_t, element_type *, element_type &amp;&gt;     {     private:         element_type *a;      public:         element_type * get()         {             return a;         }          void set(element_type *value)         {             a = value;         }     };        class reverse_iterator : public std::reverse_iterator&lt;iterator&gt;     {     private:         iterator der1;      public:         iterator base()         {             return iterator(der1);         }     };  };     int main() {     using namespace std;      container&lt;int&gt;::iterator c;     container&lt;int&gt;::reverse_iterator d;      cout &lt;&lt; c.get() &lt;&lt; " ";     cout &lt;&lt; d.base().get() &lt;&lt; endl;     return 0; } </code></pre>  <p>Obviously if you compile this you'll find "c.get()" functions perfectly, d.base().get() provides the error message.</p>  <p>This is a constructed example specifically to illustrate the issue. Please do Not provide answers that do not relate to the issue.</p>  <p>Please note that this error does not result when another artificially-constructed base class is used - it is specific to std::iterator under visual studio.</p>