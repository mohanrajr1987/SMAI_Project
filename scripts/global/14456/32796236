<p>I'm computing the mean and variance of an array using SSE intrinsics. Basically, this is the summation of the values and its squares which can be illustrated in the following program:</p>  <pre><code>int main( int argc, const char* argv[] ) {     union u     {         __m128 m;         float f[4];     } x;      // Allocate memory and initialize data: [1,2,3,...stSize+1]     const size_t stSize = 1024;     float *pData = (float*) _aligned_malloc(stSize*sizeof(float), 32);     for ( size_t s = 0; s &lt; stSize; ++s ) {         pData[s] = s+1;     }      // Sum and sum of squares     {         // Accumlation using SSE intrinsics         __m128 mEX = _mm_set_ps1(0.f);         __m128 mEXX = _mm_set_ps1(0.f);         for ( size_t s = 0; s &lt; stSize; s+=4 )          {             __m128 m = _mm_load_ps(pData + s);                   mEX = _mm_add_ps(mEX, m);             mEXX = _mm_add_ps(mEXX, _mm_mul_ps(m,m));         }          // Final reduction         x.m = mEX;         double dEX = x.f[0] + x.f[1] + x.f[2] + x.f[3];         x.m = mEXX;         double dEXX = x.f[0] + x.f[1] + x.f[2] + x.f[3];          std::cout &lt;&lt; "Sum expected: " &lt;&lt; (stSize * stSize + stSize) / 2 &lt;&lt; std::endl;         std::cout &lt;&lt; "EX: " &lt;&lt; dEX &lt;&lt; std::endl;         std::cout &lt;&lt; "Sum of squares expected: " &lt;&lt; 1.0/6.0 * stSize * (stSize + 1) * (2 * stSize + 1) &lt;&lt; std::endl;         std::cout &lt;&lt; "EXX: " &lt;&lt; dEXX &lt;&lt; std::endl;     }      // Clean up     _aligned_free(pData); } </code></pre>  <p>Now when I compile and run the program in Debug mode I get the following (and correct) output:</p>  <pre><code>Sum expected: 524800 EX: 524800 Sum of squares expected: 3.58438e+008 EXX: 3.58438e+008 </code></pre>  <p>However, compiling and running the program in Release mode the following (and wrong) results are produced:</p>  <pre><code>Sum expected: 524800 EX: 524800 Sum of squares expected: 3.58438e+008 EXX: 3.49272e+012 </code></pre>  <p>Changing the order of accumulation, i.e. EXX is updated before EX, the results are OK:</p>  <pre><code>Sum expected: 524800 EX: 524800 Sum of squares expected: 3.58438e+008 EXX: 3.58438e+008 </code></pre>  <p>Looks like a 'counterproductive' compiler optimization or why is the order of execution relevant? Is this a known bug?</p>  <p><strong>EDIT:</strong> I just looked at the assembler output. Here is what I get (only the relevant parts). For the release build with <code>/arch:AVX</code> compiler flag we have:</p>  <pre><code>; 69   :    // Second test: sum and sum of squares ; 70   :    { ; 71   :        __m128 mEX = _mm_set_ps1(0.f); vmovaps xmm1, XMMWORD PTR __xmm@0 mov ecx, 256                ; 00000100H  ; 72   :        __m128 mEXX = _mm_set_ps1(0.f); vmovaps xmm2, xmm1 npad    12 $LL3@main:  ; 73   :        for ( size_t s = 0; s &lt; stSize; s+=4 )  ; 74   :        { ; 75   :            __m128 m = _mm_load_ps(pData + s);       vmovaps xmm0, xmm1  ; 76   :            mEX = _mm_add_ps(mEX, m); vaddps  xmm1, xmm1, XMMWORD PTR [rax] add rax, 16  ; 77   :            mEXX = _mm_add_ps(mEXX, _mm_mul_ps(m,m)); vmulps  xmm0, xmm0, xmm0 vaddps  xmm2, xmm0, xmm2 dec rcx jne SHORT $LL3@main </code></pre>  <p>This is clearly wrong as this (1) saves the accumulated EX result (<code>xmm1</code>) in <code>xmm0</code> (2) accumulates EX with the current value (<code>XMMWORD PTR [rax]</code>) and (3) accumulates in EXX (<code>xmm2</code>) the square of the accumulated EX result previously save in <code>xmm0</code>.</p>  <p>In contrast, the version without the <code>/arch:AVX</code> looks fine and as expected:</p>  <pre><code>; 69   :    // Second test: sum and sum of squares ; 70   :    { ; 71   :        __m128 mEX = _mm_set_ps1(0.f); movaps  xmm1, XMMWORD PTR __xmm@0 mov ecx, 256                ; 00000100H  ; 72   :        __m128 mEXX = _mm_set_ps1(0.f); movaps  xmm2, xmm1 npad    10 $LL3@main:  ; 73   :        for ( size_t s = 0; s &lt; stSize; s+=4 )  ; 74   :        { ; 75   :            __m128 m = _mm_load_ps(pData + s);       movaps  xmm0, XMMWORD PTR [rax] add rax, 16 dec rcx  ; 76   :            mEX = _mm_add_ps(mEX, m); addps   xmm1, xmm0  ; 77   :            mEXX = _mm_add_ps(mEXX, _mm_mul_ps(m,m)); mulps   xmm0, xmm0 addps   xmm2, xmm0 jne SHORT $LL3@main </code></pre>  <p>This really looks like a bug. Can anyone comfirm or refute this issue with a different compiler version? (I currently do not have permission to update the compiler)</p>