<p>Given A positive integer <code>k (k≤50)</code>, a DNA string s of length at most <code>5,000</code> representing a motif, and a DNA string t of length at most <code>50,000</code> representing a genome.</p>  <p>The problem consists on returning all substrings <code>t′</code> of t such that the edit distance <code>d_E(s,t′)</code> </p>  <blockquote>   <p>The edit distance between two strings is the minimum number of elementary   operations (insertions, deletions, and substitutions) to transform one   string into the other, for instamce <code>s = 'TGCATAT'</code> and <code>t' = 'ATCCGAT'</code> <a href="http://i.stack.imgur.com/lJ2XH.png" rel="nofollow"><img src="http://i.stack.imgur.com/lJ2XH.png" alt="enter image description here"></a>   <a href="http://codereview.stackexchange.com/questions/10130/edit-distance-between-two-strings">here is a c++ implementation by</a> user1131146 account aban    Maybe it would be better to use that??</p> </blockquote>  <p>is less than or equal to <code>k</code>. Each substring should be encoded by a pair containing its location in <code>t</code> followed by its length.</p>  <p>for instance</p>  <pre><code>2 ACGTAG ACGGATCGGCATCGT </code></pre>  <p>should output</p>  <pre><code>1 4 1 5 1 6 </code></pre>  <p>For this example <code>k=2</code> results mean:<br> For indices <code>1 to 4</code>, <code>d_E(s,t′)=2</code> (ADD <code>T</code> THEN one <code>A</code> BEFORE LAST <code>t's G</code>)</p>  <pre><code>s  = ACGTAG t' = ACGG </code></pre>  <p>For indices <code>1 to 5</code> <code>d_E(s,t′)=2</code> (ADD <code>G</code> to end of <code>t'</code> THEN replace <code>t's G</code> at index 4 by <code>T</code>)</p>  <pre><code>s  = ACGTAG t' = ACGGA </code></pre>  <p>For indices <code>1 to 6</code> <code>d_E(s,t′)=2</code> (REPLACE LAST <code>t's T</code> BY <code>G</code>THEN replace <code>t's G</code> at index 4 by <code>T</code>) </p>  <pre><code>s  = ACGTAG t' = ACGGAT </code></pre>  <p>Having the solution to get <code>all substrings of a genome that are within a certain fixed distance of the desired motif</code>,What would be the best way to parallelize a solution using omp. As the longer the strings become program takes too much time.</p>  <p>I have tested using omp <code>#pragma omp parallel for</code> then using a <code>lock</code> in the write to file section, and also <code>#pragma omp critical</code> However I do not know if I am paralelizing it correctly.</p>  <pre><code>void alignment(vector&lt;vi&gt;&amp;a, string &amp;x, string y, int k){     string tx,ty;     int i,j;     int ylen=a[0].size();     for(i=1;i&lt;a.size();i++){         for(j=max(1,i-k);j&lt;=min(ylen,i+k);j++){              a[i][j] = max(x[i-1] == y[j-1]?a[i-1][j-1] : (a[i-1][j-1]-1), max(a[i-1][j]-1,a[i][j-1]-1));         }     } }  int main() {     int k = 23;     string s = "AATTAGCTAAGGTGTACGATGTCCCATTGTGTAAGATTAGGAACTCCATTTAGGTTACCTCCGTCTTAAGTGATGGACCGTGGGTAGCTGCGTCCGATGGACTCATGCAGCGCCCGGATACCTGCAGTATTTATTATATAGGTCTGCGCACCAAACGATTTCTTTCGTGGTCGGGATTCCGGGGTCCTCCGCTATTCAGAGAGCTAAATA";     string t = "ACAATGCAGCAATCCAGCGCCGGAATTTAAGAATAGGTCAGTTTGTAAGGCACTGTTCCCGTTATTCGTAATGCAGTATTAACGTTAATGCTCGAGACCATATTGGACGTCAGTATGCAGACCTGTGCTAGGGTGGTCTATTTCAAGATCACCGAGCTAGGCGCGTGAGCTAACAGGCCGTAATGGTGGCGCCCGCTCCCATAATCACTTCACGAAGCATTAGGTAGACTACCATTTAGGAAGCCCTCTCGCCCGCGTACTGGTTACAGCCCACTACAATGGATACTCCTTACTTCGGTGCAGGCAAGACTTCTACAAAGAAGCGTCCAAGAAGTTGTCGTAGCTCGTTCTTACCCCACCTGTATAAAATTGATCCAGTCGTACATATGACGATGCTGAGCCTCGGACTGGTAAATACAAGTCAAAGGACCAACCCATTACAGTATGAACTACCGGTGG";     time_t start = time(NULL);     std::ofstream out("output.txt");     ifstream someStream( "data.txt" );     string line;     getline( someStream, line );    int k = atoi(line.c_str() );     getline( someStream, line );    string s =line;     getline( someStream, line );    string t= line;     int slen=s.length(), tlen=t.length();     vector&lt;vi&gt;a( slen+1, vi(slen+k+1));      int i,j;     for(i=1;i&lt;a.size();i++)         fill(a[i].begin(),a[i].end(),-999),a[i][0]=a[i-1][0]-1;     #pragma omp parallel for     {         for(j=1;j&lt;a[0].size();j++)         {             a[0][j]=a[0][j-1]-1;         }     }     //cout &lt;&lt; "init";     time_t endINIT = time(NULL);     cout&lt;&lt;"Execution Init Time: "&lt;&lt; (double)(endINIT-start)&lt;&lt;" Seconds"&lt;&lt;std::endl;     //omp_lock_t writelock;     //omp_init_lock(&amp;writelock);      #pragma omp parallel for     {     for(i=0;i&lt;=tlen-slen+k;i++)     {         alignment(a,s,t.substr(i,slen+k),k);          for(j=max(0,slen-k);j&lt;=min(slen+k,tlen-i);j++)         {             if(a[slen][j]&gt;=-k)             {                  //omp_set_lock(&amp;writelock);                     //cout&lt;&lt;(i+1)&lt;&lt;' '&lt;&lt;j&lt;&lt;endl;                 #pragma omp critical                  {                     out &lt;&lt;(i+1)&lt;&lt;' '&lt;&lt;j&lt;&lt;endl;                 }                 //omp_unset_lock(&amp;writelock);             }         }     }     }     //omp_destroy_lock(&amp;writelock);     time_t end = time(NULL);     cout&lt;&lt;"Execution Time: "&lt;&lt; (double)(end-start)&lt;&lt;" Seconds"&lt;&lt;std::endl;       out.close();     return 0; } </code></pre>