<p>Given a binary string (that is a string consisting of only 0 and 1). They were supposed to perform two types of query on the string.<a href="https://www.hackerearth.com/code-monk-segment-tree-and-lazy-propagation/algorithm/2-vs-3/" rel="nofollow">Problem</a></p>  <p><strong>Type 0:</strong> Given two indices l and r.Print the value of the binary string from l to r modulo 3.</p>  <p><strong>Type 1:</strong> Given an index l flip the value of that index if and only if the value at that index is 0.</p>  <p>I am trying to solve this using <strong>BIT</strong>.</p>  <p>If the number in <strong>range [l,r] is even</strong>  then:<br> if the sum of the numbers of one is even then the answer is 0 else 2</p>  <p>If the number in <strong>range [l,r] is odd</strong><br> if the sum of the numbers of one is even then the answer is 0 else 1</p>  <p>But I am getting wrong answer for some test cases what wrong is in my approach.</p>  <pre><code>public static void update(int i){      while(A.length&gt;i){         A[i]+=1;         i+=i&amp;-i;     }  }  public static int ans(int i){     int a=0;      while(i&gt;0){         a+=A[i];         i-=i&amp;-i;     }     return a; } </code></pre>  <p>Answer for each Query.</p>  <pre><code>while(Q&gt;0){     Q--;     int x = in.nextInt();     int l = in.nextInt()+1;     if(x==1){         if((ans(l)-ans(l-1))==0) update(l);          continue;     }     int r  = in.nextInt()+1;      int f = ans(r) - ans(r-1);      if(f==0){          int sum = ans(r)- ans(l-1);         if(sum%2==0) System.out.println(0);         else System.out.println(2);     }else{          int sum = ans(r)- ans(l-1);         if(sum%2==0) System.out.println(0);         else System.out.println(1);      } } </code></pre>  <p><a href="http://ideone.com/ZkouKQ" rel="nofollow">Full CODE</a></p>