<p>I have to write a program which simulate the way an elevator works. The goal of the program is to display the number of floors that will be reached before the the elevator reaches the desired floor of the passenger. I know this is pretty vague but I am running of time so would be glad if someone could correct my code and suggest improvements and I am not yet done with it because I am kind of at a lost of how to proceed being a beginner at Data Structures. Am getting errors where I am using the priority queues <code>floors_up</code> and <code>floors_down</code> and <code>floors</code>.</p>  <pre><code>package lesson1; import java.util.*;  public class Elevator_Order {   final static Comparator&lt;Elevator&gt; TargetFloorComparator= new Comparator&lt;Elevator&gt;(){      public int compare(Elevator A, Elevator B){          if (A.getTarget.compareTo(B.getTarget())&lt;0) return -1;         else             if (A.getTarget().compareTo(B.getTarget())&gt;0) return 1;             else                  return 0;     } }; </code></pre>  <p>public static final int MAX_FLOORS = 8;</p>  <pre><code>private int current; private int floors_up; private int floors_down; private int floors; private int target; private int where;     public void userCallAt(int where) {     setTarget(where); }   public void setTarget(int target) {      // ignore if target is current     if (target == current) {         return;     }      // add target to right queue     if (floors == floors_up) {         if (target &lt; current) {             floors_down.offer(target);         } else {             floors_up.offer(target);         }     } else {         if (target &gt; current) {             floors_up.offer(target);         } else {             floors_down.offer(target);         }     }      // swap queue to turn around the elevator     if (floors.isEmpty()) {         floors = (floors == floors_up ? floors_down : floors_up);     } }  public int getTarget() {      if (!floors.isEmpty()) {         return floors.peek();     }      if (floors_up.isEmpty() &amp;&amp; floors_down.isEmpty()) {         return current;     }      floors = (floors == floors_up ? floors_down : floors_up);     return floors.peek(); }  public int getCurrent() {     return current; }  public void step(int target) {     if (target &gt; current) {         current++;     } else {         current--;     } }  public void stop() {     floors.poll(); }  public void move() {      while (getCurrent() != getTarget()) {         do {             step(getTarget());         } while (getCurrent() != getTarget());         stop();     }     }  public static void main(String[] args) {     // TODO Auto-generated method stub     Scanner sc = new Scanner(System.in);      int dir, c_floor, desired_floor;      System.out.println("Please enter the direction you want to go; enter 1 for up, enter 0 for down.");     dir= sc.nextInt();       PriorityQueue&lt;Integer&gt; floors_down= new PriorityQueue&lt;Integer&gt;();     PriorityQueue&lt;Integer&gt; floors_up= new PriorityQueue&lt;Integer&gt;();  // effective floor queue     private PriorityQueue&lt;Integer&gt; floors = floors_up;      if(dir==0){         Object dir;         floors_down.add(dir);     }     else if(dir==1){         floors_up.add(dir);     }      System.out.println("Please enter the current floor");     c_floor= sc.nextInt();      System.out.println("Enter the floor you want to go to");     desired_floor= sc.nextInt();      if(desired_floor&lt;c_floor){         floors_down.add(desired_floor);     }     else           if(desired_floor&gt;c_floor){             floors_up.add(desired_floor);         }  } </code></pre>  <p>}</p>