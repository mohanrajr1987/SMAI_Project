<p>I'm looking for a data structure which would efficiently solve <a href="https://en.wikipedia.org/wiki/Order-maintenance_problem" rel="nofollow">Order-maintenance problem</a>. In the other words, I need to efficiently</p>  <ul> <li>insert (in the middle),</li> <li>delete (in the middle),</li> <li>compare positions of elements in the container.</li> </ul>  <p>I found good articles which discuss this problem:</p>  <ul> <li><a href="https://www.cs.cmu.edu/~sleator/papers/maintaining-order.pdf" rel="nofollow">Two Algorithms for Maintaining Order in a List</a>,</li> <li><a href="http://erikdemaine.org/papers/DietzSleator_ESA2002/paper.pdf" rel="nofollow">Two Simplified Algorithms for Maintaining Order in a List</a>.</li> </ul>  <p>The algorithms are quite efficient (some state to be O(1) for all operations), but they do not seem to be trivial, and I'm wondering if there is an open source C++ implementation of these or similar data structures. </p>  <p>I've seen <a href="http://cs.stackexchange.com/questions/14708/maintaining-an-efficient-ordering-where-you-can-insert-elements-in-between-any">related topic</a>, some simpler approaches with time complexity O(lg n) for all operations were suggested, but here I'm looking for existing implementation.</p>  <p>If there was an example in some other popular languages it would be good too, this way I would be able at least to experiment with it before trying to implement it myself.</p>  <p><strong>Details</strong></p>  <p>I'm going to </p>  <ul> <li>maintain a list of pointers to objects, </li> <li>from time to time I will need to change object's order (delete+insert),</li> <li>given a subset of objects I need to be able to quickly sort them and process them in correct order.</li> </ul>  <p><strong>Note</strong></p>  <p>The standard ordering containers (std::set, std::map) is not what I'm looking for because they will maintain order for me, but I need to order elements myself. Similar to what I would do with std::list, but there position comparison would be linear, which is not acceptable.</p>