<p>This is a homework question. My book does not address how to actually sift through the addresses so I need some help</p>  <p>Given a struct</p>  <pre><code>struct lnode {  struct lnode *prev;  char *str;  int strsize;  struct lnode *next; }; </code></pre>  <p>The linked list starts at address 0x0602060, and looking at the memory around that address we see</p>  <pre><code>(gdb) x/36x 0x0602010 0x602010:       0x0000000000602060      0x0000000000602040 0x602020:       0x0000000000000016      0x00000000006020b0 0x602030:       0x0000000000000000      0x0000000000000021 0x602040:       0x206d72657464696d      0x756874206e6f2031 0x602050:       0x00000a7961647372      0x0000000000000031 0x602060:       0x0000000000000000      0x0000000000602090 0x602070:       0x000000000000000d      0x0000000000602010 0x602080:       0x0000000000000000      0x0000000000000021 0x602090:       0x6f662074276e6f64      0x0000000a74656772 0x6020a0:       0x0000000000000000      0x0000000000000031 0x6020b0:       0x0000000000602010      0x00000000006020e0 0x6020c0:       0x0000000000000016      0x0000000000000000 0x6020d0:       0x0000000000000000      0x0000000000000021 0x6020e0:       0x2035206573616870      0x6d20657564207369 0x6020f0:       0x00000a7961646e6f      0x0000000000020f11 0x602100:       0x0000000000000000      0x0000000000000000 0x602110:       0x0000000000000000      0x0000000000000000 0x602120:       0x0000000000000000      0x0000000000000000 </code></pre>  <p>I understand how I would traverse a singly linked list with a single variable in the memory. I would :</p>  <p>1.Begin at the first address, check where it points to, follow that to the next set of memory</p>  <p>2.The first set of bytes would hold the value in that node, the second set would hold the pointer to the next node</p>  <p>3.Continue</p>  <p>However, this does not work here. </p>  <p>The first node is said to be at 0x602060. Going there and checking the bytes reveals that there are no variable values, followed by a pointer to the next node 0x602090.</p>  <pre><code>0x0000000000000000      0x0000000000602090 </code></pre>  <p>Going to 0x602090 presents bytes in both sections with no apparent return address. Considering the size of the struct I assume that first the char pointer is shown, then the size in the second column as follows</p>  <pre><code> 0x6f662074276e6f64 (char*)     0x0000000a74656772 (int with padding) </code></pre>  <p>Going on, however, what I'm looking at starts to make less sense My assumption is that the next two lines</p>  <pre><code>  (1) 0x0000000000000000      0x0000000000000031   (2) 0x0000000000602010      0x00000000006020e0 </code></pre>  <p>represent (1) some unknown result we don't have to consider and (2) previous pointer followed by next pointer? But the previous pointer is not the same as the start location. And my assumption that one node is represented by 3 line chunks does not seem to hold starting at address 0x6020e0.</p>  <p>Can someone please give me some hints as to how I am supposed to traverse this? Any help is greatly appreciated.</p>