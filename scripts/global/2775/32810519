<p>I am using Dagger 2 to inject my Activity's dependencies, and everything is working beautifully. But when I try to run my Espresso tests, I'm encountering a "chicken and the egg" scenario. In order to set my component, the module needs the current activity's context, but at that point in the espresso test, I don't have it (because launchActivity has not run yet).</p>  <p>I'm using a module of mocks in my tests, but I want this dialog to always be the real one, not a mock, because I want it to dislay during the tests.</p>  <p>Simply put, I'm trying to inject a custom Dialog, which needs the current activity's context to construct itself. Here is my code:</p>  <p>MyApplication.java</p>  <pre><code>public class MyApplication extends Application {     private static AmbassadorActivityComponent component = null;      public static AmbassadorActivityComponent getComponent() {         return component;     }      public static void setComponent(AmbassadorActivityComponent comp) {         component = comp;     }      public void onCreate() {         super.onCreate();     } } </code></pre>  <p>MainActivity.java</p>  <pre><code>public class MainActivity extends AppCompatActivity {     @Inject     TweetDialog tweetDialog;      @Singleton     @Component(modules=AmbassadorActivityModule.class)     public interface ApplicationComponent extends AmbassadorActivityComponent {     }      @Override     protected void onCreate(Bundle savedInstanceState) {         super.onCreate(savedInstanceState);         setContentView(R.layout.activity_ambassador);          if (MyApplication.getComponent() == null) {             ApplicationComponent component = DaggerAmbassadorActivity_ApplicationComponent.builder().ambassadorActivityModule(new AmbassadorActivityModule(this)).build();             MyApplication.setComponent(component);         }         MyApplication.getComponent().inject(this);     }      .... stuff omitted      private void _btnClicked() {         tweetDialog.show();     }  } </code></pre>  <p>AmbassadorActivityComponent.java</p>  <pre><code>public interface AmbassadorActivityComponent {     void inject(AmbassadorActivity ambassadorActivity);     void inject(TweetDialog tweetDialog); } </code></pre>  <p>TweetDialog.java</p>  <pre><code>@Singleton class TweetDialog extends Dialog {      @Inject     TweetRequest tweetRequest;      @Inject     public TweetDialog(@ForActivity Context context) {         super(context);          //get injected modules we need         MyApplication.getComponent().inject(this);     } } </code></pre>  <p>AmbassadorActivityModule.java</p>  <pre><code>@Module public class AmbassadorActivityModule {     private final Context context;      public AmbassadorActivityModule(Context context) {         this.context = context;     }      @Provides     @Singleton     TweetRequest provideTweetRequest() {         return new TweetRequest();     }      @Provides     @Singleton     @ForActivity     Context provideContext() {         return context;     } } </code></pre>  <p>As I've said, when running the application, everything works great. It's when I set up my test that things break down.</p>  <p>AmbassadorActivityTest.java</p>  <pre><code>@RunWith(AndroidJUnit4.class) @MediumTest public class AmbassadorActivityTest {      @Inject     TweetRequest tweetRequest;      @Singleton     @Component(modules = {MockAmbassadorActivityModule.class})     public interface TestComponent extends AmbassadorActivityComponent {         void inject(AmbassadorActivityTest ambassadorActivityTest);     }      @Rule     public ActivityTestRule&lt;AmbassadorActivity&gt; mActivityTestIntentRule = new ActivityTestRule&lt;&gt;(AmbassadorActivity.class, true, false);      @Before     public void beforeEachTest() {         Instrumentation instrumentation = InstrumentationRegistry.getInstrumentation();         MyApplication app = (MyApplication)instrumentation.getTargetContext().getApplicationContext(); </code></pre>  <p>//THE BELOW LINE IS WHERE MY PROBLEM IS - INSTANTIATING MY MODULE, I NEED THE ACTIVITY CONTEXT, BUT I DON'T HAVE IT AT THIS POINT BECAUSE launchActivity HAS NOT RUN YET</p>  <pre><code>        TestComponent component = DaggerAmbassadorActivityTest_TestComponent.builder().mockAmbassadorActivityModule(new MockAmbassadorActivityModule(context)).build();         app.setComponent(component);         component.inject(this);          Intent intent = new Intent();         mActivityTestIntentRule.launchActivity(intent);     } } </code></pre>  <p>MockAmbassadorActivityModule.java</p>  <pre><code>@Module public class MockAmbassadorActivityModule {     private final Context context;      public MockAmbassadorActivityModule(Context context) {         this.context = context;     }      @Provides     @Singleton     TweetRequest provideTweetRequest() {         return mock(TweetRequest.class);     }      @Provides     @Singleton     @ForActivity     Context provideContext() {         return context;     } } </code></pre>  <p>The whole point is that I'm mocking the tweetRequest class (which is just an async request), but I'm not mocking the TweetDialog - I want that to run as normal so it appears during my test.</p>  <p>What am I doing wrong? I'm wondering if there's a better way to reconfigure my modules. I need the TweetDialog injected, but I want it to always use the current activity's context. Please help!</p>