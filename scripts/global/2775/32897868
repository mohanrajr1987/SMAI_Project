<p>This is going to be a little crazy, but I believe that if it's possible, it's going to be the most maintainable solution for the task at hand. </p>  <p>Our application uses Autofac for dependency injection.</p>  <p>We use a custom data file format that we need to be able to evolve for technical (performance/storage space optimizations) or domain reasons. The application will always only <em>write</em> the most recent version of the format, but needs to be able to <em>read</em> all previous versions too. The evolution will generally be rather gradual between versions with changes only in a few places, so a lot of the code for reading it will remain the same.</p>  <p>The file format version number is stored as an integer value at the beginning of the file. Reading any version of the file format will always result in the same data structure, called <code>Scenario</code> here.</p>  <p>A class that can read data from a file takes a dependency on <code>IReadDataFile</code>:</p>    <pre class="lang-cs prettyprint-override"><code>public interface IReadDataFile {     Scenario From(string fileName); } </code></pre>  <p>Behind that is a non-trivial object graph for reading the various parts of a scenario. However, the required graph looks a little different for each of the file format versions (illustrative example, not the actual types; the real graphs are much more complex):</p>  <p>Version 1:</p>  <pre class="lang-cs prettyprint-override"><code>ReadDataFileContents : IReadDataFileContents └&gt; ReadCoreData : IReadCoreData └&gt; ReadAdditionalData : IReadAdditionalData    └&gt; NormalizeName : INormalizeName </code></pre>  <p>Version 2:</p>  <pre class="lang-cs prettyprint-override"><code>ReadDataFileContentsV2 : IReadDataFileContents └&gt; ReadCoreData : IReadCoreData └&gt; ReadAdditionalDataV2 : IReadAdditionalData    └&gt; NormalizeNameV2 : INormalizeName       └&gt; AdditionalNameRegex : IAdditionalNameRegex </code></pre>  <p>Version 3:</p>  <pre class="lang-cs prettyprint-override"><code>ReadDataFileContentsV2 : IReadDataFileContents └&gt; ReadCoreData : IReadCoreData └&gt; ReadAdditionalDataV3 : IReadAdditionalData    └&gt; NormalizeNameV2 : INormalizeName       └&gt; AdditionalNameRegexV3 : IAdditionalNameRegex </code></pre>  <p>(I'm only considering entirely separate graphs like this; handling this in a single graph and switching every time there is a version-related difference obviously gets really messy very quickly.)</p>  <p>Now whenever the <code>IReadDataFile.From()</code> method is called to load a file, it needs to get hold of the appropriate subgraph for the file format version. An easy way to achieve this is via an injected factory: </p>  <pre class="lang-cs prettyprint-override"><code>public class ReadDataFile : IReadDataFile {     private readonly IGetDataFileVersion getDataFileVersion;     private readonly Func&lt;int, IReadDataFileContents&gt; createReadDataFileContents;      public ReadDataFile(         IGetDataFileVersion getDataFileVersion,         Func&lt;int, IReadDataFileContents&gt; createReadDataFileContents)     {         this.getDataFileVersion = getDataFileVersion;         this.createReadDataFileContents = createReadDataFileContents;     }      public Scenario From(string fileName)     {         var version = this.getDataFileVersion.From(fileName);         var readDataFileContents = this.createReadDataFileContents(version);         return readDataFileContents.From(fileName);     } } </code></pre>  <p>The question is how registration and resolution of those subgraphs will work.</p>  <p>Registering the complete subgraphs as <code>Keyed&lt;T&gt;</code> by hand is very involved and error-prone and does not scale well for additional file format versions (especially as the graphs are a lot more complex than the example).</p>  <p>Instead, I would like the registration for the whole thing as described above to look like this:</p>  <pre class="lang-cs prettyprint-override"><code>builder.RegisterAssemblyTypes(typeof(IReadDataFile).Assembly).AsImplementedInterfaces();  builder.RegisterType&lt;ReadDataFileContents&gt;().As&lt;IReadDataFileContents&gt;(); builder.RegisterType&lt;ReadDataFileContentsV2&gt;().Keyed&lt;IReadDataFileContents&gt;(2);  builder.RegisterType&lt;ReadAdditionalData&gt;().As&lt;IReadAdditionalData&gt;(); builder.RegisterType&lt;ReadAdditionalDataV2&gt;().Keyed&lt;IReadAdditionalData&gt;(2); builder.RegisterType&lt;ReadAdditionalDataV3&gt;().Keyed&lt;IReadAdditionalData&gt;(3);  builder.RegisterType&lt;NormalizeName&gt;().As&lt;INormalizeName&gt;(); builder.RegisterType&lt;NormalizeNameV2&gt;().Keyed&lt;INormalizeName&gt;(2);  builder.RegisterType&lt;AdditionalNameRegex&gt;().As&lt;IAdditionalNameRegex&gt;(); builder.RegisterType&lt;AdditionalNameRegexV3&gt;().Keyed&lt;IAdditionalNameRegex&gt;(3);  builder.Register&lt;Func&lt;int, IReadDataFileContents&gt;&gt;(c =&gt; {     var context = c.Resolve&lt;IComponentContext&gt;();      return version =&gt; // magic happens here }); </code></pre>  <p>That means there are only explicit registrations for the components that vary between the graphs. And by "magic happens here", I mean that for getting away with this minimum in registrations, the resolution will have to do the heavy lifting.</p>  <p>The way I would like this to work is this: For each component (in this subgraph) to be resolved, it is attempted to resolve a registration keyed to the requested file format version. If that attempt fails, another one is made for the next lower version, and so forth; when the resolution for key <code>2</code> fails, the default registration is resolved.</p>  <p>A complete example:</p>  <ul> <li>The <code>createReadDataFileContents</code> factory is called with a <code>version</code> value of <code>3</code>, so the required graph is the one for file format version 3 given above.</li> <li>An attempt is made to resolve <code>IReadDataFileContents</code> with the key <code>3</code>. This is unsuccessful; there is no such registration.</li> <li>Now an attempt is made to resolve <code>IReadDataFileContents</code> with the key <code>2</code>. This succeeds.</li> <li>The constructor requires an <code>IReadCoreData</code>. It is attempted to resolve this with the key <code>3</code>, then <code>2</code>; both fail, so the default registration is resolved, which succeeds.</li> <li>The second constructor parameter is <code>IReadAdditionalData</code>; it is attempted to resolve this with the key <code>3</code>, which succeeds.</li> <li>The constructor requires <code>INormalizeName</code>; resolution with key <code>3</code> fails, then the attempt for <code>2</code> succeeds.</li> <li>This constructor in turn requires <code>IAdditionalNameRegex</code>; the resolution attempt with key <code>3</code> succeeds.</li> </ul>  <p>The tricky thing here (and the one I can't figure out how to do) is that the version "countdown" fallback process needs to happen for <strong>each</strong> individual dependency to be resolved, each time starting from the initial value of <code>version</code>.</p>  <p>Poking around the Autofac API and a bit of googling yielded a few things that looked interesting, but none of them seemed to offer an obvious path to a solution.</p>  <ul> <li><code>Module.AttachToComponentRegistration()</code> - I have used this elsewhere to hook into the resolution process using the <code>registration.Preparing</code>; however, that event is only raised when a suitable registration has been found, and there doesn't appear to be an event that is raised before that, nor a way to register a callback in case of resolution failure (which surprises me).</li> <li><code>IRegistrationSource</code> - This seems to be the way to implement such more general registration/resolution principles, but I can't get my head around what I'd need to do inside that, in case that is actually the place I'm looking for.</li> <li><code>WithKeyAttribute</code> - We can't use this here, because we need to control the "version" of a dependency that is injected from the outside (also, the actual business code would become dependent on Autofac, which is never good.)</li> <li><code>ILifetimeScope.ResolveOperationBeginning</code> - This looked very promising, but the event is only raised for resolutions that have already been successful.</li> <li><code>IIndex&lt;TKey, TValue&gt;</code> - Another thing that looked really good at first, but it contains already constructed instances, which leaves no way to get the version key to the resolution for the lower levels.</li> </ul>  <p>A problem to solve on the side would be restricting the whole thing to just the types that are actually relevant for this, but I guess that could be done convention based (namespace etc.) if need be.</p>  <p>Another thought that might help is that after all the registrations are made (which would have to be determined somehow), the "gaps" could be "filled up" - meaning if there is a registration keyed with 3 but none with 2, one will be added that is equal to the default registration. That would allow resolving <em>all</em> dependencies in the subgraph with the same key and do away with the need for that "cascaded fallback" mechanism which may be the most difficult part of the whole thing.</p>  <p>Is there any way this can be achieved with Autofac?</p>  <p>(Also, thanks for reading this epic in the first place!)</p>