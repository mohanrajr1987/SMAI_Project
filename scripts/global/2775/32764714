<p>I'm using Simple Injector with an ASP.NET Web API project, and I want to use different implementations for one interface, depending on the version of REST endpoint used. For example, if v1 of an endpoint is used, <code>IPaymentData</code> should be instantiated with a class called <code>PaymentData</code>, but if v2 is used <code>IPaymentData</code> should be implemented by a class called <code>PaymentDataNew</code>. This is turning out to be problematic!</p>  <p>I don't want to use a composite class like a part of Simple Injector documentation suggests since that means that my code needs to be aware of and take into account the injection framework I'm using (bad).</p>  <p>I noticed in the latest version (3.0) that something called <a href="https://simpleinjector.readthedocs.org/en/latest/advanced.html#context-based-injection" rel="nofollow">"Context based injection"</a> is a feature. Using the <code>container.RegisterConditional</code> function it should be possible to run a delegate each time a type is resolved.</p>  <pre><code>container.RegisterConditional(     typeof(IPaymentData),     c =&gt; ((HttpContext.Current.Items["version"] as string ?? "1")                   == "2") ? typeof(PaymentDataNew) : typeof(PaymentData),         Lifestyle.Scoped,         c =&gt; true         ); </code></pre>  <p>This doesn't seem to work, though, since even though the lifetime is scoped, and the default lifestyle is <code>WebApiRequestLifestyle</code> the delegate which returns the implementation depending on version is only called for the first request that comes in. Subsequent requests skip this (they seem to be using a cached implementation). </p>  <p>Is there something I'm missing? How can I make sure the delegate is called each time a request comes in??</p>