<p>In my controllers, all dependencies are received through injection, following the <a href="https://en.wikipedia.org/wiki/Dependency_inversion_principle" rel="nofollow">Dependency inversion principle</a>, except for one, the Mapper class, which is instantiated by the constructor:</p>  <pre class="lang-c# prettyprint-override"><code>public class HomeController : Controller {     private readonly ISomeAppService SomeAppService;     private readonly Mapper Mapper;      public HomeController(ISomeAppService someAppService)     {         SomeAppService = someAppService;         Mapper = new Mapper();     }      public ActionResult Index()     {         var someList = SomeAppService.GetSomeList();         var someListDTO = Mapper.Map(someList);         return View(new HomeIndexViewModel(someListDTO));     } </code></pre>  <p>The <code>SomeAppService</code> is an Application Layer's Service in front of my Domain Layer. The Mapper receives domain objects and returns DTOs to be used by the view.</p>  <p>My reasoning is that since a <a href="http://stackoverflow.com/questions/11064316/what-is-viewmodel-in-mvc">ViewModel represents only the data that you want to display on your view/page</a>, I can't foresee any situation where I would need to replace a Mapper with something else, or how this could be bad for testing. I also can't see this Mapper class being reused on any other Presentation Layer, since other views can be different from the Web presentation. To me it feels as a part of the Controller.</p>  <p>The question is, is this correct? Do I need to receive the Mapper through dependency injection? Do I need to define an interface for it? And if so, for what reasons? I want to adhere to SOLID principles, but I want to know if and how they apply here.</p>