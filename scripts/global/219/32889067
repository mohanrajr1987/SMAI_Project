<p>I have implemented XOR encryption algorithm like so:</p>  <pre><code>string XOR(string data, const char* key) {     string xorstring = data; //initialize new variable for our xordata     for (int i = 0; i &lt; xorstring.length(); i++) { //for loop for scrambling bits in the string     xorstring[i] = data[i] ^ key[i]; //scrambling the string/descrambling it     }      return xorstring; } </code></pre>  <p>Which works just fine, like: <code>string ciphertext =  XOR("test", "1234");</code> will return the ciphertext and when decrypting:<code>string plaintext = XOR(ciphertext, "1234");</code> it will return 'test'.</p>  <p>So, I wanted to create an algorithm that would break the xor cipher by brute forcing, so basically trying to decrypt the ciphertext with every possible key combination.</p>  <p>It (should) work like this:</p>  <ul> <li>generate strings from an character array of alphabet</li> <li>xor(decrypt) the given ciphertext with the given string to get plaintext</li> <li>after that, xor(encrypt) the generated plaintext and compare it in if statement to see if it matches with the original ciphertext</li> <li>if it matches, the correct key was found to decrypt the ciphertext.</li> </ul>  <p>Simple as that, but I found my self struggling with the algorithm:</p>  <pre><code>const char Numbers[11] = "0123456789"; const char AlphabetUpper[27] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"; const char AlphabetLower[27] = "abcdefghijklmnopqrstuvwxyz";  string XOR(string data, const char* key) {    string xorstring = data; //initialize new variable for our xordata    for (int i = 0; i &lt; xorstring.length(); i++) { //for loop for scrambling   bits in the string     xorstring[i] = data[i] ^ key[i]; //scrambling the string/descrambling it    }    return xorstring;  }   string cipher, plain; //store the ORIGINAL ciphertext and plaintext   int main()  {     plain = "test"; //set the plaintext     cipher = XOR(plain, "1234"); //encrypt it with the xor function      cout &lt;&lt; plain &lt;&lt; endl;  //output     cout &lt;&lt; cipher &lt;&lt; endl; //output      cout &lt;&lt; "press enter to start bruteforcing!" &lt;&lt; endl;     getchar();      while (true) //loop for bruteforcing     {        static int stringlength = 1; //the keylength starts from 1 and then        //expands to 2,3,4,5, etc...        BruteForce(stringlength, cipher, ""); //call the brute force function        stringlength++; //increment the keylength     }     return 0; }  void BruteForce(int length, string ciphertext,  string tempKey) {     static int count = 0; // for counting how many times key was generated     string decipher, recipher; //for storing new XORed strings.     if (length == 0)      {        //decrypt the given ciphertext with the random key        decipher = XOR(ciphertext, tempKey.c_str());        //encrypt it again with the same key for comparison        recipher = XOR(decipher, tempKey.c_str());         cout &lt;&lt; deciphered &lt;&lt; endl; //output         //compare the two ciphertexts        if (ciphertext == recipher)        {          //....           cout &lt;&lt; "Key found! It was: '" &lt;&lt; tempKey &lt;&lt; "'" &lt;&lt; endl;           cout &lt;&lt; "it took " &lt;&lt; count &lt;&lt; " iterations to find the key!";           getchar();        }       return;    }    count++;    //generate the keys.    for (int i = 0; i &lt; 26; i++) {        std::string appended = tempKey + AlphabetLower[i];        BruteForce(length - 1, ciphertext, appended);     }     for (int i = 0; i &lt; 26; i++) {        std::string appended = tempKey + AlphabetUpper[i];        BruteForce(length - 1, ciphertext, appended);      }     for (int i = 0; i &lt; 10; i++) {        std::string appended = tempKey + Numbers[i];        BruteForce(length - 1, ciphertext, appended);    } } </code></pre>  <p>The algorithm does <em>not</em> work, for an unknown reason. </p>  <p>Very bizarre, in theory it should work. When the program is ran, it says the key was found on every execution of the bruteforce() function. Try it your self. Could someone point out that what I am doing wrong here? Help is appreciated. Thanks.</p>