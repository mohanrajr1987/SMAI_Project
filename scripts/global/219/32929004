<p>I've reversed the following algorithm from a challenge binary I'm investigating:</p>  <pre><code>def encrypt(plain):     l = len(plain)     a = 10     cipher = ""      for i in range(0, l):         if i + a &lt; l - 1:             cipher += chr( xor(plain[i], plain[i+a]) )         else:             cipher += chr( xor(plain[i], plain[a]) )          if ord(plain[i]) % 2 == 0: a += 1 # even         else: a -= 1 # odd      return cipher  from binascii import hexlify print hexlify(encrypt("this is a test string")) </code></pre>  <p>Essentially, it XORs each character with another character in the string, offset by <code>a</code>. <code>a</code> initial value is <code>10</code>, as the function iterates over the characters in the string, <code>a +=1</code> if  the character's value is even or <code>a -= 1</code> if it's odd.</p>  <p>I've worked out in my head how to reverse this cipher and retrieve plain text, it would require the use of a recursive function to find out which character offsets are even/odd in the original string. IE: Given the properties of XOR % 2, we now that if <code>cipher[0]</code> is odd then either <code>plain[0]</code> or <code>plain[10]</code> is odd, but not both. Similarly if <code>cipher[0]</code> is even then both <code>plain[0]</code> and <code>plain[10]</code> are even, or both are odd. From there a recursive algorithm should be able to work the rest.</p>  <p>Once we know which characters in plaintext are even/odd, reversing the rest is trivial. I've spent a few hours working this out, but now I'm at loss implementing it.</p>  <p>I've used basic recursive algorithms in the past but never anything that "branches out" to solve something like this.</p>  <p>Given a <code>cipher</code> string resulting from this function, how could we <s>use a recursive algorithm to</s> determine the parity of each character in the original plain string?</p>  <p><strong>EDIT</strong>: Sorry just to be clear and in response to a comment, after scratching my head on this for a few hours I thought the recursion strategy outlined above would be the only way to solve this. If not I'm open to any hints/assistance to solving the title question.</p>