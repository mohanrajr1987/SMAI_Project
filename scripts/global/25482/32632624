<p>I have a table view where two cells have UITextView into which the user can enter long data. Following some answers here in Stackoverflow, I implemented a protocol/delegate to detect when the user has finished entering the data which then will be saved in a global dictionary:</p>  <pre><code>class DetailsNewTaskViewController: UITableViewController, TextViewCellDelegate {  var cellData:[String:String] = [:]   func controllerView(controller: UITableViewCell, textViewDidEndEditing: String, atIndex:Int) {          switch(atIndex) {             case 0:                 self.cellData["titolo"] = (controller as! LittleTextCell).textView.text                 break             case 1:                 self.cellData["oggetto"] = (controller as! BigTextCell).textView.text                 break             default:                 break         }  } </code></pre>  <p>and this is the relative custom cell class:</p>  <pre><code>class LittleTextCell: UITableViewCell, UITextViewDelegate {   @IBOutlet weak var label : UILabel!   @IBOutlet weak var textView : UITextView!   var delegate:TextViewCellDelegate?   var rowIndex:Int?    func textViewDidEndEditing(textView: UITextView) {     delegate?.controllerView(self, textViewDidEndEditing: textView.text, atIndex: rowIndex!)   } } </code></pre>  <p>where the delegate for textView is the class itself. </p>  <p>And this is a screenshot of the application: <a href="http://i.stack.imgur.com/i3lju.png" rel="nofollow"><img src="http://i.stack.imgur.com/i3lju.png" alt="enter image description here"></a></p>  <p>The "problem" is that only AFTER the user taps another cell/field then the text is stored in the global dictionary. What about if the user taps "Fine" button (to save data) without having touched another field after he's finished entering the text? That a fatal nil error is raised. So I would like to know if there is a way to detect that the user has stopped typing in even if he's still inside that cell so that the content is always stored. Is it possible? Is there a particular method to implement?</p>  <p><strong>UPDATE</strong>: the function associated to "Fine" button:</p>  <pre><code>func saveTask(sender:UIButton!) {      self.dateFormatter.dateFormat = "yyyy-MM-dd"      var taskToSave = Task(id: -1,                           titolo: self.cellData["titolo"]!,                           oggetto: self.cellData["oggetto"]!,                           check_mail: self.cellData["check_mail"]!.toBool()!,                           id_progetto: self.projects[self.cellData["progetto_nome"]!]!.id,                           progetto_nome: nil,                           assegnato_a: nil,                           id_assegnato_a: self.users[self.cellData["assegnato_a"]!]!.id,                           richiesto_da: nil,                           id_richiesto_da: self.users[self.cellData["richiesto_da"]!]!.id,                           priorita: self.cellData["priorita"]!,                           termine_consegna: self.dateFormatter.dateFromString(self.cellData["termine_consegna"]!)!,                           stato: self.cellData["stato"]!)        self.taskService.addTaskService(taskToSave) {         (response: String) in          if ((response.rangeOfString("Could not connect to the server.")) != nil) {             dispatch_async(dispatch_get_main_queue()) {                 self.alertView.title = "Operazione fallita!"                 self.alertView.message = "Impossibile connettersi al server. \n Riprovare."                 self.alertView.delegate = self                 self.alertView.addButtonWithTitle("OK")                 self.alertView.show()             }             println(response)         }          else {             if ((response.rangeOfString("status code: 200")) != nil) {                 dispatch_async(dispatch_get_main_queue()) {                     self.alertView.title = "Operazione eseguita!"                     self.alertView.message = "Task creato correttamente"                     self.alertView.delegate = self                     self.alertView.addButtonWithTitle("OK")                     self.alertView.show()                      self.navigationController?.popViewControllerAnimated(true)                 }             }              else {                 println(response)             }          }     } } </code></pre>