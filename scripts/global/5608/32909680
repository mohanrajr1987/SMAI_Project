<p>I store my data in a multilevel nested list. This list may look like this</p>  <pre><code>my.list = list()  my.list[[1]] = list("naive" = list("a"=c(1,1)) ) my.list[[2]] = list("naive" = list("b"=c(2,1)) ) my.list[[3]] = list("naive" = list("c"=c(3,1)) ) my.list[[4]] = list("naive" = list("d"=c(4,1)) ) my.list[[5]] = list("naive" = list("e"=c(5,1)) ) </code></pre>  <p>Now I want to do some operations on the stored values, like selecting the first elements of the 2-d vectors and combine them in another vector. Of course this can be done like the following</p>  <pre><code>foo = c(my.list[[1]][["naive"]][[1]][1],         my.list[[2]][["naive"]][[1]][1],         my.list[[3]][["naive"]][[1]][1],         my.list[[4]][["naive"]][[1]][1],         my.list[[5]][["naive"]][[1]][1]) </code></pre>  <p>But this is really awkward if I have many more than 5 first level sublists. And I have the same feeling about for-looping through <code>K</code> in <code>my.list[[K]][["naive"]][[1]][1]</code>, <code>K=1:5</code>.</p>  <p>The suggestions provided for similar questions using neat <code>mapply</code>, <code>Reduce</code>, <code>sapply</code> cannot be applied directly due to presence of the <code>"naive"</code> second level sublist.</p>  <p>Can someone help we with a clever and instructive solution, where values stored according to such multilevel list structure can be concatenated, added to each other or both? In example above, the final desired result could be adding respective components for all vectors, and storing the result in a new 2-d vector, that in this case would be <code>foo = c(15,5)</code>. Your answer would help me a lot.</p>