<p>I'm building a class which uses Winsock2 functions. The problem I have is that the linker can't resolve winsock functions (bind, closesocket, etc) because I wrapped the class inside a namespace. If I try to remove the namespace wrapper then it works, but then I can't code properly my class inside a namespace.</p>  <p>My question is: Is there a namespace that I can use to prefix winsock API functions in order to work inside a namespace?</p>  <h2>See the example.</h2>  <h2>In Header file:</h2>  <pre><code>namespace MyNamespace {   class Server   {     ...     BOOL Init()     ...   }   ... } </code></pre>  <h2>In Cpp file:</h2>  <pre><code>namespace MyNamespace {   ...   BOOL Server::Init()   {     ...     int bindResult = ::bind(ListenSocket, (struct sockaddr *) &amp;Address, sizeof(Address));     ...   }   ... } </code></pre>  <p>Thanks in advance!</p>  <h1>Edit</h1>  <p>I created a test console application to replicate the issue. If you compile it says: "TestNamespaces.obj : error LNK2019: external symbol __imp__closesocket@4 can't resolve ..." "TestNamespaces.obj : error LNK2019: external symbol __imp__WSASocketW@24 can't resolve ..."</p>  <h2>DemoIssueNamespace.cpp file:</h2>  <pre><code>#include "stdafx.h" #include "TestNamespaces.h"  int main() {     using namespace TestNamespace;     TestNamespacesClass *object;     object = new TestNamespacesClass();     return 0; } </code></pre>  <h2>TestNamespace.h file:</h2>  <pre><code>#pragma once #include "stdafx.h"  #include &lt;WinSock2.h&gt;  namespace TestNamespace {     class TestNamespacesClass     {     private:         SOCKET m_socket;     public:         TestNamespacesClass();         ~TestNamespacesClass();     }; } </code></pre>  <h2>TestNamespaces.cpp file:</h2>  <pre><code>#include "stdafx.h" #include "TestNamespaces.h"  namespace TestNamespace {     TestNamespacesClass::TestNamespacesClass()     {         m_socket = WSASocket(AF_INET, SOCK_STREAM, 0, NULL, 0, WSA_FLAG_OVERLAPPED);     }     TestNamespacesClass::~TestNamespacesClass()     {         closesocket(m_socket);     } } </code></pre>