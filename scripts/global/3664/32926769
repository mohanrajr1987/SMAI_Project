<p>propably this question was asked before but I found nothing about it so far.</p>  <p>Suppose I have some code in a file called test.py (that was a result from my question yesterday <a href="http://stackoverflow.com/questions/32903967/wrapping-np-arrays-pow-method">Wrapping np.arrays __pow__ method</a>)</p>  <pre><code>import numpy as np from functools import wraps, reduce  #Create a subclass of np.ndarray to speed up the power operation class MyArray(np.ndarray):   def __pow__(self, other):     return reduce(lambda x,y: x*y, [self for _ in range(other)])  #Create a wrapper so that arrays are created using my Class instead of the old one.     def change_ndarray(func):   @wraps(func)   def wrapper(*args, **kwargs):     return func(*args, **kwargs).view(MyArray)   return wrapper      np.array = change_ndarray(np.array) </code></pre>  <p>So far it worked great in my file every array was produced using the wrapped np.array. But then to compare the speed gain I was confused:</p>  <pre><code>&gt;&gt;&gt; import numpy as np &gt;&gt;&gt; %timeit np.linspace(10,1000,1000000)**3 10 loops, best of 3: 154 ms per loop &gt;&gt;&gt; import test &gt;&gt;&gt; %timeit np.linspace(10,1000,1000000)**3 10 loops, best of 3: 40.6 ms per loop </code></pre>  <p>How come the linspace now works with the wrapped ndarray instead of the old one? How does it come that <code>np.linspace</code> now calls <code>t.np.array</code>? I thought that was another namespace and what does linspace have to do with np.array?</p>  <p>As a note I read through <a href="https://docs.python.org/3/reference/import.html" rel="nofollow">https://docs.python.org/3/reference/import.html</a> but that's really tough reading and so maybe I have missed it in there. I would be happy if anyone could give me a push in the right direction.</p>