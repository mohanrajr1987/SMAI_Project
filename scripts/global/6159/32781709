<p>I have a dialog window containing check-boxes, when each of them is checked a particular class needs to be instantiated and a run a a task on a separated thread (one for each check box). I have 14 check-boxes to check the <code>.isChecked()</code> property and is comprehensible checking the returned Boolean for each of them is not efficient and requires a lot more coding. </p>  <p>Hence I decided to get all the children items corresponding to check-box element, get just those that are checked, appending their names to list and loop through them matching their name to d dictionary which key is the name of the check box and the value is the corresponding class to instantiate.</p>  <p><strong>EXAMPLE:</strong></p>  <pre><code># class dictionary       self.summary_runnables = {'dupStreetCheckBox': [DupStreetDesc(),0],                               'notStreetEsuCheckBox': [StreetsNoEsuDesc(),1],                               'notType3CheckBox': [Type3Desc(False),2],                               'incFootPathCheckBox': [Type3Desc(True),2],                               'dupEsuRefCheckBox': [DupEsuRef(True),3],                               'notEsuStreetCheckBox': [NoLinkEsuStreets(),4],                               'invCrossRefCheckBox': [InvalidCrossReferences()],                               'startEndCheckBox': [CheckStartEnd(tol=10),8],                               'tinyEsuCheckBox': [CheckTinyEsus("esu",1)],                               'notMaintReinsCheckBox': [CheckMaintReins()],                               'asdStartEndCheckBox': [CheckAsdCoords()],                               'notMaintPolysCheckBox': [MaintNoPoly(),16],                               'notPolysMaintCheckBox': [PolyNoMaint()],                               'tinyPolysCheckBox': [CheckTinyEsus("rd_poly",1)]}   # looping through list     self.long_task = QThreadPool(None).globalInstance()     self.long_task.setMaxThreadCount(1)     start_report = StartReport(val_file_path)     end_report = EndReport()     # start_report.setAutoDelete(False)     # end_report.setAutoDelete(False)     end_report.signals.result.connect(self.log_progress)     end_report.signals.finished.connect(self.show_finished)     # end_report.setAutoDelete(False)     start_report.signals.result.connect(self.log_progress)     self.long_task.start(start_report)     # print str(self.check_boxes_names)     for check_box_name in self.check_boxes_names:         run_class = self.summary_runnables[check_box_name]         if run_class[0].__class__.__name__ is 'CheckStartEnd':             run_class[0].tolerance = tolerance         runnable = run_class[0]()         runnable.signals.result.connect(self.log_progress)         self.long_task.start(runnable)     self.long_task.start(end_report) </code></pre>  <p><strong>example of a runnable (even if some of them use different global functions)</strong></p>  <p>I  can't post the global functions that write content to file as they are too many and not all 14 tasks execute the same type  function. arguments of these functions are int keys to other dictionaries that contain the report static content and the SQL queries to return report main dynamic contents.</p>  <pre><code>class StartReport(QRunnable):      def __init__(self, file_path):         super(StartReport,self).__init__()         # open the db connection in thread         db.open()         self.signals = GeneralSignals()         # self.simple_signal = SimpleSignal()         # print self.signals.result         self.file_path = file_path         self.task = "Starting Report"         self.progress = 1         self.org_name = org_name         self.user = user         self.report_title = "Validation Report"         print "instantiation of start report "      def run(self):         self.signals.result.emit(self.task, self.progress)         if self.file_path is None:             print "I started and found file none "             return         else:             global report_file             # create the file and prints the header             report_file = open(self.file_path, 'wb')             report_file.write(str(self.report_title) + ' for {0} \n'.format(self.org_name))             report_file.write('Created on : {0} at {1} By : {2} \n'.format(datetime.today().strftime("%d/%m/%Y"),                                                                                 datetime.now().strftime("%H:%M"),                                                                                 str(self.user)))             report_file.write(                 "------------------------------------------------------------------------------------------ \n \n \n \n")             report_file.flush()             os.fsync(report_file.fileno())   class EndReport(QRunnable):      def __init__(self):         super(EndReport,self).__init__()         self.signals = GeneralSignals()         self.task = "Finishing report"         self.progress = 100       def run(self):         self.signals.result.emit(self.task, self.progress)         if report_file is not None:             # write footer and close file             report_file.write("\n \n \n")             report_file.write("---------- End of Report -----------")             report_file.flush()             os.fsync(report_file.fileno())             report_file.close()             self.signals.finished.emit()             # TODO: checking whether opening a db connection in thread might affect the db on the GUI             # if db.isOpen():             #     db.close()         else:             return   class DupStreetDesc(QRunnable):     """     duplicate street description report section creation     :return: void if the report is to text             list[string] if the report is to screen     """     def __init__(self):         super(DupStreetDesc,self).__init__()         self.signals = GeneralSignals()         self.task = "Checking duplicate street descriptions..."         self.progress = 16.6      def run(self):         self.signals.result.emit(self.task,self.progress)         if report_file is None:             print "report file is none "             # items_list = write_content(0, 0, 0, 0)             # for item in items_list:                  # self.signals.list.emit(item)         else:             write_content(0, 0, 0, 0) </code></pre>  <p>Now, I used this approach before and it has always worked fine without using multiprocessing. In this case it works good to some extent, I can run the tasks the first time but if I try to run for the second time I get the following Python Error :</p>  <pre><code>self.long_task.start(run_class[0]) RuntimeError: wrapped C/C++ object of type DupStreetDesc has been deleted </code></pre>  <p>I tried to use <code>run_class[0].setAutoDelete(False)</code> before running them in the loop but pyQt crashes with a minidump error (I am running the code in QGIS) and I the programs exists with few chances to understand what has happened.</p>  <p>On the other hand, if I run my classes separately, checking with an if else statement each check-box, then it works fine, I can run the tasks again and the C++ classes are not deleted, but it isn't a nice coding approach, at least from my very little experience.</p>  <p>Is there anyone else out there who can advise a different approach in order to make this run smoothly without using too many lines of code? Or knows whether there is a more efficient pattern to handle this problem, which I think must be quite common?</p>