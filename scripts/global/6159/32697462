<p>I am implementing a series of threaded tasks to write a text report file, the report consists of different sections. I have two common functions (write header, write content) that are executed for each section of the report and I am using Qthread pool/QRunnable to run the write to file process separately from the main GUI application. The approach seems to work fine as long as the tasks are defined inside the run method but my program crashes (I get a SQLITE db error) as soon as I try to invoke a global function from the run method of every class of QRunnable (corresponding to each report section).</p>  <p>EXAMPLE:</p>  <pre><code>class Application:  def report_to_file(self,file_path):     self.report.file_path = val_file_path     self.long_task = QThreadPool()     self.long_task.setMaxThreadCount(1)     start_report = StartReport(val_file_path)     check_dups = DupStreetDesc()     third_section = ThirdSection()     start_report.signals.result.connect(self.process_results)     check_dups.signals.result.connect(self.process_results)     third_section.result.connect(self.process_results)     self.long_task.start(start_report)     self.long_task.start(check_dups)     self.long_task.start(third_section)     self.long_task.waitForDone()  def process_results(self):     print "the task has been executed successfully!"  def finished(self):     QMessageBox.information(self.validation_dia,"Message","Task finished") </code></pre>  <p>In another module I have my Runnables and writing functions as globals (not wrapped inside a class)</p>  <pre><code>global report_file global queries  def write_content(query_id, header_id, header_no_content_id, columns_name_id, include_footpaths=True, include_subtitle=False):      # in here I query the db and write text into the file, this function is used from all the Qrunnable classes   def write_headers(section_header, include_footpaths=False, include_subtitle=False):      # here I write other content to the same file ,this function is used from all the Qrunnable classes    class StartReport(QRunnable):  def __init__(self, file_path):     super(StartReport,self).__init__()     self.signals = GeneralSignals()     self.file_path = file_path     self.task = "Starting the Report"     # print "on report start report file is " + str(self.report_file)     self.org_name = org_name     self.user = user     self.report_title = "Roadnet Validation Report"     global progress_win     self.progress_win = progress_win     self.progress_win.setLabelText("Report Initialisation")     self.progress_win.show()  def run(self):     if self.file_path is None:         return     else:         global report_file         # create the file and prints the header         report_file = open(self.file_path, 'wb')         report_file.write(str(self.report_title) + ' for {0} \n'.format(self.org_name))         report_file.write('Created on : {0} at {1} By : {2} \n'.format(datetime.today().strftime("%d/%m/%Y"),                                                                             datetime.now().strftime("%H:%M"),                                                                             str(self.user)))         report_file.write(             "------------------------------------------------------------------------------------------ \n \n \n \n")         self.signals.result.emit(self.task) </code></pre>  <p><strong>in the case above the function runs because everything happens inside the run method</strong>    </p>  <p><strong>In the case below the process crashes when entering the global function</strong> </p>  <pre><code>class DupStreetDesc(QRunnable):     """     duplicate street description report section creation     :return: void if the report is to text             list[string] if the report is to screen     """     def __init__(self):         # print(StartReport.report_file)         self.signals = GeneralSignals()         self.task = "Checking duplicate street descriptions..."         super(DupStreetDesc,self).__init__()         # report_file         # self.report_file = report_file         global progress_win         self.progress_win = progress_win         self.progress_win.setLabelText("Checking duplicate street descriptions...")     def run(self):         global report_file         global queries         print "I run " + " report file is " + str(report_file)         print " these are queries " + str(queries)         print " this is the connection " + str(db)         if report_file is None:             items_list = write_content(0, 0, 0, 0)             self.progress_win.setValue(1)             return items_list         else:             # here is where I call the global functions             write_headers(0)             write_content(0, 0, 0, 0)             progress_win.setValue(1)         self.signals.result.emit(self.task)  class GeneralSignals(QObject):     result = pyqtSignal(str) </code></pre>  <p>I am new to this Qthread pool class in Pyqt and in all examples I have seen so far functions are run inside the run method without invoking any external function. I don't know if it is possible, can anyone tell me the right approach to accomplish this?</p>