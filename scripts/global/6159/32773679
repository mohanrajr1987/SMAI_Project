<p><strong>Short version</strong></p>  <p>I have a <code>QTreeView</code> and want users to have fine-grained control over the appearance of text, giving them rich-text formatting options. I already have it so entire items can be selected for formatting (e.g., as bold), but I need more flexibility. For instance, the user must be able to highlight <em>parts</em> of an item's text and embolden it.</p>  <p>Note I am using <code>QStandardItemModel</code> (see SSCCE below).</p>  <p><strong>Detailed version</strong></p>  <p>To embolden an entire item is simple:</p>  <pre><code>itemFont = item.font() itemFont.setBold(True) item.setFont(itemFont)  </code></pre>  <p>Unfortunately, my users need more fine-grained control, so instead of</p>  <blockquote>   <p><strong>Hi how are you?</strong></p> </blockquote>  <p>they should be able to select just the first word using their mouse and make that item's text appear as:</p>  <blockquote>   <p><strong>Hi</strong> how are you?</p> </blockquote>  <p>Two options I am considering are:</p>  <ol> <li><p><strong>setIndexWidget</strong></p>  <p>In each cell where I need this functionality, display it as a <code>QTextEdit</code> widget using <code>setIndexWidget</code>, something like was done here:  <a href="http://stackoverflow.com/questions/15283677/to-set-widgets-on-children-items-on-qtreeview">To set widgets on children items on QTreeView</a>. Then I could use the standard tools for rich text editing in each cell.</p></li> <li><p><strong>Custom delegate</strong></p>  <p>Use a custom delegate to paint each item where I need this functionality, something like what was applied here: <a href="http://stackoverflow.com/questions/1956542/how-to-make-item-view-render-rich-html-text-in-qt">How to make item view render rich (html) text in Qt</a></p></li> </ol>  <p>Note unlike that question, I'm not just asking how to render rich text, but how to let the user <em>select text</em> and have it rendered as rich text on a fine-grained scale.</p>  <p><strong>Update</strong></p>  <p>I just reviewed Summerfield's PyQt book, and realize he pretty much implements exactly what I want in Chapter 14 using a custom delegate whose editor includes a <code>QTextEdit</code> line editor with rich text capabilities (from chapter 13) for editing the relevant column. This clearly seems the way to go (i.e., option 2 above).</p>  <p>I am in the process of implementing it in the context of my SSCCE. There are a few wrinkles I'm working on so it will be a few days. The curious should check out the <code>ships-delegate</code> example from Chapter 14 of his book.</p>  <p><strong>SSCCE</strong></p>  <pre><code>from PySide import QtGui, QtCore import sys  class MainTree(QtGui.QMainWindow):     def __init__(self, tree, parent = None):         QtGui.QMainWindow.__init__(self)         self.setAttribute(QtCore.Qt.WA_DeleteOnClose)          self.setCentralWidget(tree)         self.createStatusBar()         self.createBoldAction()         self.createToolbar()      def createStatusBar(self):                                   self.status = self.statusBar()         self.status.setSizeGripEnabled(False)         self.status.showMessage("Ready")      def createToolbar(self):         self.textToolbar = self.addToolBar("Text actions")         self.textToolbar.addAction(self.boldTextAction)      def createBoldAction(self):         self.boldTextAction = QtGui.QAction("Bold", self)         self.boldTextAction.setIcon(QtGui.QIcon("boldText.png"))         self.boldTextAction.triggered.connect(self.emboldenText)         self.boldTextAction.setStatusTip("Make selected text bold")      def emboldenText(self):         print "Make selected text bold...How do I do this?"   class SimpleTree(QtGui.QTreeView):     def __init__(self, parent = None):             QtGui.QTreeView.__init__(self)         model = QtGui.QStandardItemModel()         model.setHorizontalHeaderLabels(['Title', 'Summary'])         rootItem = model.invisibleRootItem()         item0 = [QtGui.QStandardItem('Title0'), QtGui.QStandardItem('Summary0')]         item00 = [QtGui.QStandardItem('Title00'), QtGui.QStandardItem('Summary00')]         rootItem.appendRow(item0)         item0[0].appendRow(item00)                   self.setModel(model)         self.expandAll()   def main():     app = QtGui.QApplication(sys.argv)     myTree = SimpleTree()     #myTree.show()     myMainTree = MainTree(myTree)     myMainTree.show()     sys.exit(app.exec_())  if __name__ == "__main__":     main() </code></pre>