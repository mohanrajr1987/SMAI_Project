<p>I am getting confused with standard library transform when applied to a vector of unique_ptr. I have defined a binary functor addScalar that take 2 const references to unique_ptr and return a const reference to a unique_ptr in order to avoid copying (that is forbidden with unique_ptr). </p>  <p>I then try to use it in a std::transform, but it seems impossible for unique_ptr do undergo binary operation at all, in spite of all my precautions to avoid unique_ptr copying...</p>  <p>Has anybody an idea of how to use std::transform with std::unique_ptr ? Or am I obliged to run through the vector with a for-loop and perform the addition "manually" ? I am also wondering if I could use <code>unique_ptr&lt;const Scalar&gt;</code> in my functor.</p>  <p>Here is my class :</p>  <pre><code>#include "space.h" #include "scalar.h" #include &lt;vector&gt; #include &lt;algorithm&gt; #include &lt;memory&gt;  using std::vector; using std::ostream; using std::unique_ptr;  class addScalar {    public:       unique_ptr&lt;Scalar&gt; const&amp; operator()(unique_ptr&lt;Scalar&gt; const&amp; scal1, unique_ptr&lt;Scalar&gt; const&amp; scal2)       {          *scal1 += *scal2;          return scal1;       }; };  class Tensor4D {    public:       Tensor4D(Space&amp; space_in, int ncomp);       Tensor4D(const Tensor4D&amp; tens);       Tensor4D&amp; operator=(const Tensor4D&amp; tens);       size_t size() const {return comp.size();};       ~Tensor4D();    protected:       Space* const space;       vector&lt;unique_ptr&lt;Scalar&gt;&gt; comp;    public:       Tensor4D&amp; operator+=(const Tensor4D&amp; tens); }; </code></pre>  <p>and here is the implementation of operator+= :</p>  <pre><code>Tensor4D&amp; Tensor4D::operator+=(const Tensor4D&amp; tens) {    assert(comp.size() == tens.comp.size());    transform(tens.comp.begin(), tens.comp.end(), comp.begin(), tens.comp.begin(), addScalar());    return *this; } </code></pre>  <p>I get the following ugly compiler errors :</p>  <pre><code>/usr/include/c++/4.8/bits/stl_algo.h: In instantiation of ‘_OIter std::transform(_IIter1, _IIter1, _IIter2, _OIter, _BinaryOperation) [with _IIter1 = __gnu_cxx::__normal_iterator&lt;const std::unique_ptr&lt;Scalar&gt;*, std::vector&lt;std::unique_ptr&lt;Scalar&gt; &gt; &gt;; _IIter2 = __gnu_cxx::__normal_iterator&lt;std::unique_ptr&lt;Scalar&gt;*, std::vector&lt;std::unique_ptr&lt;Scalar&gt; &gt; &gt;; _OIter = __gnu_cxx::__normal_iterator&lt;const std::unique_ptr&lt;Scalar&gt;*, std::vector&lt;std::unique_ptr&lt;Scalar&gt; &gt; &gt;; _BinaryOperation = addScalar]’: tensor4D.C:44:94:   required from here /usr/include/c++/4.8/bits/stl_algo.h:4965:12: error: no match for ‘operator=’ (operand types are ‘const std::unique_ptr&lt;Scalar&gt;’ and ‘const std::unique_ptr&lt;Scalar&gt;’)   *__result = __binary_op(*__first1, *__first2);         ^ /usr/include/c++/4.8/bits/stl_algo.h:4965:12: note: candidates are: In file included from /usr/include/c++/4.8/memory:81:0,              from /home/gmartinon/Kadath/C++/Include/scalar.h:27,              from tensor4D.h:5,              from tensor4D.C:1: /usr/include/c++/4.8/bits/unique_ptr.h:190:7: note: std::unique_ptr&lt;_Tp, _Dp&gt;&amp; std::unique_ptr&lt;_Tp, _Dp&gt;::operator=(std::unique_ptr&lt;_Tp, _Dp&gt;&amp;&amp;) [with _Tp = Scalar; _Dp = std::default_delete&lt;Scalar&gt;]    operator=(unique_ptr&amp;&amp; __u) noexcept    ^ /usr/include/c++/4.8/bits/unique_ptr.h:190:7: note:   no known conversion for argument 1 from ‘const std::unique_ptr&lt;Scalar&gt;’ to ‘std::unique_ptr&lt;Scalar&gt;&amp;&amp;’ /usr/include/c++/4.8/bits/unique_ptr.h:203:2: note: template&lt;class _Up, class _Ep&gt; typename std::enable_if&lt;std::__and_&lt;std::is_convertible&lt;typename std::unique_ptr&lt;_Up, _Ep&gt;::pointer, typename std::unique_ptr&lt;_Tp, _Dp&gt;::_Pointer::type&gt;, std::__not_&lt;std::is_array&lt;_Up&gt; &gt; &gt;::value, std::unique_ptr&lt;_Tp, _Dp&gt;&amp;&gt;::type std::unique_ptr&lt;_Tp, _Dp&gt;::operator=(std::unique_ptr&lt;_Up, _Ep&gt;&amp;&amp;) [with _Up = _Up; _Ep = _Ep; _Tp = Scalar; _Dp = std::default_delete&lt;Scalar&gt;]   operator=(unique_ptr&lt;_Up, _Ep&gt;&amp;&amp; __u) noexcept   ^ /usr/include/c++/4.8/bits/unique_ptr.h:203:2: note:   template argument deduction/substitution failed: In file included from /usr/include/c++/4.8/algorithm:62:0,              from tensor4D.h:8,              from tensor4D.C:1: /usr/include/c++/4.8/bits/stl_algo.h:4965:12: note:   types ‘std::unique_ptr&lt;_Tp, _Dp&gt;’ and ‘const std::unique_ptr&lt;Scalar&gt;’ have incompatible cv-qualifiers   *__result = __binary_op(*__first1, *__first2);         ^ In file included from /usr/include/c++/4.8/memory:81:0,              from /home/gmartinon/Kadath/C++/Include/scalar.h:27,              from tensor4D.h:5,              from tensor4D.C:1: /usr/include/c++/4.8/bits/unique_ptr.h:211:7: note: std::unique_ptr&lt;_Tp, _Dp&gt;&amp; std::unique_ptr&lt;_Tp, _Dp&gt;::operator=(std::nullptr_t) [with _Tp = Scalar; _Dp = std::default_delete&lt;Scalar&gt;; std::nullptr_t = std::nullptr_t]        operator=(nullptr_t) noexcept        ^ /usr/include/c++/4.8/bits/unique_ptr.h:211:7: note:   no known conversion for argument 1 from ‘const std::unique_ptr&lt;Scalar&gt;’ to ‘std::nullptr_t’ /usr/include/c++/4.8/bits/unique_ptr.h:274:19: note: std::unique_ptr&lt;_Tp, _Dp&gt;&amp; std::unique_ptr&lt;_Tp, _Dp&gt;::operator=(const std::unique_ptr&lt;_Tp, _Dp&gt;&amp;) [with _Tp = Scalar; _Dp = std::default_delete&lt;Scalar&gt;] &lt;near match&gt;    unique_ptr&amp; operator=(const unique_ptr&amp;) = delete;                ^ /usr/include/c++/4.8/bits/unique_ptr.h:274:19: note:   no known conversion for implicit ‘this’ parameter from ‘const std::unique_ptr&lt;Scalar&gt;*’ to ‘std::unique_ptr&lt;Scalar&gt;*’ </code></pre>