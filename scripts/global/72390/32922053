<p>I have a class that has function pointer to kernel function, that can change from outside.</p>  <pre><code>class Bar  {    public:      int i; }  class Foo  {    public:      std::function&lt;double()&gt; kernel;      Bar bar;          };  int main() {    Foo f;   f.kernel = []() -&gt; double { return i * i; }; //this is not working obviously  } </code></pre>  <p>How can I achieve behaviour that is "presented", eg. read class variables inside lambda. I can bypass it by passing <code>f</code> inside and write <code>f.bar.i</code>, but that is not very nice solution.</p>