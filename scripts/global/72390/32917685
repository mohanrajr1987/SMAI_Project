<p>I'm really banging my head here, because the below code worked for hours, until I started getting an error out of the blue.</p>  <pre><code>#include &lt;iostream&gt; #include &lt;string&gt; #include &lt;functional&gt; #include &lt;algorithm&gt;  template&lt;typename ret_t&gt; ret_t get_num(const std::string &amp;prompt = "",             const std::string &amp;error = "",                 const std::function&lt;bool(ret_t)&gt; &amp;condition = [] { return true; })                             //default value of &amp;conditon is just a lambda that returns true  {     //....not complete function     ret_t num = 0;     std::cin &gt;&gt; num;      if (condition(num))         return num;      std::cerr &lt;&lt; error;     return get_num&lt;ret_t&gt;(prompt, error, condition); }  int main() {     //it works fine if I supply the third argument     int number = get_num&lt;int&gt;("Enter num: ", "Bad input! ", [](int num) { return num &gt; 0; });      //this gives me an error, while it should run      //fine and the condition should always evaluate to true     int number2 = get_num&lt;int&gt;("Enter num2: ", "Bad input! ");      std::cout &lt;&lt; number;      std::cin.ignore();     std::cin.get(); } </code></pre>  <p>Everything works fine if I specify the type of the of a variable that the lambda takes (no matter what type it is):</p>  <pre><code>template&lt;typename ret_t&gt; ret_t get_num(const std::string &amp;prompt = "",             const std::string &amp;error = "",                 const std::function&lt;bool(ret_t)&gt; &amp;condition = [] (ret_t) { return true; }) </code></pre>  <p>Also, even if I don't specify the default value of &amp;condition with a lambda, but instead if I use a normal function like below, it still does not work:</p>  <pre><code>bool func() {     return true; }  template&lt;typename ret_t&gt; ret_t get_num(const std::string &amp;prompt = "",             const std::string &amp;error = "",                 const std::function&lt;bool(ret_t)&gt; &amp;condition = func) </code></pre>