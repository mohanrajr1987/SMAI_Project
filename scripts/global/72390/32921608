<p>Here is the problem I was thinking about lately. Let's say our interface is a member function that returns object which is expensive to copy and cheap to move (std::string, std::vector, et cetera). Some implementations may compute the result and return a temporary object while others may simply return a member object.</p>  <p>Sample code to illustrate:</p>  <pre><code>// assume the interface is: Vec foo() const // Vec is cheap to move but expensive to copy  struct RetMember {     Vec foo() const { return m_data; }     Vec m_data;     // some other code }  struct RetLocal {     Vec foo() const {         Vec local = /*some computation*/;         return local;     } }; </code></pre>  <p>There are also various "clients". Some only read the data, some require an ownership.</p>  <pre><code>void only_reads(const Vec&amp;) { /* some code */ } void requires_ownership(Vec) { /* some code */ } </code></pre>  <p>Code above composes well, but is not as efficient as it could be. Here are all combinations:</p>  <pre><code>RetMember retmem; RetLocal retloc;  only_reads(retmem.foo()); // unnecessary copy, bad only_reads(retloc.foo()); // no copy, good  requires_ownership(retmem.foo()); // copy, good requires_ownership(retloc.foo()); // no copy, good </code></pre>  <p>What is a good way to fix this situation?</p>  <p>I came up with two ways, but I'm sure there is a better solution.</p>  <p>In my first attempt I wrote a DelayedCopy wrapper that holds either a value of T or a pointer to const T. It is very ugly, requires extra effort, introduces redundant moves, gets in the way of copy elision and probably has many other problems.</p>  <p>My second thought was a <a href="https://en.wikipedia.org/wiki/Continuation-passing_style" rel="nofollow">continuation-passing style</a>, which works quite well but turns member functions into member function templates. I know, there is std::function, but it has its overhead so performance-wise it may be unacceptable.</p>  <p>Sample code:</p>  <pre><code>#include &lt;boost/variant/variant.hpp&gt; #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;type_traits&gt;  struct Noisy {    Noisy() = default;   Noisy(const Noisy &amp;) { std::puts("Noisy: copy ctor"); }   Noisy(Noisy &amp;&amp;) { std::puts("Noisy: move ctor"); }    Noisy &amp;operator=(const Noisy &amp;) {     std::puts("Noisy: copy assign");     return *this;   }   Noisy &amp;operator=(Noisy &amp;&amp;) {     std::puts("Noisy: move assign");     return *this;   } };  template &lt;typename T&gt; struct Borrowed {   explicit Borrowed(const T *ptr) : data_(ptr) {}   const T *get() const { return data_; }  private:   const T *data_; };  template &lt;typename T&gt; struct DelayedCopy { private:   using Ptr = Borrowed&lt;T&gt;;   boost::variant&lt;Ptr, T&gt; data_;    static_assert(std::is_move_constructible&lt;T&gt;::value, "");   static_assert(std::is_copy_constructible&lt;T&gt;::value, "");  public:   DelayedCopy() = delete;    DelayedCopy(const DelayedCopy &amp;) = delete;   DelayedCopy &amp;operator=(const DelayedCopy &amp;) = delete;    DelayedCopy(DelayedCopy &amp;&amp;) = default;   DelayedCopy &amp;operator=(DelayedCopy &amp;&amp;) = default;    DelayedCopy(T &amp;&amp;value) : data_(std::move(value)) {}   DelayedCopy(const T &amp;cref) : data_(Borrowed&lt;T&gt;(&amp;cref)) {}    const T &amp;ref() const { return boost::apply_visitor(RefVisitor(), data_); }    friend T take_ownership(DelayedCopy &amp;&amp;cow) {     return boost::apply_visitor(TakeOwnershipVisitor(), cow.data_);   }  private:   struct RefVisitor : public boost::static_visitor&lt;const T &amp;&gt; {     const T &amp;operator()(Borrowed&lt;T&gt; ptr) const { return *ptr.get(); }     const T &amp;operator()(const T &amp;ref) const { return ref; }   };    struct TakeOwnershipVisitor : public boost::static_visitor&lt;T&gt; {     T operator()(Borrowed&lt;T&gt; ptr) const { return T(*ptr.get()); }     T operator()(T &amp;ref) const { return T(std::move(ref)); }   }; };  struct Bar {   Noisy data_;    auto fl() -&gt; DelayedCopy&lt;Noisy&gt; { return Noisy(); }   auto fm() -&gt; DelayedCopy&lt;Noisy&gt; { return data_; }    template &lt;typename Fn&gt; void cpsl(Fn fn) { fn(Noisy()); }   template &lt;typename Fn&gt; void cpsm(Fn fn) { fn(data_); } };  static void client_observes(const Noisy &amp;) { std::puts(__func__); } static void client_requires_ownership(Noisy) { std::puts(__func__); }  int main() {   Bar a;    std::puts("DelayedCopy:");   auto afl = a.fl();   auto afm = a.fm();    client_observes(afl.ref());   client_observes(afm.ref());    client_requires_ownership(take_ownership(a.fl()));   client_requires_ownership(take_ownership(a.fm()));    std::puts("\nCPS:");    a.cpsl(client_observes);   a.cpsm(client_observes);    a.cpsl(client_requires_ownership);   a.cpsm(client_requires_ownership); } </code></pre>  <p>Output:</p>  <pre><code>DelayedCopy: Noisy: move ctor client_observes client_observes Noisy: move ctor Noisy: move ctor client_requires_ownership Noisy: copy ctor client_requires_ownership  CPS: client_observes client_observes client_requires_ownership Noisy: copy ctor client_requires_ownership </code></pre>  <p>Are there better techniques to pass values that avoid extra copies yet are still general (allow returning both temporaries and data members)?</p>  <p>On a side note: the code was compiled with g++ 5.2 and clang 3.7 in C++11. In C++14 and C++1z DelayedCopy doesn't compile and I'm not sure whether it's my fault or not.</p>