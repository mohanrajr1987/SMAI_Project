<p><code>std::tuple</code> is highly template-loaded beast. To access to n-th member compiler must perform a plenty of template instantiations, although its simple nature: access to n-th data member of corresponding imaginary struct. It seems that <code>std::tuple</code> should be a core language feature, something like this (pseudocode):</p>  <pre><code>template&lt; typename ...types &gt; struct/* or class, or even union */ V {     types... V; // defines implicitly `operator [/*constant expression*/]` to access by index     // if more than one variadic parameter pack provided     // (during expanding of parameter pack of template      // parameters in specializations) then instead of     // `V` there can be specific data-member name (say, `x`),     // but still with `x.operator []` implicitly defined      // member functions and data members allowed };  V&lt; int, double, bool &gt; v{1, 0.0, false}; static_assert(std::is_same&lt; decltype(v[0]), int &gt;{}); static_assert(std::is_same&lt; decltype(v[1]), double &gt;{}); static_assert(std::is_same&lt; decltype(v[2]), bool &gt;{});  template&lt; typename ...types &gt; V&lt; types... &gt; ctor(types &amp;&amp;... args) { return {std::forward&lt; types &gt;(args)...}; }  auto f = 0.0; auto const b = false; auto w = ctor(1, f, b, std::move(b)); static_assert(std::is_same&lt; decltype(w[0]), int &gt;{}); static_assert(std::is_same&lt; decltype(w[1]), double &amp; &gt;{}); static_assert(std::is_same&lt; decltype(w[2]), bool const &amp; &gt;{}); static_assert(std::is_same&lt; decltype(w[3]), bool const &gt;{}); </code></pre>  <p>Is there any proposal of something like language supported variadic data-members definition syntax for classes?</p>