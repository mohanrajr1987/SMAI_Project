<p>Given</p>  <pre><code>template &lt;typename...&gt; struct Pack; using T1 = std::tuple&lt;int, char, double&gt;; using T2 = std::tuple&lt;bool, double, int, char&gt;; </code></pre>  <p><code>TupleTree&lt;Pack, T1, T2&gt;</code> shall be</p>  <pre><code>Pack&lt;     Pack&lt;int, bool&gt;, Pack&lt;int, double&gt;, Pack&lt;int, int&gt;, Pack&lt;int, char&gt;,     Pack&lt;char, bool&gt;, Pack&lt;char, double&gt;, Pack&lt;char, int&gt;, Pack&lt;char, char&gt;,     Pack&lt;double, bool&gt;, Pack&lt;double, double&gt;, Pack&lt;double, int&gt;, Pack&lt;double, char&gt; &gt; </code></pre>  <p>And this extends to any number of tuples.  Easy enough to understand the definition?  Ok, I have the program working correctly:</p>  <p><a href="http://ideone.com/OumeZK" rel="nofollow">http://ideone.com/OumeZK</a></p>  <p>But now I want to extend the definition to</p>  <pre><code>`TupleTreeWithRepeats&lt;P, std::index_sequence&lt;Is...&gt;, Tuples...&gt;` </code></pre>  <p>where <code>Is...</code> will indicate the number of times each tuple is being used repeatedly until moving on to the next tuple.  Note that <code>&lt;Is...&gt; = &lt;1,1,...,1&gt;</code> will reduce to the same as <code>TupleTree&lt;P, Tuples...&gt;</code>.  The ambiguity that I'm stuck with is with these two specializations:</p>  <pre><code>TupleTreeWithRepeatsHelper&lt;P, std::index_sequence&lt;Is...&gt;, LoopNumber, P&lt;Ts...&gt;, First, Rest...&gt; TupleTreeWithRepeatsHelper&lt;P, std::index_sequence&lt;I, Is...&gt;, I, P&lt;Ts...&gt;, First, Rest...&gt; </code></pre>  <p>For some reason, the presence of <code>P&lt;Ts...&gt;</code> causes the ambiguity because when I replace it with a single-named type the ambiguity is removed.  Even when I replace <code>std::index_sequence&lt;Is...&gt;</code> with <code>std::index_sequence&lt;I, Is...&gt;</code>, the ambiguity is still there.  What's going on?  And how to fix this?  Here is the code, which is almost the same as that for <code>TupleTree</code>:</p>  <pre><code>#include &lt;iostream&gt; #include &lt;tuple&gt; #include &lt;type_traits&gt;  template &lt;typename T&gt; struct Identity { using type = T; };  // Merging packs of types. template &lt;typename...&gt; struct MergePacks;  template &lt;typename Pack&gt; struct MergePacks&lt;Pack&gt; : Identity&lt;Pack&gt; {};  template &lt;template &lt;typename...&gt; class P, typename... Types1, typename... Types2, typename... Packs&gt; struct MergePacks&lt;P&lt;Types1...&gt;, P&lt;Types2...&gt;, Packs...&gt; : MergePacks&lt;P&lt;Types1..., Types2...&gt;, Packs...&gt; {};  // Appending a type to a pack. template &lt;typename Pack, typename T&gt; struct AppendType;  template &lt;template &lt;typename...&gt; class P, typename... Ts, typename T&gt; struct AppendType &lt;P&lt;Ts...&gt;, T&gt; {     using type = P&lt;Ts..., T&gt;; };  // ExpandPackWithTuple takes a pack, and creates N packs that each end with the tuple's elements, N is the size of the tuple. template &lt;template &lt;typename...&gt; class P, typename Pack, typename Tuple, typename Indices&gt; struct ExpandPackWithTupleHelper;  template &lt;template &lt;typename...&gt; class P, typename Pack, typename Tuple, std::size_t... Is&gt; struct ExpandPackWithTupleHelper&lt;P, Pack, Tuple, std::index_sequence&lt;Is...&gt;&gt; {     using type = P&lt;typename AppendType&lt;Pack, typename std::tuple_element&lt;Is, Tuple&gt;::type&gt;::type...&gt;; };  template &lt;template &lt;typename...&gt; class P, typename Pack, typename Tuple&gt; using ExpandPackWithTuple = typename ExpandPackWithTupleHelper&lt;P, Pack, Tuple, std::make_index_sequence&lt;std::tuple_size&lt;Tuple&gt;::value&gt;&gt;::type;  // TupleTreeWithRepeats. template &lt;template &lt;typename...&gt; class P, typename NumRepeats, std::size_t LoopNumber, typename OutputPack, typename... Tuples&gt; struct TupleTreeWithRepeatsHelper;  template &lt;template &lt;typename...&gt; class P, std::size_t I, std::size_t... Is, std::size_t LoopNumber, typename... Ts, typename First, typename... Rest&gt; struct TupleTreeWithRepeatsHelper&lt;P, std::index_sequence&lt;I, Is...&gt;, LoopNumber, P&lt;Ts...&gt;, First, Rest...&gt; :     TupleTreeWithRepeatsHelper&lt;P, std::index_sequence&lt;I, Is...&gt;, LoopNumber + 1, typename MergePacks&lt;ExpandPackWithTuple&lt;P, Ts, First&gt;...&gt;::type, First, Rest...&gt; {};  template &lt;template &lt;typename...&gt; class P, std::size_t I, std::size_t... Is, typename... Ts, typename First, typename... Rest&gt; struct TupleTreeWithRepeatsHelper&lt;P, std::index_sequence&lt;I, Is...&gt;, I, P&lt;Ts...&gt;, First, Rest...&gt; :     TupleTreeWithRepeatsHelper&lt;P, std::index_sequence&lt;Is...&gt;, 0, typename MergePacks&lt;ExpandPackWithTuple&lt;P, Ts, First&gt;...&gt;::type, Rest...&gt; {};  template &lt;template &lt;typename...&gt; class P, std::size_t... Is, std::size_t LoopNumber, typename OutputPack&gt; struct TupleTreeWithRepeatsHelper&lt;P, std::index_sequence&lt;Is...&gt;, LoopNumber, OutputPack&gt; {     using type = OutputPack; };  template &lt;template &lt;typename...&gt; class P, typename NumRepeats, typename... Tuples&gt; struct TupleTreeWithRepeats;  template &lt;template &lt;typename...&gt; class P, std::size_t I, std::size_t... Is, typename... Tuples&gt; struct TupleTreeWithRepeats&lt;P, std::index_sequence&lt;I, Is...&gt;, Tuples...&gt; : TupleTreeWithRepeatsHelper&lt;P, std::index_sequence&lt;Is...&gt;, 0, P&lt;P&lt;&gt;&gt;, Tuples...&gt; {};  // Testing template &lt;typename...&gt; struct Pack; using T1 = std::tuple&lt;int, char, double&gt;; using T2 = std::tuple&lt;bool, double, int, char&gt;; using T3 = std::tuple&lt;double, int&gt;;  int main() {     std::cout &lt;&lt; std::is_same&lt;         TupleTreeWithRepeats&lt;Pack, std::index_sequence&lt;1,1,1&gt;, T1, T2, T3&gt;::type,         Pack&lt;             Pack&lt;int, bool, double&gt;, Pack&lt;int, bool, int&gt;, Pack&lt;int, double, double&gt;, Pack&lt;int, double, int&gt;, Pack&lt;int, int, double&gt;, Pack&lt;int, int, int&gt;, Pack&lt;int, char, double&gt;, Pack&lt;int, char, int&gt;,             Pack&lt;char, bool, double&gt;, Pack&lt;char, bool, int&gt;, Pack&lt;char, double, double&gt;, Pack&lt;char, double, int&gt;, Pack&lt;char, int, double&gt;, Pack&lt;char, int, int&gt;, Pack&lt;char, char, double&gt;, Pack&lt;char, char, int&gt;,             Pack&lt;double, bool, double&gt;, Pack&lt;double, bool, int&gt;, Pack&lt;double, double, double&gt;, Pack&lt;double, double, int&gt;, Pack&lt;double, int, double&gt;, Pack&lt;double, int, int&gt;, Pack&lt;double, char, double&gt;, Pack&lt;double, char, int&gt;         &gt;     &gt;::value &lt;&lt; '\n';  // ambiguous } </code></pre>