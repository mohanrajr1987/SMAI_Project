<p>I'm trying to make a compile time generics example. I've made it enforce that the methods exists, but I can't figure out how to enforce the return type:</p>  <pre><code>#include &lt;type_traits&gt; template&lt;class...&gt; struct voider { using type = void; } template&lt;class... T&gt; using void_t = typename voider&lt;T...&gt;::type;  template&lt;class T, class = void&gt; struct add_able : std::false_type {}; template&lt;class T&gt; struct add_able &lt; T, void_t &lt; std::is_same &lt; decltype(std::declval&lt;T&gt;().addOne()), void &gt;,               std::is_same &lt; decltype(std::declval&lt;T&gt;().subOne()), void &gt; &gt; &gt; : std::true_type {};  class A { public: int addOne(); void subOne(); } // compiles and runs class B { public: void addOne(int); void subOne(); } // fails class C { public: void addOne(); void subOne(); } // compiles and runs as expected class D { public: void subOne(); } // fails </code></pre>  <p>This ensures that there is a <code>addOne()</code> and <code>subOne()</code> method but the return types are completely arbitrary.  How do I enforce this?</p>