<p>I need to implement a container to hold an amount of elements and for some reason, it has to work without any heap allocation. Another requirement is, that the container elements should not be copied or moved in any way. They have to constructed directly into the memory allocated by the container.</p>  <p>For that, I decided to use placement new and delegate the memory management completely to the container implementation (found some useful information about placement new at <a href="http://www.drdobbs.com/cpp/calling-constructors-with-placement-new/232901023" rel="nofollow">drdobbs</a>).</p>  <p>A running example is found <a href="http://coliru.stacked-crooked.com/a/defd059e8250c685" rel="nofollow">here</a>. (Please note, that the use of <code>new uint8_t[size]</code> and <code>std::queue</code> is just to keep the example simple. My real code has more complex, heap-less implementation instead.)</p>  <p>This perfectly works so far, as the client code has to put elements into the container with calls like:</p>  <pre><code>executer.push(new (executer) MyRunnable("Hello", 123)); </code></pre>  <p>Now I want do remove the need of the repeated write <code>executer</code> in this statement. I would rather like to write something like e.g.:</p>  <pre><code>executer.pushNew(MyRunnable("Hello", 123)); </code></pre>  <p>or</p>  <pre><code>executer.pushNew(MyRunnable, "Hello", 123); </code></pre>  <p>maybe by providing an appropriate template but I failed to write one (no preprocessor macros, please).</p>  <p>I'd found some useful information about <code>std::allocator</code> here at <a href="http://www.drdobbs.com/the-standard-librarian-what-are-allocato/184403759" rel="nofollow">drdobbs</a> but don't know how to apply it to my problem (further, the article is of anno 2000 and so don't take use of possible C++11 advantages).</p>  <p>Could one help me to find a way to not longer need to give the <code>executer</code> twice?</p>  <p><strong>Edit:</strong> After successful approving <a href="http://stackoverflow.com/a/32926314/2069064">Jarod42</a>'s answer, I'd updated my running example code <a href="http://coliru.stacked-crooked.com/a/fc2c00c71f545df5" rel="nofollow">here</a>.</p>  <p>And for the history, here the original example code of my initial question:</p>  <pre><code>#include &lt;iostream&gt; #include &lt;queue&gt;   class Runnable {     // Runnable should be uncopyable and also unmovable     Runnable(const Runnable&amp;) = delete;     Runnable&amp; operator = (const Runnable&amp;) = delete;         Runnable(const Runnable&amp;&amp;) = delete;     Runnable&amp; operator = (const Runnable&amp;&amp;) = delete;     public:     explicit Runnable() {}     virtual ~Runnable() {}     virtual void run() = 0; };   class MyRunnable: public Runnable { public:     explicit MyRunnable(const char* name, int num): name(name), num(num) {}     virtual void run() override {         std::cout &lt;&lt; name &lt;&lt; " " &lt;&lt; num &lt;&lt; std::endl;     } private:     const char* name;     int num; };   class Executer {     // Executer should be uncopyable and also unmovable     Executer(const Executer&amp;) = delete;     Executer&amp; operator = (const Executer&amp;) = delete;         Executer(const Executer&amp;&amp;) = delete;     Executer&amp; operator = (const Executer&amp;&amp;) = delete;     public:     explicit Executer() {         }      void* allocateEntry(size_t size) {         // this heap allocation is just to keep this example simple         // my real implementation uses it's own memory management instead (blockpool)         return new uint8_t[size];     }      void push(Runnable* entry) {         queue.push(entry);     }      template &lt;typename R&gt; // this don't works     void pushNew(R) {         push(new (*this) R);     }      inline friend void* operator new(size_t n, Executer&amp; executer) {         return executer.allocateEntry(n);     }      void execute() {         while (queue.size() &gt; 0) {             Runnable* entry = queue.front();             queue.pop();             entry-&gt;run();             // Now doing "placement delete"             entry-&gt;~Runnable();             uint8_t* p = reinterpret_cast&lt;uint8_t*&gt;(entry);             delete[] p;         }      }  private:     // this use of std::queue is just to keep this example simple     // my real implementation uses it's own heap-less queue instead     std::queue&lt;Runnable*&gt; queue {}; };   int main() {     Executer executer;     executer.push(new (executer) MyRunnable("First", 1));     executer.push(new (executer) MyRunnable("Second", 2));     executer.push(new (executer) MyRunnable("Third", 3));      // but want to use it more like one this      //executer.pushNew(MyRunnable("Fifth", 5));  // how to implement it?     //executer.pushNew(MyRunnable, "Sixth", 6);  // or maybe for this usage?      executer.execute(); } </code></pre>