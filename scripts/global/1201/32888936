<p>I have a generic OdataController implementation that depends on a IService implementation.</p>  <p>To avoid having to write a lot of controllers I would like to do something this for extended functionality in my service ...</p>  <ol> <li><p>Define a method on the Controller ...</p>  <p>[HttpGet] public IHttpActionResult Method(params object[] args) {     var name = args[0].ToString();     var callArgs = args.ToList();     callArgs.RemoveAt(0);     return Ok(service.GetType().GetMethod(name).Invoke(service, callArgs.ToArray())); }</p></li> </ol>  <p>The assumption is that the method will have at least 1 param passed in (via the url) which would be the name of the method on the service to call. </p>  <p>Based on that I would make the call and return whatever result the service comes back with.</p>  <p>Where I get stuck is how to map that as a function in the OData model. I current have this method ...</p>  <pre><code>void ConfigureSet&lt;T&gt;(ODataConventionModelBuilder builder, Type serviceType) where T : class {     // register basic CRUD endpoint     var setConfig = builder.EntitySet&lt;T&gt;(typeof(T).Name);      // get methods that are not part of the basic crud set     var methods = serviceType.GetMethods().Except(typeof(IService&lt;&gt;).GetMethods());      // setup some sort of function route to map in the model the method?     builder.EntityType&lt;T&gt;().Collection.Function("Method");  } </code></pre>  <p>That last line is where I get stuck, I'm not sure WebApi / OData supports doing this, it's basically forcing me to create a new controller type for each service type I have.</p>  <p>in other words if i have a Foo method in the service I need a Foo method in the controller to match it. Seems wasteful, or maybe I need to re-think my stack design?</p>