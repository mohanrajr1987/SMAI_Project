<p>I'm having some trouble figuring out why compiler complains about not finding an implicit parameter for reads because I'm almost sure that it is in the scope. The error is the following: </p>  <p>Error:(13, 18) No Json deserializer found for type Config. Try to implement an implicit Reads or Format for this type.     test.validate[Config].map {                  ^</p>  <p>Error:(13, 18) not enough arguments for method validate: (implicit rds: play.api.libs.json.Reads[Config])play.api.libs.json.JsResult[wings.m2m.conf.model.Config]. Unspecified value parameter rds.     test.validate[Config].map {                  ^</p>  <p>and it happens in the following code:</p>  <pre><code>import play.api.libs.json._ import play.api.libs.json.Reads._ import Config.JsonImplicits._  import scala.util.Try  object Test {   def main(args: Array[String]) {      val test = Json.obj("action" -&gt; Config.Action.nameAcquisitionRequest.toString, "value" -&gt; "hola")     test.validate[Config].map {       t =&gt; println(t)         t     }   } }  /**  * Config companion object  */ object Config {    type ValueType = String    val ActionKey = "action"    val ValueKey = "value"    object Action extends Enumeration {      type Action = Value      val nameAcquisitionRequest = Value("nameAcquisitionRequest")     val nameAcquisitionReject = Value("nameAcquisitionReject")     val nameAcquisitionAck = Value("nameAcquisitionAck")      val broadcast = Value("broadcast")    }    /**    * Json implicit conversions    */   object JsonImplicits {      implicit object ConfigReads extends Reads[Config] {        def hTypeCast(action: Config.Action.Value, value: Config.ValueType): Config = {         action match {           case Config.Action.nameAcquisitionRequest =&gt; NameAcquisitionRequest(value)           case Config.Action.nameAcquisitionReject =&gt; NameAcquisitionReject(value)           case Config.Action.nameAcquisitionAck =&gt; NameAcquisitionAck(value)         }       }        override def reads(json: JsValue): JsResult[Config] = json match {           case json: JsObject =&gt;             val action = (json \ ActionKey).as[String]             Try(Config.Action.withName(action)) map {               a =&gt;                 val value = (json \ ValueKey).as[String]                 JsSuccess(hTypeCast(a, value))             } getOrElse (JsError("Can't convert to Config"))           case _ =&gt; JsError("Can't convert to Config")         }       }       implicit object ConfigWrites extends OWrites[Config] {        def jsObjectCreator(action: Config.Action.Value, value: Config.ValueType): JsObject = {         Json.obj(ActionKey -&gt; action.toString, ValueKey -&gt; Json.toJson(value))       }        override def writes(o: Config): JsObject = o match {         case c: NameAcquisitionRequest =&gt; jsObjectCreator(Config.Action.nameAcquisitionRequest, c.value)         case c: NameAcquisitionReject =&gt; jsObjectCreator(Config.Action.nameAcquisitionReject, c.value)         case c: NameAcquisitionAck =&gt; jsObjectCreator(Config.Action.nameAcquisitionAck, c.value)       }     }   }  }  sealed trait Config {   val value: Config.ValueType }  /**  * Intermediate config message  * @param value  */ case class NameAcquisitionRequest(override val value: String)   extends Config  case class NameAcquisitionReject(override val value: String)   extends Config  case class NameAcquisitionAck(override val value: String)   extends Config  case class Broadcast(override val value: String)   extends Config </code></pre>  <p>the error occurs when executing the main method on the Test object. To make this example work, make sure to add the following dependency in the SBT:   "com.typesafe.play" %% "play-json" % "2.4.1" . And I'm not sure, but maybe this resolver is needed: resolvers += "Typesafe Repo" at "<a href="http://repo.typesafe.com/typesafe/releases/" rel="nofollow">http://repo.typesafe.com/typesafe/releases/</a>"</p>