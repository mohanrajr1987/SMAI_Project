<p>I'm trying to apply a series of optional filtering operations to a query by using a list of the operations and folding over the list. </p>  <pre><code>val table = TableQuery[Fizz] val filters = List(filter1(option1)_, filter2(option2)_, filter3(option3)_) val filteredQuery = filters.foldLeft(table){(q, filter) =&gt; filter(q)} </code></pre>  <p>The partially applied filter functions have a signature of </p>  <pre><code>Query[Fizz, FizzRow, Seq] =&gt; Query[Fizz, FizzRow, Seq] </code></pre>  <p>Basically, in each function, I am optionally applying the filtering if the filter parameter option* is present. However, the compiler does not like the fact that I am passing in a TableQuery to a function that takes Query, even though TableQuery is a subtype of Query. Is there a way to convert a TableQuery to Query? Or a better way to go about chaining filter functions on a query?</p>  <p>The compiler error in question is </p>  <p>type mismatch;</p>  <p>found  :scala.slick.lifted.Query[generated.Tables.Farm,generated.Tables.FarmRow,Seq]</p>  <p>required: scala.slick.lifted.TableQuery[generated.Tables.Farm]</p>  <p>I can get it to compile by using table.drop(0) instead of table but obviously that seems like a poor workaround. I see that there's a to method on TableQuery that converts it to a Query but it also takes an implicit ctc: TypedCollectionTypeConstructor[D].</p>  <p>An example of one of the filterX functions listed above:</p>  <pre><code>def filterCharacteristics(characteristics: Option[List[Int]])(table: Query[Farm,FarmRow,Seq]) = { characteristics.map(chars =&gt;   (for {     (fc, f) &lt;- Farmcharacteristic.filter(_.characteristicId inSet chars) join table on (_.farmId === _.farmId)   } yield f)).getOrElse(table) } </code></pre>