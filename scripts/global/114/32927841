<p>Given string of digits like "72388" and int n, delete n characters from the sting such the resulting string contains minimal number representation, you must preserve relative position of digits. Example: if st="72388" and n=2, the answer is 238.  </p>  <p>Below solution does not seem to work for all the cases. How can we reduce a string to minimal string ?</p>  <p>Solution : Idea here is scan from left to right delete a char if it is greater than next char in string array and prev char. if the number of chars deleted are less than 'n' by the end of the iteration, repeat the same iteration from end to start of the string.</p>  <pre><code>char * min_string(char *str, int n) { static char buf[100] = ""; int len = strlen(str); int k = -1; int count = 0; int i; char prev, curr, next;  if(len == 0 || len &lt; n) return -1;  if(len == n) return 0;  prev = str[0]; for(i=1; i&lt;len-1 &amp;&amp; count&lt;=n; i++) { curr = str[i]; next = str[i+1]; if(curr &gt; next &amp;&amp; curr &gt; prev) {     count++;     continue; } else if(curr &lt; next &amp;&amp; curr &lt;= prev) {     count++;     prev = curr;     buf[k] = curr; } else {     buf[++k] = curr; } }  if(count &lt; n) { count = 0; k = len - n; prev = buf[k - 1] = str[len-1]; for(i=len-2; i&gt;0; i--) {     curr = str[i];     next = str[i-1];     if(curr &gt; next &amp;&amp; curr &gt; prev)     {     count++;     continue;     }     else if(curr &lt; next &amp;&amp; curr &lt;= prev)     {     count++;     prev = curr;     buf[k] = curr;     }     else     {     buf[--k] = curr;     } }  printf("Resulted string     :   %s\n", buf); return buf; } else { for(; i&lt;len; i++) {     buf[++k] = str[i]; }  printf("Resulted string ascending   :   %s\n", buf); return buf; } } </code></pre>