<p>I'm having some issues with creating a Mongoid document that includes an <em>array</em> of custom objects.</p>  <p>I my particular case I intend to store an array of <code>BaseDevice</code> objects. The <code>BaseDevice</code> class is already mongified and serializes from/to a plain hash using Mongoid's <a href="http://docs.mongodb.org/ecosystem/tutorial/ruby-mongoid-tutorial/#fields" rel="nofollow">custom fields</a> support. This works pretty well on single object.</p>  <p>For storing an array of <code>BaseDevice</code>, I've created the following class:</p>  <pre><code>class BaseDeviceArray &lt; Array   class &lt;&lt; self       def demongoize(object)       object ? object.map{ |obj| BaseDevice.demongoize obj } : new     end      def evolve(object)       case         when BaseDeviceArray then object.mongoize         else object       end     end   end    def mongoize     self.map(&amp;:mongoize)   end end </code></pre>  <p>The mongoid document looks like this</p>  <pre><code>class MongoPeriph   include Mongoid::Document   field :devices, type: BaseDeviceArray end </code></pre>  <p>Let's say <code>some_devices</code> is an array containing two <code>BaseDevice</code> instances.  What happens is the following: when I assign <code>some_devices</code> to the devices fields of the <code>MongoPeriph</code> instance that works correctly. </p>  <pre><code>mp = MongoPeriph.create mp.devices = some_devices mp.devices # =&gt; [#&lt;BaseDevice:0x007fa84bac0080&gt;,#&lt;BaseDevice:0x007fa84baaff78&gt;] </code></pre>  <p>When try to send <code>push</code>, <code>pop</code>, <code>shift</code>, <code>unshift</code> methods to the devices field within the mongoid document, nothing seems to happen. The changes are not appearing on the <code>mp</code> object. Also when referencing one of the objects by index (i.e. when calling <code>mp.devices[0].some_method</code>) the world does not change. </p>  <p>When <em>popping</em> objects from the array, on every <code>pop</code> a new object is given. This is expected as the deserializer is instantiating a new <code>BaseDevice</code> object for every <code>pop</code>, but the internal field is not updated i.e. the object stays there and one can pop endlessly.</p>  <p>Using the <code>BaseDeviceArray</code> separate from a mongoid document works as expected:</p>  <pre><code>foo = BaseDeviceArray.new foo &lt;&lt; BaseDevice.new </code></pre>  <p>results in an array with a BaseDevice object. </p>  <p>Btw. I found one other <a href="http://grokbase.com/t/gg/mongoid/1287rw4f78/creating-array-fields-of-specific-and-custom-types" rel="nofollow">approach</a> to this on the net. It is a more generalized way of implementing what I need, but it <em>monkey-patches</em> Mongoid. Something I try to avoid. Moreover that solution seems to have the same issue my approach has.</p>