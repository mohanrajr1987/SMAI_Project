<p>After a discussion with colleagues, I ended up testing wether if clang would optimize two divisions, with a reciprocal to 1, to a single division.</p>  <p><code>const float x = a / b; //x not used elsewhere const float y = 1 / x;</code></p>  <p>Theoretically clang could optimize to <code>const float y = b / a</code> if <code>x</code> is used only as a temporary step value, no?</p>  <p>Here's the input&amp;output of a simple test case: <a href="https://gist.github.com/Jiboo/d6e839084841d39e5ab6" rel="nofollow">https://gist.github.com/Jiboo/d6e839084841d39e5ab6</a> (in both ouputs you can see that it's performing the two divisions, instead of optimizing)</p>  <p>This related question, is behind my comprehension and seem to focus only on why a specific instruction isn't used, whereas in my case it's the optimisation that isn't done: <a href="http://stackoverflow.com/questions/32002277/why-does-gcc-or-clang-not-optimise-reciprocal-to-1-instruction-when-using-fast-m">Why does GCC or Clang not optimise reciprocal to 1 instruction when using fast-math</a></p>  <p>Thanks, JB.</p>