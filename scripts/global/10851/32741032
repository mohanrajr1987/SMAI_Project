<p>Consider the following code:</p>  <pre><code>    int bn_div(bn_t *bn1, bn_t *bn2, bn_t *bnr)   {     uint32 q, m;        /* Division Result */     uint32 i;           /* Loop Counter */     uint32 j;           /* Loop Counter */      /* Check Input */     if (bn1 == NULL) return(EFAULT);     if (bn1-&gt;dat == NULL) return(EFAULT);     if (bn2 == NULL) return(EFAULT);     if (bn2-&gt;dat == NULL) return(EFAULT);     if (bnr == NULL) return(EFAULT);     if (bnr-&gt;dat == NULL) return(EFAULT);       #if defined(__i386__) || defined(__amd64__)     __asm__ (".intel_syntax noprefix");     __asm__ ("pushl %eax");     __asm__ ("pushl %edx");     __asm__ ("pushf");     __asm__ ("movl %eax, (bn1-&gt;dat[i])");     __asm__ ("xorl %edx, %edx");     __asm__ ("divl (bn2-&gt;dat[j])");     __asm__ ("movl (q), %eax");     __asm__ ("movl (m), %edx");     __asm__ ("popf");     __asm__ ("popl %edx");     __asm__ ("popl %eax");     #else     q = bn-&gt;dat[i] / bn-&gt;dat[j];     m = bn-&gt;dat[i] % bn-&gt;dat[j];     #endif     /* Return */     return(0);   } </code></pre>  <p>The data types uint32 is basically an unsigned long int or a uint32_t unsigned 32-bit integer.  The type bnint is either a unsigned short int (uint16_t) or a uint32_t depending on if 64-bit data types are available or not.  If 64-bit is available, then bnint is a uint32, otherwise it's a uint16.  This was done in order to capture carry/overflow in other parts of the code.  The structure bn_t is defined as follows:</p>  <pre><code>typedef struct bn_data_t bn_t; struct bn_data_t   {     uint32 sz1;         /* Bit Size */     uint32 sz8;         /* Byte Size */     uint32 szw;         /* Word Count */     bnint *dat;         /* Data Array */     uint32 flags;       /* Operational Flags */   }; </code></pre>  <p>The function starts on line 300 in my source code.  So when I try to compile/make it, I get the following errors:</p>  <pre><code>system:/home/user/c/m3/bn 1036 $$$ -&gt;make clang -I. -I/home/user/c/m3/bn/.. -I/home/user/c/m3/bn/../include  -std=c99 -pedantic -Wall -Wextra -Wshadow -Wpointer-arith -Wcast-align -Wstrict-prototypes  -Wmissing-prototypes -Wnested-externs -Wwrite-strings -Wfloat-equal  -Winline -Wunknown-pragmas -Wundef -Wendif-labels  -c /home/user/c/m3/bn/bn.c /home/user/c/m3/bn/bn.c:302:12: warning: unused variable 'q' [-Wunused-variable]     uint32 q, m;        /* Division Result */            ^ /home/user/c/m3/bn/bn.c:302:15: warning: unused variable 'm' [-Wunused-variable]     uint32 q, m;        /* Division Result */               ^ /home/user/c/m3/bn/bn.c:303:12: warning: unused variable 'i' [-Wunused-variable]     uint32 i;           /* Loop Counter */            ^ /home/user/c/m3/bn/bn.c:304:12: warning: unused variable 'j' [-Wunused-variable]     uint32 j;           /* Loop Counter */            ^ /home/user/c/m3/bn/bn.c:320:14: error: unknown token in expression     __asm__ ("movl %eax, (bn1-&gt;dat[i])");              ^ &lt;inline asm&gt;:1:18: note: instantiated into assembly here         movl %eax, (bn1-&gt;dat[i])                         ^ /home/user/c/m3/bn/bn.c:322:14: error: unknown token in expression     __asm__ ("divl (bn2-&gt;dat[j])");              ^ &lt;inline asm&gt;:1:12: note: instantiated into assembly here         divl (bn2-&gt;dat[j])                   ^ 4 warnings and 2 errors generated. *** [bn.o] Error code 1  Stop in /home/user/c/m3/bn. system:/home/user/c/m3/bn 1037 $$$ -&gt; </code></pre>  <p><strong>What I know:</strong></p>  <p>I consider myself to be fairly well versed in x86 assembler (as evidenced from the code that I wrote above).  However, the last time that I mixed a high level language and assembler was using Borland Pascal about 15-20 years ago when writing graphics drivers for games (pre-Windows 95 era).  My familiarity is with Intel syntax.</p>  <p><strong>What I don't know:</strong></p>  <p>How do I access members of bn_t (especially *dat) from asm?  Since *dat is a pointer to uint32, I am accessing the elements as an array (eg. bn1->dat[i]).</p>  <p>How do I access local variables that are declared on the stack?</p>  <p>I am using push/pop to restore clobbered registers to their previous values so as to not upset the compiler.  However, do I also need to include the volatile keyword on the local variables as well?</p>  <p>Or, is there a better way that I am not aware of?  I don't want to put this in a separate function call because of the calling overhead as this function is performance critical.</p>  <p><strong>Additional:</strong></p>  <p>Right now, I'm just starting to write this function so it is no where complete.  There are missing loops and other such support/glue code.  But, the main gist is accessing local variables/structure elements.</p>  <p>EDIT 1:</p>  <p>The syntax that I am using seems to be the only one that clang supports.  I tried the following code and clang gave me all sorts of errors:</p>  <pre><code>__asm__ ("pushl %%eax",     "pushl %%edx",     "pushf",     "movl (bn1-&gt;dat[i]), %%eax",     "xorl %%edx, %%edx",     "divl ($0x0c + bn2 + j)",     "movl %%eax, (q)",     "movl %%edx, (m)",     "popf",     "popl %%edx",     "popl %%eax"     ); </code></pre>  <p>It wants me to put a closing parenthesis on the first line, replacing the comma.  I switched to using %% instead of % because I read somewhere that inline assembly requires %% to denote CPU registers, and clang was telling me that I was using an invalid escape sequence.</p>