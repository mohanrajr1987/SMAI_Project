<p>I've been hit by some weird behaviour recently that caused me to tear my hair out a little.  I think I've finally worked out the problem and understand the cause but would like a sanity check on my conclusions.  I'll skip the problem and just state my assertion for simplicity (the back story is long and tedious).</p>  <p>All this is occuring on both OSX and the iOS simulator (I'd imagine the same is true for on device, but I haven't tested that).</p>  <ul> <li>dylib A: Exports function <code>foo</code> marked as weak. </li> <li>dylib B: Exports function <code>foo</code> <strong>not</strong> marked as weak. </li> <li>Application X: linked against dylib A.</li> </ul>  <p>The application runs (dylib A is automatically loaded) and calls <code>foo</code>.  <code>A::foo</code> (excuse the notation abuse) is called.  The application then loads dylib B.  The symbol for <code>foo</code> is rebound to <code>B::foo</code>.  Subsequent calls to <code>foo</code> always call <code>B::foo</code>, furthermore <code>foo</code> can never be rebound as dylib B defines <code>foo</code> to be strong.</p>  <p>Correct?</p>  <p>As I write this, logically I can only conclude that it must be (indeed I've verified this behaviour with an example).  The behaviour is effectively the same as what happens during static linking.  My surprise was that dynamic rebinding could actually occur, as you can imagine that it could lead to some weird behaviour if a function can change implementation part way through execution.</p>  <p>N.B. I stubled over this when overriding <code>operator new</code> in a dylib.  Since libc++ (implicitly) exports <code>operator new</code> as weak the scenario above arose.</p>  <p>Presumably the moral is that if you use weak dynamic symbols then you must be very sure you know what you're doing :)</p>