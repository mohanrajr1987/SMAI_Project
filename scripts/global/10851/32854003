<p>I'm working a linter for c++ which ties into clang. Currently, I'm trying to figure out how to the overrides on a method. As an example, suppose the following</p>  <pre><code>class Foo {  public:   void foo(int x); //lets alias this to M1 };  class Bar: public Foo {  public:   void foo(int y); //and alias this to M2 }; </code></pre>  <p>What I'm trying to figure out is, given a <code>FunctionDecl</code> or <code>CXXMethodDecl</code> which refers to M1, find the override (M2) if it exists. Alternative, if the <code>...Decl</code> refers to M2, then get a reference to M1 if it exists.</p>  <p>I have the following function which gets called for every CXXMethodDecl that exists:</p>  <pre><code>bool ParameterNameMismatchDetector::VisitCXXMethodDecl(     clang::CXXMethodDecl* declaration) {    declaration-&gt;getCanonicalDecl(); // this never gets the "other" method   declaration-&gt;getFirstDecl(); // never gets the "other" method    # I think this is what I want but there's a compilation error for the .next call   for (auto iterator = declaration-&gt;begin_overridden_methods();         iterator != declaration-&gt;end_overridden_methods(); iterator.next()) {     LOG(INFO) &lt;&lt; it;   }    return true; } </code></pre>  <p>I get the following error with the <code>for</code> loop above:</p>  <pre><code>.../ParameterNameMismatchDetector.cpp:54:56: error: member reference base type 'const clang::CXXMethod Decl *const *' is not a structure or union     it != declaration-&gt;end_overridden_methods(); it.next()) {                                                  ~~^~~~~ </code></pre>  <p>I guess my two questions are:</p>  <ol> <li>How can I fix that compilation error?</li> <li>Am I approaching this find-overridden-methods problem correctly?</li> </ol>  <p>Just for the sake of completeness, what I'm ultimately trying to do is detect when an overridden method has differently named parameters and then raise a lint error. The example I've shown above is one of the cases that I want to raise the lint error for.</p>  <p>EDIT: Did some more work and found that I can fix the compilation error with <code>++iterator</code>. I also found that <code>declaration-&gt;size_overridden_methods()</code> returns <code>0</code> for both <code>Foo::foo</code> and <code>Bar::foo</code>. Looks like I need a new approach to solving the problem.</p>