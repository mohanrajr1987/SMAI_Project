<p>I am working on project where we use shared libraries as plugins. In last few days, I needed to change one class in one of our plugins to a templated class, while limiting the possible template options through explicit instantiation. I provide you here the very simplified version of what I am trying to achieve.</p>  <p><strong>a.h</strong></p>  <pre class="lang-cpp prettyprint-override"><code>#ifndef A_H #define A_H  template &lt;int&gt; class A { public:     A();      void setValue(int value);     int getValue() const;  private:     int _value; };  #endif </code></pre>  <p>Here is a class declaration. I don't want to keep definition of methods in the header file.</p>  <p><strong>a.cpp</strong></p>  <pre class="lang-cpp prettyprint-override"><code>#include "a.h"  // Explicit instantiation template class A&lt;1&gt;; template class A&lt;2&gt;;  template &lt;int n&gt; A&lt;n&gt;::A() : _value(0) { }  template &lt;int n&gt; void A&lt;n&gt;::setValue(int value) {     _value = value; }  template &lt;int n&gt; int A&lt;n&gt;::getValue() const {     return _value; } </code></pre>  <p>Here is definition. Don't ask me why I need such template. This is just very simplified form.</p>  <p><strong>foo.h</strong></p>  <pre class="lang-cpp prettyprint-override"><code>#ifndef FOO_H #define FOO_H  extern "C" void foo();  #endif </code></pre>  <p>This files serves as an interface between plugin and "the core". Function with C linkage can be easily obtained using <code>dlsym</code>.</p>  <p><strong>foo.cpp</strong></p>  <pre class="lang-cpp prettyprint-override"><code>#include &lt;iostream&gt; #include "a.h" #include "foo.h"  void foo() {     A&lt;1&gt;* a1 = new A&lt;1&gt;;     a1-&gt;setValue(1);     std::cout &lt;&lt; a1-&gt;getValue() &lt;&lt; std::endl;      A&lt;2&gt;* a2 = new A&lt;2&gt;;     a2-&gt;setValue(2);     std::cout &lt;&lt; a2-&gt;getValue() &lt;&lt; std::endl; } </code></pre>  <p>Just definition of <code>foo</code> function, which uses templated class <code>A</code>.</p>  <p>These were all files that are compiled as plugin. The core looks like this.</p>  <p><strong>main.cpp</strong></p>  <pre class="lang-cpp prettyprint-override"><code>#include &lt;iostream&gt; #include &lt;dlfcn.h&gt;  int main(int argc, char** argv) {     if (argc != 2)         return 1;      void* plugin = dlopen(argv[1], RTLD_NOW);     if (plugin == nullptr)     {         std::cerr &lt;&lt; dlerror() &lt;&lt; std::endl;         return 1;     }      void* fooSym = dlsym(plugin, "foo");     if (fooSym == nullptr)     {         std::cerr &lt;&lt; dlerror() &lt;&lt; std::endl;         return 1;     }      auto foo = reinterpret_cast&lt;void(*)()&gt;(fooSym);     foo();      dlclose(plugin); } </code></pre>  <p>If I compile both core and plugin with <code>g++</code> everything works fine. However, when compiled with <code>clang</code>, I get this from <code>dlopen</code> error.</p>  <pre><code>liba_clang.so: undefined symbol: _ZNK1AILi1EE8getValueEv </code></pre>  <p>If you run <code>nm</code> on these shared libraries, you get this.</p>  <pre><code>$ nm -C liba_gcc.so | grep "A&lt;" 00000000000010a8 W A&lt;1&gt;::setValue(int) 0000000000001092 W A&lt;1&gt;::A() 0000000000001092 W A&lt;1&gt;::A() 00000000000010e6 W A&lt;2&gt;::setValue(int) 00000000000010d0 W A&lt;2&gt;::A() 00000000000010d0 W A&lt;2&gt;::A() 00000000000010c0 W A&lt;1&gt;::getValue() const 00000000000010fe W A&lt;2&gt;::getValue() const $ nm -C liba_clang.so | grep "A&lt;"                  U A&lt;1&gt;::setValue(int)                  U A&lt;1&gt;::A()                  U A&lt;2&gt;::setValue(int)                  U A&lt;2&gt;::A()                  U A&lt;1&gt;::getValue() const                  U A&lt;2&gt;::getValue() const </code></pre>  <p>In gcc version, they are all defined as weak symbols, what is fine. But in clang version, they are all undefined.</p>  <p>After few experiments, I found out that if I don't use explicit instantiation and rather put all definitions in header file, even clang version works because they turn into weak symbols.</p>  <p>Is there any solution to this? I would like to keep the definitions separated from declaration.</p>