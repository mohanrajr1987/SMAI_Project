<p>I'm working on a tool based on clang's AST, and I'm curious to know why clang works this way.</p>  <p>Here's my input.  I have a very simple class that is defined like this:</p>  <pre><code>class Foo {     int foo(); }; </code></pre>  <p>Then in my RecursiveASTVisitor, I have code that looks like this:</p>  <pre><code>bool MyASTVisitor::VisitCXXRecordDecl(clang::CXXRecordDecl *D) {     for (auto const &amp; method : D-&gt;methods()) {         llvm::outs() &lt;&lt; method-&gt;getQualifiedNameAsString() &lt;&lt; "(";         for (auto const &amp; param : method-&gt;params())             llvm::outs() &lt;&lt; param-&gt;getType().getAsString() &lt;&lt; ", ";         llvm::outs() &lt;&lt; ")";         if (method-&gt;isImplicit())             llvm::outs() &lt;&lt; " [implicit]";         llvm::outs() &lt;&lt; "\n";     }     return true; } </code></pre>  <p>All this does is spit out the list of methods defined in all the classes that are visited.  The output for this is as we'd expect:</p>  <pre><code>Foo::foo() </code></pre>  <p>Now, let's make a small change to our Foo class.  Let's make the foo() method virtual:</p>  <pre><code>class Foo {     virtual int foo(); }; </code></pre>  <p>Now my output changes:</p>  <pre><code>Foo::foo() Foo::operator=(const class Foo &amp;, ) [implicit] Foo::~Foo() [implicit] </code></pre>  <p>My question is, why does adding a virtual method to a class cause clang to create an implicit assignment operator and destructor?  If I add --std=c++11, it creates an implicit move-assignment operator as well.  Is this an implementation detail of clang, or is it part of the C++ standard?</p>