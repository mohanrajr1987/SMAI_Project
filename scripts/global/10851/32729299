<p>Alternate title: Why does my dylib include extra exported symbols when compiled by Xcode vs Makefile?</p>  <p>My company builds a c++ dynamic library (dylib) on the Mac using clang and we recently ported our hand crafted Makefile to the CMake build system and are now using the generated Xcode projects. After ensuring that all the compiler/linker flags and environment variables matched exactly between the two systems, we noticed that the dylib created by CMake/Xcode was slightly larger. Closer examination showed that it contained some additional exported symbols (from templated functions that were never referenced and therefore should never have been instantiated - the specific templates had their definitions and specializations in the source files as we use explicit instantiation frequently, although in this case they were not explicitly instantiated). Examining the disassembly of some of the object files showed slight instruction differences as well. The only thing that got the libraries to match in size and symbols exactly was to <strong>match the order of the compiler flags exactly</strong>. This appears to demonstrate some order dependent interaction between compiler flags which seems like a compiler bug or at least poorly documented behavior.</p>  <p>For this specific issue, these were the compiler invocations:</p>  <pre><code>clang++ -fvisibility=hidden -fvisibility-ms-compat -c foo.cpp -o foo.o  clang++ -fvisibility-ms-compat -fvisibility=hidden -c foo.cpp -o foo.o </code></pre>  <p>And this was the linker invocation:</p>  <pre><code>clang++ -dynamiclib -o libfoo.dylib foo.o </code></pre>  <p>Displaying the exported symbols with:</p>  <pre><code>nm -g libfoo.dylib </code></pre>  <p>showed the differences. I submitted this <a href="https://llvm.org/bugs/show_bug.cgi?id=24918" rel="nofollow">LLVM Bug</a>.</p>  <p>Are there ever any valid situations where compiler flag ordering matters?</p>