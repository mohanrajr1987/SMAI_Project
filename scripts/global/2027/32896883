<p>I want to fill an array-based stack that takes void* by default with size_t*, and have the values those pointers point to match the "i" variable in a loop. The problem is that pointers all must have a different name to them, and the amount of them I need is not set (changes on every execution of the program). Therefore, I thought of creating them, allocating memory and setting their values within a loop. Like:</p>  <pre><code>size_t* pointer1 = malloc (size_t); *pointer1 = 1; size_t* pointer2 = malloc (size_t); *pointer2 = 2; size_t* pointer3 = malloc (size_t); </code></pre>  <p>etc.</p>  <p>But I don't know how can I get to name them dynamically. If this isn't good practice, what should I do to fill my stack with pointers? Which is the easiest way, considering they have to be freed/deleted afterwards?</p>  <p>This is all being done just to test if the stack works. If there's an alternative, easier solution, please let me know. I checked 10+ suggestions of similar questions but none seemed to answer mine.</p>  <p>PLEASE KEEP IN MIND: THIS IS C!</p>  <pre><code>struct stack {     void **data;     size_t capacity;     size_t n_of_elements; };  //This is the function I intend to create the pointers on. //Right now it only uses one pointer whose pointed value changes and that //doesn't work because I need to pop the values later on and I can't do it //if the memory address doesn't change whilst values are being removed.  bool stack_add_numbers (stack_t* stack, size_t qty) {     size_t* iter_point;      for (size_t i=0; i&lt;=qty;i++)     {         iter_point = &amp;i;         stack_push(stack, iter_point);          if (stack_peek_top(stack)!=NULL)         {            void* value = stack_peek_top(stack);            printf("%i", *((int*)value));         }      }     return true; }  void* stack_peek_top(const stack_t* stack)     {return stack-&gt;data[(stack-&gt;n_of_elements)-1];}  bool stack_push(stack_t* stack, void* value) {     if((stack-&gt;n_of_elements)&gt;=(stack-&gt;capacity))         {//return result of redimension function}     else     {         stack-&gt;data[stack-&gt;n_of_elements]=value;         stack-&gt;n_of_elements++;         return true;     } }  void* stack_pop(stack_t* stack) {     if(!stack_is_empty(stack))     {         void* give_back = stack_ver_tope(stack);         stack-&gt;data[(stack-&gt;n_of_elements-1)]=NULL;         stack-&gt;n_of_elements--;          if ((stack-&gt;n_of_elements)&lt;((stack-&gt;capacity)/4))             {//return result of redimension function}          return give_back;     }     else return NULL; } </code></pre>