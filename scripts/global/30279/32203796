<p>I've recently stumbled upon some unintuitive behaviour of <code>Decimal.Parse</code>, I'd like to discuss. The case is at follows. My program gets number as strings from other program, "scientifically" formatted (it's a black box for me). The strings are parsed using <code>Decimal.Parse</code>.</p>  <pre><code>Dim Value As Decimal = Decimal.Parse(StrValue, Globalization.NumberStyles.Float, System.Globalization.NumberFormatInfo.InvariantInfo) </code></pre>  <p>Everything was fine, until it tried to parse <code>"1.9721522630525295e-31"</code>. On this string Decimal.Parse raises an OverflowException. "Ok," I thought, "let's try Double instead!"</p>  <pre><code>Dim dblValue As Double = Double.Parse(StrValue) </code></pre>  <p>This works fine. Kind of: the result is <code>0.0000000000000019721522630525295</code>. (or: <code>Double.Parse(StrValue).ToString = "1,97215226305253E-15"</code>)</p>  <p>Ok, next try.</p>  <pre><code>Dim dblValue As Double = Double.Parse(StrValue, Globalization.NumberStyles.Float, System.Globalization.NumberFormatInfo.InvariantInfo) </code></pre>  <p>Works as expected, the <code>E-31</code> stays that way.</p>  <p>So, this is my <strong>1st question</strong>: why is Double.Parse behaving this way?</p>  <p><strong>edit</strong> By "this way" I mean giving me a number 16 orders of magnitude greater then expected (<code>E-15</code> instead of <code>E-31</code>). The question was <strong>answer</strong>ed by varocarbas: the reason is my local decimal and thousands separators settings. The <code>.</code> in <code>"1.9721522630525295e-31"</code> is treated by <code>Double.Parse(StrValue)</code> like thousands separator (i.e. ignored), and thus the Value becames <code>0.0000000000000019721522630525295</code>.</p>  <p>Then I did, like I always did before, convert the result to decimal.</p>  <pre><code>Dim decValue = CDec(dblValue) </code></pre>  <p>No exceptions but the value I got was once again <code>1.9721522630525295E-15</code>. After some google I learned about <code>Convert.ToDecimal</code>, which works fine (the <code>...E-31</code> is converted to <code>0</code>.)</p>  <p>The <strong>2nd question</strong>: shall we always use <code>Convert.ToDecimal</code> and never <code>CDec</code> or are there some rules or best practices or whatever?</p>  <p>So, after all of that I'm now using the following code.</p>  <pre><code>If Not Decimal.TryParse(StrValue, Globalization.NumberStyles.Float, System.Globalization.NumberFormatInfo.InvariantInfo, _                            Value) Then     Value = Convert.ToDecimal(Double.Parse(StrValue, Globalization.NumberStyles.Float, System.Globalization.NumberFormatInfo.InvariantInfo)) End If </code></pre>  <p>My <strong>3rd</strong> and last (for the moment) <strong>question</strong> is: is this code the proper way to do it?</p>  <p>(specs: Visual Studio 2005, .net 3.5, application compiled as 32-bit, Windows locale is set to German.)</p>