<p>I've just started to work with threads,  I want to write simple file compressor. It should create two background threads - one for reading and other one for writing. The first one should read file by small chunks and put them into Queue, where int - is chunkId. The second thread should dequeue chunks and write them down in order(using chunkId) into output stream (file, which this thread created in begin).</p>  <p>I did it. But I cant understand why after my program ends and I open my gziped file - I see, that my chunks mixed, and file doesn't have previous order.</p>  <pre><code>public static class Reader {     private static readonly object Locker = new object();      private const int ChunkSize = 1024*1024;      private static readonly int MaxThreads;     private static readonly Queue&lt;KeyValuePair&lt;int, byte[]&gt;&gt; ChunksQueue;     private static int _chunksComplete;      static Reader()     {         MaxThreads = Environment.ProcessorCount;         ChunksQueue = new Queue&lt;KeyValuePair&lt;int,byte[]&gt;&gt;(MaxThreads);     }      public static void Read(string filename)     {         _chunksComplete = 0;          var tRead = new Thread(Reading) { IsBackground = true };         var tWrite = new Thread(Writing) { IsBackground = true };          tRead.Start(filename);         tWrite.Start(filename);          tRead.Join();         tWrite.Join();          Console.WriteLine("Finished");     }      private static void Writing(object threadContext)     {         var filename = (string) threadContext;          using (var s = File.Create(filename + ".gz"))         {             while (true)             {                 var dataPair = DequeueSafe();                 if (dataPair.Value == null)                     return;                  while (dataPair.Key != _chunksComplete)                 {                     Thread.Sleep(1);                 }                  Console.WriteLine("write chunk {0}", dataPair.Key);                  using (var gz = new GZipStream(s, CompressionMode.Compress, true))                 {                     gz.Write(dataPair.Value, 0, dataPair.Value.Length);                 }                  _chunksComplete++;             }         }     }      private static void Reading(object threadContext)     {         var filename = (string) threadContext;          using (var s = File.OpenRead(filename))         {             var counter = 0;             var buffer = new byte[ChunkSize];             while (s.Read(buffer, 0, buffer.Length) != 0)             {                 while (ChunksQueue.Count == MaxThreads)                 {                     Thread.Sleep(1);                 }                  Console.WriteLine("read chunk {0}", counter);                  var dataPair = new KeyValuePair&lt;int, byte[]&gt;(counter, buffer);                  EnqueueSafe(dataPair);                  counter++;             }              EnqueueSafe(new KeyValuePair&lt;int, byte[]&gt;(0, null));         }     }      private static void EnqueueSafe(KeyValuePair&lt;int, byte[]&gt; dataPair)     {         lock (ChunksQueue)         {             ChunksQueue.Enqueue(dataPair);         }     }      private static KeyValuePair&lt;int, byte[]&gt; DequeueSafe()     {         while (true)         {             lock (ChunksQueue)             {                 if (ChunksQueue.Count &gt; 0)                 {                     return ChunksQueue.Dequeue();                 }             }              Thread.Sleep(1);         }     }  } </code></pre>  <p>UPD: I can use only .NET 3.5</p>