<p>I want to make an instance declaration, but the free type variable is not the last variable. For example, I have a class declaration</p>  <pre><code>class Poppable m where   tryPop :: m a -&gt; Maybe (a, m a) </code></pre>  <p>Now I want to make Q.PSQ (priority queue) an instance of Poppable. Specifically I want something like this:</p>  <pre><code>instance (Ord p) =&gt; Poppable (\a -&gt; Q.PSQ a p) where   tryPop = fmap (first Q.key) . Q.minView </code></pre>  <p>However, this is not legal Haskell code. If the order of arguments to PSQ were switched, then I would have no problem:</p>  <pre><code>instance (Ord p) =&gt; Poppable (Q.PSQ p) where   tryPop = fmap (first Q.key) . Q.minView </code></pre>  <p>How do I switch the order of arguments for the instance declaration?</p>  <p>Now I could wrap PSQ with a newtype:</p>  <pre><code>newtype PSQ'' a b = PSQ'' (Q.PSQ b a) </code></pre>  <p>However this seems clunky to me because I have to constantly wrap/unwrap it. Is there an easier way?</p>  <p>*</p>  <p>I tried using data/type families, but both give errors.</p>  <p>(1) Using a data family declaration:</p>  <pre><code>data family PSQ' a b data instance PSQ' a b = PSQ b a instance (Ord p) =&gt; Poppable (PSQ' p) where   tryPop = fmap (first Q.key) . Q.minView </code></pre>  <p>However this gives the error</p>  <pre><code>Couldn't match type `Q.PSQ a p0' with `PSQ' p a' </code></pre>  <p>even though they can match by setting p=p0.</p>  <p>(2) Type families won't work either.</p>  <pre><code>type family PSQ' a b where   PSQ' b a = Q.PSQ a b </code></pre>  <p>gives </p>  <pre><code>Illegal type synonym family application in instance: PSQ' p </code></pre>