<p>I'm trying to implement <code>MaybeT</code> in the spirit of the <code>mtl</code> library. With this non-compiling solution: </p>  <pre><code>{-# LANGUAGE FlexibleInstances, MultiParamTypeClasses, UndecidableInstances #-}  import Control.Monad import Control.Monad.Trans import Control.Monad.State  newtype MaybeT m a = MaybeT { runMaybeT :: m (Maybe a) }  instance (Monad m) =&gt; Monad (MaybeT m) where     x &gt;&gt;= f = MaybeT $ runMaybeT x &gt;&gt;= maybe (return Nothing) (runMaybeT . f)     return a = MaybeT $ return (Just a)     fail _ = MaybeT $ return Nothing  instance MonadTrans MaybeT where      lift m = MaybeT (liftM Just m)  instance (MonadIO m) =&gt; MonadIO (MaybeT m) where     liftIO m = lift (liftIO m)  instance (MonadState s m) =&gt; MonadState s (MaybeT m) where     get = lift get     put = lift . put  ... </code></pre>  <p>I get the error:</p>  <blockquote>   <p>Could not deduce (Applicative (MaybeT m)) arising from the   superclasses of an instance declaration from the context (Monad m)</p> </blockquote>  <p>If I implement the following, it compiles:</p>  <pre><code>instance (Monad m) =&gt; Applicative (MaybeT m) where     pure = return     (&lt;*&gt;) = ap   instance (Monad m) =&gt; Functor (MaybeT m) where     fmap = liftM </code></pre>  <p>Can GHC do this for me?</p>