<p>In working with lenses, I occasionally have the need for some basic text parsing in the chain of optics. In one API I'm dealing with, there is a JSON field like this:</p>  <pre><code>"timespent": "0.25", </code></pre>  <p>Since it is incorrectly encoded as a string instead of a number, I can't just do the typical <code>lens-aeson</code> solution:</p>  <pre><code>v ^? key "timespent" . _Double -- this doesn't work </code></pre>  <p>So, I need this instead:</p>  <pre><code>v ^? key "timespent" . _String . mystery </code></pre>  <p>where the <code>mystery</code> optic needs to turn <code>Text</code> into a <code>Double</code>. I know that <code>mystery</code> could be typed as follows:</p>  <pre><code>mystery :: Prism' Text Double </code></pre>  <p>And I could built this as follows:</p>  <pre><code>mystery = prism' (pack . show) (readMaybe . unpack) </code></pre>  <p>And technically, this function could have an even more general type signature with <code>Read</code> and <code>Show</code> constraints, but that's not really what my question is about. What I don't like is the <code>Prism</code> is really too strong for what I'm doing. Most of the time, I'm interested in parsing but not is rendering it back to a string. So, I need either a <code>Traversal</code> or a <code>Fold</code> but I'm not sure which one, and I'm not sure how to build them. When I look at the type signature of <code>^?</code> to find the minimum optic required, I see:</p>  <pre><code>(^?) :: s -&gt; Getting (First a) s a -&gt; Maybe a </code></pre>  <p>I can sort of understand what this means but not very well. So, to make my question clear, it is:</p>  <p>If I have a function <code>f :: Text -&gt; Maybe a</code>, how can I turn this into a <code>Traversal</code> or a <code>Fold</code>? Thanks, and let me know if there is anything I can clarify.</p>