<p>So I'm writing a line to get the second to last element of a list. Initially my code was</p>  <pre><code>mySLast x = last.take ((length x) - 1) x </code></pre>  <p>Which worked up until the <code>last</code> function. Realized the my <code>take</code> business is already included in Haskell as <code>init</code> so I rewrote as</p>  <pre><code>mySLast = last.init  </code></pre>  <p>This still doesn't work. I find this puzzling because <code>init::[a]-&gt;[a]</code> and <code>last::[a]-&gt;a</code> so they definitely should be composable morphisms in the <strong>Hask</strong> Category. </p>  <p>I tried asking Haskell what it thinks the type is and it said</p>  <pre><code>ghci&gt; :t last.init last.init :: [c] -&gt; c ghci&gt; last.init [3,2,4,1]  &lt;interactive&gt;:45:6:     Couldn't match expected type ‘a -&gt; [c]’                 with actual type ‘[Integer]’      Relevant bindings include        it :: a -&gt; c (bound at &lt;interactive&gt;:45:1)     Possible cause: ‘init’ is applied to too many arguments      In the second argument of ‘(.)’, namely ‘init [3, 2, 4, 1]’      In the expression: last . init [3, 2, 4, 1] </code></pre>  <p>Even though </p>  <pre><code>ghci&gt; init [3,2,4,1] [3,2,4] ghci&gt; last [3,2,4] 4 </code></pre>  <p>So I must be misunderstanding something about composing functions in Haskell. Any insight would be greatly appreciated!</p>