<p>I am working with Java of late, and was wondering whether there was any kind of interface implementation derivation in Java. My preferred programming language is Haskell, which is in many ways antithetical to Java, but one feature that I was wondering whether Java had anything like is the ability to derive interface implementations of compound types from the interface implementations of their parameters. For example, in Haskell:</p>  <pre><code>data Pair k v = Pair k v  instance (Ord k) =&gt; Ord (Pair k v) where     compare (Pair x _) (Pair x' _) = compare x x' </code></pre>  <p>This allows you to order a <code>Pair</code> if its first parameter can be ordered, without explicitly requiring that to be the case. However, the closest I can come  to this in Java is through explicit requirement:</p>  <pre><code>class Pair&lt;K extends Comparable&lt;K&gt;, V&gt; extends Comparable&lt;Pair&lt;K,V&gt;&gt; {     K k;     V v;     public int compareTo(Pair&lt;K,V&gt; p) {         return k.compareTo(p.k);     } } </code></pre>  <p>Without a way of leaving the comparability to be inferred, it is impossible for me to implement a BST of pairs without ensuring that all pairs have a comparable first element, so I cannot implement any kind of Map where the first element is not explicitly required to be Comparable. Is there any way around this, other than creating a method of my BST class that attempts to compare the generic type by casting it first as comparable, and then as a Pair with a comparable key, comparing whenever comparability is possible?</p>