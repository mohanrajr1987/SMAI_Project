<p>I am connecting to a web service that only allows MAX (could be 1,5,10 depending on your license) concurrent connections to it from the same source. I need a solution that can in real time (not asynchronously) queue requests to the web service, ensuring that only MAX request are running at once.</p>  <p>I have the current set up working:</p>  <pre><code>$jobId = $this-&gt;queue-&gt;addJob($operation);                while ( !$this-&gt;queue-&gt;canRunJob($jobId) ) {   //error_log("Queue full, waiting");                         usleep(500);                                     } $this-&gt;queue-&gt;runJob($jobId); ... $this-&gt;queue-&gt;completeJob($jobId); </code></pre>  <p>This uses a custom queue class, that uses a mysql table to track jobs, and the count the number of actively running and pending jobs.</p>  <p><code>$this-&gt;queue-&gt;addJob</code> adds the new job to the database, with a status of "pending"</p>  <p><code>$this-&gt;queue-&gt;canRunJob($jobId)</code> checks to see how many running jobs there are. If there are less than MAX jobs running, it will grab the next pending job from the list in FIFO order. </p>  <p>The PHP script is looping and sleeping until the job can run. </p>  <p>Once it <code>canRunJob</code> it calls <code>$this-&gt;queue-&gt;runJob($jobId)</code> which updates the job in the queue to "running" and sends the request to the webservice.</p>  <p>When the webservice returns the response it calls <code>$this-&gt;queue-&gt;completeJob($jobId)</code> which updates the job in the queue to  "completed".</p>  <p>This works 95% of the time, but if the web service provider is bogged down, or down completely, it slowly causes a process buildup on my server which locks up web and database connections. </p>  <p>Looking for suggestions of another way to handle this scenario without looping / sleeping</p>