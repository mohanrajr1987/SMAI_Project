<p>How can i implement the Dijkstra using only queues instead of priority queues  .Is this possible ? if not,why ? This is My Code in java.. whats my mistake ?<br> "S" is the starting node "W" is the weight "N" is the size of the matrix. I added 1 to the length of the adj matrix since the first node is "1". </p>  <p>This is a problem from HackerRank Link :<a href="https://www.hackerrank.com/challenges/dijkstrashortreach" rel="nofollow">https://www.hackerrank.com/challenges/dijkstrashortreach</a></p>  <pre><code>  import java.io.*;   import java.util.*;  public class Solution {  public static void main(String[] args) {      Scanner in = new Scanner (System.in);     int cases = in.nextInt();      for(int i=0; i&lt;cases; i++){         int N = in.nextInt();         int M = in.nextInt();         int adj[][] = new int[N+1][N+1];          for(int j=0; j&lt;N+1; j++){             for(int k=0; k&lt;N+1; k++){                 adj[j][k] = 0;             }         }          for(int j=0; j&lt;M; j++){             int A = in.nextInt();             int B = in.nextInt();             int W = in.nextInt();              adj[A][B] = W;             adj[B][A] = W;         }          int S  = in.nextInt();          Queue&lt;Integer&gt; que = new  LinkedList&lt;Integer&gt;();         que.add(S);          int dist[] = new int[N+1];         Arrays.fill(dist,Integer.MAX_VALUE);         boolean vis[] = new boolean[N+1];          dist[S] = 0;         vis[S] = true;          while(!que.isEmpty()){             int q = que.poll();              for(int j=1; j&lt;=N; j++){                 if(!vis[j]&amp;&amp;q!=j &amp;&amp; adj[q][j]!=0){                      if(dist[j]&gt;dist[q]+adj[q][j]){                       dist[j] = dist[q]+adj[q][j];                         que.add(j);                     }                  }             }             vis[q] = true;         }          for(int j=1; j&lt;=N; j++){             if(dist[j]!=0)             System.out.print(dist[j]+" ");         }     }  } </code></pre>  <p>}</p>