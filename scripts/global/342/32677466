<p>I am trying to read from a serial port and put the data in a queue.</p>  <p>I have a thread to read from this queue and do some calculation on the data. the name of the thread is: QueueThread</p>  <p>how ever, 1 of threads freezes. </p>  <p>here is my code:</p>  <pre><code> private void init() {   _sp.DataReceived += new SerialDataReceivedEventHandler(Sp_DataReceived);   QueueThread = new Thread(new ThreadStart(queueThread));   QueueThread.IsBackground = true;   QueueThread.Start(); }       private void Sp_DataReceived(object sender, SerialDataReceivedEventArgs e)     {                   spd.data = new byte[(sender as SerialPort).BytesToRead]; // get the bytes to read                                                                     (sender as SerialPort).Read(spd.data, 0, (sender as SerialPort).BytesToRead);                      _mySerialPortData.ComName = _sp.PortName;                     _mySerialPortData.data = spd.data;                     _mySerialPortData.dt = DateTime.Now;                      lock (_message)                     {                     _queueSerialData.Enqueue(_mySerialPortData);                                                 }     }        private void queueThread()     {          while (true)         {             //System.Threading.Thread.Sleep(10);             //lock (_message)             //{             int queuecnt = _queueSerialData.Count;                 if (queuecnt &gt; 0)                 {                       SerialPortData spdq1 = new SerialPortData();                     lock (_queueSerialData)                         {                         spdq1 = _queueSerialData.Dequeue();                     }                      if (spdq1.data[0] == 0x0D) // is it the start of the 0x0D                                                                     {                          if (spdq1.data.Length &lt; 2)                         {                             _queueSerialData.Enqueue(spdq1);                             break;                         }                            int x = Int32.Parse(spdq1.data[1].ToString()); //data[1] is the length of the message.                                                  x = x + 2; //the +2 is for include the STM and the EOM                            if (spdq1.data.Length &gt; x) // does the data that has been recieived                          {                             if (spdq1.data[x] == 0x0A) //found 0x0A meesage                               {                                 if (x == spdq1.data.Length - 1) // if the message  is the exact length.                                 {                                     Newspdq1 = spdq1;                                     _queueSerialDataFinal.Enqueue(Newspdq1);                                 }                                   else //  if message is not the exact length there is more message.                                 {                                     Newspdq1 = new SerialPortData();                                     Newspdq1.ComName = spdq1.ComName;                                     Newspdq1.dt = spdq1.dt;                                     Newspdq1.data = new byte[x + 1];                                      for (int j = 0; j &lt; x + 1; j++)                                     {                                         Newspdq1.data[j] = spd.data[j];                                     }                                     lock (_queueSerialDataFinal)                                     {                                         _queueSerialDataFinal.Enqueue(Newspdq1); // this is a real message                                     }                                      int y = Int32.Parse(spdq1.data[x + 2].ToString()); //x+2 is the length of the next message                                     y = y + 2; //the +2 is for include the STM and the EOM                                        if (spdq1.data[spdq1.data.Length - 1] == 0x0A) // the length of the secound  message is exactly the end of the messages                                     {                                         Newspdq1 = new SerialPortData();                                         Newspdq1.ComName = spdq1.ComName;                                         Newspdq1.dt = spdq1.dt;                                         Newspdq1.data = new byte[y + 1];                                          for (int j = x + 1; j &lt; spdq1.data.Length; j++)                                         {                                             Newspdq1.data[j - x - 1] = spd.data[j];                                             lock (_queueSerialDataFinal)                                             {                                                 _queueSerialDataFinal.Enqueue(Newspdq1);                                             }                                         }                                     }                                      else                                     {                                         _queueSerialData.Enqueue(spdq1);                                         break;                                     }                                 }                              }                              else // the message doesn'e end with EOM                              {                                 _queueSerialData.Enqueue(spdq1);                                 break;                             }                          }                     }                       else                     {                         _queueSerialData.Enqueue(spdq1);                         break;                     }                    //  }                  }                  if (_queueSerialData2.Count &gt; 0)                 {                     lock (_queueSerialData2)                     {                     }                  }                       System.Threading.Thread.Sleep(1);          //  }         }     } </code></pre>