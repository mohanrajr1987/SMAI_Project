<p>I've written a simple lock-free single-consumer/-producer queue. It's supposed to work like this:</p>  <ul> <li>at any time many consumers may read from it</li> <li>at any time multiple producers can write to it, added elements will be made available later</li> <li>after write modification is finished, we call "makePushedElementsAvailable()", so that consumers can read the newly added elements</li> </ul>  <p>.</p>  <pre><code>template&lt;typename T, int Size&gt; class MCMPQueue { public:     MCMPQueue();     bool tryPushLater(const T &amp;element);     bool tryPop(T &amp;element);     void makePushedElementsAvailable(); protected: private:     T elements[Size];     std::atomic&lt;int&gt; iHead, iTail, iWrite; };  template&lt;typename T, int Size&gt; MCMPQueue&lt;T, Size&gt;::SCMPQueue() : iHead(0), iTail(0), iWrite(0) { }  template&lt;typename T, int Size&gt; void MCMPQueue&lt;T, Size&gt;::makePushedElementsAvailable() {     iTail.store(iWrite.load()); }  template&lt;typename T, int Size&gt; bool MCMPQueue&lt;T, Size&gt;::tryPop(T &amp;element) {     int newIndex;     int index;     do {         index = iHead.load();         if (index == iTail.load())             return false;         newIndex = index + 1;     } while (!iHead.compare_exchange_weak(index, newIndex));      index = index % Size;     element = elements[index];     return true; }  template&lt;typename T, int Size&gt; bool MCMPQueue&lt;T, Size&gt;::tryPushLater(const T &amp;element) {     int newIndex;     int index;     do {         index = iWrite.load();         if (index - iHead.load() &gt;= Size)             return false;         newIndex = index + 1;     } while (!iWrite.compare_exchange_weak(index, newIndex));      index = index % Size;     elements[index] = element;     return true; } </code></pre>  <p>So far this seems to work fine, I'd like to have it checked by some others though please. Is there a simpler way than making the elements available after all updating has finished?</p>  <p>Thanks.</p>