<p>I know this question was answered many times, but I'm struggling to understand how it works.</p>  <p>So in my application the user must be able to select items which will be added to a queue (displayed in a <code>ListView</code> using an <code>ObservableList&lt;Task&gt;</code>) and each item needs to be processed sequentially by an <code>ExecutorService</code>.  </p>  <p>Also that queue should be editable (change the order and remove items from the list).</p>  <pre><code>private void handleItemClicked(MouseEvent event) {     if (event.getClickCount() == 2) {         File item = listView.getSelectionModel().getSelectedItem();         Task&lt;Void&gt; task = createTask(item);         facade.getTaskQueueList().add(task); // this list is bound to a ListView, where it can be edited         Future result = executor.submit(task);          // where executor is an ExecutorService of which type?          try {             result.get();         } catch (Exception e) {             // ...         }     } } </code></pre>  <p>Tried it with <code>executor = Executors.newFixedThreadPool(1)</code> but I don't have control over the queue.<br> I read about <code>ThreadPoolExecutor</code> and queues, but I'm struggling to understand it as I'm quite new to Concurrency.</p>  <p>I need to run that method <code>handleItemClicked</code> in a background thread, so that the UI does not freeze, how can I do that the best way?</p>  <p><strong>Summed up: How can I implement a queue of tasks, which is editable and sequentially processed by a background thread?</strong></p>  <p>Please help me figure it out</p>  <p><strong>EDIT</strong> Using the <code>SerialTaskQueue</code> class from vanOekel helped me, now I want to bind the List of tasks to my <code>ListView</code>.</p>  <pre><code>ListProperty&lt;Runnable&gt; listProperty = new SimpleListProperty&lt;&gt;(); listProperty.set(taskQueue.getTaskList()); // getTaskList() returns the LinkedList from SerialTaskQueue queueListView.itemsProperty().bind(listProperty);  </code></pre>  <p>Obviously this doesn't work as it's expecting an ObservableList. There is an elegant way to do it?</p>