<p>I'm trying to save a series of frames from Kinect II to the hard drive as jpegs. In order to do so, I add each new frame to a queue and then, at the end of the programme, I dequeue and write down to separate jpeg files, one frame per file, as that is what I want. The problem is that I get <em>n</em> times the same picture, even though the frames were acquired at different times. The file names are taken from another queue and this, i.e. file naming, works perfectly well. Does anyone have any idea what I may be doing wrong? Here are some excerpts from the C# code. </p>  <pre><code>    public static Queue&lt;string&gt; paths = new Queue&lt;string&gt;();     public static Queue&lt;WriteableBitmap&gt; photographs = new Queue&lt;WriteableBitmap&gt;(); </code></pre>  <p>...</p>  <pre><code>    private void Reader_ColorFrameArrived(object sender, ColorFrameArrivedEventArgs e)     {         // ColorFrame is IDisposable         using (ColorFrame colorFrame = e.FrameReference.AcquireFrame())         {             if (colorFrame != null)             {                 FrameDescription colorFrameDescription = colorFrame.FrameDescription;                  using (KinectBuffer colorBuffer = colorFrame.LockRawImageBuffer())                 {                     colorBitmap.Lock();                      if (idx == 1)                     {                         photographs.Enqueue(colorBitmap);                     }                      // verify data and write the new color frame data to the display bitmap                     if ((colorFrameDescription.Width == colorBitmap.PixelWidth) &amp;&amp; (colorFrameDescription.Height == colorBitmap.PixelHeight))                     {                         colorFrame.CopyConvertedFrameDataToIntPtr(                             colorBitmap.BackBuffer,                             (uint)(colorFrameDescription.Width * colorFrameDescription.Height * 4),                             ColorImageFormat.Bgra);                          colorBitmap.AddDirtyRect(new Int32Rect(0, 0, colorBitmap.PixelWidth, colorBitmap.PixelHeight));                     }                      colorBitmap.Unlock();                 }             }         }     } </code></pre>  <p>...</p>  <pre><code>    private void StopRecordButton_Click(object sender, RoutedEventArgs e)     {         do         {             using (FileStream fs = new FileStream(paths.Dequeue(), FileMode.Create))             {                 JpegBitmapEncoder encoder = new JpegBitmapEncoder();                 encoder.Frames.Add(BitmapFrame.Create(photographs.Dequeue()));                 encoder.Save(fs);                 encoder = null;             }         } while (photographs.Count &gt; 0);          idx = 0;         updateStatus("Ready", Status);     } </code></pre>  <p>I skipped enqueueing the paths, as that works obviously, since I get a set of jpeg files named exactly as I wanted. The only problem is that each file contains the same picture.</p>