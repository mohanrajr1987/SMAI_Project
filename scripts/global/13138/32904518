<p>My program generates random numbers from 0 to 12 but if the result is 12 it would set dash as the text of JLabel, instead of the number generated.</p>  <p>Now, I wanted to sort my <code>JPanel</code> in ascending order based on the <code>JLabel</code> contents. In case of similarities in numbers, the black <code>JPanels</code> are placed on the left. It works fine except when there are dashes included, in which it doesn't sort properly. I would like to insert the <code>JPanels</code> containing dashes anywhere but it's not working as expected.</p>  <p>Screencaps from a shorter version of my program:</p>  <p>Pure numbers:</p>  <p><a href="http://i.stack.imgur.com/BPe9S.png" rel="nofollow"><img src="http://i.stack.imgur.com/BPe9S.png" alt="enter image description here"></a></p>  <p>Dash included:</p>  <p><a href="http://i.stack.imgur.com/qzJFv.png" rel="nofollow"><img src="http://i.stack.imgur.com/qzJFv.png" alt="enter image description here"></a></p>  <p>Here's the shorter version of my code (using the logic of integer sorting):</p>  <pre><code>import java.awt.*; import javax.swing.*; import java.util.ArrayList; import java.util.Collections; import java.util.Random; import java.util.Comparator;  public class SortFrames extends JFrame {     static ArrayList&lt;JPanel&gt; panels = new ArrayList&lt;JPanel&gt;();     JPanel panel = new JPanel();     JPanel sortPane = new JPanel();     int toWrite = 0;     int colorGen = 0;     int comparison = 0;     Random rand = new Random();      public SortFrames()     {         for(int i = 0; i&lt;4;i++)         {             panels.add(new JPanel());         }          for(JPanel p: panels)         {             toWrite = rand.nextInt(13);             colorGen = rand.nextInt(2);                  p.add(new JLabel());             JLabel lblToSet = (JLabel)p.getComponent(0);              if(colorGen == 0)             {                 p.setBackground(Color.BLACK);                 lblToSet.setForeground(Color.WHITE);             }              if(colorGen == 1)             {                 p.setBackground(Color.WHITE);                 lblToSet.setForeground(Color.BLACK);             }              if(toWrite != 12){lblToSet.setText("" +toWrite);}                        if(toWrite == 12){lblToSet.setText("-");}                        p.setPreferredSize(new Dimension(30, 30));             panel.add(p);         }           sortMethod();          for(JPanel p: panels)         {             panel.add(p);             panel.revalidate();         }          add(panel);         panel.setPreferredSize(new Dimension(300, 300));         setPreferredSize(new Dimension(300, 300));         setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);         setVisible(true);         pack();         setLocationRelativeTo(null);     }      public void sortMethod()     {         for(int i = 0; i&lt;(panels.size());i++)         {             for(int j = i+1; j&lt;(panels.size());j++)             {                 JLabel one = (JLabel)(panels.get(i)).getComponent(0);                 JLabel two = (JLabel)(panels.get(j)).getComponent(0);                 String lblOne = one.getText();                 String lblTwo = two.getText();                  if(!lblOne.equals("-") &amp;&amp; !lblTwo.equals("-"))                 {                     int comp1 = Integer.parseInt(lblOne);                     int comp2 = Integer.parseInt(lblTwo);                     JPanel pnl1 = panels.get(i);                     JPanel pnl2 = panels.get(j);                              if(comp1 == comp2)                     {                         if(pnl1.getBackground() == Color.BLACK &amp;&amp; pnl2.getBackground() == Color.WHITE)                                   {                             panels.set(i, pnl1);                             panels.set(j, pnl2);                         }                                 if(pnl1.getBackground() == Color.WHITE &amp;&amp; pnl2.getBackground() == Color.BLACK)                                   {                             panels.set(i, pnl2);                             panels.set(j, pnl1);                         }                     }                      if(comp1 != comp2)                     {                         if(comp1&gt;comp2)                         {                             panels.set(i, pnl2);                             panels.set(j, pnl1);                         }                     }                 }                  if(lblOne.equals("-") &amp;&amp; !lblTwo.equals("-"))                 {                     JPanel pnl1 = panels.get(i);                     panels.set(rand.nextInt(panels.size()), pnl1);                 }                             if(!lblOne.equals("-") &amp;&amp; lblTwo.equals("-"))                 {                     JPanel pnl2 = panels.get(j);                     panels.set(rand.nextInt(panels.size()), pnl2);                 }             }                }     }      public static void main(String args[])     {         new SortFrames();     } } </code></pre>  <p>I also have another method, which is by using <code>Comparator</code> class which also creates the same problem (this sorts equal numbers based on foreground but still the same as to sort equal numbers based on background so it has no effect on the said issue).</p>  <pre><code>private static class JPanelSort implements Comparator&lt;JPanel&gt; {     @Override     public int compare(JPanel arg0, JPanel arg1)      {         JLabel one = ((JLabel) arg0.getComponent(0));         JLabel two = ((JLabel) arg1.getComponent(0));         String firstContent = one.getText();         String secondContent = two.getText();                 try         {                        comparisonRes = Integer.compare(Integer.parseInt(firstContent), Integer.parseInt(secondContent));                    if(comparisonRes == 0)             {                            if(one.getForeground() == Color.BLACK &amp;&amp; two.getForeground() == Color.WHITE)                 {                     comparisonRes = 1;                       }                 if(two.getForeground() == Color.BLACK &amp;&amp; one.getForeground() == Color.WHITE)                 {                     comparisonRes = -1;                              }             }         }          catch(NumberFormatException e)         {             comparisonRes = 0;         }         return comparisonRes;      }        }    </code></pre>  <p>Please tell me your ideas. Thank you.</p>