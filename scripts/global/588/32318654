<p>I am developing a complete library (in Javascript) containing main structures and algorithms. I need to design a compare function in order to compare every kind of data.</p>  <p>Iâ€™ll use this function as:</p>  <p>a = some data (string, number, object, array, ...)</p>  <p>b = some data (string, number, object, array, ...)</p>  <p>b.compare(a) :</p>  <ul> <li>0 if a is equal to b</li> <li>1 if  b i greater than </li> <li>-1 if b is less than a</li> </ul>  <p>I designed my version and I got inspired by _.eq of underscore.js framework.</p>  <p>What do you think about it?  Is there any better way to implement it?</p>  <pre><code>function compare (a, b, aStack, bStack) {          // with this I can youse compare as b.compare(a)         b = b || this.data;          // Unwrap any wrapped objects.         if (b instanceof ObjectNode) b = b.data;         if (a instanceof ObjectNode) a = a.data;          // Identical objects are equal. `0 === -0`, but they aren't identical.         // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).         if (a === b) {             if(a !== 0) return 0;             else if(1 / a === 1 / b) return 0;             else return (1 / b &gt; 1 / a)? 1 : -1;         }         // A strict comparison is necessary because `null == undefined`.         if (a == null || b == null || a == undefined || b == undefined) {             if(a === b) return 0;             /* Now I am defining:             (NaN &gt; null)             null &gt; undefined             null &lt; everything else             undefined &lt; everything */             if(a == undefined) return 1;             if(b == undefined) return -1;             if(a == null)   return 1;         }          // Compare `[[Class]]` names.         var className = toString.call(a);         if (className !== toString.call(b)) {              // In this case I compare strings;             if(className &lt; toString.call(b)) 1;             if(className &gt; toString.call(b)) -1;          }         switch (className) {                 // Strings, numbers, regular expressions, dates, and booleans are compared by value.             case '[object RegExp]':                 // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')             case '[object String]':                 // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is                 // equivalent to `new String("5")`.                 if('' + a === '' + b) return 0;                 if('' + a &lt; '' + b) return 1;                 if('' + a &gt; '' + b) return -1;              case '[object Number]':                 // `NaN`s are equivalent, but non-reflexive.                 // Object(NaN) is equivalent to NaN                 // Nan is less than anyother but bigger than undefined and than null                 if (+a !== +a) return (+b !== +b)? 0 : 1;                 // An `egal` comparison is performed for other numeric values.                 if (+a === 0) return  (1 / +b === 1 / a)? 0 : ((1 / +b &gt; 1 / a)? 1 : -1);                 return (+a === +b)? 0 : (+b &gt; +a)? 1 : -1;             case '[object Date]':             case '[object Boolean]':                 // Coerce dates and booleans to numeric primitive values. Dates are compared by their                 // millisecond representations. Note that invalid dates with millisecond representations                 // of `NaN` are not equivalent.                 return (+a === +b) ? 0 : (+b &gt; +a)? 1 : -1;         }          var areArrays = className === '[object Array]';         if (!areArrays) {             if (typeof a != 'object') return 1;             if (typeof b != 'object') return -1;              // Objects with different constructors are not equivalent, but `Object`s or `Array`s             // from different frames are.             var aCtor = a.constructor, bCtor = b.constructor;             if (aCtor !== bCtor &amp;&amp; !((typeof aCtor == 'function') &amp;&amp; aCtor instanceof aCtor &amp;&amp;                                      (typeof bCtor == 'function') &amp;&amp; bCtor instanceof bCtor)                 &amp;&amp; ('constructor' in a &amp;&amp; 'constructor' in b)) {                 return b&gt;a? 1 : -1;             }         }         // Assume equality for cyclic structures. The algorithm for detecting cyclic         // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.          // Initializing stack of traversed objects.         // It's done here since we only need them for objects and arrays comparison.         aStack = aStack || [];         bStack = bStack || [];         var length = aStack.length;         while (length--) {             // Linear search. Performance is inversely proportional to the number of             // unique nested structures.             if (aStack[length] === a) return bStack[length] === b;         }          // Add the first object to the stack of traversed objects.         aStack.push(a);         bStack.push(b);          // Recursively compare objects and arrays.         if (areArrays) {             // Compare array lengths to determine if a deep comparison is necessary.             length = a.length;             if (length !== b.length) return b.length&gt;a.length? 1 : -1;             // Deep compare the contents, ignoring non-numeric properties.             var res;             while (length--) {                 if ( (res = this.compare(a[length], b[length], aStack, bStack)) != 0) return res;             }         } else {             // Deep compare objects.             var keys = Object.keys(a), key;             length = keys.length;             // Ensure that both objects contain the same number of properties before comparing deep equality.             if (Object.keys(b).length !== length) return (Object.keys(b).length &gt; length)? 1 : -1;             while (length--) {                 // Deep compare each member                 key = keys[length];                 if (!(hasOwnProperty.call(b, key) &amp;&amp; (res = this.compare(a[key], b[key], aStack, bStack)) === 0)) return res;             }         }         // Remove the first object from the stack of traversed objects.         aStack.pop();         bStack.pop();         return 0;     } </code></pre>