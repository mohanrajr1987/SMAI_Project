<p>I want to deserialize an object with properties.  The object is well constructed but setters/getters are not correctly instancied if I don't type explicitly my object.</p>  <p>Is it an intended behavior or a bug ?</p>  <p>Minimal example:</p>  <pre><code>package models; class TestClass {     public var test(default, set): String;     public function set_test(myVar) {         trace("Set " + myVar);         return test = myVar;     } }  class Main {     public function new()      {        var typedTest: TestClass = Type.createInstance(Type.resolveClass("models.TestClass"), []);        var untypedTest = Type.createInstance(Type.resolveClass("models.TestClass"), []);        trace(Type.getClassName(Type.getClass(typedTest)));   //"models.TestClass"        trace(Type.getClassName(Type.getClass(untypedTest )));  //"models.TestClass"        typedTest.test = "12";  // "Set 12"        untypedTest.test = "15"; //nothing happens here        Reflect.setProperty(untypedTest, "test", "18"); // "Set 18"     } } </code></pre>  <p>I'm kinda confused about this one.</p>  <hr>  <p>SOLUTION <a href="https://github.com/HaxeFoundation/haxe/issues/4562" rel="nofollow">github answer</a></p>  <p>Properties are resolved at compile-time which means that the type has to be known. See <a href="http://haxe.org/manual/class-field-property-type-system-impact.html" rel="nofollow">http://haxe.org/manual/class-field-property-type-system-impact.html</a></p>  <p>Reflect.setProperty is triggered at runtime...</p>