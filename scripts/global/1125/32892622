<p>I'm using DataContractJsonSerializer (my only option for this specific project) to serialize a class similar to this which includes the <code>[IgnoreDataMember]</code> attribute: </p>  <pre><code> public class TestClass {     public int Test1 { get; set; }     public int Test2 { get; set; }     [IgnoreDataMember]     public int Test3 { get; set; } } </code></pre>  <p>My serialization code is taken right from the example page from MS:</p>  <pre><code>TestClass MyTest = new TestClass(); MyTest.Test1 = 1; MyTest.Test2 = 2; MyTest.Test3 = 3;  MemoryStream stream1 = new MemoryStream(); DataContractJsonSerializer ser = new DataContractJsonSerializer(typeof(TestClass)); ser.WriteObject(stream1, MyTest); stream1.Position = 0; StreamReader sr = new StreamReader(stream1); string sContent = sr.ReadToEnd(); </code></pre>  <p>But the output I get back always includes the <code>Test3</code> attribute:</p>  <pre><code>{"Test1":1,"Test2":2,"Test3":3} </code></pre>  <p>If I define the class like this:</p>  <pre><code> [DataContract]     public class TestClass     {         [DataMember]         public int Test1 { get; set; }         [DataMember]         public int Test2 { get; set; }         public int Test3 { get; set; }     } </code></pre>  <p>I get back the proper output like this:</p>  <pre><code>{"Test1":1,"Test2":2} </code></pre>  <p>The class I really want to serialize has dozens of properties and I only want to ignore a small number of them so I would prefer to use <code>[IgnoreDataMember]</code> instead of <code>[DataContaract]</code> and <code>[DataMember]</code>.</p>  <p>Am I doing something wrong with the way I'm using the <code>[IgnoreDataMember]</code>?  </p>