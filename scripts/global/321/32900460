<p>Normally if I want to allocate a zero initialized array I would do something like this:</p>  <pre><code>int size = 1000; int* i = (int*)calloc(sizeof int, size)); </code></pre>  <p>And later my code can do this to check if an element in the array has been initialized:</p>  <pre><code>if(!i[10]) {   // i[10] has not been initialized } </code></pre>  <p>However in this case I don't want to pay the upfront cost of zero initializing the array because the array may be quite large (i.e. gigs). But in this case I can afford to use as much memory as I want memory.</p>  <p>I think I remember that there is a technique to keep track of the elements in the array that have been initialed, without paying any up front cost, that also allows O(1) cost (not amortized with a hash table). My recollection is that the technique requires an extra array of the same size.</p>  <p>I think it was something like this:</p>  <pre><code>int size = 1000; int* i = (int*)malloc(size*sizeof int)); int* i_markers = (int*)malloc(size*sizeof int)); </code></pre>  <p>If an entry in the array is used it is recorded like this:</p>  <pre><code>i_markers[10] = &amp;i[10]; </code></pre>  <p>And then it's use can be checked later like this:</p>  <pre><code>if(i_markers[10] != &amp;i[10]) {   // i[10] has not been initialized } </code></pre>  <p>Of course this isn't quite right because <code>i_markers[10]</code> could have been randomly set to <code>&amp;i[10]</code>.</p>  <p>Can anyone out there remind me of the technique?</p>  <p>Thank you!</p>  <hr>  <p>I think I remembered it. Is this right? Is there a better way or are there variations on this? Thanks again. (This was updated to be the right answer)</p>  <pre><code>struct lazy_array {     int size;     int* values;     int* used;     int* back_references;     int num_used; };  struct lazy_array* create_lazy_array(int size) {     struct lazy_array* lazy = (struct lazy_array*)malloc(sizeof(lazy_array));     lazy-&gt;size = 1000;     lazy-&gt;values = (int*)malloc(size*sizeof int));     lazy-&gt;used = (int*)malloc(size*sizeof int));     lazy-&gt;back_references = (int*)malloc(size*sizeof int));     lazy-&gt;num_used = 0;     return lazy; }  void use_index(struct lazy_array* lazy, int index, int value) {     lazy-&gt;values[index] = value;     if(is_index_used(lazy, index))       return;     lazy-&gt;used[index] = lazy-&gt;used;     lazy-&gt;back_references[lazy-&gt;used[index]] = index;     ++lazy-&gt;used; }  int is_index_used(struct lazy_array* lazy, int index) {     return lazy-&gt;used[index] &lt; lazy-&gt;num_used &amp;&amp;         lazy-&gt;back_references[lazy-&gt;used[index]] == index); } </code></pre>