<p>I have been learning C for the last few weeks in Linux Mint. But, I switched to OSX and was testing this code:</p>  <pre><code>#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt;   int main() {   int *arr = calloc(10, sizeof(int));   if(arr == NULL)     printf("arr is null");    for(int i = 0; i &lt; 10; i++, arr++){     printf("%d \n", *arr);   }     free(arr);    return 0;  } </code></pre>  <p>This should work and print 10 zeros, which it does but it does not free arr.</p>  <p>This is the output:</p>  <pre><code>0  0  0  0  0  0  0  0  0  0  a.out(532,0x7fff72606300) malloc: *** error for object 0x7ff060c04b48: pointer being freed was not allocated *** set a breakpoint in malloc_error_break to debug Abort trap: 6 </code></pre>  <p>I don't understand how I could access memory that was not allocated. Shouldn't the output be "arr is null" if arr is not allocated?</p>