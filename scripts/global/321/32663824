<p>I have been learning C for a while and I am writing C code for a project. I mainly tried to test the usage of structs. I wrote a simple create and delete method for it:</p>  <pre><code>#include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt;  struct TokenizerT_ {   int index; };  typedef struct TokenizerT_ TokenizerT;  TokenizerT *TKCreate( char * ts ) {   TokenizerT *tk = (TokenizerT *)(malloc(sizeof(TokenizerT)));    if(tk == NULL)     return NULL;    tk-&gt;index = 0;    return tk; }  void TKDestroy( TokenizerT * tk ) {   free(tk);   return; }  int main(int argc, char ** argv) {     TokenizerT *tk = TKCreate(argv[1]);     printf("%lu\n", sizeof(tk-&gt;index));     TKDestroy(tk);     return 0; } </code></pre>  <p>So, this compiles and prints 4 as expected on my machine. However, when I ran it through valgrind I get this:</p>  <pre><code>==816== Memcheck, a memory error detector ==816== Copyright (C) 2002-2015, and GNU GPL'd, by Julian Seward et al. ==816== Using Valgrind-3.11.0.SVN and LibVEX; rerun with -h for copyright info ==816== Command: ./test ==816==  --816-- run: /usr/bin/dsymutil "./test" warning: no debug symbols in executable (-arch x86_64) 4 ==816==  ==816== HEAP SUMMARY: ==816==     in use at exit: 38,504 bytes in 415 blocks ==816==   total heap usage: 516 allocs, 101 frees, 45,484 bytes allocated ==816==  ==816== LEAK SUMMARY: ==816==    definitely lost: 0 bytes in 0 blocks ==816==    indirectly lost: 0 bytes in 0 blocks ==816==      possibly lost: 0 bytes in 0 blocks ==816==    still reachable: 0 bytes in 0 blocks ==816==         suppressed: 38,504 bytes in 415 blocks ==816==  ==816== For counts of detected and suppressed errors, rerun with: -v ==816== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0) </code></pre>  <p>I don't know if this is helpful but my machine is OSX 10.10.5. I really have no idea how my program makes 501 mallocs. </p>