<p>Right now, I'm attempting to familiarize myself with C by writing a function which, given a string, will replace all instances of a target substring with a new substring. However, I've run into a problem with a reallocation of a <code>char*</code> array. To my eyes, it seems as though I'm able to successfully reallocate the array <code>string</code> to a desired new size at the end of the main loop, then perform a <code>strcpy</code> to fill it with an updated string. However, it fails for the following scenario:</p>  <p>Original input for string: "use the restroom. Then I need"<br/> Target to replace: "the" (case insensitive)<br/> Desired replacement value: "th'"</p>  <p>At the end of the loop, the line <code>printf("result: %s\n ",string);</code> prints out the correct phrase "use th' restroom. Then I need". However, <code>string</code> seems to then reset itself: the call to <code>strcasestr</code> in the <code>while()</code> statement is successful, the line at the beginning of the loop <code>printf("string: %s \n",string);</code> prints the original input string, and the loop continues indefinitely.</p>  <p>Any ideas would be much appreciated (and I apologize in advance for my flailing debug <code>printf</code> statements). Thanks!</p>  <p>The code for the function is as follows:</p>  <pre><code>int replaceSubstring(char *string, int strLen, char*oldSubstring,     int oldSublen, char*newSubstring, int newSublen ) {     printf("Starting replace\n");     char* strLoc;      while((strLoc = strcasestr(string, oldSubstring)) != NULL )     {         printf("string: %s \n",string);         printf("%d",newSublen);         char *newBuf = (char *) malloc((size_t)(strLen +             (newSublen - oldSublen)));         printf("got newbuf\n");         int stringIndex = 0;         int newBufIndex = 0;         char c;         while(true)         {             if(stringIndex &gt; 500)                 break;             if(&amp;string[stringIndex] == strLoc)             {                 int j;                 for(j=0; j &lt; newSublen; j++)                 {                      printf("new index: %d  %c --&gt; %c\n",                         j+newBufIndex, newBuf[newBufIndex+j], newSubstring[j]);                     newBuf[newBufIndex+j] = newSubstring[j];                 }                 stringIndex += oldSublen;                 newBufIndex += newSublen;             }             else             {                 printf("old index: %d  %c --&gt; %c\n", stringIndex,                     newBuf[newBufIndex], string[stringIndex]);                 newBuf[newBufIndex] = string[stringIndex];                 if(string[stringIndex] == '\0')                     break;                 newBufIndex++;                 stringIndex++;             }         }         int length = (size_t)(strLen + (newSublen - oldSublen));         string = (char*)realloc(string,             (size_t)(strLen + (newSublen - oldSublen)));         strcpy(string, newBuf);         printf("result: %s\n ",string);         free(newBuf);     }     printf("end result: %s ",string); } </code></pre>