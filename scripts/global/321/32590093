<p>Hey guys really hoping you can help. This program im working on with another person was running fine at some point. Then sometimes it would crash but then run fine again after restarting windows. Was very intermittent and now always crashes. At some point I thought maybe its because I upgraded to windows 10 somehow (i know). On my windows 10 machine it now it always crashes no matter what.</p>  <p>So I installed VS on my windows 7 machine and got different behavior again.</p>  <p>So it runs fine but displays no output if it is run without debugging.</p>  <p>If I run with debugging it triggers an unhandled exception break point when allocating memory in the following section of code.</p>  <pre><code>/* * clone() * Precondition: s is defined and not NULL * Postcondition: a copy of s has been returned * Informally: Clone a sample */  sample clone(sample s) {     sample c;      c = (sample)malloc(sizeof(struct sample_int)); //&lt;-----exception error      c-&gt;name = (char *)malloc((strlen(s-&gt;name) + 1)*sizeof(char));     strcpy(c-&gt;name, s-&gt;name);      c-&gt;sequence = (char *)malloc((strlen(s-&gt;sequence) + 1)*sizeof(char));     strcpy(c-&gt;sequence, s-&gt;sequence);      c-&gt;match = s-&gt;match;      return c; } </code></pre>  <p>When clicking continue I get an Access Violation at location... error.</p>  <p>By this stage it is the 2nd time the function has been called. Below is the header file for sample.c</p>  <pre><code>/*  * Specification for the Sample ADT  * Author Julian Dermoudy  * Version 20/8/15  */  #ifndef SAMPLE_H #define SAMPLE_H  struct sample_int; typedef struct sample_int *sample;  void init_sample(sample *s, char *name, char *sequence); char *getName(sample s); char *getSequence(sample s); int getMatch(sample s); void setName(sample s, char *name); void setSequence(sample s, char *name); void setMatch(sample s, int m); sample clone(sample s); char *toString(sample s);  #endif </code></pre>  <p>the clone function is taking an existing sample struct with data in all feilds </p>  <p>Am I missing something about malloc? And why would it seem to work fine on 1 computer never on another and bring up this exception error on yet another computer?</p>  <p>Any advice would be greatly appreciated.</p>  <p>Figured noone is reading this anymore but good to have a record for myself :) I am slowly solving my own problem bu pretymuch rewriting the entire group project myself.</p>  <p>The problem was in the function that initialises the samples..</p>  <pre><code>void init_sample(sample *s, char *name, char *samp) {     *s = (sample)malloc(sizeof(sample));     (*s)-&gt;name = name;     (*s)-&gt;sequence = samp;     //(*s)-&gt;match=0; //&lt;--here. } </code></pre>  <p>So for some reason setting a default value of 0 will cause the next malloc call in any function anywhere to trigger the access violation. I think it must have something to do with the fact that all elements of the struct are pointers but not match.</p>  <p>I can set the match value from the driver file after the sample is initialized and everything is fine but if I set it within the initialization i get varying behavior depending on what computer is running it. Some crash some just have no output and some still work for some reason.</p>  <p>So I guess my question now is.. How do I set a value inside a struct via a struct pointer?</p>  <p>UPDATE: I eventually found the problem. One of the functions was alocating memory the size of sample witch is a pointer to a struct rather than alocating the size of the struct itself. For some reason created no problems at all unless the a value in the struct was accessed from within the function initializing it. Witch would in turn make the very next use of malloc crash the program. Where as it was fine accessing the structs from the driver c file.</p>  <p>So my guess is that as I was allocating memory size of struct pointer and not size of struct allocates a tiny excess of unused memory each time its called and windows doesn't like it.</p>  <p>Think thats what happened anyway.</p>