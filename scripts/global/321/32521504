<p>Suppose I have the following C code:</p>  <pre><code>#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt;  #define NUM_PEOPLE 24  typedef struct {     char **name;     int age; } person_t;  void get_person_info(person_t *person);  int main(int argc, char **argv) {     for (int i = 0; i &lt; NUM_PEOPLE; i++) {         person_t new_person;         get_person_info(&amp;new_person);     }      return 0; } </code></pre>  <p>where <code>get_person_info()</code> just fills out the <code>person_t</code> struct to which a pointer is passed in. Is it necessary to <code>malloc()</code> memory for <code>new_person</code> within <code>main()</code>? That is, should the line</p>  <pre><code>person_t new_person; </code></pre>  <p>instead be</p>  <pre><code>person_t *new_person = (person_t *) malloc(sizeof(person_t)); </code></pre>  <p>and then change <code>get_person_info()</code> to accept a <code>person_t **</code> instead of a <code>person_t *</code>?</p>  <p>Sorry if this question is confusing -- I'm not sure whether or not this is a case where it is necessary to reserve memory, given that a pointer to that memory is passed into <code>get_person_info()</code> to avoid causing a segmentation fault.</p>