<p>In order to better understand the differences between <code>malloc</code> and <code>calloc</code> I tried to find an example where <code>malloc</code> leaves the memory uninitialized/reuses it from a previous allocation.</p>  <p>I came across the SO question <a href="http://stackoverflow.com/questions/8029584/why-does-malloc-initialize-the-values-to-0-in-gcc">Why does malloc initialize the values to 0 in gcc?</a></p>  <p>I tried to replicate the exampe, but allocating a char array instead and setting a single value. However, it seems <code>malloc</code> works in that case, but why?</p>  <p>Code:</p>  <pre><code>#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;assert.h&gt;  int main(void) {     // this shows, that malloc does not initialize memory     {         double *a = malloc(sizeof(double)*100);         *a = 100;         printf("%f\n", *a);         free(a);     }     {         double *a = malloc(sizeof(double)*100);         printf("%f\n", *a);         free(a);     }      // tried the same with chars, but my example doesn't work     {         char *ptr = malloc(sizeof(char) * 10);         ptr[0] = 'a';         printf("%s\n", ptr);         free(ptr);     }      {         char *ptr = malloc(sizeof(char) * 10);         printf("%s\n", ptr);         free(ptr);     }      return 0; } </code></pre>  <p>Output:</p>  <pre><code>$ clang -ggdb memset_test.c $  ./a.out 100.000000 100.000000 a &lt;empty string&gt; </code></pre>  <p>I can't see the difference, why does the first exable using doubles work, but not mine?</p>