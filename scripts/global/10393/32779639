<p>As far as I understand it you need to change the cursor in the <code>call()</code> method of a <code>Task</code> to be able to change the cursor properly. But in my application, I press a button and do something. And I do not want the application do to anything before this is done. I just want to inform the user that the the application is loading by changing the cursor.</p>  <p>Problem is that if I start a separate thread for the task, the rest of the program doesn't wait for that task to succeed. And if I put it in the same thread as the application (I guess that's what I'm doing), by doing <code>Platform.runLater(task)</code>, the cursor doesn't change.</p>  <p>The method that is called when I press the button is a void method, so that prevents me from putting the return statement inside the tasks <code>setOnSucceeded()</code> method.</p>  <p>The optimal scenario would be if I could just do this:</p>  <pre><code>//app.getPrimaryStage() returns the application stage.  void method () throws InterruptedException {     app.getPrimaryStage().getScene().setCursor(Cursor.WAIT);      // Simulate execution of code that takes some time     Thread.sleep(3000);      app.getPrimaryStage().getScene().setCursor(Cursor.DEFAULT);  } </code></pre>  <p>Or just create a task and execute it in the current thread, like this: </p>  <pre><code>//app.getPrimaryStage() returns the application stage.  void method () throws InterruptedException {     Task&lt;Void&gt; task = new Task&lt;Void&gt;() {         protected Void call() {             app.getPrimaryStage().getScene().setCursor(Cursor.WAIT);              // Simulate execution of code that takes some time             Thread.sleep(3000);              app.getPrimaryStage().getScene().setCursor(Cursor.DEFAULT);              return null;         }     };       Platform.runLater(task);   } </code></pre>  <p>But none of these methods work. I can see that the cursor is changing "underneath" by doing this: <code>app.getPrimaryStage().getScene().cursorProperty().addListener((obs, oldValue, newValue) -&gt; { System.out.println(newValue); });</code> But the change isn't showing unless I run the task in a separate thread. Why is this? And what is the best way to force the program to wait for a task that is run by a separate thread?</p>