<p>Assumed this would be a duplicate many times over, but I couldn't find anything doing quite what I'm trying to do, so...</p>  <p>Without too much detail, I have a set of web applications that work together, and share some databases...meaning each application has it's own back-end SQL database, however there are use cases where other applications in the system need access to data in another database.  Also, depending on how this system is installed, the physical locations of the web applications (ASP.NET MVC) can vary...for example, they may all be on a single machine, meaning all web applications have direct access to all databases, or in physically different places/networks...meaning we need a web interface/service (odata v4) for some calls in some situations.</p>  <p>So far, I've handled this pretty well by developing the web applications completely decoupled from the underlying source.  Meaning, direct connections (typically via EF6, though some direct ADO calls are in use too) and web service calls (oData v4) can be used interchangably, literally with the switch of a boolean value.  This is done via an independent interface library...so the controller/view levels of the web applications work with nothing but interfaces...both at the DBContext/Odata client context level, and at the individual entity model level.  </p>  <p>Now, this all works great...however one aspect I'm completely missing is the navigation properties of the models, which in some cases would be very helpful.  I have had virtually no luck trying to implement a generic interface for these objects (in both 1-n and n-n scenarios), and I'm thinking (hoping???) that somebody has figured this out previously?  It seems like somethign that would be fairly common, but perhaps not.  </p>  <p>Ideally, a navigation property, such as a set of say, "Employees" in a particular "Company", could be accessed via an interface, such as:</p>  <pre><code>interface ICompany  {     //(or IQueryable&lt;&gt;, or List&lt;&gt;, etc)    IEnumerable&lt;IEmployee&gt;  Employees { get; }     // other properties here...etc } </code></pre>  <p>This way, I could use this common interface interchangably, regardless of the datasource (both the EF-generated data models Company and Employee, and the Odata client generated models with the same name, both implement ICompany and IEmployee respectively).</p>  <p>I'm not sure if this could be done is such a way that the underlying concrete types can work as-is, or if I'd have to do some manual coding for these types...such as writing a .Expand() statement for the odata model manually and returning that, but either way would be acceptable.</p>  <p>The only way I've found is to add my own (differently-named, obviously) property to the interface, and manually add code to each concrete type (via partial class definitions)...but ideally I'd like to have a cleaner solution, hopefully one that doesn't require additional properties that don't actually map to any entity in the database.</p>