<p>I have a portion of my database created with</p>  <pre><code>/*    Create table of scores of games played. Every game will have a score recorded, but there    will only be a corresponding name if the user enters one */ CREATE TABLE Scores ( id int IDENTITY(1,1) NOT NULL PRIMARY KEY,                       score int NOT NULL,                       name VARCHAR (50)                      );  /*      Create table of text logs of the games played. These are reviewed to sniff out cheating.   */ CREATE TABLE GameLogs ( id int IDENTITY(1,1) NOT NULL PRIMARY KEY,                          scoreId INT NOT NULL FOREIGN KEY REFERENCES scores(id) ON DELETE CASCADE ON UPDATE CASCADE,                          logText VARCHAR (8000)                        );  </code></pre>  <p>and I'm using the model generated by the Entity framework to try and perform the equivalent of the following transaction. </p>  <pre><code> INSERT INTO Scores (score, name) VALUES (someNumber, someString);   SELECT MAX(id) as new_id FROM Scores;   INSERT INTO GameLogs (scoreId, logText) VALUES (new_id, someOtherString); </code></pre>  <p>The corresponding classes that are generated by Entity are</p>  <pre><code>public partial class Score {     public Score()     {         GameLogs = new HashSet&lt;GameLog&gt;();     }      public int id { get; set; }      [Column("score")]     public int score1 { get; set; }      [StringLength(50)]     public string name { get; set; }      public virtual ICollection&lt;GameLog&gt; GameLogs { get; set; } } </code></pre>  <hr>  <pre><code>public partial class GameLog {     public int id { get; set; }      public int scoreId { get; set; }      [StringLength(8000)]     public string logText { get; set; }      public virtual Score Score { get; set; } } </code></pre>  <hr>  <pre><code>public partial class SnakeDb : DbContext {     public SnakeDb()         // Comment/uncomment the base(...) depending on where project is being deployed at the moment         // Local Database:         //: base("name=snakedb")         // Remove database:          : base("name=remote_snakedb")     {     }      public virtual DbSet&lt;BannedIP&gt; BannedIPs { get; set; }     public virtual DbSet&lt;GameLog&gt; GameLogs { get; set; }     public virtual DbSet&lt;IP&gt; IPs { get; set; }     public virtual DbSet&lt;Score&gt; Scores { get; set; }      protected override void OnModelCreating ( DbModelBuilder modelBuilder )     {         modelBuilder.Entity&lt;GameLog&gt;()             .Property(e =&gt; e.logText)             .IsUnicode(false);          modelBuilder.Entity&lt;IP&gt;()             .HasMany(e =&gt; e.BannedIPs)             .WithRequired(e =&gt; e.IP)             .WillCascadeOnDelete(false);          modelBuilder.Entity&lt;Score&gt;()             .Property(e =&gt; e.name)             .IsUnicode(false);     } } </code></pre>  <hr>  <p>In one of my controllers I have the method</p>  <pre><code>    [HttpPost]     public ActionResult SubmitScore ( NameScoreLog nsp )     {          // Submit name and score to Scores database         SD.Scores.Add( new Score { name = nsp.name, score1 = nsp.score } );          // ...           SD.SubmitChanges();      } </code></pre>  <p>which is where I plan to perform the transaction I mentioned. Right now I am completely clueless about how I am going to extract the <code>id</code> from the last element added to <code>SD.Scores</code>, i.e. do the equivalent of </p>  <pre><code>SELECT MAX(id) as new_id FROM Scores;  </code></pre>  <p>which, by the way, I realize is a flawed way of getting the <code>id</code> the last added score, given that another score could be inserted in between the time that I added my score and made the above query.</p>  <p>Can someone give me some guidance on how to attack this problem?</p>