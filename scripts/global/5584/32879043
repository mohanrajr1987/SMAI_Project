<p>I'm a little confused about usage of <strong>ARRAY_INDEX_BUFFER</strong> (Index Buffers) vs <strong>ARRAY_BUFFER</strong> (Array Buffers) and am looking for clarification / better understanding.</p>  <p><strong>Specifically, I'm confused about how (Given the presences of multiple array buffers) how does WebGL and an index buffer know which array buffer to reference?*</strong></p>  <p>Using code obtained from <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Tutorial/Creating_3D_objects_using_WebGL" rel="nofollow">Mozilla's Creating 3D objects using WebGL Demo</a>  as the basis, I understand array buffers are assigned and initialized as </p>  <pre><code>cubeVerticesBuffer = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, cubeVerticesBuffer); var vertices = [     // Front face     -1.0, -1.0,  1.0,      1.0, -1.0,  1.0,      1.0,  1.0,  1.0,     -1.0,  1.0,  1.0,      // Back face     -1.0, -1.0, -1.0,     -1.0,  1.0, -1.0,      1.0,  1.0, -1.0,      1.0, -1.0, -1.0,      // Top face     -1.0,  1.0, -1.0,     -1.0,  1.0,  1.0,      1.0,  1.0,  1.0,      1.0,  1.0, -1.0,      // Bottom face     -1.0, -1.0, -1.0,      1.0, -1.0, -1.0,      1.0, -1.0,  1.0,     -1.0, -1.0,  1.0,      // Right face      1.0, -1.0, -1.0,      1.0,  1.0, -1.0,      1.0,  1.0,  1.0,      1.0, -1.0,  1.0,      // Left face     -1.0, -1.0, -1.0,     -1.0, -1.0,  1.0,     -1.0,  1.0,  1.0,     -1.0,  1.0, -1.0 ]; gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW); </code></pre>  <p>And then the indices are stored in the index buffer as</p>  <pre><code>cubeVerticesIndexBuffer = gl.createBuffer(); gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVerticesIndexBuffer);   var cubeVertexIndices = [     0,  1,  2,      0,  2,  3,    // front     4,  5,  6,      4,  6,  7,    // back     8,  9,  10,     8,  10, 11,   // top    12, 13, 14,     12, 14, 15,   // bottom    16, 17, 18,     16, 18, 19,   // right    20, 21, 22,     20, 22, 23    // left  ]  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cubeVertexIndices), gl.STATIC_DRAW); </code></pre>  <p>But given there is also a color array buffer defined as </p>  <pre><code>var colors = [     1.0,  1.0,  1.0,  1.0,    // Front face: white     1.0,  0.0,  0.0,  1.0,    // Back face: red     0.0,  1.0,  0.0,  1.0,    // Top face: green     0.0,  0.0,  1.0,  1.0,    // Bottom face: blue     1.0,  1.0,  0.0,  1.0,    // Right face: yellow     1.0,  0.0,  1.0,  1.0     // Left face: purple ]; var generatedColors = []; for (j=0; j&lt;6; j++) {     var c = colors[j];     for (var i=0; i&lt;4; i++) {       generatedColors = generatedColors.concat(c);     } }  cubeVerticesColorBuffer = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, cubeVerticesColorBuffer); gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(generatedColors), gl.STATIC_DRAW); </code></pre>  <p>But then once it gets to the draw routine, the ordering is</p>  <pre><code>gl.bindBuffer(gl.ARRAY_BUFFER, cubeVerticesBuffer); gl.vertexAttribPointer(vertexPositionAttribute, 3, gl.FLOAT, false, 0, 0);  gl.bindBuffer(gl.ARRAY_BUFFER, cubeVerticesColorBuffer); gl.vertexAttribPointer(vertexColorAttribute, 4, gl.FLOAT, false, 0, 0);  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVerticesIndexBuffer); gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0); </code></pre>  <p>I'm assuming that the <strong>bindBuffer</strong> method tells the WebGL "state machine" to make a generic buffer "active" and that the <strong>gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER</strong> makes a new index buffer active based on the current generic buffers</p>  <p>Somehow, I don't think my understanding of what was going on with that is totally correct. Any clarification would be greatly appreciated. Specifically I'd like at some point to add additional objects, with different buffers (say a sphere or a torus, with a whole other color scheme)</p>  <p>But I understand the <strong>drawElements(</strong> just draws based on the indexes rather than the actual arrays done by <strong>drawArrays(</strong></p>  <p>correct?</p>