<p><strong>How do you clear the rendered texture?</strong> </p>  <p>I'm kind of lost in this OpenGL code I inherited from someone.  I've tried this, however it has no effect on it:</p>  <pre><code>- (void)clearFrameBuffer {     glClearColor(1.0f, 0.0f, 0.0f, 1.0f);     glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); </code></pre>  <hr>  <p>This is how the frame and render buffers are created:</p>  <pre><code>glEnable(GL_TEXTURE_2D);  glDisable(GL_BLEND); glDisable(GL_DEPTH_TEST); glDisable(GL_STENCIL_TEST);  //Onscreen framebuffer object glGenFramebuffers(1, &amp;_viewFramebufferIndex); glBindFramebuffer(GL_FRAMEBUFFER, self.viewFramebufferIndex);  glGenRenderbuffers(1, &amp;_viewRenderbufferIndex); glBindRenderbuffer(GL_RENDERBUFFER, self.viewRenderbufferIndex);  [self.renderContext renderbufferStorage:GL_RENDERBUFFER                            fromDrawable:(CAEAGLLayer *)self.layer]; glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_RENDERBUFFER, self.viewRenderbufferIndex); </code></pre>  <p>And this is how something is drawn (No, I don't fully understand this code):</p>  <pre><code>- (void)drawSample:(CMSampleBufferRef)sample {     if (!sample) {         return;     }      CVPixelBufferRef pixelBuffer = CMSampleBufferGetImageBuffer(sample);     if (!pixelBuffer) {         //There's something wrong with the frame, needs further debugging         return;     }      if (![[EAGLContext currentContext] isEqual:self.renderContext]) {         [EAGLContext setCurrentContext:self.renderContext];     }      glClearColor(1.0f, 0.0f, 0.0f, 1.0f);      GLfloat vertices[] = {         -kRenderSize * 0.5f, -kRenderSize * 0.5f,         kRenderSize * 0.5f, -kRenderSize * 0.5f,         -kRenderSize * 0.5f, kRenderSize * 0.5f,         kRenderSize * 0.5f, kRenderSize * 0.5f     };      glBindFramebuffer(GL_FRAMEBUFFER, self.viewFramebufferIndex);      // Set the view port to the entire view     glViewport(0,                0,                CGRectGetWidth(self.frame) * self.contentScaleFactor,                CGRectGetHeight(self.frame) * self.contentScaleFactor);     glBindRenderbuffer(GL_RENDERBUFFER, self.viewRenderbufferIndex);     glClear(GL_COLOR_BUFFER_BIT);      glUseProgram(textureParams[kOffsetProgramBorder]);     // Draw the layer rectangle     glVertexAttribPointer(ATTRIB_POSITION, 2, GL_FLOAT, 0, 0, vertices);     glEnableVertexAttribArray(ATTRIB_POSITION);     glUniform4f(textureParams[kOffsetUniformBorder_0], 0.0f, 0.0f, 0.0f, 1.0f);     glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);      if (!textureCache) {         CVOpenGLESTextureCacheCreate(kCFAllocatorDefault,                                      NULL,                                      self.renderContext,                                      NULL,                                      &amp;textureCache);     }      OSType framePixelFormat = CVPixelBufferGetPixelFormatType(pixelBuffer);     size_t frameWidth = CVPixelBufferGetWidth(pixelBuffer);     size_t frameHeight = CVPixelBufferGetHeight(pixelBuffer);     size_t stopDraw = 0;     CVReturn error[3];     CVOpenGLESTextureRef texturePlane[3];     GLfloat textureWidth;      if (CVPixelBufferIsPlanar(pixelBuffer)) {         // adjust for YUVB         textureWidth = (GLfloat)frameWidth/(GLfloat)CVPixelBufferGetBytesPerRowOfPlane(pixelBuffer, 0);     }     else {         // adjust for RGBA         textureWidth = (GLfloat)frameWidth/(GLfloat)(CVPixelBufferGetBytesPerRow(pixelBuffer)&gt;&gt;2);     }      // prepare vertex arrays for rendering     GLfloat textureVertices[] = {         0.0f,          1.0f,         textureWidth,  1.0f,         0.0f,          0.0f,         textureWidth,  0.0f,     };     CGRect viewRect = [self viewSamplingRectFromTexture:CGSizeMake(frameWidth, frameHeight)];     GLfloat viewVertices[] = {         viewRect.origin.x,                     viewRect.origin.y,         viewRect.origin.x+viewRect.size.width, viewRect.origin.y,         viewRect.origin.x,                     viewRect.origin.y+viewRect.size.height,         viewRect.origin.x+viewRect.size.width, viewRect.origin.y+viewRect.size.height,     };      // different handling for each format      // Use shader program.      glUseProgram(textureParams[kOffsetProgramYUVB]);     //Mapping the luma plane of a 420v buffer as a source texture:     error[0] = CVOpenGLESTextureCacheCreateTextureFromImage(kCFAllocatorDefault,                                                             textureCache,                                                             pixelBuffer,                                                             NULL,                                                             GL_TEXTURE_2D,                                                             GL_LUMINANCE,                                                             CVPixelBufferGetWidthOfPlane(pixelBuffer, 0),                                                             CVPixelBufferGetHeightOfPlane(pixelBuffer, 0),                                                             GL_LUMINANCE,                                                             GL_UNSIGNED_BYTE,                                                             0,                                                             &amp;texturePlane[0]);     if (error[0] == kCVReturnSuccess) {         glActiveTexture(GL_TEXTURE0);         glBindTexture(GL_TEXTURE_2D, CVOpenGLESTextureGetName(texturePlane[0]));         glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);         glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);         glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);         glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);         glUniform1i(textureParams[kOffsetUniformYUVB_0], 0);     }     else         stopDraw++;     //Mapping the chroma plane of a 420v buffer as a source texture:     error[1] = CVOpenGLESTextureCacheCreateTextureFromImage(kCFAllocatorDefault,                                                             textureCache,                                                             pixelBuffer,                                                             NULL,                                                             GL_TEXTURE_2D,                                                             GL_LUMINANCE_ALPHA,                                                             CVPixelBufferGetWidthOfPlane(pixelBuffer, 1),                                                             CVPixelBufferGetHeightOfPlane(pixelBuffer, 1),                                                             GL_LUMINANCE_ALPHA,                                                             GL_UNSIGNED_BYTE,                                                             1,                                                             &amp;texturePlane[1]);     if (error[1] == kCVReturnSuccess) {         glActiveTexture(GL_TEXTURE1);         glBindTexture(GL_TEXTURE_2D, CVOpenGLESTextureGetName(texturePlane[1]));         glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);         glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);         glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);         glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);         glUniform1i(textureParams[kOffsetUniformYUVB_1], 1);     }     else         stopDraw++;     if (!stopDraw) {         // Draw the texture on the screen with OpenGL ES 2         glVertexAttribPointer(ATTRIB_POSITION, 2, GL_FLOAT, 0, 0, viewVertices);         glEnableVertexAttribArray(ATTRIB_POSITION);         glVertexAttribPointer(ATTRIB_TEXCOORD, 2, GL_FLOAT, 0, 0, textureVertices);         glEnableVertexAttribArray(ATTRIB_TEXCOORD);         glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);     }     [self.renderContext presentRenderbuffer:GL_RENDERBUFFER];     for (size_t i=0; i&lt;2; i++)         if (error[i] == kCVReturnSuccess) {             glBindTexture(CVOpenGLESTextureGetTarget(texturePlane[i]), 0);             glBindTexture(GL_TEXTURE_2D, 0);             CFRelease(texturePlane[i]);         } </code></pre>