<p>When I run my OpenGL app, I get the following error:</p>  <p><a href="http://i.stack.imgur.com/FxJo0.png"><img src="http://i.stack.imgur.com/FxJo0.png" alt="enter image description here"></a></p>  <p>I googled but can't get any useful information.</p>  <p>Here're a piece of source code:</p>  <pre><code>- (void)render:(CADisplayLink*)displayLink {     [self.canvas clear];     glPixelStorei(GL_UNPACK_ALIGNMENT, 1);     glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);     glEnable(GL_BLEND);      NSInteger mLength = mParticles.count;     NSInteger drawCount = 0;     NSInteger drawIndex = 0;     WQParticle* drawParticle;     CGFloat drawX,drawY,drawScale,drawAngle;     GLKMatrix4 changeColorMatrix;     if (mLength &gt; 0){         glBindFramebuffer(GL_FRAMEBUFFER, FBO);         glViewport(0,0,width,height);         drawCount = 0;         drawIndex = -1;         while ( drawCount &lt; mLength){             drawParticle = mParticles[drawCount];              if(!(drawParticle.flg &amp;&amp; random &gt; 0.5)){                  if (drawIndex != drawParticle.texIndex) {                     glActiveTexture(GL_TEXTURE0);                     glBindTexture(GL_TEXTURE_2D, (GLuint)(texture[drawParticle.texIndex]));                     glUniform1i((GLint)uniLocation[1], 0);                     drawIndex = drawParticle.texIndex;                 }                  if(drawParticle.flg){                     drawX = drawParticle.posX + (random * 1 - 0.5) * drawParticle.scale * 0.06;                     drawY = drawParticle.posY + (random * 1 - 0.5) * drawParticle.scale * 0.06;                     drawScale = drawParticle.scale * (random * 0.4 + 0.8);                     changeColorMatrix = [self setChangeColorWithDp:drawParticle n:random];                     drawX = drawX / drawScale;                     drawY = drawY / drawScale;                 }else{                     drawX = drawParticle.posX / drawParticle.scale;                     drawY = drawParticle.posY / drawParticle.scale;                     drawScale = drawParticle.scale;                     changeColorMatrix = [self setChangeColorWithDp:drawParticle n:1];                 }                 glUniformMatrix4fv((GLint)uniLocation[2], 1, 0, changeColorMatrix.m);                 drawAngle = drawParticle.angle;                 CGFloat drawR = sqrt(drawX * drawX + drawY * drawY);                 CGFloat oa = 2 * M_PI - acos(drawX / drawR);                 drawX = cos(oa - drawAngle) * drawR;                 drawY = sin(oa - drawAngle) * drawR;                  mMatrix = GLKMatrix4Identity;                 mMatrix = GLKMatrix4Rotate(mMatrix, drawAngle, 0, 0, 1);                 mMatrix = GLKMatrix4Scale(mMatrix, drawScale, drawScale, drawScale);                 mMatrix = GLKMatrix4Translate(mMatrix, drawX, drawY, 0);                 mvpMatrix = GLKMatrix4Multiply(f_tmpMatrix, mMatrix);                  glUniform1i((GLint)uniLocation[3], YES);                 glUniformMatrix4fv((GLint)uniLocation[0], 1, 0, mvpMatrix.m);                 glDrawElements(GL_TRIANGLES, sizeof(indices), GL_UNSIGNED_BYTE, 0);             }              if (drawParticle.life &gt; 0) {                 [mVF getForceFromPosWithPx:drawParticle.posX Py:drawParticle.posY];                 [drawParticle setVFupdateWithOutX:mVF.outX OutY:mVF.outY];                 drawCount++;                 continue;             }             [mParticles removeObjectAtIndex:drawCount];             mLength = mLength - 1;         }         glBindFramebuffer(GL_FRAMEBUFFER,0);     }      glBindTexture(GL_TEXTURE_2D, FBOTexture);     mMatrix = GLKMatrix4Identity;     mvpMatrix = GLKMatrix4Multiply(tmpMatrix, mMatrix);     glUniformMatrix4fv((GLint)uniLocation[0], 1, 0, mvpMatrix.m);     glUniform1i((GLint)uniLocation[3], NO);     glDrawElements(GL_TRIANGLES, sizeof(indices), GL_UNSIGNED_BYTE, 0);     [self.canvas.glContext presentRenderbuffer:GL_RENDERBUFFER]; } </code></pre>  <p>How can I solve this?</p>