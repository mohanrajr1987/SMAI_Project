<p>I am using Python 3.4, Pandas 0.16.2 and Jupyter Notebook as my IDE.</p>  <p>I am importing the following two dataframes as follows:</p>  <pre><code>Lookup = pd.read_excel("LookupMergeOutput.xlsx")  Concatenated = pd.read_csv('Concatenated.csv', error_bad_lines = False, na_values='', iterator=True,  chunksize=1000) data = pd.concat([chunk for chunk in Concatenated], ignore_index=True) </code></pre>  <p><strong>Data</strong></p>  <p><strong><em>Lookup</em></strong> dataframe spec: 23353 rows 8; 8 columns</p>  <pre><code>Columns:          Dtype:  LOGINNAME         object FIRSTNAME         object LASTNAME          object ID_y               int64 CREATEUSERID       int64 REVISIONUSERID     int64 BEGINDATE         object ENDDATE           object </code></pre>  <p><strong><em>data</em></strong> dataframe spec: 23653 rows; 667 columns</p>  <p>The column of interest for the merge in this dataframe is <code>REFERENCE_ID</code> with </p>  <pre><code>data.REFERENCE_ID.dtype  </code></pre>  <p>as 'object'</p>  <p>The columns to merge on are <code>ID_y</code> and <code>REFERENCE_ID</code> (in the <strong><em>data</em></strong> dataframe). The columns in <strong><em>Lookup</em></strong> contain unique value counts (eg. 265926639 etc). </p>  <p>The <strong><em>data</em></strong> dataframe has unique values, but also repeating instances of an an entry (for example, three instances of 265946567. Moreover, there are error strings with the following caricature: <code>421D6158-22D4-EDAC-0DEA-33B1FB5CC7AF</code>. </p>  <p><strong>Goal</strong>: To merge <strong><em>Lookup</em></strong> and <strong><em>data</em></strong> on the to key columns <code>ID_y</code> and <code>REFERENCE_ID</code>, respectively. </p>  <p>***References and prior search for answers but with little fruit to bear:</p>  <ol> <li><a href="http://stackoverflow.com/questions/25793709/pandas-dataframe-left-merge-without-reindexing">Left merge without reindexing</a></li> <li><a href="http://stackoverflow.com/questions/20060562/conditional-merge-for-csv-files-using-python-pandas">Conditional Merge</a></li> <li><a href="http://chrisalbon.com/python/pandas_join_merge_dataframe.html" rel="nofollow">Chris Albon's Tutorial</a></li> <li><a href="http://stackoverflow.com/questions/23668427/pandas-joining-multiple-dataframes-on-columns">Merging multiple dataframes</a></li> <li><a href="http://www.datacarpentry.org/python-ecology/04-merging-data" rel="nofollow">Data Carpentry's Review</a></li> </ol>  <p>What I have attempted so far:</p>  <pre><code>merged_left = pd.merge(left=Lookup,right=data, how='left', left_on='ID_y', right_on='REFERENCE_ID') </code></pre>  <p>This returns all of the <strong><em>Lookup</em></strong> data but all 667 columns of the <strong><em>data</em></strong> dataframe come back as null values.  </p>  <p>In theory, if there are common numbers in the two "key" columns, the data from the <strong><em>data</em></strong> dataframe to match. My hypothesis is either that there is a data type conflict or because there are repeating numbers in the <strong><em>data</em></strong> dataframe, that the merge is not taking place. I want to avoid dropping the duplicates or multiple instances of keys in the <strong><em>data</em></strong> column as this may have valid data. </p>  <p>I have also tried to rename the <code>ID_y</code>columnname to <code>REFERENCE_ID</code> and perform a merge as follows: </p>  <pre><code>Lookup=Lookup.rename(columns = {'ID_y':'REFERENCE_ID'}) </code></pre>  <p>This produces a <code>null</code> dataframe (just columns, but no values). I have also attempted to set the index as <code>ID_y</code> and <code>REFERENCE_ID</code> and then perform the merge on the index:</p>  <pre><code>Lookup = Lookup.set_index('ID_y') data = data.set_index('REFERENCE_ID')  merged_on_index = pd.merge(Lookup,data, left_index=True,right_index=True) </code></pre>  <p>I receive the following traceback:</p>  <pre><code>--------------------------------------------------------------------------- TypeError                                 Traceback (most recent call last) &lt;ipython-input-35-3909fd759082&gt; in &lt;module&gt;() ----&gt; 1 pd.merge(AgentLookup,data,left_index=True,right_index=True)  C:\WinPython-64bit-3.4.3.5\python-3.4.3.amd64\lib\site-packages\pandas\tools\merge.py in merge(left, right, how, on, left_on, right_on, left_index, right_index, sort, suffixes, copy)      36                          right_index=right_index, sort=sort, suffixes=suffixes,      37                          copy=copy) ---&gt; 38     return op.get_result()      39 if __debug__:      40     merge.__doc__ = _merge_doc % '\nleft : DataFrame'  C:\WinPython-64bit-3.4.3.5\python-3.4.3.amd64\lib\site-packages\pandas\tools\merge.py in get_result(self)     184      185     def get_result(self): --&gt; 186         join_index, left_indexer, right_indexer = self._get_join_info()     187      188         ldata, rdata = self.left._data, self.right._data  C:\WinPython-64bit-3.4.3.5\python-3.4.3.amd64\lib\site-packages\pandas\tools\merge.py in _get_join_info(self)     257         if self.left_index and self.right_index:     258             join_index, left_indexer, right_indexer = \ --&gt; 259                 left_ax.join(right_ax, how=self.how, return_indexers=True)     260         elif self.right_index and self.how == 'left':     261             join_index, left_indexer, right_indexer = \  C:\WinPython-64bit-3.4.3.5\python-3.4.3.amd64\lib\site-packages\pandas\core\index.py in join(self, other, how, level, return_indexers)    2041             other = other.astype('O')    2042             return this.join(other, how=how, -&gt; 2043                              return_indexers=return_indexers)    2044     2045         _validate_join_method(how)  C:\WinPython-64bit-3.4.3.5\python-3.4.3.amd64\lib\site-packages\pandas\core\index.py in join(self, other, how, level, return_indexers)    2054             else:    2055                 return self._join_non_unique(other, how=how, -&gt; 2056                                              return_indexers=return_indexers)    2057         elif self.is_monotonic and other.is_monotonic:    2058             try:  C:\WinPython-64bit-3.4.3.5\python-3.4.3.amd64\lib\site-packages\pandas\core\index.py in _join_non_unique(self, other, how, return_indexers)    2125     2126         left_idx, right_idx = _get_join_indexers([self.values], [other.values], -&gt; 2127                                                  how=how, sort=True)    2128     2129         left_idx = com._ensure_platform_int(left_idx)  C:\WinPython-64bit-3.4.3.5\python-3.4.3.amd64\lib\site-packages\pandas\tools\merge.py in _get_join_indexers(left_keys, right_keys, sort, how)     459      460     # get left &amp; right join labels and num. of levels at each location --&gt; 461     llab, rlab, shape = map(list, zip( * map(fkeys, left_keys, right_keys)))     462      463     # get flat i8 keys from label lists  TypeError: type object argument after * must be a sequence, not map </code></pre>  <p>At this point in time, I at a loss as to what would be the best strategy. I welcome feedback on next steps. </p>