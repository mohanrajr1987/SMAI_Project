<h2>INTRODUCTION:</h2>  <p>I have converted <a href="https://commons.wikimedia.org/wiki/File:Ghostscript_Tiger.svg" rel="nofollow">Ghostscript Tiger.svg</a> to XAML, using Inkscape. Now I wanted to create small app that can zoom and pan that image.</p>  <h2>PROBLEM:</h2>  <p>My panning code doesn't perform as expected. Although panning logic seems to be correct, when panning, image continues to move when my mouse is not moving.</p>  <p>To clarify: </p>  <ol> <li>I press left mouse button down, move the mouse -> image moves in the proper direction;</li> <li>I stop moving the mouse, but left mouse button is still down -> image keeps moving in the same direction, instead of stopping.</li> </ol>  <h2>RELEVANT INFORMATION:</h2>  <p>When converted into XAML, Ghostscript Tiger is nothing more than a Canvas with enormous amount of drawing commands, mostly Paths. </p>  <p>In order to implement zoom and panning, I have decided to bind <code>ScaleTransform</code> and <code>TranslateTransform</code> to dependency properties, in my XAML.</p>  <p>Being new to WPF, I have used Stack Overflow to find examples on how to do it. Below is submitted the code behind and XAML ( tiger part is omitted for brewity ).</p>  <p>XAML:</p>  <pre><code>&lt;Window x:Class="TestZaMapu.MainWindow"         Name="GlavniProzor"         xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"         xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"         Title="MainWindow" Height="350" Width="525" PreviewKeyUp="GlavniProzor_PreviewKeyUp" PreviewMouseWheel="GlavniProzor_PreviewMouseWheel"&gt;         &lt;!-- I have bound Canvas' backround to main window's background--&gt;     &lt;Canvas xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" Name="svg4306" Width="494.44705" Height="510.55356" Background="{Binding ElementName=GlavniProzor, Path=Background}" MouseLeftButtonDown="svg4306_MouseLeftButtonDown" MouseLeftButtonUp="svg4306_MouseLeftButtonUp" MouseMove="svg4306_MouseMove" LostMouseCapture="svg4306_LostMouseCapture"&gt;         &lt;!--I am binding scaling factor, and translations here--&gt;         &lt;Canvas.RenderTransform&gt;             &lt;TransformGroup&gt;                 &lt;TranslateTransform X="{Binding ElementName=GlavniProzor, Path=TranslationFactorX}" Y="{Binding ElementName=GlavniProzor, Path=TranslationFactorY}"/&gt;                 &lt;ScaleTransform ScaleX="{Binding ElementName=GlavniProzor, Path=ZoomFactor}" ScaleY="{Binding ElementName=GlavniProzor, Path=ZoomFactor}"/&gt;             &lt;/TransformGroup&gt;         &lt;/Canvas.RenderTransform&gt;         &lt;!-- Bunch of Paths... --&gt;     &lt;/Canvas&gt; &lt;/Window&gt; </code></pre>  <p>Code behind:</p>  <pre><code>using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Windows; using System.Windows.Controls; using System.Windows.Data; using System.Windows.Documents; using System.Windows.Input; using System.Windows.Media; using System.Windows.Media.Imaging; using System.Windows.Navigation; using System.Windows.Shapes;  namespace TestZaMapu {     /// &lt;summary&gt;     /// Interaction logic for MainWindow.xaml     /// &lt;/summary&gt;     public partial class MainWindow : Window     {         public MainWindow()         {             InitializeComponent();             // initialize variables             ZoomFactor = 1.0;             TranslationFactorX = 0.0;             TranslationFactorY = 0.0;         }          // needed for zoom math         private const double WHEEL_DELTA = 120.0;         // needed for panning the image         private Point ptOldPosition;          public static readonly DependencyProperty TranslateX =             DependencyProperty.Register("TranslationFactorX", typeof(double), typeof(MainWindow));          public static readonly DependencyProperty TranslateY =             DependencyProperty.Register("TranslationFactorY", typeof(double), typeof(MainWindow));          public static readonly DependencyProperty Zoom =            DependencyProperty.Register("ZoomFactor", typeof(double), typeof(MainWindow));          public double ZoomFactor         {             get { return (double)GetValue(Zoom); }             set { SetValue(Zoom, value); }         }          public double TranslationFactorX         {             get { return (double)GetValue(TranslateX); }             set { SetValue(TranslateX, value); }         }          public double TranslationFactorY         {             get { return (double)GetValue(TranslateY); }             set { SetValue(TranslateY, value); }         }          /************* INCLUDED BECAUSE IT MIGHT BE IMPORTANT *****/         // zoom on keypress         private void GlavniProzor_PreviewKeyUp(object sender, KeyEventArgs e)         {             base.OnPreviewKeyUp(e);              if ((e.Key == Key.Add) || (e.Key == Key.Subtract))             {                 ZoomFactor += (e.Key == Key.Add) ? 0.1 : -0.1;                 e.Handled = true;             }         }          // zoom on mouse wheel         private void GlavniProzor_PreviewMouseWheel(object sender, MouseWheelEventArgs e)         {             base.OnPreviewMouseWheel(e);              if (Keyboard.Modifiers == ModifierKeys.Control)             {                 ZoomFactor += 0.1 * (double)(e.Delta) / WHEEL_DELTA;                 e.Handled = true;             }         }          /************** RELEVANT PART *******************/         // svg4306 is the name of the Canvas         private void svg4306_MouseLeftButtonDown(object sender, MouseButtonEventArgs e)         {             base.OnMouseLeftButtonDown(e);              if (svg4306.IsMouseCaptured)                 return;              ptOldPosition = e.GetPosition(svg4306);              svg4306.CaptureMouse();         }         // svg4306 is the name of the Canvas         private void svg4306_MouseLeftButtonUp(object sender, MouseButtonEventArgs e)         {             base.OnMouseLeftButtonUp(e);              if (svg4306.IsMouseCaptured)             {                 svg4306.ReleaseMouseCapture();             }         }         // svg4306 is the name of the Canvas         private void svg4306_MouseMove(object sender, MouseEventArgs e)         {             base.OnMouseMove(e);              if (svg4306.IsMouseCaptured &amp;&amp; e.LeftButton == MouseButtonState.Pressed)             {                 Point pt = e.GetPosition(svg4306);                  if (pt != ptOldPosition)                 {                     Vector vectDifference = ptOldPosition - pt;                     ptOldPosition = pt;                      TranslationFactorX += vectDifference.X;                     TranslationFactorY += vectDifference.Y;                 }             }         }          private void svg4306_LostMouseCapture(object sender, MouseEventArgs e)         {             // at this moment no cleanup is required, so do the default...             base.OnLostMouseCapture(e);         }      } } </code></pre>  <p>When testing the app, please make small moves with the mouse, since image "flies away" pretty fast.</p>  <h2>MY EFFORTS TO SOLVE THIS:</h2>  <p>I have found alternative solution here on Stack Overflow, but I would really like to solve my task the way I originally intended. </p>  <h2>QUESTION:</h2>  <p>Why is my image continuing to move, although I stop moving the mouse?</p>