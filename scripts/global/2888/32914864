<p>I'm writing a small command line tool to interact with a client (a game, nothing illegal though, just experimenting), mainly over HTTP. I have written an older version of this tool some time ago and run into some problems which I now have fixed.</p>  <p>That's why I wanted to rewrite my code to have it more clear and just nicer. But now I run into some really wired problems and cant find out why.</p>  <p>I do all of this on a Mac with XCode. The problem occurs while I send the server's (I'm the server) version (plaintext HTML). The strange thing is, I copy/pasted that part of the code from my old version, and there it is working even when I run it now. So I have two programs with exact the same code, but only one of them is working correctly.</p>  <p>This is the procedure:</p>  <ol> <li>Open up a socket and bind to a specific port, wait for client.</li> <li>If client asks for server version, respond with plain HTML + version number</li> <li>Done.</li> </ol>  <p>2 programs, same code, different results:</p>  <p>old version: client reads out version number correctly new version: client fails to read out version number</p>  <p>This is the code to write the data over the socket (keep in mind this is the old ugly code fro the old version):</p>  <pre><code>int socketWriteNormal_Old(int socket, std::string data, int mode, char final_buffer[], int bytes){     if(mode == 0){         char buffer[512];         int error;         std::string chunk;          if(data.length() &gt; 511){             while(data.length() &gt; 0){                 if(data.length() &gt;= 511){                     chunk = data.substr(0,511);                     data = data.substr(511, data.length());                 }                 else{                     chunk = data;                     data = "";                 }                 bzero(buffer, 512);                 chunk.copy(buffer, chunk.length());                 error = write(socket, buffer, strlen(buffer));                 if(error &lt; 0){                     return error;                 }             }         }         else{             bzero(buffer,512);             data.copy(buffer,512);             error = write(socket, buffer, strlen(buffer));         }          return error;     }     else{         int error = write(socket, final_buffer, bytes);          std::cout &lt;&lt; final_buffer &lt;&lt; " " &lt;&lt; bytes &lt;&lt; std::endl;         std::cout &lt;&lt; error &lt;&lt; std::endl;          return error;     } } </code></pre>  <p>This is how I listen on a port (connection seems to work on both versions):</p>  <pre><code>int socketListen(int socket, int port){      struct sockaddr_in serv_addr, cli_addr;      int newsock;      socklen_t clilen;      serv_addr.sin_family = AF_INET;     serv_addr.sin_addr.s_addr = INADDR_ANY;     serv_addr.sin_port = htons(port);      std::cout &lt;&lt; "[socketListen] Binding server_socket to port " &lt;&lt; port &lt;&lt; std::endl;      if(bind(socket, (struct sockaddr *) &amp;serv_addr, sizeof(serv_addr)) &lt; 0){         return -1;     }      std::cout &lt;&lt; "[socketListen] Running Listen()" &lt;&lt; std::endl;      listen(socket,5);     clilen = sizeof(cli_addr);     std::cout &lt;&lt; "[socketListen] running accept()" &lt;&lt; std::endl;     newsock = accept(socket, (struct sockaddr *) &amp;cli_addr, &amp;clilen);     std::cout &lt;&lt; "[socketListen] got new socket!" &lt;&lt; std::endl;     if(newsock &lt; 0){         return -2;     }     else{         return newsock;     } } </code></pre>  <p>This is the packet dump of whireshark of both packets created with the new and with the old version.</p>  <p>old and working version:</p>  <p><a href="http://i.stack.imgur.com/Z30Ou.jpg" rel="nofollow"><img src="http://i.stack.imgur.com/Z30Ou.jpg" alt="enter image description here"></a></p>  <p>new and not working version:</p>  <p><a href="http://i.stack.imgur.com/8fN7o.jpg" rel="nofollow"><img src="http://i.stack.imgur.com/8fN7o.jpg" alt="enter image description here"></a></p>  <p>As you can see, there is no difference.. or at least I can not find one. This is really driven me crazy, never had such strange problems..</p>  <p>Also, with the new version, I got another problem. The tool has a second function which downloads specific data from a server, also plain HTTP and binary data. The strange thing is, when I run the programm from command line I get a segfault after 3-6 seconds, but when I run it over XCode/gdb it does work fine...</p>  <p>If anyone had same strange problems or does know something about this, pls help me.</p>