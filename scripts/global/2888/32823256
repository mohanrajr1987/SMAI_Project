<p>I am reading a book about sockets in .NET and there are some things that I have issues with and can't get the hang of.</p>  <p>Here is an example straight from the book that shows a TCP echo client and server.</p>  <p>Here is the client application:</p>  <pre><code>byte[] byteBuffer = Encoding.ASCII.GetBytes(input); TcpClient client = null; NetworkStream netStream = null; try {     // Create socket that is connected to server on specified port     client = new TcpClient(server, port);     netStream = client.GetStream();      // Send the encoded string to the server     netStream.Write(byteBuffer, 0, byteBuffer.Length);     Console.WriteLine("Sent {0} bytes to server...", byteBuffer.Length);      int totalBytesRecieved = 0;  //total bytes recieved so far     int bytesRecieved = 0;  //bytes recieved in the last read      while (totalBytesRecieved &lt; byteBuffer.Length)     {         if ((bytesRecieved = netStream.Read(byteBuffer, totalBytesRecieved,             byteBuffer.Length - totalBytesRecieved)) == 0)         {             Console.WriteLine("connection closed prematurly");         }         totalBytesRecieved += bytesRecieved;     }      Console.WriteLine("Received {0} bytes from server: {1}", totalBytesRecieved,     Encoding.ASCII.GetString(byteBuffer, 0, totalBytesRecieved)); } catch (Exception ex) {     Console.WriteLine(ex.Message); } finally {     netStream.Close();     client.Close(); }  </code></pre>  <p>and here's the server application:</p>  <pre><code>TcpListener listener = null;  try {     // Create a TCPListener to accept client connections     listener = new TcpListener(IPAddress.Any, serverPort);     listener.Start(); } catch (SocketException se) {     Console.WriteLine(se.ErrorCode + ": " + se.Message);     Environment.Exit(se.ErrorCode); }  byte[] byteBuffer = new byte[BUFFSIZE];  //recieve buffer int bytesRecieved;                       //recieved byte count  while (true) {     TcpClient client = null;     NetworkStream netStream = null;      try     {         client = listener.AcceptTcpClient();         netStream = client.GetStream();         Console.Write("Handling Clinet - ");          // Receive until client closes connection, indicated by 0 return value         int totalBytesEchoed = 0;         while ((bytesRecieved = netStream.Read(byteBuffer, 0, byteBuffer.Length)) &gt; 0)         {             netStream.Write(byteBuffer, 0, bytesRecieved);             totalBytesEchoed += bytesRecieved;         }         Console.WriteLine("echoed {0} bytes.", totalBytesEchoed);          // Close the stream and socket. We are done with this client!         netStream.Close();         client.Close();     }     catch (Exception ex)     {         Console.WriteLine(ex.Message);     } } </code></pre>  <p>My main problem is with the stream part of the application. I will try to explain what has happened in both applications and ask some questions, correct me if anywhere I made a mistake in my explanation:</p>  <p>in the client application we first write a byte buffer to the stream that has been established between client and server. The syntax is straightforward and nothing's wrong here. Next we read some bytes to the exact same buffer after the server has done some operations on the stream. When we want to read the data, we must do it in a loop to get the data in chunks and then write the bytes received to the byte buffer. The syntax of <code>Read()</code> method is like this: the first argument takes the buffer array, the second argument takes the offset, and the third is the maximum of bytes to put into the buffer.</p>  <p>Since we want to fill the byte buffer, we should specify the offset the total bytes received to fill THE REST of the buffer array and declare <code>byteBuffer.Length - totalBytesRecieved</code> as the maximum number of bytes to put into the buffer. No problems here. But the question here is:</p>  <ol> <li><p>How does the program know that the server did some operation on the stream and then read the data?</p>  <p>Now in the server application, I can't understand what is happening with the reading of the data.We read the into the whole buffer array, and write all of it into the stream right after that.</p></li> <li><p>Shouldn't we write the data with an offset? Would someone explain how this writing and reading is working?</p></li> <li><p>How do the read and write methods won't conflict with each other since they are operating on the same stream(the same sequence of bytes)?`</p></li> <li><p>How does the program know where to read the next data and where to write the next data into the stream that they don't?</p></li> </ol>