<p>I have some devices attached to the same network. All of them runs a TCP server. I have my PC also connected to the same network. I need to collect data from the other devices. So I'm about to write an app in Qt framework which does that. I will exchange small packets with the devices, so I thought I make a generic object for devices which has a QTcpSocket member, and I use signals and slots for receiving data. I have an other class which I use to connect to devices. It inherits QObject and QRunnable. the QRunnables's run method implements the connecting procedure and it looks like this:</p>  <pre><code>QTcpSocket socket;  socket.connectToHost(this-&gt;hostAddress, this-&gt;portNumber);  if(socket.waitForConnected()) {     emit Connected(this-&gt;deviceId, socket.socketDescriptor()); } else {     emit Error(this-&gt;deviceId); } </code></pre>  <p>This function is run in a separate thread using QThreadPool to avoid long delay due to connecting time:</p>  <pre><code>Connector* connector = new Connector(hostAddress, port, id);  connect(connector, &amp;Connector::Connected, this, &amp;CommunicationLayer::Connected); connect(connector, &amp;Connector::Error, this, &amp;CommunicationLayer::Error);  QThreadPool::globalInstance()-&gt;start(connector); </code></pre>  <p>And when the Connected signal is fired, I instantiate a device object for that specific id:</p>  <pre><code>this-&gt;devices.push_back(new Device(id, socketDescriptor, this));  connect(this-&gt;devices.back(), &amp;Device::DataReceived, this, &amp;CommunicationLayer::DataReceived); </code></pre>  <p>The socket's descriptor is passed as an argument and then when the Device object is instantiated, and I call QTcpSocket::setSocketDescriptor on the socket inside the device object with that argument.</p>  <p>My problem is that sometimes I got strange messages: QSocketNotifier: Invalid socket 7 and type 'Read', disabling... QSocketNotifier: Invalid socket 7 and type 'Write', disabling...</p>  <p>Sometimes I don't get anything and it just works, sometimes I get both, sometimes just one of them. I am a bit clueless.</p>  <p><strong>Edit:</strong></p>  <p>I think I found what's a problem: because I'm declaring the socket in the run function as an auto variable, it goes out of scope as the function returns, so the socket descriptor is invalid. And because it's running in a separate thread sometimes my device is constructed before the function returns and this way the socket descriptor remains valid. I made the socket object in run function a pointer, it works now, but I don't know if it could cause a memory leak. Any ideas? (If I use a smart pointer to manage the socket's lifetime, I get the same result as before with the auto variable)</p>