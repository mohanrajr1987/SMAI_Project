<p>Recently I am learning unix network progamming and come across a problem with get uid,pid under Linux with SCM_CREDENTIALS. The following is the code snippet.</p>  <p>Fedora 21 4.1.6-100.fc21.x86_64 + gcc 4.9.2</p>  <p><em>Server : Once connected, call sendmsg to client.</em></p>  <pre><code>#include "unp.h" #define CONTROL_LEN  (sizeof(struct cmsghdr) + sizeof(struct ucred))  ssize_t write_fd(int fd, void* ptr, int nbytes);  int main(int argc, char **argv) {   if (argc != 2)   {     printf("usage : domainsvr &lt;filepath&gt;\n");     exit(-1);   }    int listenfd, connfd;   int n,i,optval;   socklen_t clilen;   char buf[128] = {'\0'};   struct sockaddr_un cliaddr, servaddr;    listenfd = socket(AF_LOCAL, SOCK_STREAM, 0);   unlink(argv[1]);   memset(&amp;servaddr, 0,sizeof(servaddr));   servaddr.sun_family = AF_LOCAL;   strcpy(servaddr.sun_path, argv[1]);    bind(listenfd, (struct sockaddr*) &amp;servaddr,sizeof(servaddr));   optval = 1;   setsockopt(listenfd, SOL_SOCKET, SO_PASSCRED, &amp;optval, sizeof(optval));   listen(listenfd, 5);    while (1)   {     clilen = sizeof(cliaddr);     connfd = accept(listenfd, (struct sockaddr*)(&amp;cliaddr), &amp;clilen);     if (connfd &lt; 0)     {       if (errno == EINTR)       {     continue;       }       else       {     printf("accept error\n");     exit(-1);       }     }      snprintf(buf,sizeof(buf),"%s","123456789");     write_fd(connfd,(void*)buf,strlen(buf));     close(connfd);   }      return 0; }  ssize_t write_fd(int fd, void* ptr, int nbytes) {   struct msghdr  msg;   struct iovec   iov[1];   struct cmsghdr *cmptr;   struct ucred   *credp;    union    {     struct cmsghdr cmh;     char   control[CMSG_SPACE(sizeof(struct ucred))];       } control_un;    char control[CONTROL_LEN];   int n;    memset(&amp;msg,0,sizeof(msg));   iov[0].iov_base     = ptr;   iov[0].iov_len      = nbytes;   msg.msg_name        = NULL;   msg.msg_namelen     = 0;   msg.msg_iov         = iov;   msg.msg_iovlen      = 1;   msg.msg_flags       = 0;     control_un.cmh.cmsg_len = CMSG_LEN(sizeof(struct ucred));   control_un.cmh.cmsg_level = SOL_SOCKET;   control_un.cmh.cmsg_type =  SCM_CREDENTIALS;     msg.msg_control = control_un.control;   msg.msg_controllen = sizeof(control_un.control);    cmptr = CMSG_FIRSTHDR(&amp;msg);   credp = (struct ucred*)CMSG_DATA(cmptr);   credp-&gt;uid = geteuid();   credp-&gt;gid = getegid();   credp-&gt;pid = getpid();      n = sendmsg(fd, &amp;msg,0);    printf("write_fd:%d\n",n);    return n; } </code></pre>  <p><em>Client : call recvmsg to retrieve</em></p>  <pre><code>#include "unp.h" #define CONTROL_LEN  (sizeof(struct cmsghdr) + sizeof(struct ucred))  ssize_t read_fd(int fd, void* pbuff,struct ucred* cmsgcredptr);  int main(int argc, char **argv) {   int sockfd,n;   char buf[512] = {'\0'};   struct sockaddr_un servaddr;   struct ucred cred;    if (argc != 2)   {     printf("usage : domaincli &lt;filepath&gt;\n");     exit(-1);   }    memset(&amp;servaddr, 0,sizeof(servaddr));   sockfd = socket(AF_LOCAL, SOCK_STREAM, 0);    servaddr.sun_family = AF_LOCAL;   strcpy(servaddr.sun_path, argv[1]);   connect(sockfd, (struct sockaddr*) &amp;servaddr, sizeof(servaddr));    while ( (n = read_fd(sockfd,buf,&amp;cred)) &gt; 0)   {     buf[n] = '\0';     printf("Recv_msg from server: %s\n",buf);     printf("uid is:%d\n",cred.uid);     printf("gid is:%d\n",cred.gid);     printf("pid is:%d\n",cred.pid);   }    return 0; }  ssize_t read_fd(int fd, void* pbuff,struct ucred* cmsgcredptr) {   struct msghdr msg;   struct iovec  iov[3];   struct cmsghdr *cmptr;    char buf1[3],buf2[3],buf3[4];   char control[CONTROL_LEN];   int n;    union    {     struct cmsghdr cmh;     char   control[CMSG_SPACE(sizeof(struct ucred))];       } control_un;    memset(&amp;msg,0,sizeof(msg));   iov[0].iov_base = buf1;   iov[0].iov_len = 3;   iov[1].iov_base = buf2;   iov[1].iov_len = 3;   iov[2].iov_base = buf3;   iov[2].iov_len = 3;    msg.msg_name        = NULL;   msg.msg_namelen     = 0;   msg.msg_iov         = iov;   msg.msg_iovlen      = 3;   msg.msg_control     = NULL;   msg.msg_control     = control_un.control;   msg.msg_controllen  = sizeof(control_un.control);    n = recvmsg(fd, &amp;msg, 0);    // After the line, msg.msg_controllen is reset = 0. WHY?    cmptr = (struct cmsghdr *) msg.msg_control;   if (cmptr-&gt;cmsg_type == SCM_CREDENTIALS)     printf("match the cred level\n");    memcpy(cmsgcredptr, CMSG_DATA(cmptr), sizeof(struct ucred));    memcpy(pbuff,buf1,sizeof(buf1));    memcpy(pbuff+sizeof(buf1),buf2,sizeof(buf2));   memcpy(pbuff+sizeof(buf1) + sizeof(buf2),buf3,sizeof(buf3));    return n; } </code></pre>  <p>A strange phenomena is that after client calls recvmsg, the control_len of the struct msghdr is reset to 0.</p>  <p>The following is the strace from both server and client:</p>  <p><strong>Server: See that uid,gid is 1000</strong></p>  <pre><code>socket(PF_LOCAL, SOCK_STREAM, 0)        = 3 unlink("/home/tony/Desktop/dt")         = 0 bind(3, {sa_family=AF_LOCAL, sun_path="/home/tony/Desktop/dt"}, 110) = 0 setsockopt(3, SOL_SOCKET, SO_PASSCRED, [1], 4) = 0 listen(3, 5)                            = 0 accept(3, {sa_family=AF_LOCAL, NULL}, [2]) = 4 geteuid()                               = 1000 getegid()                               = 1000 getpid()                                = 7414 sendmsg(4, {msg_name(0)=NULL, msg_iov(1)=[{"123456789", 9}], msg_controllen=32, [{cmsg_len=28, cmsg_level=SOL_SOCKET, cmsg_type=SCM_CREDENTIALS, {pid=7414, uid=1000, gid=1000}}], msg_flags=0}, 0) = 9 fstat(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 0), ...}) = 0 mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f033db29000 write(1, "write_fd:9\n", 11write_fd:9 )            = 11 close(4)  = 0 </code></pre>  <p><strong>Client: See that uid,gid is not consistent with that from sever,  but the "123456789" is ok here.</strong></p>  <pre><code>socket(PF_LOCAL, SOCK_STREAM, 0)        = 3 connect(3, {sa_family=AF_LOCAL, sun_path="/home/tony/Desktop/dt"}, 110) = 0 recvmsg(3, {msg_name(0)=NULL, msg_iov(3)=[{"123", 3}, {"456", 3}, {"789", 3}], msg_controllen=0, msg_flags=0}, 0) = 9 fstat(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 1), ...}) = 0 mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7feb2c76e000 write(1, "Recv_msg from server: 123456789\n", 32Recv_msg from server: 123456789 ) = 32 write(1, "uid is:0\n", 9uid is:0 )               = 9 write(1, "gid is:0\n", 9gid is:0 )               = 9 write(1, "pid is:0\n", 9pid is:0 )               = 9 recvmsg(3, {msg_name(0)=NULL, msg_iov(3)=[{"", 3}, {"", 3}, {"", 3}], msg_controllen=0, msg_flags=0}, 0) = 0 </code></pre>  <p>I am newer to network programming. Hoping someone could spare time to illustrate what is going with the client. Why the msg.controll_len is reset to 0. Much appreciated.</p>