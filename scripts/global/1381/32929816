<p>The requirement is that, I need to write an ArrayList of integers. I need thread-safe access of the different integers (write, read, increase, decrease), and also need to allow maximum concurrency.</p>  <p>The operation with each integer is also special, like this: - Mostly frequent operation is to read - Secondly frequent operation is to decrease by one only if the value is greater than zero. Or, to increase by one (unconditionally) - Adding/removing elements is rare, but still needed.</p>  <p>I thought about AtomicInteger. However this becomes unavailable, because the atomic operation I want is to compare if not zero, then decrease. However the atomic operation provided by AtomicInteger, is compare if equal, and set. If you know how to apply AtomicInteger in this case, please raise it here.</p>  <p>What I am thinking is to synchronized the access to each integer like this: </p>  <pre><code>ArrayList &lt;Integer&gt; list;  ... ... // Compare if greater than zero, and decrease Integer n = list.get(index); boolean success = false; synchronized (n) {     if (n&gt;0) { n--; success=true; } }  // To add one Integer n = list.get(index); synchronized (n) {     n++; }  // To just read, I am thinking no need synchronization at all. int n = list.get(index).intValue(); </code></pre>  <p>With my solution, is there any side-effect? Is it efficient to maintain hundreds or even thousands of synchronized integers?</p>  <p>Then another thing is to implement the operation of add/delete, that it is thread-safe, but do not impact much of the concurrency of the other operations. I am thinking ReadWriteLock, for add/delete, need to acquire the write lock, for other operations (change the value of one integer), acquire the read lock.  Is this a right approach?</p>