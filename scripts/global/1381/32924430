  <p>Greetings everyone,</p>  <p>I am developing a (strategy) game in C# and while I was working on UI behaviour, I thought about a construction that allows code being written like this:</p>  <pre class="lang-cs prettyprint-override"><code>//This is running in a parallel thread.  Vector2 targetPosition = UI.ChoosePosition(); //waits for position being picked tank.GoTo(targetPosition); //instructs the tank to go to that position </code></pre>  <p>The code above is running in a seperate thread than the main Update/Draw loop. (For clarity: I will call the thread with the Update/Draw loop the "main thread", and the thread that runs the above code will be called "parallel thread") It is never actually run simultaneously to the main thread - a construction of semaphores allows me to give the control to the parallel thread and back to the main thread as soon as the parallel thread is waiting. As long as the parallel thread is working, the main thread is waiting.</p>  <p>The current thread stops when ChoosePosition is called and continues when a position is picked (and the main thread allows it to continue running). All this works great, and I am quite content how clean the code looks. You can simply read it from top to bottom, which is far worse when such behaviour is programmed into an Update method that runs in a loop.</p>  <p>You see that I don't actually need threads for this - I just want to have multiple stacks at once. The part about threads that cares about speeding up programs through parallel code execution is irrelevant for me. I guess that this causes some overhead, as I have to wait for the OS to switch to the parallel thread and back. I am not quite sure how much overhead though.</p>  <p>Now I thought about using a similar construction for unit behaviour, which would allow me to write code of similar "clean-ness", e. g. like this:</p>  <pre class="lang-cs prettyprint-override"><code>//Shooting behaviour of the tank. //Again, this is running in a parallel, but synchronized thread. while(target.IsAlive &amp;&amp; !tank.IsDisrupted) {     tank.TurnTurret(targetDirection); //suspends current thread until turret is turned correctly     tank.WaitForShotReady(); //suspends thread again     tank.Shoot();     soundSystem.StartSoundEffect("tank_shooting");     particleSystem.EmitParticles(tank.TurretMuzzlePosition); } </code></pre>  <p>The problem is that this would require an own stack for every (active) unit, and that means an own thread for every (active) unit. Aditionally, as stated above, I fear some OS overhead from the thread switching. This leads me to my first question:</p>  <h2>Is there a class in the .NET framework that allows me to have a seperate stack without having the overhead of a thread?</h2>  <p><sup><sub>("Stack" obviously referring to the call stack, and not to the data structure.)</sub></sup></p>  <p>AFAIK the <strong>ThreadPool</strong> and <strong>Task</strong> classes (which internally either uses a new thread or the ThreadPool) are not suited for long-running tasks/threads as they provide a limited number of threads (and therefore a limited number of stacks). According to MSDN, a task marked as long-running just creates a thread in the background.</p>  <p>Of course I benchmarked the performance implications of running a lot of threads that are not in the ready-queue. It turns out that they are quite acceptable: the creation of 10k threads takes a bit under a second, and as I can reuse threads for new units once an old one dies, this performance overhead comes only at loading time. The frame time overhead of 10k threads seems to be about 1-2 ms per frame (although I tested with a very high framerate, I'm not sure how this scales), which isn't that great, but probably acceptable, considering 10k units will require a lot of performance anyway and therefore be more like the upper bound of units existing simultaneously.</p>  <p>(And before you ask: yes, memory consumption was a few hundred megabytes, but that's relatively low compared to the memory the rest of the game requires. It's not designed for low-end computers anyway :-) )</p>  <p>So my result is basically: Performance overhead is not great, but acceptable even with threads. But: The performance was terrible (like, literally a hundred times worse) when I ran the benchmark with Visual Studio debugging, because the VS '15 UI displays all the threads and a lot of thread-related events. I like this behaviour in general, because it makes debugging multi-threaded applications much easier, but when displaying <em>these</em> threads, performance is kill. So my second question (which would be answered by the first one, too) is:</p>  <h2>Is there a possibillity to hide a thread from Visual Studio?</h2>  <p>You might now argue that threads are not made for "mass production" and constant blocking, and that this approach is an abuse of threads. That might be true, but there are several reasons against this:</p>  <ol> <li>My task manager shows me more than 1.5k threads running right now, while just having a browser and Visual Studio open. This doesn't seem to cause any performance issues, and I bet that most of these threads are not in the Ready-Queue but are currently blocking. (I can't look it up in the Windows task manager, but when using htop on Linux it's visible that most threads are not actually doing anything.) Not only my benchmarks, but the system I use everyday shows me that having a lot of idle threads in the background is no problem at all.</li> <li>MS-owned Windows Forms works in a (kind of) similar way: when a dialog box is opened, the current thread stops, but certain OS threads keep the window semi-responsive (make noise when clicked). This requires a vastly smaller amount of threads though.</li> <li>Even if threads are not really "designed" for this use case, they might still work just fine. If you say "don't use threads, they aren't made for this", I would prefer a reason that refers to the properties of the concept or implementation of the thread, and not to the incentive of the author of threads - because an incentive alone doesn't neccesarily break anything :-)</li> </ol>  <p>I guess that I am not the only person on earth encountering this kind of situation. Is there maybe a pattern that could be applied here? </p>  <p>I know that I could probably use some scripting engine. But I really like C# and its ecosystem, and I would like to not have even more external dependencies.</p>