<p>My structure looks like :</p>  <pre><code>public class ReadCSV {      volatile List&lt;FlightDetails&gt; detail;    main()  {      ReadCSV obj=new ReadCSV();      obj.detail=Collections.synchronizedList(new ArrayList&lt;FlightDetails&gt;());      new Thread(new Runnable(){          @Override         public void run() {               try {                 ...                 //pass the object along                 readAndParseFile("someFile.csv",obj);              } catch (IOException e) {                 ...             }                 // prints  Alright             System.out.println(obj.detail.get(0).getDep_loc());         }            }).start();      // Throws AIOB Exception     System.out.println(obj.detail.get(0).getArr_loc()); }  static void readAndParseFile(String csvFileName, ReadCSV obj) {   ... .. //make changes to the object  obj.detail.add()  // works fine  } </code></pre>  <p>While passing the object without the thread, the changes are made.But the changes are not reflected even after making the field <code>Volatile</code>.</p>  <p>1) what is wrong in the above code? 2) Is it alright to follow this approach? 3) what is the general way to do such jobs?</p>  <p>I am very new to multi threading . </p>