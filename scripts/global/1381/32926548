<p>So, I'm using a Hibernate DAO with Spring. My DAO is going to be constructed by the ApplicationContext IOC container, and the SessionFactory is going to be injected by the container (LocalSessionFactoryBean).</p>  <p>Now, this DAO is going to be a singleton, used for all CRUD operations in my program, with a pool of database connections behind it. My concern is about the thread safety of the sessionFactory field.</p>  <p>My understanding of thread safety is that all state fields need to be guarded in a multi-threaded environment. Now, the use of this class will be that Spring will set the SessionFactory upon bean creation, and that factory won't be changed after that. This means that TECHNICALLY it could function safely in a multi-threaded environment, but I feel that's a very risky practice, to just operate on the assumption that the setter method won't be called again.</p>  <p>The thing is, synchronizing the SessionFactory would require all calls to it to be synchronized as well. So the insertPortfolio() method I put in below would need to be synchronized as well, which defeats the purpose of having a pool of available connections to the database, since access will be limited to one thread at a time.</p>  <p>I guess the best solution I can think of is to change this from setter injection to constructor injection, and make the SessionFactory field final. But I'm trying to understand the broader issues at stake here, so I can make good multi-threaded safety decisions with spring in the future.</p>  <pre><code>private SessionFactory sessionFactory;  public HibernatePortfolioDao() {}  public void setSessionFactory(SessionFactory sessionFactory){     this.sessionFactory = sessionFactory; }  @Override public void insertPortfolio(PortfolioModel portfolioModel) {     sessionFactory.getCurrentSession().save(portfolioModel); } </code></pre>