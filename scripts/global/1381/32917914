<p>I have a cluster_manager.py script that has two classes - one is a thread manager object, that is essentially responsible for taking a list of tasks that are passed to one of the class's function, filling a queue and assigning threads to the items in the queue. </p>  <pre><code>import threading import queue import requests import sys  import http  from Jaws2_Engine.Jaws_Objects import jaws_manifest from Jaws2_Engine.Jaws_Core import jaws_framework, shell_task, database_task  from PyQt5 import QtCore  global critical_error critical_error = "ONERROR"  class thread_manager(object):     def __init__(self):         self.threads = list()         self.task_queue = queue.Queue()         self.result_queue = queue.Queue()      def messageReceived(self, message):         print("error message in thread manager: %s" % message)         if message == critical_error:             print("A critical error has occurred. Run cycle is stopping execution.")             for thread in self.threads:                 thread.stop()                 sys.exit(2)      def manageThreads(self, manifest):         #Queues created initially to be filled with tasks by the thread manager and retrieved via independent threads          threads = list()          for task in manifest.Tasks:             self.task_queue.put(task)          for task in manifest.Tasks:             t = TaskProcess(self.task_queue, self.result_queue)             t.message_ready.connect(self.messageReceived)             threads.append(t)             print("Starting worker {}".format(task.command))             t.start()          self.task_queue.join()          # while not result_queue.empty(): </code></pre>  <p>Then I have a second class that is the worker thread that goes and performs the task. What I want to do is to pass a kill signal back to the thread manager to tell it to kill all currently running threads, but the signal is not being sent to the messageReceived function of the thread manager. Do you see anything I may be doing incorrectly? </p>  <pre><code>class TaskProcess(QtCore.QThread):     task_queue = None     result_queue = None     taskStatus = None      message_ready = QtCore.pyqtSignal(object)      def __init__(self, task_queue=None, result_queue=None):         QtCore.QThread.__init__(self)         self.task_queue = task_queue         self.result_queue = result_queue         self.framework_shell = ""          self.class_setup()      def class_setup(self):         jaws = jaws_framework()         self.framework_shell = jaws.connect_shell         self.message_ready.emit("emitting signal from taskprocess to thread manager..")      def run(self):         while True:             try:                 task_to_run = self.task_queue.get_nowait()             except queue.Empty:                 break             else:                 if task_to_run.task_type == shell_task:                     result, stderr, session_succeeded = self.framework_shell(task_to_run.command, return_result=True)                     print("session succeeded: %s" % session_succeeded)                     if session_succeeded == False:                         print("%s" % critical_error)                         self.message_ready.emit(critical_error)                     for r in result:                         print("%s.%s" % (task_to_run.table, r))                         #self.message_ready.emit("table: %s result: %s" % (task_to_run.table, r))                     self.result_queue.put((task_to_run, result,))                 elif task_to_run.task_type == database_task:                     pass                 self.task_queue.task_done()                 #print(task_to_run.command)      def stop(self):         self.__stop.set() </code></pre>