<p>I observed an odd behavior when using the Ping class. After creating and launching a number of instances via .SendAsync(...) from within a thread that hosts a Form, I am waiting for a List from which each instance removes itself in the method called by the PingCompleted event getting empty, but this never happened because the callback method never got executed, until I inserted an Application.DoEvents() in the waiting loop.</p>  <p>I discovered that the callback method is executed in the same thread that called .SendAsync, which of course explains why the callback didn't work. If I first create another thread and call .SendAsync there, or do this in a console project, the callback is alternately executed in one of a small number of different threads, none of them being identical to the thread that called .SendAsync.</p>  <p>So why does the behavior of Ping.SendAsync and probably others regarding thread creation depend on whether there is a Form associated to the invoking thread or not? I thought maybe to save the programmer the need of checking .InvokeRequired when accessing a Control from a callback method, but I prefer utilizing .InvokeRequired/.Invoke in these methods that actually involve interaction with Forms/Controls, rather than not even having the method executed because of deadlock.</p>