<p>Javascript is single threaded. So every piece of code which I write is executed in a single thread of javascript runtime provided by Node. So when I execute following code:</p>  <pre><code>var fs = require("fs");  fs.readFile('input.txt', function (err, data) {    if (err) {        return console.error(err);    }    console.log("Asynchronous read: " + data.toString()); });  // Synchronous read var data = fs.readFileSync('input.txt'); </code></pre>  <p>Following is my understanding of workflow, please correct me if I am wrong:</p>  <p><code>fs.readFile</code> is popped off the call stack by <strong>manager</strong> in Node immediately and moved to some other thread where it starts the reading stuff.</p>  <p>When reading is complete, <strong>manager</strong> in Node:</p>  <ul> <li>puts the callback function of <code>fs.readFile</code> in the queue stack</li> <li>which event loop eventually puts in the call stack and executes</li> </ul>  <p><code>fs.readFileSync</code> is not popped off the stack but is executed in the runtime thread itself like any other function.</p>  <p>So, who is this  <strong>manager</strong> in node which executes Node API I/O functions in other threads and manages their call stacks. </p>  <p>So does Node use multi-cores to execute it's API functions in the background?</p>