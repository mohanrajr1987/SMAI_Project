<p>Consider following implementation, a method accepts an <code>IProgress&lt;int&gt;</code>, iterates over 10000 objects. The <code>numbers</code> array variable returns 10000 objects, but the <code>IProgress&lt;int&gt;</code> reports only between 9970 - 9980 objects. It varies per run, so some get "lost".</p>  <pre><code>    protected async override Task&lt;int[]&gt; CollectDataAsyncImpl(IProgress&lt;int&gt; progress) {                         return await Task.Run&lt;int[]&gt;(() =&gt; {              var numbers = new List&lt;int&gt;();              foreach (var idx in new Int32Range(1, 10000).AsEnumerable().Index()) {                                                              numbers.Add(idx.Value);                                      if (progress != null) {                     progress.Report(idx.Value);                 }              }              return numbers.ToArray();         });     } </code></pre>  <p>As reference, here's the test I ran. It fails at the third assert <code>Assert.Equal(10000, result[9999]);</code>.</p>  <pre><code>[Fact] async void ReportsProgress() {                 var sut = new IntegerCollector();     var result = new List&lt;int&gt;();     var output = await sut.CollectDataAsync(new Progress&lt;int&gt;(i =&gt; result.Add(i)));     Assert.Equal(10000, output.Length);     Assert.Equal(1, result[0]);     Assert.Equal(10000, result[9999]); } </code></pre>  <p>Clearly I'm doing something wrong, or I don't understand the internals of task/threading. Is my implementation of <code>IProgress&lt;int&gt;</code> to <code>new Progress&lt;int&gt;(i =&gt; result.Add(i))</code> not correct? Should I make that thread safe, and if so, how do I do that?</p>  <p>GitHub has the code which you can clone &amp; test with if need be: <a href="https://github.com/KodeFoxx/Kf.DataCollection/tree/master/Source/Kf.DataCollection" rel="nofollow">https://github.com/KodeFoxx/Kf.DataCollection/tree/master/Source/Kf.DataCollection</a></p>