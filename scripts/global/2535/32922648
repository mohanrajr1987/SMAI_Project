<p>I chose to use Entity Framework as a metadata design tool because I wanted to expose DTO classes that don't map to real database tables. Three reasons for that </p>  <ol> <li>My server model does not use entities for all many-to-many relationships and <a href="http://stackoverflow.com/a/13636530/150342">Breeze does not support many-to-many relations where the mapping table is hidden</a></li> <li>I have many-to-many relationships that can be flattened when data is sent to a single device.</li> <li>I can reduce the size of the model considerably on the client because many of the properties are unecessary on the client model.</li> </ol>  <p>So I have code like this:</p>  <pre><code>public class BreezeRepository {     //The ServerContext maps to a database     readonly EFContextProvider&lt;Data.Models.ServerContext&gt; _contextProvider         = new EFContextProvider&lt;Data.Models.ServerContext&gt;();      public string MetaData     {         get         {             //The DtoContext is a context that is not linked to a database             //It is purely to used to define the DTO's             var metaDataContext = new EFContextProvider&lt;DtoContext&gt;();             return metaDataContext.Metadata();         }     }      public IQueryable&lt;PersonDto&gt; Properties(string userId)     {        //Mapping server model to client model        return _contextProvider             .Context             .Persons             .Where(//etc)             .Select(p =&gt; new PersonDto{//etc})     } } </code></pre>  <p>Now I need to map from the client model back to the server model in <code>SaveChanges</code>:</p>  <pre><code>public SaveResult SaveChanges(JObject clientSaveBundle) {     var serverSaveBundle = new JObject();     //How do I extract the Dto's and put them into a new serverSaveBundle     return _contextProvider.SaveChanges(serverSaveBundle); } </code></pre>