<p>I have a problem, it am totally stuck on what to do. I am new to EF :(</p>  <p>I've used <a href="http://www.codeproject.com/Articles/839640/Unknown-Class-Dynamically-Generated-at-runtime-for" rel="nofollow">code</a> from Adriaan Booysen to create a dynamic model. I'm can't use <code>WCFDataService</code> because of the limitations, and I've changed some of the code to make it work for me. When I run the it the first time, it works, I get my data, but when I execute the method again, I get the error that the entity type is not part of the model.</p>  <p>What I've noticed is that when I run the application, and create the first Entity, the OnModelCreating is fired, and the model is added, but the second time it does not happen, and I think that is why I get the error, but I'm not sure what to do to make it fire again.</p>  <p>This is the code for <code>DynamicDbContext</code></p>  <pre><code>public partial class DynamicDbContext : DbContext {     public DynamicDbContext()         : base("name=DynamicDbContext")     {         Database.SetInitializer(new NullDatabaseInitializer&lt;DynamicDbContext&gt;());     }      public void AddTable(Type type, List&lt;string&gt; KeyFields)     {         _tables.Add(type.Name, type);         _keys = KeyFields;     }      private List&lt;string&gt; _keys;     private Dictionary&lt;string, Type&gt; _tables = new Dictionary&lt;string, Type&gt;();      protected override void OnModelCreating(DbModelBuilder modelBuilder)     {         //base.OnModelCreating(modelBuilder);         var entityMethod = modelBuilder.GetType().GetMethod("Entity");          foreach (var table in _tables)         {             entityMethod.MakeGenericMethod(table.Value).Invoke(modelBuilder, new object[] { });             foreach (var pi in (table.Value).GetProperties())             {                 if (_keys.Contains(pi.Name.ToUpper()))                     modelBuilder.Entity(table.Value).HasKey(pi.PropertyType, pi.Name);                 else                     switch (pi.PropertyType.Name)                     {                         case "Int16":                         case "Int32":                         case "Int64":                         case "Boolean":                             modelBuilder.Entity(table.Value).PrimitiveProperty(pi.PropertyType, pi.Name);                             break;                         default:                             modelBuilder.Entity(table.Value).DynamicProperty(pi.PropertyType, pi.Name);                             break;                     }             }         }     } } </code></pre>  <p>I have a class then to get the <code>DbSet</code></p>  <pre><code>public class Class1 : DynamicDbContext {      public DbSet LoadTypes(string TableName, Dictionary&lt;string, Type&gt; Fields, List&lt;string&gt; KeyFields)     {         var dcf = new DynamicClassFactory("Query." + TableName);         var type = CreateType(dcf, TableName, Fields);          AddTable(type, KeyFields);         return Set(type);     }      private static Type CreateType(DynamicClassFactory dcf, string name, Dictionary&lt;string, Type&gt; Fields)     {         var type = dcf.CreateDynamicType&lt;BaseDynamicEntity&gt;(name, Fields);         return type;     } } </code></pre>  <p>The <code>DynamicClassFactory</code> creates the in memory assembly. If your look at the codeproject code, you can see what it does. I didn't change anything there.</p>  <p>In my application I do the following:</p>  <pre><code>var c = new Class1(); var Types = new Dictionary&lt;string, Type&gt;(); /*Code to populate the Fields and Field Types into the Types variable*/ source.QueryableSource = c.LoadTypes(TableName, Types, new List&lt;string&gt;() { "NO" }); </code></pre>  <p>source is a <code>EntityServerModeSource</code> from DevExpress and allows me to populate a pivot more efficiently. If anybody can just point me in the right direction of what to do, I can figure it out, but currently I'm not sure what to do.</p>