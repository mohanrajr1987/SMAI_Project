<p>So I'm writing a Class for an object with several properties that I don't want a user to have to initialize all at once, but all of these attributes are essential to the abstraction and function my class provides (i.e. Ideally, a user shouldn't experience an AttributeError). I wrote an <strong>init</strong>() function that accepts these properties as either a dictionary, arguments, or both, and sets any attributes not initialized by the user to None.</p>  <pre><code># class Thing:  properties = set(['attr_1', 'attr_2', 'attr_3', 'attr_4', 'attr_5', 'some_dict', 'some_list', 'some_other_list'])  def __init__(self, *arg_hash, **kwargs):       # Set allowed attributes from a dict       for dictionary in arg_hash:           for key in dictionary:               if (key in Thing.properties):                   setattr(self, key, dictionary[key])       # Set allowed attributes from arguments       for key in kwargs:           if (key in Thing.properties):               setattr(self, key, kwargs[key])       # Set remaining attributes to None       for prop in Thing.properties:           if (not hasattr(self, prop)):               setattr(self, prop, None) </code></pre>  <p>I've done this with a set() called 'properties', which has every attribute I want initialized in each instance of my class. Users can't set attributes that are not in the set, and every 'property' in the set becomes an attribute, even if the value is None. This is more or less the behavior I am looking for, but Jedi-Vim does not recognize that these are attributes of each instance, and so auto-complete does not find matches for any of these. </p>  <p>Is there an elegant way to get this or similar behavior and have Jedi-Vim recognize my attributes? Or is there a reason I should not have my class behave this way? Any advice would be wonderful, and please let me know if there is a better way to phrase this question or if anything is unclear.</p>