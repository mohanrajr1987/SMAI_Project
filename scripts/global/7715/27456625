<p>I am learning about abstract data types <a href="http://interactivepython.org/runestone/static/pythonds/SortSearch/Hashing.html#implementing-the-map-abstract-data-type" rel="nofollow">here</a>. Lately I have been reading about hashing with a Map (or some data structure like a dict).</p>  <p>Here is how the code looks like:</p>  <pre><code>class HashTable:     def __init__(self):         self.size = 11         self.slots = [None] * self.size         self.data = [None] * self.size  def put(self,key,data):   hashvalue = self.hashfunction(key,len(self.slots))    if self.slots[hashvalue] == None:     self.slots[hashvalue] = key     self.data[hashvalue] = data   else:     if self.slots[hashvalue] == key:       self.data[hashvalue] = data  #replace     else:       nextslot = self.rehash(hashvalue,len(self.slots))       while self.slots[nextslot] != None and \                       self.slots[nextslot] != key:         nextslot = self.rehash(nextslot,len(self.slots))        if self.slots[nextslot] == None:         self.slots[nextslot]=key         self.data[nextslot]=data       else:         self.data[nextslot] = data #replace  def hashfunction(self,key,size):      return key%size  def rehash(self,oldhash,size):     return (oldhash+1)%size  def get(self,key):   startslot = self.hashfunction(key,len(self.slots))    data = None   stop = False   found = False   position = startslot   while self.slots[position] != None and  \                        not found and not stop:      if self.slots[position] == key:        found = True        data = self.data[position]      else:        position=self.rehash(position,len(self.slots))        if position == startslot:            stop = True   return data  def __getitem__(self,key):     return self.get(key)  def __setitem__(self,key,data):     self.put(key,data) </code></pre>  <p>Now within the textbook, the author states that the size of the hashtable is arbitrary. See here:</p>  <blockquote>   <p>Note that the initial size for the hash table has been chosen to be   11. Although this is arbitrary, it is important that the size be a prime number so that the collision resolution algorithm can be as   efficient as possible.</p> </blockquote>  <p>Why is this arbitrary? It would seem that the number of slots given is directly correlated to how many values can be stored. I know that other hashtables may be flexible and be able to store more data into one data slot, but in <strong>THIS</strong> specific example, it isn't just 'arbitrary'. It is exactly how many values can be stored.</p>  <p>Am I missing something here?</p>