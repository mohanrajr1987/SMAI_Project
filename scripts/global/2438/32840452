<p>I have 3 tables called Borrower (primary key borrowerId), Address (primary key addressId) and Borrower_Address (primary key borrowerId, addressId and addressType). They maintain many to many relationship in the third table (Borrower_Address)<br> My problem is when I try to insert a new <strong>address</strong> for a given borrower then it is inserting record in <strong>address</strong> and <strong>borrower_address</strong> table and working as expected. But when I try to insert 2 addresses for a given borrower then it is inserting two addresses in the <strong>Address</strong> table so generating two new addressId (say 100,200) but while inserting 2 records into <strong>Borrower_Address</strong> table, it is trying to insert with the latest addressId (200 in this case).</p>  <p>My mapping is as follows</p>  <pre><code>@Entity @Table(name="BORROWER") @NamedQuery(name="Borrower.findAll", query="SELECT b FROM Borrower b") @Cacheable(false) public class Borrower {     @EmbeddedId     private BorrowerPK id;      @OneToMany(fetch=FetchType.LAZY, mappedBy="borrower", cascade={CascadeType.DETACH, CascadeType.MERGE, CascadeType.PERSIST, CascadeType.REFRESH}, orphanRemoval=true)     @JsonManagedReference     private List&lt;BorrAddr&gt; borrAddrs = new ArrayList&lt;BorrAddr&gt;(); }   @Embeddable public class BorrowerPK implements Serializable {     @SequenceGenerator(name = "borrSeq", sequenceName = "BORROWER_SEQ", allocationSize = 1, initialValue = 1)     @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "borrSeq")     @Column(name="BORROWER_ID")     private long borrowerId; }  @Entity @Table(name="ADDRESS") @NamedQuery(name="Address.findAll", query="SELECT a FROM Address a") @Cacheable(false) public class Address {     @EmbeddedId     private AddressPK id;      @OneToMany(fetch=FetchType.LAZY, mappedBy="address", cascade={CascadeType.DETACH, CascadeType.MERGE, CascadeType.PERSIST, CascadeType.REFRESH})     @JsonManagedReference     private List&lt;BorrAddr&gt; borrAddrs = new ArrayList&lt;BorrAddr&gt;(); }  @Embeddable public class AddressPK implements Serializable {     @SequenceGenerator(name = "addSeq", sequenceName = "ADDRESS_SEQ", allocationSize = 1, initialValue = 1)     @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "addSeq")     @Column(name="ADDRESS_ID")     private long addressId; }   @Entity @Table(name="BORR_ADDR") @NamedQuery(name="BorrAddr.findAll", query="SELECT b FROM BorrAddr b") @Cacheable(false) public class BorrAddr implements Serializable {     private static final long serialVersionUID = 1L;      @EmbeddedId     private BorrAddrPK id;      @ManyToOne(fetch=FetchType.LAZY, cascade={CascadeType.DETACH, CascadeType.MERGE, CascadeType.PERSIST, CascadeType.REFRESH})     @JoinColumns({             @JoinColumn(name="BORROWER_ID", referencedColumnName="BORROWER_ID")         })     @JsonBackReference     private Borrower borrower;      //bi-directional many-to-one association to Address     @ManyToOne(fetch=FetchType.LAZY, cascade={CascadeType.DETACH, CascadeType.MERGE, CascadeType.PERSIST, CascadeType.REFRESH})     @JoinColumns({         @JoinColumn(name="ADDRESS_ID", referencedColumnName="ADDRESS_ID")         })     @JsonBackReference     private Address address; }   @Embeddable public class BorrAddrPK implements Serializable {     @Column(name="BORROWER_ID", insertable=false, updatable=false)     private long borrowerId;      @Column(name="ADDRESS_ID", insertable=false, updatable=false)     private long addressId;      @Column(name="ADDR_TYPE")     private String addrType; }    Repository To save data ========================  public interface BorrAddrRepository extends MssBaseRepository&lt;BorrAddr, BorrAddrPK&gt;{  }  @NoRepositoryBean public interface MssBaseRepository&lt;T, ID extends Serializable&gt; extends         JpaRepository&lt;T, ID&gt; {  }    Code to save data =================== borrAddrRepository.save(borrAddrList) </code></pre>