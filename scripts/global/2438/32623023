<p>I have an object <code>Option</code> which is like a type, it only has a property: <code>name</code> (it could have more properties in the future). Instances of <code>Option</code> have a unique name.</p>  <p>Many objects may have zero or more of <code>Option</code> instances.</p>  <p>For example:</p>  <pre><code>class Consumer:     options = models.ManyToManyField(Option, blank=True, help_text="the options") </code></pre>  <p>But then, in order to create the <code>Option</code> instances for <code>Consumer</code>'s many-to-many <code>options</code> relationship, I need to create a new <code>Option</code> instance and add it to <code>options</code>.</p>  <p>This however "breaks" my uniqueness: Now I have two with the same name! And so forth for every instance of <code>Option</code> I create.for <code>Many-to-Many</code> links. Instead of the 4 I need, I have now 68 in my DB...</p>  <p>I believe I have fundamentally misunderstood <code>Many-To-Man</code>y, and / or mis-designed this relationship...</p>  <p>Can anybody help?</p>  <p>EDIT: Here's how I set options in an example:</p>  <pre><code>def enable_option(request, pk=0, option_pk=0, *args, **kwargs):     consumer = get_object_or_404(Consumer, pk=pk)     option = get_object_or_404(Option, pk=option_pk)      new_option = Option()     new_option.name = option.name // I know I am breaking my own rule...but when I read the consumer options, I need the exact same name! Still, I believe I am modeling wrong     new_option.save()     consumer.options.add(new_option)     consumer.save()      return HttpResponse() </code></pre>