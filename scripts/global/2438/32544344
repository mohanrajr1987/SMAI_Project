<p>I'm having an m:n relationsship like <a href="https://howtoprogramwithjava.com/hibernate-manytomany-unidirectional-bidirectional">here</a>, except for that there's some information be to associated with the <code>AuthorBook</code> entity. So I guess, I need no <code>@JoinTable</code> at all and should create a <code>class AuthorBook</code> consisting of one link to each of <code>Author</code> and <code>Book</code> and the additional information, right?</p>  <p>I tried it like</p>  <pre><code>@Entity public class AuthorBook {     @Id @ManyToOne Author author;     @Id @ManyToOne Book book;     @LobOrWhatever AdditionalInformation additionalInformation; } </code></pre>  <p>and I ran into problems (I can't recall exactly anymore). So I've introduced a <code>@GeneratedId int id</code> and changed the references to <code>@NaturalId</code>. This works mostly well, but funnily, it forces me to pass attached <code>Author</code> and <code>Book</code> to <code>Session#byNaturalId</code> which makes no sense to me (I have the ids and the entities should be fetched together). I also tried</p>  <pre><code>session.byNaturalId(AuthorBook.class)      .using("author.id", someAuthorId)      .using("book.id", someBookId)      .load(); </code></pre>  <p>but this was refused telling me that "author.id" is no natural id (which is actually true as the natural id is "author", but its "id" works equally well).</p>  <p>Looking at the web, I find everyone using ids instead of entities in such a table, so I wonder if I'm trying something impossible.... (or stupid).</p>