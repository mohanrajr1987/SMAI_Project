<p>I try to find best solution to the problem while updating entity which has deep relationships. Because my entities are too complex and have deeper relationships, I simplified into this.</p>  <p><em>MainCategory - Category</em> has one-to-many relationship and <em>Category - SubCategory</em> has also one-to-many relationship</p>  <pre><code>public class MainCategory {     [Key]     public int Id { get; set; }     public string MainCategoryName { get; set; }      public virtual ICollection&lt;Category&gt; Categories { get; set; } }  public class Category {     [Key]     public int Id { get; set; }     public string CategoryName { get; set; }      public virtual ICollection&lt;SubCategory&gt; SubCategories { get; set; } }  public class SubCategory  {     [Key]     public int Id { get; set; }     public string SubCategoryName { get; set; }      public Category Category { get; set; } } </code></pre>  <p>Here is how I handle the situation while updated or new MainCategory entity with child and grandchild records comes from somewhere.</p>  <pre><code>public void AddOrUpdateMainCategory() {     using (var ctx = new MyContext())     {         // Gets MainCategory domain object.         // Domain object has no id property because it does not come from (ctx.MainCategories)         var mainCategory = GetMainCategory();          var mainCategoryFromDb = ctx.MainCategory.Include(x =&gt; x.Categories.Select(y =&gt; y.SubCategories)).FirstOrDefault(x =&gt; someCondition());          if (mainCategoryFromDb == null)         {             ctx.ShopParameterPeriodItems.Add(mainCategory);         }          // If mainCategoryFromDb is not null, mainCategory object should map to mainCategoryFromDb.         else         {             ctx.SubCategories.RemoveRange(mainCategoryFromDb.Categories.SelectMany(x =&gt; x.SubCategories));             ctx.Categories.RemoveRange(mainCategoryFromDb.Categories);             ctx.MainCategories.Remove(mainCategoryFromDb);              ctx.MainCategories.Add(mainCategory);          }           ctx.SaveChanges();     } } </code></pre>  <h2>Problems of code</h2>  <ul> <li>Because updating mechanism is deleting old entity and its child and grandchild entities and adding a new one, Id value of database records are refreshed every time. This would be a big problem if any foreign key exists to <em>MainCategory</em>, <em>Category</em>, or <em>SubCategory</em> from different tables.</li> <li><p>The first problem can be solved like that</p>  <pre><code>    foreach (var category in mainCategoryFromDb.Categories)     {          foreach (var subCategory in category.SubCategories)          {               // Set subCategory properties          }           // Set category properties     }      // Set mainCategoryFromDb properties </code></pre>  <p>This solves <strong>Id loss</strong> problem but as I wrote, entities are very complex. It would be hard to maintain and we do not know, for example, which category of <strong>mainCategory</strong> will update category of <strong>mainCategoryFromDb</strong> because mainCategory and its child and grandchild entities do not have Id property.</p></li> </ul>  <p>What I am looking for is a way to solve the problems.</p>