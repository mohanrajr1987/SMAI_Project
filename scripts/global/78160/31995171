<p>I am using EF5 and I have some entities that I wrote myself and also wrote a function that adds all the mappings to the modelbuilder configurations.  </p>  <p>Running a simple test query, I can query items from a table successfully but when I try to add a new item and save, I get an exception that the primary key of my entity is null, even though I gave it a value.</p>  <p>It's quite possible that I messed up the mappings, but I don't know why it would work for a query and not a save.</p>  <pre><code>public class User : IMappedEntity  {     [Key]     [Column("USER_ID")]     public int UserID { get; set; }      [Column("FIRST_NAME")]     public String FirstName { get; set; }      [Column("LAST_NAME")]     public String LastName { get; set; }  }  protected override void OnModelCreating(DbModelBuilder modelBuilder) {         modelBuilder.Conventions.Remove&lt;System.Data.Entity.ModelConfiguration.Conventions.PluralizingEntitySetNameConvention&gt;();         modelBuilder.Conventions.Remove&lt;System.Data.Entity.ModelConfiguration.Conventions.PluralizingTableNameConvention&gt;();      var addMethod = (from m in (modelBuilder.Configurations).GetType().GetMethods()                      where m.Name == "Add"                          &amp;&amp; m.GetParameters().Count() == 1                         &amp;&amp; m.GetParameters()[0].ParameterType.Name == typeof(EntityTypeConfiguration&lt;&gt;).Name                      select m).First();      if(mappings != null)     {         foreach(var map in mappings)         {             if(map != null &amp;&amp; !mappedTypes.Contains(map.GetType()))             {                 var thisType = map.GetType();                  if (thisType.IsGenericType)                 {                     thisType = map.GetType().GenericTypeArguments[0];                 }                  var thisAddMethod = addMethod.MakeGenericMethod(new[] {thisType});                 thisAddMethod.Invoke(modelBuilder.Configurations, new[] { map });                 mappedTypes.Add(map.GetType());             }         }     } }  private List&lt;Object&gt; BuildMappings(IEnumerable&lt;Type&gt; types) {     List&lt;Object&gt; results = new List&lt;Object&gt;();      var pkType = typeof(KeyAttribute);     var dbGenType = typeof(DatabaseGeneratedAttribute);      foreach (Type t in types)     {         String tableName = GetTableName(t);         String schemaName = GetSchema(t);         var mappingType = typeof(EntityTypeConfiguration&lt;&gt;).MakeGenericType(t);         dynamic mapping = Activator.CreateInstance(mappingType);          if (!String.IsNullOrWhiteSpace(schemaName))            mapping.ToTable(tableName, SchemaName.ToUpper());         else            mapping.ToTable(tableName);          var keys = new List&lt;PropertyInfo&gt;();          foreach (PropertyInfo prop in t.GetProperties())         {             String columnName = prop.Name;              if(Attribute.IsDefined(prop, typeof(ColumnAttribute)))             {                 columnName  = (prop.GetCustomAttribute(typeof(ColumnAttribute)) as ColumnAttribute).Name;             }              if(Attribute.IsDefined(prop, pkType))                keys.Add(prop);              var genFunc = (typeof(Func&lt;,&gt;)).MakeGenericType(t, prop.PropertyType);             var param = Expression.Parameter(t, "t");             var body = Expression.PropertyOrField(param, prop.Name);             dynamic lambda = Expression.Lambda(genFunc, body, new ParameterExpression[] { param });              //if (prop.PropertyType == typeof(Guid) || prop.PropertyType == typeof(Nullable&lt;Guid&gt;))             //{             //    mapping.Property(lambda).HasColumnType("Guid");             //}             //else             mapping.Property(lambda).HasColumnName(columnName);              if (Attribute.IsDefined(prop, dbGenType))                mapping.Property(lambda).HasDatabaseGeneratedOption(DatabaseGeneratedOption.Computed);         }          if (keys.Count == 0)            throw new InvalidOperationException("Entity must have a primary key");         dynamic entKey = null;          if(keys.Count == 1)         {             var genFunc = (typeof(Func&lt;,&gt;)).MakeGenericType(t, keys[0].PropertyType);             var param = Expression.Parameter(t, "t");             var body = Expression.PropertyOrField(param, keys[0].Name);             entKey = Expression.Lambda(genFunc, body, new ParameterExpression[] { param });         }         else         {             //if entity uses a compound key, it must have a function named "GetPrimaryKey()" which returns Expression&lt;Func&lt;EntityType,Object&gt;&gt;             //this is because I can't create an expression tree that creates an anonymous type             entKey = t.GetMethod("GetPrimaryKey");         }          mapping.HasKey(entKey);          results.Add(mapping);     }      return results; }  static void Main(string[] args) {     using (var ctx = new DQSA.Data.DBContext("DQSATEST"))     {         var xxx = (from u in ctx.Query&lt;DQSA.Data.Entities.User&gt;()                    select u).ToList(); //this works, I can see my user          ctx.Set&lt;DQSA.Data.Entities.User&gt;().Add(new DQSA.Data.Entities.User()             { UserID = 0,               FirstName="Sam",               LastName="Sam"             });          ctx.SaveChanges(); //get an exception here          xxx = (from u in ctx.Query&lt;DQSA.Data.Entities.User&gt;()                select u).ToList();     } } </code></pre>