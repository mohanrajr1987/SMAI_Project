<p>I need to walk a directory tree and get stat values for every file.  I want to do this safely while the filesystem is being modified.</p>  <p>In Python, the best option is <a href="https://docs.python.org/dev/library/os.html#os.fwalk" rel="nofollow"><code>os.fwalk</code></a>, which gives access to the fd for the directory being traversed; I can then <code>os.stat</code> with the dir_fd (<code>fstatat</code>) and get current stat values.  This is as race-free as it can be made on Linux (if the contents of this directory are being modified, I may have to rescan it).  In C, there is <a href="http://man7.org/linux/man-pages/man3/nftw.3.html" rel="nofollow"><code>nftw</code></a>, which is implemented similarly, and <a href="http://man7.org/linux/man-pages/man3/fts.3.html" rel="nofollow"><code>fts</code></a>, which in glibc uses a plain (l)stat and therefore is racy (it reduces the race window by changing directories, which is inconvenient).</p>  <p>C++ has a new <a href="http://en.cppreference.com/w/cpp/experimental/fs" rel="nofollow">filesystem API</a> <a href="https://www.boost.org/doc/libs/1_59_0/libs/filesystem/doc/" rel="nofollow">graduated from boost</a>, which caches <code>stat</code> values but <a href="https://stackoverflow.com/questions/23540985/how-to-get-the-inode-with-boostfilesystem">doesn't expose them</a> (and I need access to st_dev).  This isn't purely a header library, so I can't work around that.</p>  <p>Am I missing a decent C++ option, that uses <code>fstatat</code> and isn't bound by Boost's ideal of not exposing platform-specific calls?  Or is my best option to wrap <code>nftw</code> (or even <code>find</code>)?</p>