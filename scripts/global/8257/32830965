<p>I want my server to communicate with client over Streams and here's how I see that</p>  <pre><code>//Streams I got from SshCommand SocketInputStream clientIn; SocketOutputStream clientOut;  //My process that will be communicate with client Process process; InputStream serverIn = process.getIn(); OutputStream serverOut = process.getOut(); </code></pre>  <p>And then I use <code>copy(InputStream in, OutputStream out)</code> method from <code>google.guava</code> lib</p>  <pre><code>copy(clientIn, serverOut); serverOut.flush(); </code></pre>  <p>As a next step of communication I want to client tell his bytes to the client</p>  <pre><code>copy(serverIn, clientOut); </code></pre>  <p>But if I do this just after <code>client -&gt; server</code> copy client doesn't have anything in his stream yet and that code just freezes, because <code>SocketInputStream</code> is a special implementation of <code>InputStream</code> and it doesn't return <code>0</code> or <code>-1</code> when the stream is empty but wait while that stream's data materializes</p>  <pre><code>in.read(buf)//here isn't any bytes             //and here my code stops working </code></pre>  <p>I've made terrible temporary solution:</p>  <pre><code>public void copy(InputStream in, OutputStream out){     byte[] buf = new byte[4 * 1024];     long total = 0;     while (in.available() &gt; 0) { //stop if nothing is available       int r = from.read(buf);       if (r == -1) {             //this condition isn't working         break;     }   to.write(buf, 0, r);   total += r; } ... for(int i = 0; i &lt; bigNumberOfRepeats; i++){     copy(clientIn, serverOut);     serverOut.flush();     copy(serverIn, clientOut);     clientOut.flush(); } //closing all inputs </code></pre>  <p>By that I just wait some time while client generates data, but it's awful Is there a proper way to do that?</p>