<p>I have an <code>EmguCV.Image&lt;Brg, Byte&gt;()</code> instance and another 3rd party API, that requires <code>Stream</code> that represents the image data.</p>  <p>I was able to convert the EmguCV image to the stream and pass it to the 3rd party API using <code>System.Drawing.Bitmap.Save</code> but that is not very efficient.</p>  <p><strong>How to get the stream as afficietnly as possible?</strong></p>  <p>This code works:</p>  <pre><code>var image = new Image&lt;Rgb, byte&gt;("photo.jpg"); var bitmap = image.Bitmap// System.Drawing - this takes 108ms! using (var ms = new MemoryStream()) {    bitmap.Save(ms, ImageFormat.Bmp); //not very efficient neither    ms.Position = 0;    return ImageUtils.load(ms); //the 3rd party API } </code></pre>  <p>I have tried to create <code>UnmanagedMemoryStream</code> directly from the image:</p>  <pre><code>byte* pointer = (byte*)image.Ptr.ToPointer(); int length = image.Height*image.Width*3; var unmanagedMemoryStream = new UnmanagedMemoryStream(pointer, length); </code></pre>  <p>but when i try to read from it, it throws an <code>AccessViolationException</code>: Attempted to read or write protected memory.</p>  <pre><code>for (int i = 0; i &lt; length; i++) {    //throw AccessViolationException at random interation, e.g i==82240, 79936, etc    unmanagedMemoryStream.ReadByte();      } </code></pre>  <p>the length is 90419328 in this case and it shoudl be correct, because it has the same value as image.ManagedArray.Length;</p>  <p>How to get the stream without copying the data?</p>