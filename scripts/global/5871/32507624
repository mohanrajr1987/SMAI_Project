<p>I know it's bad practice to manually deallocate, so I don't want to do that. Is there a good way to make a class deallocate itself? I wrote a program that makes a template matrix, and overloaded the copy contructor. I want to now implement the move contructor/operator using copy and then deallocating the matrix that's given in the parameter.</p>  <pre><code>template &lt;typename T&gt; class matrix {     private:         int cols;         int rows;         T **array_;      //pointer to array of pointers     public:         ~matrix();          matrix &lt;T&gt; &amp; operator=(const matrix &lt;T&gt; &amp; matr){             CopyMatrix(matr);        //copy, not move             return *this;            //matr still exists         }          matrix&lt;T&gt;(matrix&lt;T&gt; &amp;&amp; matr){     //move contructor             CopyMatrix(matr);             delete matr.array_;        //will this work?         }          matrix &lt;T&gt; &amp; operator=(matrix&lt;T&gt; &amp;&amp; matr){  //move operator             CopyMatrix(matr);             delete matr.array_;        //will this work?             return *this;         } }   template &lt;typename T&gt; matrix &lt;T&gt;::~matrix(){     for (int i = 0; i &lt; rows; i++){         delete [] array_[i];     }     delete array_; } </code></pre>