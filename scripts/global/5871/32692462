<p>Let's say I have a very simple class</p>  <pre><code>class C {      private:         int _a;          int _b;      public:         C (int a, int b) :_a { a }, _b { b } {}         int a () { return _a; }         int b () { return _b; }         bool operator== (C c) {             return this-&gt;_a == c.a() &amp;&amp; this-&gt;_b == c.b();         } }; </code></pre>  <p>and I want to overload the operator <code>+=</code> such that</p>  <pre><code>C foo(8, 42); C bar(1, 1);  C zoo(9, 43); foo += bar; assert(foo == zoo); </code></pre>  <p>runs fine.</p>  <p>As far as I've read other people code, I should write something like</p>  <pre><code>C operator+= (C c) {     return { this-&gt;_a += c.a(), this-&gt;_b += c.b() }; } </code></pre>  <p>but to my understanding, <code>return</code>ing something is useless. Indeed, the assertion above does not fail even when I overload <code>+=</code> as</p>  <pre><code>void operator+= (C c) {     this-&gt;_a += c.a();     this-&gt;_b += c.b(); } </code></pre>  <p>or</p>  <pre><code>C operator+= (C c) {     this-&gt;_a += c.a();     this-&gt;_b += c.b();     return C(0,0); } </code></pre>  <p>TL;DR: <em>why shouldn't I return void when overloading <code>+=</code></em>?</p>