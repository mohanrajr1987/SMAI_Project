<p>We're having trouble passing a pointer reference as a constant, copying the referenced pointer to a non-constant, and sending it to a class function.</p>  <p>This problem has a simple fix: allow the passed parameter to be passed as a non-constant. Unfortunately, this is for a project and the header file must remain unchanged. Here's the basic idea:</p>  <ul> <li>There exists a universe of points; each point is a structure instance that contains dimension and values.</li> <li>There also exist clusters of addresses to points; clusters do not contain instances of the points themselves, but just their location. This allows for overlap in the "contents" of a cluster without duplication of physical data. All points in a cluster are organized by link list; the cluster itself points to the first node, and each node points to the subsequent node until null.</li> </ul>  <p>Thus:</p>  <pre><code>class Point {     int dim;          // number of dimensions of the point     double *values;   // values of the point's dimensions } </code></pre>  <p>and:</p>  <pre><code>typedef Point * PointPtr;          // Points to a point typedef struct LNode * LNodePtr;   // Points to a link node  struct LNode         // Link node structure {     PointPtr p;      // Points to a point     LNodePtr next;   // Points to the next link node };  class Cluster {     int size;     LNodePtr points;  public:     Cluster &amp;operator+=(const Point &amp;rhs);   // Add a point } </code></pre>  <p>We are required to overload the += operator to add a point to a cluster, and were given the above declaration. So far, the only code that somewhat behaves is the following:</p>  <pre><code>Cluster &amp;Cluster::operator+=(const Point &amp;rhs)   // This line is not allowed to change {     PointPtr newPtPtr = new Point(rhs);     this-&gt;add(newPtPtr);   // Adds the point to the cluster     return *this; } </code></pre>  <p>But, this creates a new physical point in the universe.</p>  <p>What we'd like to see work is something along the lines of the following:</p>  <pre><code>Cluster &amp;Cluster::operator+=(const Point &amp;rhs) {     PointPtr newPt = &amp;rhs;   // This could also be type "Point *"     this-&gt;add(newPt);     return *this; } </code></pre>  <p>But I'm receiving an "invalid conversion" message:</p>  <pre><code>error: invalid conversion from 'const Clustering::Point*' to 'Clustering::PointPtr {aka Clustering::Point*}' [-fpermissive]      PointPtr newPt = &amp;rhs; </code></pre>  <p>All I can see that is different is the constant - is there any workaround to capture that referenced pointer address?</p>