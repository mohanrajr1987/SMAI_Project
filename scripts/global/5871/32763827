<p>I am trying to overload the '&lt;&lt;' operator correctly but I keep getting errors when trying to compile.</p>  <p>Below is the code that I have so far:</p>  <p>Sandwich.h:</p>  <pre><code>#ifndef SANDWICH_H_ #define SANDWICH_H_ #include &lt;string&gt; #include &lt;iosfwd&gt;  class Sandwich {     public:         // Constructors         Sandwich(std::string name, float price) : name(name), price(price) {}         Sandwich() : name("Sandwich"), price(0.00) {}          // Accessor Functions         std::string getName() const { return name; }         float getPrice() const { return price; }          // Other Functions         friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Sandwich&amp; object);         friend bool operator==(Sandwich &amp;sandwich1, Sandwich &amp;sandwich2);         friend bool operator!=(Sandwich &amp;sandwich1, Sandwich &amp;sandwich2);         friend bool operator&lt;(Sandwich &amp;sandwich1, Sandwich &amp;sandwich2);         friend bool operator&gt;(Sandwich &amp;sandwich1, Sandwich &amp;sandwich2);          friend bool operator&lt;=(Sandwich &amp;sandwich1, Sandwich &amp;sandwich2);         friend bool operator&gt;=(Sandwich &amp;sandwich1, Sandwich &amp;sandwich2);      private:         // Data Fields         std::string name;         float price; }; #endif </code></pre>  <p>Sandwich.cpp:</p>  <pre><code>#include "Sandwich.h" #include &lt;ostream&gt; using std::ostream;  bool operator==(Sandwich &amp;sandwich1, Sandwich &amp;sandwich2) {     if (sandwich1.getName()==sandwich2.getName() &amp;&amp; sandwich1.getPrice()==sandwich2.getPrice())     {         return true;     }     else     {         return false;     } }  bool operator!=(Sandwich &amp;sandwich1, Sandwich &amp;sandwich2) {     if (sandwich1.getName()!=sandwich2.getName() &amp;&amp; sandwich1.getPrice()!=sandwich2.getPrice())     {         return true;     }     else     {         return false;     } }  bool operator&lt;(Sandwich &amp;sandwich1, Sandwich &amp;sandwich2) {     if (sandwich1.getPrice()&lt;sandwich2.getPrice())     {         return true;     }     else     {         return false;     } }  bool operator&gt;(Sandwich &amp;sandwich1, Sandwich &amp;sandwich2) {     if (sandwich1.getPrice()&gt;sandwich2.getPrice())     {         return true;     }     else     {         return false;     } }  bool operator&lt;=(Sandwich &amp;sandwich1, Sandwich &amp;sandwich2) {     if (sandwich1.getPrice()&lt;=sandwich2.getPrice())     {         return true;     }     else     {         return false;     } }  bool operator&gt;=(Sandwich &amp;sandwich1, Sandwich &amp;sandwich2) {     if (sandwich1.getPrice()&gt;=sandwich2.getPrice())     {         return true;     }     else     {         return false;     } }  ostream&amp; operator&lt;&lt;(ostream&amp; os, const Sandwich&amp; object) {     os &lt;&lt; "Sandwich name: " &lt;&lt; object.getName &lt;&lt; "\nSandwich price: " &lt;&lt; object.getPrice &lt;&lt; '\n';     return os; } </code></pre>  <p>This class will eventually be the base class for 4 subclasses. I am trying to make make sure this works before going on, but it won't compile correctly and the errors that I am getting are:</p>  <pre><code>Sandwich.cpp: In function ‘std::ostream&amp; operator&lt;&lt;(std::ostream&amp;, const Sandwich&amp;)’: Sandwich.cpp:86:26: error: no match for ‘operator&lt;&lt;’ (operand types are ‘std::basic_ostream&lt;char&gt;’ and ‘&lt;unresolved overloaded function type&gt;’)   os &lt;&lt; "Sandwich name: " &lt;&lt; object.getName &lt;&lt; "\nSandwich price: " &lt;&lt; object.getPrice &lt;&lt; '\n';                           ^ </code></pre>  <p>Plus a bunch of possible candidates. </p>  <p>Not quite sure where I went wrong, I thought I had properly overloaded the operator.</p>