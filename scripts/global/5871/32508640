<p>I am attempting to fix the following:</p>  <pre><code>val temp1 = (3, "hello") val temp2 = (2, "abcde") temp1 &lt;= temp2 </code></pre>  <p>which returns the error</p>  <pre><code>&lt;console&gt;:24: error: value &lt;= is not a member of (Int, String)               temp1 &lt;= temp2                     ^ </code></pre>  <p>I've tried adding the following to my code:</p>  <pre><code>implicit val tempOrdering = new Ordering[(Int, String)] {   override def compare(a: (Int, String), b: (Int, String)): Int =     {     if      (a._1 &lt; b._1) { -1 }     else if (a._1 &gt; b._1) { 1 }     else if (a._2 &lt; b._2) { -1 }     else if (a._2 &gt; b._2) { 1 }     else 0     }   override def lteq(a: (Int, String), b: (Int, String)): Boolean = compare(a, b) &lt;= 0 }  implicit val tempPartialOrdering = new PartialOrdering[(Int, String)] {   override def tryCompare(a: (Int, String), b: (Int, String)): Option[Int] = {     if      (a._1 &lt; b._1) { Some(-1) }     else if (a._1 &gt; b._1) { Some(1) }     else if (a._2 &lt; b._2) { Some(-1) }     else if (a._2 &gt; b._2) { Some(1) }     else Some(0)   }   override def lteq(x: (Int, String), y: (Int, String)) = {     tryCompare(x, y).map(_ &lt;= 0).getOrElse(false)   } } </code></pre>  <p>and temp1 &lt;= temp2 still does not work.</p>  <p>I am able to run commands such as</p>  <pre><code>List(temp1, temp2).min </code></pre>  <p>but not</p>  <pre><code>min(temp1, temp2) </code></pre>  <p>so it seems that scala is not seeing my declaration of ordering for (Int, String) tuples.</p>  <p>I can reference my declaration using</p>  <pre><code>tempPartialOrdering.lteq(temp1, temp2) </code></pre>  <p>and some of my coworkers have suggested making a new class just for (Int, String) tuples, but I find these solutions inelegant.  I would REALLY like to be able to use the plain old "&lt;=" comparison operator!</p>  <p>Does anyone know what I'm doing wrong, that "&lt;=" is still not a member of (Int, String)?  Is there a way to implicitly set this?</p>