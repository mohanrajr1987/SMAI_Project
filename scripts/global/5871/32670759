<p>I can't figure out how to get a <code>std::string</code> reference into an <code>std::unordered_map</code> using a <code>std::reference_wrapper</code>.  Per the following link I understand I need to overload <code>operator==</code>.</p>  <p><a href="http://stackoverflow.com/questions/8513050/why-can-template-instances-not-be-deduced-in-stdreference-wrappers">Why can template instances not be deduced in `std::reference_wrapper`s?</a></p>  <p>However, I can't figure out how to write <code>operator==</code> such that it will take a <strong>const</strong> <code>std::reference_wrapper</code>.  If the wrapper were not <strong>const</strong> it would not be a problem.</p>  <p>Using a char instead of <code>std::string</code> works fine (doesn't require overloading <code>operator==</code>).</p>  <p>Code:</p>  <pre><code>#include &lt;iostream&gt; #include &lt;unordered_map&gt; #include &lt;functional&gt;  bool operator==(const std::reference_wrapper&lt;std::string&gt; lhs,                 const std::reference_wrapper&lt;std::string&gt; rhs) {     return std::equal_to&lt;std::string&gt;()(lhs.get(), rhs.get()); }  int main(){     char        chr('a');     std::string str("b");     int         num(1);      // this works (char)     std::unordered_map&lt;std::reference_wrapper&lt;char&gt;, int, std::hash&lt;char&gt;&gt; charMap;     std::pair&lt;std::reference_wrapper&lt;char&gt;, int&gt; charPair(chr , num);     charMap.insert(charPair);     std::cout &lt;&lt; "charMap works.  Output: " &lt;&lt; charMap[chr] &lt;&lt; std::endl;      // does not work (std::string)     std::unordered_map&lt;std::reference_wrapper&lt;std::string&gt;, int, std::hash&lt;std::string&gt;&gt; stringMap;     std::pair&lt;std::reference_wrapper&lt;std::string&gt;, int&gt; stringPair(str , num);     stringMap.insert(stringPair);  // compile error } </code></pre>  <p>Compile error:</p>  <pre><code>error: no match for ‘operator==’ (operand types are ‘const std::reference_wrapper&lt;std::__cxx11::basic_string&lt;char&gt; &gt;’ and ‘const std::reference_wrapper&lt;std::__cxx11::basic_string&lt;char&gt; &gt;’)        { return __x == __y; } </code></pre>