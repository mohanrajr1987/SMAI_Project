<p>I am coding in C++ in Microsoft Visual studio and I'm trying to overload the + binary operator as a non-member function to use with objects of my class Statistician so that I can add two of these objects and assign the result to a third object  like for example (Statistician sumObjects = s + b;) but all I'm getting are error messages. in the header file The line that starts with keyword friend is part of the overloading </p>  <pre><code>/******************/ /***    HEADER  ***/ /******************/  //File : statisticiantADT.h #ifndef A_Statistician #define A_Statistician   namespace Statistician_operator_overload  //done in header and      implementation { class Statistician { public:     //constructor     Statistician();      //Friend function     // overloaded operators      friend Statistician operator +(const Statistician&amp; param_P1, const Statistician&amp; param_P2);      //mutator (a.k.a   Setter)     void next_number(double p_newItem);     void eraseAll();      //accessors  (a.k.a   Getter)     int length() const;     //Post-condition: returns 0 if empty sequence     double lastNumber() const;     //Precondition: Non-empty sequence     double sum() const;     //Post-condition: return 0 if empty sequence     double arithmeticMeans() const;     //Precondition: Non-empty sequence     double smallestNumber() const;     //Precondition: Non-empty sequence     double largestNumber() const;     //Precondition: Non-empty sequence  private:     int m_length;     double m_last;     double m_sum;     double m_arithmeticMeans;     double m_smallest;     double m_largest;   };   //NONMEMBER FUNCTIONS for the Statistician class  //I tried this line below instead of the line above which starts  w/ friend      Statistician...... but didn't help //Statistician operator +(const Statistician&amp; param_P1, const Statistician&amp; param_P2);  }   //end of namespace  #endif </code></pre>  <p>in the implementation file you will see my attempt to implement the overloading of the +  which in Microsoft Visual Studio has an error message every time I use the object name sum except for (Statistician sum();) Error: expression must have class type </p>  <p>Also getting an error on the return line for the implementation of the overloading function which says  Error (active)      no suitable constructor exists to convert from "Statistician_operator_overload::Statistician ()" to "Statistician_operator_overload::Statistician"</p>  <pre><code>/**************************/ /***    IMPLEMENTATION  ***/ /**************************/ // just adding every library I can think of  #include &lt;string&gt; #include &lt;cassert&gt; #include &lt;cstdlib&gt; #include &lt;iomanip&gt;  //Implementation: Class Statistician #include "statisticiantADT.h" #include &lt;iostream&gt; #include &lt;cfloat&gt;    namespace Statistician_operator_overload   //done in header and  implementation {  /***    CONSTRUCTOR ***/ Statistician::Statistician() {     m_length = 0;     m_last = 0.0;     m_sum = 0.0;     m_arithmeticMeans = 0.0;     m_smallest = DBL_MAX; //macro constant from cfloat header     m_largest = 0.0; }    //overloading the  +  operator for use with Statistician objects Statistician operator +(const Statistician&amp; param_P1, const Statistician&amp;     param_P2) // Postcondition: The Sum of param_P1 and param_P2 is returned {     Statistician sum(); //object to store the sum of the to paramiter  objects     //assigning summed member variables      sum.m_length = param_P1.m_length + param_P2.m_length;     sum.m_last = param_P2.m_last;     sum.m_sum = param_P1.m_sum + param_P2.m_sum;     //member variable m_arithmeticMeans     if ((param_P1.m_length &gt; 0)||(param_P2.m_length &gt; 0))     sum.m_arithmeticMeans = (param_P1.m_sum + param_P2.m_sum)/(param_P1.m_length + param_P2.m_length);     else         sum.m_arithmeticMeans = 0.0;     //member variable m_smallest     if (param_P1.m_smallest &lt; param_P2.m_smallest)         sum.m_smallest = param_P1.m_smallest;     else         sum.m_smallest = param_P2.m_smallest;     //member variable m_largest     if (param_P1.m_largest &gt; param_P2.m_largest)         sum.m_largest = param_P1.m_largest;     else         sum.m_largest = param_P2.m_largest;      return sum;  }    //  void Statistician::eraseAll() {     m_length = 0.0;     m_last = 0.0;     m_sum = 0.0;     m_arithmeticMeans = 0.0;     m_smallest = 0.0;     m_largest = 0.0; }  /***     MUTATORS   ***/  //setters void Statistician::next_number(double p_newItem) {     m_length++;     m_last = p_newItem;     m_sum += p_newItem;     if (m_length &gt; 0) //         m_arithmeticMeans = m_sum / m_length;     else         m_arithmeticMeans = 0.0;       if (p_newItem &lt; m_smallest)         m_smallest = p_newItem;     if (p_newItem &gt; m_largest)         m_largest = p_newItem; }   /***    ACCESSORS   ***/   //getters int Statistician::length() const //Postcondition: returns 0 if empty sequence {     return m_length; }  double Statistician::lastNumber() const //Precondition: Non-empty sequence {     return m_last; }  double Statistician::sum() const //Post-condition: return 0 if empty sequence {     return m_sum; }  double Statistician::arithmeticMeans() const //Precondition: Non-empty sequence   {     if (m_length &gt; 0)         return m_sum / m_length;     else         return 0.0;  }  double Statistician::smallestNumber() const //Precondition: Non-empty sequence {     return m_smallest; }  double Statistician::largestNumber() const //Precondition: Non-empty sequence {     return m_largest; }  }//end of namespace </code></pre>  <p>Here is the Driver bellow  In the driver referring to line:(cout &lt;&lt; "Sum: " &lt;&lt; s.sum() &lt;&lt; endl;) I'm getting this error message Error  C2064   term does not evaluate to a function taking 1 arguments </p>  <pre><code>/******************/ /***    DRIVER  ***/ /******************/ //File: driver.cp // just adding every library I can think of  #include &lt;string&gt; #include &lt;cassert&gt; #include &lt;cstdlib&gt; #include &lt;iomanip&gt;   #include &lt;cfloat&gt; #include "statisticiantADT.h" #include &lt;iostream&gt; using namespace std; using namespace Statistician_operator_overload; //or should I ??? using Statistician_operator_overload::Statistician;   int main() {     Statistician s;     Statistician b;       cout &lt;&lt; "Before any input..." &lt;&lt; endl;     cout &lt;&lt; "Length = " &lt;&lt; s.length() &lt;&lt; endl;     cout &lt;&lt; "Sum = " &lt;&lt; s.sum() &lt;&lt; endl &lt;&lt; endl;      cout &lt;&lt; "After adding three values to the sequence: 1.1, -2.4, 0.8..."         &lt;&lt; endl;     s.next_number(1.1);     s.next_number(-2.4);     s.next_number(0.8);      cout &lt;&lt; "Length: " &lt;&lt; s.length() &lt;&lt; endl;     cout &lt;&lt; "Last item: " &lt;&lt; s.lastNumber() &lt;&lt; endl;     cout &lt;&lt; "Sum: " &lt;&lt; s.sum() &lt;&lt; endl;     cout &lt;&lt; "Arithmetic means: " &lt;&lt; s.arithmeticMeans() &lt;&lt; endl;     cout &lt;&lt; "Smallest: " &lt;&lt; s.smallestNumber() &lt;&lt; endl;     cout &lt;&lt; "Largest: " &lt;&lt; s.largestNumber() &lt;&lt; endl;       //testing the overloaded +     Statistician sumObjects = s + b;      cout &lt;&lt; "Length: " &lt;&lt; sumObjects.length() &lt;&lt; endl;     cout &lt;&lt; "Last item: " &lt;&lt; sumObjects.lastNumber() &lt;&lt; endl;     cout &lt;&lt; "Sum: " &lt;&lt; sumObjects.sum() &lt;&lt; endl;     cout &lt;&lt; "Arithmetic means: " &lt;&lt; sumObjects.arithmeticMeans() &lt;&lt; endl;     cout &lt;&lt; "Smallest: " &lt;&lt; sumObjects.smallestNumber() &lt;&lt; endl;     cout &lt;&lt; "Largest: " &lt;&lt; sumObjects.largestNumber() &lt;&lt; endl;      /*       //Test eraseAll     cout &lt;&lt; "\n\nErasing the sequence..." &lt;&lt; endl;     cout &lt;&lt; "Checking all values..." &lt;&lt; endl;     s.eraseAll();     cout &lt;&lt; "Length: " &lt;&lt; s.length() &lt;&lt; endl;     cout &lt;&lt; "Last item: " &lt;&lt; s.lastNumber() &lt;&lt; endl;     cout &lt;&lt; "Sum: " &lt;&lt; s.sum() &lt;&lt; endl;     cout &lt;&lt; "Arithmetic means: " &lt;&lt; s.arithmeticMeans() &lt;&lt; endl;     cout &lt;&lt; "Smallest: " &lt;&lt; s.smallestNumber() &lt;&lt; endl;     cout &lt;&lt; "Largest: " &lt;&lt; s.largestNumber() &lt;&lt; endl;  */       return 0; } </code></pre>