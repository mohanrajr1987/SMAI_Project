<p>Suppose I can do <code>ostream &lt;&lt; Intermediate</code> and I can do <code>Intermediate &lt;&lt; Example</code>, can I do <code>ostream &lt;&lt; Example</code> without adding a special overloading of <code>operator&lt;&lt;</code> from <code>Example</code> to <code>ostream</code>? Alternatively, is there any other approach I can use to support both serialization/deserialization using a intermediate class and still remove boilerplate? The following was my attempt:</p>  <pre><code>#include &lt;iostream&gt; #include &lt;sstream&gt;  using namespace std;  class Intermediate { };  ostream &amp; operator&lt;&lt;(ostream &amp;stream, const Intermediate&amp; intermediate) {   (void)intermediate;   return stream; }  istream &amp; operator&gt;&gt;(istream &amp;stream, const Intermediate&amp; intermediate) {   (void)intermediate;   return stream; }  class Example { };  Intermediate &amp; operator&lt;&lt;(Intermediate &amp;intermediate, const Example &amp;example) {   (void)example;   return intermediate; }  Intermediate &amp; operator&gt;&gt;(Intermediate &amp;intermediate, Example &amp;example) {   (void)example;   return intermediate; }  int main() {   stringstream stream;   Intermediate intermediate;   Example example;    intermediate &lt;&lt; example; // WORKS   stream &lt;&lt; intermediate; // WORKS    stream &lt;&lt; example; // ERROR    return 0; } </code></pre>  <p>The error is <code>cannot bind ‘std::basic_ostream&lt;char&gt;’ lvalue to ‘std::basic_ostream&lt;char&gt;&amp;&amp;’</code>. <code>c++11</code> compiler is enabled.</p>