<p>Basically I don't understand when we need to use * and &amp; when defining methods or overload operators for self-defined classes. I've searched this site (including the suggested 'answer') and read a few books, but still I don't think I get it. I know </p>  <blockquote>   <p>A* pt</p> </blockquote>  <p>refers to a pointer named pt that points to a variable of type 'A', and </p>  <blockquote>   <p>'&amp;abc' </p> </blockquote>  <p>is just reference a of variable abc which can directly change the value of abc. (Correct me if I am wrong).</p>  <p>But I have don't know why sometimes we need to use * or &amp; when defining classes. The following is a typical example of a class for complex number taken from a reference book. </p>  <p>1) Why do we need &amp; after the first 'ComplexNumber' when overloading the assignment operator?  2) Why do need &amp; for the argument when overloading binary operator? 3) For the case of overloading the &lt;&lt; operator, I just have no idea what individual part means. 4) Sometimes I see * instead of &amp; in the beginning. Does it mean that the method returns a pointer?</p>  <p>Basically I want to know why we need &amp; or * and what happens if I don't use * or &amp;.</p>  <pre><code>ComplexNumber::ComplexNumber()  // Constructor {     mRealPart = 0.0;     mImaginaryPart = 0.0; }  // Overloading the = (assignment) operator ComplexNumber&amp; ComplexNumber::operator=(const ComplexNumber&amp; z)   // Why do we need '&amp;' after the first 'ComplexNumber'? { mRealPart = z.mRealPart; mImaginaryPart = z.mImaginaryPart; return *this; }  // Overloading the unary - operator ComplexNumber ComplexNumber::operator-() const {     ComplexNumber w;     w.mRealPart = -mRealPart;     w.mImaginaryPart = -mImaginaryPart;     return w; }  // Overloading the binary + operator ComplexNumber ComplexNumber::operator+(const ComplexNumber&amp; z) const  // Why do we need &amp; for the argument z? {     ComplexNumber w;     w.mRealPart = mRealPart + z.mRealPart;     w.mImaginaryPart = mImaginaryPart + z.mImaginaryPart;     return w; }  // Overloading the insertion &lt;&lt; operator std::ostream&amp; operator&lt;&lt;(std::ostream&amp; output, const ComplexNumber&amp; z)  // why do we need the argument 'output'? what does it do?  { // Format as "(a + bi)" or as "(a - bi)" output &lt;&lt; "(" &lt;&lt; z.mRealPart &lt;&lt; " "; if (z.mImaginaryPart &gt;= 0.0) {     output &lt;&lt; "+ " &lt;&lt; z.mImaginaryPart &lt;&lt; "i)"; } else {     // z.mImaginaryPart &lt; 0.0     // Replace + with minus sign     output &lt;&lt; "- " &lt;&lt; -z.mImaginaryPart &lt;&lt; "i)"; } </code></pre>