<p>I am using the following code which I got from github <a href="https://github.com/hanks-zyh/AnimateCheckBox" rel="nofollow">link</a>.</p>  <p>TouchCheckBox.java</p>  <pre><code>public class TouchCheckBox extends View {  private Paint mCirclePaint; private Paint mCorrectPaint; private int radius; private int width, height; private int cx, cy;                     private float[] points = new float[6]; private float correctProgress; private boolean isChecked; private boolean isAnim; private int animDurtion = 150;  private OnCheckedChangeListener listener; private int unCheckColor = Color.GRAY; private int circleColor = Color.RED;  public TouchCheckBox(Context context) {     this(context, null); }  public TouchCheckBox(Context context, AttributeSet attrs) {     this(context, attrs, 0); }  public TouchCheckBox(Context context, AttributeSet attrs, int defStyleAttr) {     super(context, attrs, defStyleAttr);     init(context);  }  @TargetApi(Build.VERSION_CODES.LOLLIPOP) public TouchCheckBox(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) {     super(context, attrs, defStyleAttr, defStyleRes); }  private void init(Context context) {      mCirclePaint = new Paint(Paint.ANTI_ALIAS_FLAG);     mCirclePaint.setColor(Color.RED);     mCirclePaint.setStyle(Paint.Style.FILL);      mCorrectPaint = new Paint(Paint.ANTI_ALIAS_FLAG);     mCorrectPaint.setColor(Color.WHITE);     mCorrectPaint.setStyle(Paint.Style.FILL);     mCorrectPaint.setStrokeWidth(dip2px(context, 2));     setOnClickListener(new OnClickListener()     {         @Override         public void onClick(View v)         {             if (isChecked)             {                 hideCorrect();             } else              {                 showCheck();             }         }     }); }   public void setChecked(boolean checked) {     if (isChecked &amp;&amp; !checked)     {         hideCorrect();     }     else if(!isChecked &amp;&amp; checked)     {         showCheck();     } }   public boolean isChecked(){     return isChecked; }   @Override protected void onSizeChanged(int w, int h, int oldw, int oldh) {     super.onSizeChanged(w, h, oldw, oldh);     height = width = Math.min(w - getPaddingLeft() - getPaddingRight(),h - getPaddingBottom() - getPaddingTop());     cx = w / 2;     cy = h / 2;      float r = height / 2f;     points[0] = r / 2f + getPaddingLeft();     points[1] = r + getPaddingTop();      points[2] = r * 5f / 6f + getPaddingLeft();     points[3] = r + r / 3f + getPaddingTop();      points[4] = r * 1.5f +getPaddingLeft();     points[5] = r - r / 3f + getPaddingTop();     radius = (int) (height * 0.125f); }  @Override protected void onDraw(Canvas canvas) {      float f = (radius -height * 0.125f) / (height * 0.5f);     mCirclePaint.setColor(evaluate(f,unCheckColor,circleColor));     canvas.drawCircle(cx, cy, radius, mCirclePaint);       if(correctProgress&gt;0) {         if(correctProgress&lt;1/3f) {             float x = points[0] + (points[2] - points[0]) * correctProgress;             float y = points[1] + (points[3] - points[1]) * correctProgress;             canvas.drawLine(points[0], points[1], x, y, mCorrectPaint);         }else {             float x = points[2] + (points[4] - points[2]) * correctProgress;             float y = points[3] + (points[5] - points[3]) * correctProgress;             canvas.drawLine(points[0], points[1], points[2], points[3], mCorrectPaint);             canvas.drawLine(points[2], points[3], x,y, mCorrectPaint);         }     } }    public void setCircleColor(int color){     circleColor = color; }   public void setCorrectColor(int color){     mCorrectPaint.setColor(color); }   public void setUnCheckColor(int color){     unCheckColor = color; }  private int evaluate(float fraction, int startValue, int endValue) {     int startInt = startValue;     int startA = (startInt &gt;&gt; 24) &amp; 0xff;     int startR = (startInt &gt;&gt; 16) &amp; 0xff;     int startG = (startInt &gt;&gt; 8) &amp; 0xff;     int startB = startInt &amp; 0xff;      int endInt = endValue;     int endA = (endInt &gt;&gt; 24) &amp; 0xff;     int endR = (endInt &gt;&gt; 16) &amp; 0xff;     int endG = (endInt &gt;&gt; 8) &amp; 0xff;     int endB = endInt &amp; 0xff;      return ((startA + (int) (fraction * (endA - startA))) &lt;&lt; 24)             | ((startR + (int) (fraction * (endR - startR))) &lt;&lt; 16)             | ((startG + (int) (fraction * (endG - startG))) &lt;&lt; 8)             | ((startB + (int) (fraction * (endB - startB)))); }  private void showUnChecked() {     Log.i("TCB","showUnChecked");     if (isAnim)     {         return;     }      isAnim = true;     ValueAnimator va = ValueAnimator.ofFloat(0, 1).setDuration(animDurtion);     va.setInterpolator(new LinearInterpolator());     va.start();     va.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {         @Override         public void onAnimationUpdate(ValueAnimator animation) {             float value = (float) animation.getAnimatedValue(); // 0f ~ 1f             radius = (int) ((1 - value) * height * 0.375f + height * 0.125f);             if (value &gt;= 1) {                 isChecked = false;                 isAnim = false;                 if(listener!=null){                     listener.onCheckedChanged(TouchCheckBox.this,false);                 }             }             invalidate();         }     }); }  private void showCheck() {     Log.i("TCB","showCheck");     if (isAnim) {         return;     }     isAnim = true;     ValueAnimator va = ValueAnimator.ofFloat(0, 1).setDuration(animDurtion);     va.setInterpolator(new LinearInterpolator());     va.start();     va.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {         @Override         public void onAnimationUpdate(ValueAnimator animation) {             float value = (float) animation.getAnimatedValue(); // 0f ~ 1f             radius = (int) (value * height * 0.37f + height * 0.125f);             if (value &gt;= 1) {                 isChecked = true;                 isAnim = false;                 if(listener!=null){                     listener.onCheckedChanged(TouchCheckBox.this,true);                 }                 showCorrect();             }             invalidate();         }     }); }  private void showCorrect() {     Log.i("TCB","showCorrect");     if (isAnim) {         return;     }     isAnim = true;     ValueAnimator va = ValueAnimator.ofFloat(0, 1).setDuration(animDurtion);     va.setInterpolator(new LinearInterpolator());     va.start();     va.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {         @Override         public void onAnimationUpdate(ValueAnimator animation) {             float value = (float) animation.getAnimatedValue(); // 0f ~ 1f             correctProgress = value;             invalidate();             if(value&gt;=1){                 isAnim = false;             }         }     }); } private void hideCorrect() {     Log.i("TCB","hideCorrect");     if (isAnim) {         return;     }     isAnim = true;     ValueAnimator va = ValueAnimator.ofFloat(0, 1).setDuration(animDurtion);     va.setInterpolator(new LinearInterpolator());     va.start();     va.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {         @Override         public void onAnimationUpdate(ValueAnimator animation) {             float value = (float) animation.getAnimatedValue(); // 0f ~ 1f             correctProgress = 1-value;             invalidate();             if(value&gt;=1){                 isAnim = false;                 showUnChecked();             }         }     }); }  public void setOnCheckedChangeListener(OnCheckedChangeListener listener) {     this.listener = listener; }  public interface OnCheckedChangeListener {     void onCheckedChanged(View buttonView, boolean isChecked); }   public static int dip2px(Context context, float dpValue) {     final float scale = context.getResources().getDisplayMetrics().density;     return (int) (dpValue * scale + 0.5f); }   public static int px2dip(Context context, float pxValue) {     final float scale = context.getResources().getDisplayMetrics().density;     return (int) (pxValue / scale + 0.5f); } } </code></pre>  <p>I want the view to be static at first view any only animate when I press on it. I have no idea how to draw without animation. I have no idea about drawing anything programmatically. </p>