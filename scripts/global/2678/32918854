<p><strong>First, some background:</strong></p>  <p>I'm working on a project which requires me to simulate interactions between objects that can be thought of as polygons (usually triangles or quadrilaterals, almost certainly fewer than seven sides), each side of which is composed of the radius of two circles with a variable (and possibly zero) number of 'rivers' of various constant widths passing between them, and out of the polygon through some other side. As these rivers and circles and their widths (and the positions of the circles) are specified at runtime, one of these polygons with N sides and M rivers running through it can be completely described by an array of N+2M pointers, each referring to the relevant rivers/circles, starting from an arbitrary corner of the polygon and passing around (in principal, since rivers can't overlap, they should be specifiable with less data, but in practice I'm not sure how to implement that).</p>  <p>I was originally programming this in Python, but quickly found that for more complex arrangements performance was unacceptably slow. In porting this over to C++ (chosen because of its portability and compatibility with SDL, which I'm using to render the result once optimization is complete) I am at somewhat of a loss as to how to deal with the polygon structure.</p>  <p>The obvious thing to do is to make a class for them, but as C++ lacks even runtime-sized arrays or multi-type arrays, the only way to do this would be with a ludicrously cumbersome set of vectors describing the list of circles, rivers, and their relative placement, or else an even more cumbersome 'edge' class of some kind. Rather than this, it seems like the better option is to use a much simpler, though still annoying, vector of void pointers, each pointing to the rivers/circles as described above.</p>  <p><strong>Now, the question:</strong></p>  <p>If I am correct, the proper way to handle the relevant memory allocations here with the minimum amount of confusion (not saying much...) is something like this:</p>  <pre><code>int doStuffWithPolygons(){     std::vector&lt;std::vector&lt;Void *&gt;&gt; polygons;     while(/*some circles aren't assigned a polygon*/){         std::vector&lt;Void *&gt; polygon;         void *start = &amp;/*next circle that has not yet been assigned a polygon*/;         void *lastcircle = start;         void *nextcircle;         nextcircle = &amp;/*next circle to put into the polygon*/;         while(nextcircle != start){             polygon.push_back(lastcircle);             std::vector&lt;River *&gt; rivers = /*list of rivers between last circle and next circle*/;             for(unsigned i = 0; i &lt; rivers.size(); i++){                 polygon.push_back(rivers[i]);             lastcircle = nextcircle;             nextcircle = &amp;/*next circle to put into the polygon*/;         polygons.push_back(polygon);      int score = 0;     //do whatever you're going to do to evaluate the polygons here     return score; }  int main(){     int bestscore = 0;     std::vector&lt;int&gt; bestarrangement; //contains position of each circle     std::vector&lt;int&gt; currentarrangement = /*whatever arbitrary starting arrangement is appropriate*/;     while(/*not done evaluating polygon configurations*/){         //fiddle with current arrangement a bit         int currentscore = doStuffWithPolygons()         if(currentscore &gt; bestscore){             bestscore = currentscore;             bestarrangement = currentarrangement;      //somehow report what the best arrangement is      return 0; } </code></pre>  <p>If I properly understand how this stuff is handled, I shouldn't need any delete or .clear() calls because everything goes out of scope after the function call. Am I correct about this? Also, is there any part of the above that is needlessly complex, or else is insufficiently complex? Am I right in thinking that this is as simple as C++ will let me make it, or is there some way to avoid some of the roundabout construction?</p>  <p>And if you're response is going to be something like 'don't use void pointers' or 'just make a polygon class', unless you can explain how it will make the problem <strong>simpler</strong>, save yourself the trouble. I am the only one who will ever see this code, so I don't care about adhering to best practices. If I forget how/why I did something and it causes me problems later, that's my own fault for insufficiently documenting it, not a reason to have written it differently.</p>  <p><strong>edit</strong> Since at least one person asked, here's my original python, handling the polygon creation/evaluation part of the process:</p>  <pre><code>#lots of setup stuff, such as the Circle and River classes  def evaluateArrangement(circles, rivers, tree, arrangement): #circles, rivers contain all the circles, rivers to be placed. tree is a class describing which rivers go between which circles, unrelated to the problem at hand. arrangement contains (x,y) position of the circles in the current arrangement.     polygons = []     unassignedCircles = range(len(circles))     while unassignedCircles:         polygon = []         start = unassignedCircles[0]         lastcircle = start         lastlastcircle = start         nextcircle = getNearest(start,arrangement)         unassignedCircles.pop(start)         unassignedCircles.pop(nextcircle)         while(not nextcircle = start):             polygon += [lastcircle]             polygon += getRiversBetween(tree, lastcircle,nextcircle)             lastlastcircle = lastcircle             lastcircle = nextcircle;             nextcircle = getNearest(lastcircle,arrangement,lastlastcircle) #the last argument here guarantees that the new nextcircle is not the same as the last lastcircle, which it otherwise would have been guaranteed to be.             unassignedCircles.pop(nextcircle)         polygons += [polygon]     return EvaluatePolygons(polygons,circles,rivers) #defined outside. </code></pre>