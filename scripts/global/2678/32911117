<p>I'm having a problem for a few days that I can resolve. I got some old code from HPUX that i'm trying to put to work on Linux (RedHAT), and for some reason I cant use more than 2000 elements of one arry.</p>  <p>The array is a struct and where is definition</p>  <pre><code>struct str_item {          char   item [20];          double value;          char valueString [20];   }; </code></pre>  <p>The arry is part of a class </p>  <pre><code>struct str_item **dpstr_valuesCalc; </code></pre>  <p>And in the code</p>  <pre><code>while (dpstr_valuesCalc[li_pos])    {   if (!strcmp (itemStr, dpstr_valuesCalc[li_pos]-&gt;item)) return 0;   li_pos++;   }    dpstr_valuesCalc[li_pos] = new struct str_item;    strcpy (dpstr_valuesCalc[li_pos]-&gt;item, itemStr);    dpstr_valuesCalc[li_pos]-&gt;value = 0;    strcpy (dpstr_valuesCalc [li_pos]-&gt;valueString, valueString); </code></pre>  <p>And using gdb </p>  <pre><code>while (dpstr_valuesCalc[li_pos]) (gdb) p li_pos  $38 = 2000    (gdb) p dpstr_valuesCalc[li_pos]  &lt;--   $39 = (str_item *) 0x0            &lt;-- No new so it's 0  (gdb) p dpstr_valuesCalc[li_pos+1]  &lt;-- How this is something?  $40 = (str_item *) 0x91             &lt;-- Where this come from?  dpstr_valuesCalc[li_pos] = new struct str_item;  (gdb) p dpstr_valuesCalc[li_pos]     $41 = (str_item *) 0xaebd70   &lt;-- new valide str_item  (gdb) p dpstr_valuesCalc[li_pos+1]    $42 = (str_item *) 0x91             &lt;-- Still where  strcpy (dpstr_valuesCalc [li_pos]-&gt;item, itemStr);  dpstr_valuesCalc[li_pos]-&gt;value = value;  strcpy (dpstr_valuesCalc[li_pos]-&gt;valueString, ""); (gdb) p *dpstr_valuesCalc[li_pos] $43 = {item = "Test",'\000' &lt;repeats 15 times&gt;, valor = 12, valorString = '\000' &lt;repeats 19 times&gt;} (gdb) p *dpstr_valoresCalculados [li_pos+1] Cannot access memory at address 0x91 </code></pre>  <p>And later on the code</p>  <pre><code>while (dpstr_valuesCalc[li_pos]) &lt;-- in dpstr_valuesCalc [2001] is valid because (str_item *) 0x91 So it goes to  {   if (!strcmp (itemStr, dpstr_valuesCalc[li_pos]-&gt;item)) return 0; And  Program received signal SIGSEGV, Segmentation fault. __strcmp_sse2 () at ../sysdeps/x86_64/strcmp.S:213  movlpd  (%rsi), %xmm2 </code></pre>  <p>Its seems that is a memory problem, perhaps no more heap?  But if I understand malloc_stats there is still memory,  system bytes-in use bytes, its right?</p>  <pre><code>(gdb) call malloc_stats() Arena 0: system bytes     =    1200128 in use bytes     =    1195040 Total (incl. mmap): system bytes     =    1814528 in use bytes     =    1809440 max mmap regions =          3 max mmap bytes   =     614400 </code></pre>  <p>Regarding the SO i think that I don't have a problem</p>  <pre><code>ulimit -a core file size          (blocks, -c) 0 data seg size           (kbytes, -d) unlimited scheduling priority             (-e) 0 file size               (blocks, -f) unlimited pending signals                 (-i) 31192 max locked memory       (kbytes, -l) 64 max memory size         (kbytes, -m) unlimited open files                      (-n) 1024 pipe size            (512 bytes, -p) 8 POSIX message queues     (bytes, -q) 819200   real-time priority              (-r) 0 stack size              (kbytes, -s) 8192 cpu time               (seconds, -t) unlimited max user processes              (-u) 4096 virtual memory          (kbytes, -v) unlimited file locks                      (-x) unlimited </code></pre>  <p>Perhaps a linker definition? must use -fPIC?</p>  <p>And I read this</p>  <hr>  <ol start="13"> <li>Arrays indexing</li> </ol>  <p>This kind of errors is separated from the others for better structuring of the account because indexing in arrays with the usage of square brackets is just a different record of address arithmetic observed before.</p>  <p>Programming in C and then C++ has formed a practice to use variables of int/unsigned types in the constructions of the following kind:</p>  <pre><code>unsigned Index = 0; while (MyBigNumberField[Index] != id)  Index++; </code></pre>  <p>But time passes and everything changes. And now it's a high time to say - do not do this anymore! Use memsize types for indexing (large) arrays.</p>  <p>The given code won't process an array containing more than UINT_MAX items in a 64-bit program. After the access to the item with UNIT_MAX index an overflow of the Index variable will occur and we'll get infinite loop.</p>  <p>To persuade you entirely in the necessity of using only memsize types for indexing and in the expressions of address arithmetic, I'll give the last example</p>  <hr>  <p>On <a href="http://www.viva64.com/en/a/0004/#ID0E65AM" rel="nofollow">http://www.viva64.com/en/a/0004/#ID0E65AM</a></p>  <p>Can this by my problem??</p>  <p>Any help is appreciated </p>