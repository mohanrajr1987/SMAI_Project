<p>I've been trying to identify the root cause for this access violation issue for a month. But I ended up here asking help. </p>  <p>On a high level the problem is heap corruption. If I dig into further i'm getting these exceptions either during allocating memory on heap(using new) or deallocating memory (using delete). These problems were occuring only on production environments. I found these details by analysing the core dump files. I'm not able to simulate these issues in local. In one of those core dump files i found the following line of code triggering the access violation issue. <strong>this->token = new Byte[obj.tokenLength];</strong> here tokenLength is 972. </p>  <p>What would be the reason for throwing the access violation while requesting  some amount of memory for my execution. As far as I know when i call malloc with some n bytes, either the kernel has to provide the requested n bytes or has to reject and throw BAD_ALLOC exception. What is the point here to throw the access violation exception. </p>  <p>This is the call stack found in the core dump files. The last line is what calling the <strong>this->token = new Byte[obj.tokenLength];</strong>.</p>  <pre><code>ntdll.dll!@RtlpAllocateHeap@24()   Unknown ntdll.dll!_RtlAllocateHeap@12()    Unknown ntdll.dll!@RtlpAllocateUserBlock@12()  Unknown ntdll.dll!@RtlpLowFragHeapAllocFromContext@8() Unknown ntdll.dll!_RtlAllocateHeap@12()    Unknown caconnector.dll!malloc(unsigned int size=972) Line 163  C caconnector.dll!operator new(unsigned int size=972) Line 59 C++ caconnector.dll!GLSPlatformSessionInfo::GLSPlatformSessionInfo(const GLSPlatformSessionInfo &amp; obj={...}) Line 282 </code></pre>  <p>Please help me with the proper direction of analysis where i can focus on now to identify the root cause of this issue.</p>  <p>Thanks in advance.</p>