<p>I am trying to understand the output of the following code. </p>  <pre><code>#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt;  main() {     int *p = (int *) malloc(sizeof(int));     *p = 42;     *(p+1) = 41;      printf("%d -- %d\n", *p, p);     printf("%d\n", p[0]);     printf("%d -- %d\n", p[1], p+1);      free(p);      printf("%d --- %d\n", *p, p);     printf("%d --- %d\n", p[1], p+1); } </code></pre>  <p>My understanding, step by step, is as follows:</p>  <pre><code>int *p = (int *) malloc(sizeof(int)); </code></pre>  <p><em>p</em> now points to a block of memory returned by <em>malloc</em>.</p>  <pre><code>*p = 42; </code></pre>  <p>Store the value <em>42</em> in the location returned by <em>malloc</em>.</p>  <pre><code>*(p+1) = 41; </code></pre>  <p>Store the value <em>41</em> in the location directly adjacent to that returned by <em>malloc</em>.</p>  <pre><code>free(p); </code></pre>  <p>Free the space pointed to by <em>p</em>, which was originally obtained by a call to <em>malloc</em>, i.e, the location of the int <em>42</em>.</p>  <p>The results:</p>  <pre><code>42 -- 14327824 42 41 -- 14327828 0 --- 14327824 0 --- 14327828 </code></pre>  <p>My understanding is that the address <em>14327824</em> was returned by <em>malloc</em>. When the statement <pre>*(p+1) = 41;</pre> Is executed, the value <em>41</em> has been stored in a block <strong>not returned</strong> by <em>malloc</em>, i.e. <em>p+1</em>.</p>  <p>When free is called, I understand that it frees the space pointed to by <em>p</em>, i.e., the value <em>42</em>. Why then, is the value stored at <em>p+1</em> freed as well?</p>  <p>Also, if <em>malloc</em> returns a pointer <em>pt</em> to a block of uninitialized storage. Is the location <em>pt+1</em> beyond the bounds of the storage area set by <em>malloc</em>? </p>