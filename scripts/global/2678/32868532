<p>This is very similar to <a href="http://stackoverflow.com/q/1044785/608639">auto_ptr for arrays</a>. However, my wrinkle is I don't want an initialized array, which is what a <code>vector</code> would provide (the <code>const T&amp; value = T()</code>):</p>  <pre><code>explicit vector(size_type count,     const T&amp; value = T(),     const Allocator&amp; alloc = Allocator()); </code></pre>  <p>I don't want the array initialized because its a large array and the values will be immediately discarded.</p>  <p>I'm currently hacking it with the following, but it feels like something is wrong with it:</p>  <pre><code>//! deletes an array on the heap. template &lt;class T&gt; class AutoCleanup { public:     AutoCleanup(T*&amp; ptr) : m_ptr(ptr) { }     ~AutoCleanup() { if (m_ptr) { delete[] m_ptr; m_ptr = NULL; }}  private:     T*&amp; m_ptr; }; </code></pre>  <p>And:</p>  <pre><code>// AutoCleanup due to Enterprise Analysis finding on the stack based array. byte* plaintext = new byte[20480]; AutoCleanup&lt;byte&gt; cleanup(plaintext);  // Do something that could throw... </code></pre>  <p>What does C++ provide for an array of a POD type that is uninitialized and properly deleted?</p>  <hr>  <p>The project is C++03, and it has no external dependencies, like Boost.</p>