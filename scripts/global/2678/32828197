<p>I have a data parsing application I have been working on and given the sheer size of the text files it is reading, controlling memory usage is key for good performance. The two part strategy here first measures how much RAM each file would contribute to the sum total, but it also needs to know how much RAM is available to the application at a given point in time. If enough RAM is available, the application opts to do its processing in memory. Otherwise, it switches to a mode that performs all or most of the operations on disk.</p>  <p>Measuring a file's contribution to memory usage is quick and easy:</p>  <pre><code>    static Int64 GetSizeInMemory(string path)     {         //THIS CODE IS SPEEDY         Int64 r = ((Func&lt;Int64&gt;)(                     () =&gt;                         {                             try                             {                                 using (Stream s = new MemoryStream())                                 {                                     BinaryFormatter formatter = new BinaryFormatter();                                     formatter.Serialize(s, File.ReadAllLines(path));                                     return s.Length;                                 }                             }                             catch                             {                                 //this file is way too big                                 return -1;                             }                         }                 ))();         GC.Collect();         GC.WaitForPendingFinalizers();         return r;     } </code></pre>  <p>However, measuring the total amount of memory available is slow and difficult. In this case, I attempted to do so by trapping the stack overflow error, which in my thinking should give the most reliable figure.</p>  <pre><code>    static Int64 GetMaxAllowedMemory()     {         //THIS CODE IS SLOW         Int64 r = ((Func&lt;Int64&gt;)(                     () =&gt;                         {                             byte[] b = new byte[]{};                             Int64 rs = 0;                             while (true)                             {                                 try                                 {                                     Array.Resize&lt;byte&gt;(ref b, b.Length + 1);                                     b[b.Length - 1] = new byte();                                     rs = b.Length;                                 } catch (Exception e) {                                     break;                                 }                             }                             b = null;                             return rs;                         }                 ))();         GC.Collect();         GC.WaitForPendingFinalizers();         return r;     } </code></pre>  <p>Is there a better approach I should be using here?</p>  <p><strong>Please note</strong> I have looked at a number of questions similar to this one on Stack Overflow, but most deal only with obtaining a figure for the total amount of available RAM on the computer, which is not the same as the maximum amount of RAM a .NET process is allowed at runtime.</p>  <p><strong>UPDATE</strong></p>  <p>After receiving an answer, I came up with the following that allows me to get the total amount of RAM available to the application.</p>  <pre><code>    static Int64 GetMemoryFailPoint()     {         Int64 r = ((Func&lt;Int64&gt;)(                     () =&gt;                     {                         int rs = 1;                         while (true)                         {                             try                             {                                 using (new System.Runtime.MemoryFailPoint(rs))                                 {                                 }                             }                             catch {                                 break;                             }                             rs++;                         }                         return Convert.ToInt64(rs) * 1000000;                     }                 ))();         return r;     } </code></pre>