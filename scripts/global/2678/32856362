<p>When I ran a program, my console output showed the following: <strong>malloc(): memory corruption (fast)</strong> and was followed by what seemed like an address in memory. I have narrowed it down to a few functions, but I feel that I free all memory that I allocate properly. </p>  <p>The following function takes a string representing a file name.</p>  <pre><code>void readAndProcessFile(char* filename){      FILE *fileptr;     char* word = malloc(32*sizeof(char));      fileptr = fopen(filename, "r");      while(fscanf(fileptr,"%s",word) != EOF){         processWord(word);     }      fclose(fileptr);     free(word); } </code></pre>  <p>This function takes a word, removes any non-alphabetic characters and changes all letters to uppercase.</p>  <pre><code>void processWord(char* text){     char* processedWord;     processedWord = trimAndCaps(text);      if(processedWord != NULL &amp;&amp; processedWord[0] != '\0'){         addWord(processedWord);     }     free(processedWord); } </code></pre>  <p>Here's the trim and cap function</p>  <pre><code>char* trimAndCaps(char* text) {     int i = 0;     int j = 0;     char currentChar;     char* rv = malloc(sizeof(text));      while ((currentChar = text[i++]) != '\0')     {         if (isalpha(currentChar))         {             rv[j++] = toupper(currentChar);         }     }     rv[j] = '\0';      return rv; } </code></pre>  <p>And just for good measure here's the addWord function</p>  <pre><code>void addWord(char* word) {     // check if word is already in list     struct worddata* currentWord = findWord(word);      // word is in list     if(currentWord != NULL)     {         incrementCount(currentWord);     }     // word is not in list     else     {         currentWord = malloc(sizeof(struct worddata));         currentWord-&gt;count = 1;         strcpy(currentWord-&gt;word, word);         ll_add(wordList, currentWord, sizeof(struct worddata));         free(currentWord);     } } </code></pre>  <p>As you can see, all instances where I manually allocate memory, I free afterwards. This program works when there is a smaller amount of words, but not for larger. My thought process leads me to believe that there is some sort of leak, but when I have few enough words to the point that I can run it, I run the following code:</p>  <pre><code>// The following code will print out the final dynamic memory used struct mallinfo veryend = mallinfo(); fprintf(stderr, "Final Dynamic Memory used : %d\n", veryend.uordblks); </code></pre>  <p>And this shows a 0 every time for memory used. What else can cause this? Any direction or fixes are much appreciated.</p>