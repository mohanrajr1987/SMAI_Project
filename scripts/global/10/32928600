<p><strong>Background</strong></p>  <p>I am new to C++ and I am working to create an object in c++ where the object can be both an array or pointer. I need to create a UNION method that can combines two BagInterface objects. I am having trouble correcting my code so that it can compile using pointers. Any help would be greatly appreciated. </p>  <p><strong>Compile Error:</strong> </p>  <pre><code> In file included from main.cpp:3:0:  BagInterface.h:64:9: error: expected ':' before 'BagInterface'  In file included from LinkedBag.h:43:0,              from main.cpp:5:  LinkedBag.cpp: In member function 'BagInterface&lt;ItemType&gt;* LinkedBag&lt;ItemType&gt;::Union(BagInterface&lt;ItemType&gt;*)':  LinkedBag.cpp:116:26: error: expected unqualified-id before '=' token  LinkedBag.cpp:123:3: error: 'tBagPtr' was not declared in this scope  LinkedBag.cpp:133:3: error: 'tBagPtr' was not declared in this scope  LinkedBag.cpp:136:9: error: 'tBagPtr' was not declared in this scope </code></pre>  <p><strong>main.pp File (method):</strong> </p>  <pre><code>void bagTesterHW(BagInterface&lt;string&gt;* bagPtr) { //Clear Bag To Set Up Test Cases bagPtr-&gt;clear();  //Test Clear //displayBag(bagPtr);   //Second Array Bag BagInterface&lt;string&gt;* bagPtr2 = new LinkedBag&lt;string&gt;(); BagInterface&lt;string&gt;* bagPtr3 = new LinkedBag&lt;string&gt;();  //LinkedBag&lt;string&gt; bagPtr2;  //LinkedBag&lt;string&gt; bagPtr3;   //Test Case Strings string items1[] = { "two", "two", "three", "four" }; string items2[] = { "two", "four" };  //Filling Linked List for (int i = 0; i &lt; 4; i++) {     bagPtr-&gt;add(items1[i]); } // end for   for (int i = 0; i &lt; 2; i++) {     //bagPtr2.add(items2[i]); //LinkedBag     bagPtr2-&gt;add(items2[i]); } // end for  displayBag(bagPtr);  displayBag(bagPtr2);  /*Problem Code Union function not defined in Parent Object*/ bagPtr3 = bagPtr-&gt;Union(bagPtr2);   displayBag(bagPtr3);   /*Release Memory*/ bagPtr2 = nullptr;  bagPtr3 = nullptr;  /*Delete Pointers*/ delete bagPtr2;  delete bagPtr3;   cout &lt;&lt; "--------end bagTesterHW---------" &lt;&lt; endl;}  </code></pre>  <p><strong>LinkedBag.cpp (method)</strong></p>  <pre><code>template&lt;class ItemType&gt; BagInterface&lt;ItemType&gt;* LinkedBag&lt;ItemType&gt;::Union(BagInterface&lt;ItemType&gt;* bagPtr) { BagInterface&lt;ItemType&gt;* = new LinkedBag&lt;ItemType&gt; tBagPtr;  vector&lt;ItemType&gt; bagItems; bagItems = toVector();  for (int i = 0; i &lt; bagItems.size(); i++) {     tBagPtr-&gt;add(bagItems[i]); } // end for   //Clear Items bagItems.clear(); bagItems = bagPtr-&gt;toVector();   for (int i = 0; i &lt; bagItems.size(); i++) {     tBagPtr-&gt;add(bagItems[i]); } // end for  return tBagPtr; } </code></pre>  <p><strong>LinkedBag.h</strong></p>  <pre><code>#ifndef _LINKED_BAG #define _LINKED_BAG  #include "BagInterface.h" #include "Node.h"  template&lt;class ItemType&gt; class LinkedBag : public BagInterface&lt;ItemType&gt; { private: Node&lt;ItemType&gt;* headPtr; // Pointer to first node int itemCount;           // Current count of bag items  Node&lt;ItemType&gt;* getPointerTo(const ItemType&amp; target) const;  public: LinkedBag(); LinkedBag(const LinkedBag&lt;ItemType&gt;&amp; aBag); // Copy constructor virtual ~LinkedBag();                       // Destructor should be virtual int getCurrentSize() const; bool isEmpty() const; bool add(const ItemType&amp; newEntry); bool remove(const ItemType&amp; anEntry); void clear(); bool contains(const ItemType&amp; anEntry) const; int getFrequencyOf(const ItemType&amp; anEntry) const; vector&lt;ItemType&gt; toVector() const; BagInterface&lt;ItemType&gt;* Union(BagInterface&lt;ItemType&gt;* bagPtr);   }; // end LinkedBag  #include "LinkedBag.cpp" #endif </code></pre>  <p><strong>BagInterface.h (abstract) snippit</strong></p>  <pre><code>#ifndef _BAG_INTERFACE #define _BAG_INTERFACE #include &lt;vector&gt; using namespace std;  template&lt;class ItemType&gt; class BagInterface {  public: /** Gets the current number of entries in this bag. @return The integer number of entries currently in the bag. */ virtual int getCurrentSize() const = 0; . . . /** Empties and then f ills a given vector with all entries that are in this bag.  @return  A vector containing all the entries in the bag. */   virtual vector&lt;ItemType&gt; toVector() const = 0;  /** Creates a new bag that combines the contents of this bag and a  second given bag without affecting the original two bags.  @param anotherBag The given bag.  @return A bag that is the union of the two bags. */   //public BagInterface&lt;ItemType&gt; union(BagInterface&lt;ItemType&gt; anotherBag);  public BagInterface&lt;ItemType&gt;* Union(BagInterface&lt;ItemType&gt;* bagPtr);  .  .   .  };  #endif </code></pre>