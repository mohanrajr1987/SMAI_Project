<p>I am having an issue with getting a user string passed in as a variable parsed so that each word is in it's own variable. Below is my attempt at this, there is another part of the program called client.c that is requesting user input, once I type in a string in the client "foo 123 anwhere blah" it gets passed into the server program below as the variable "buf". Once I have it I make a copy of it into temp so I don't damage the original string (at least at this point in testing). Then I run the strctok against the variable trying to parse out each word.</p>  <p>If i'm even on the right track with this at the moment it will compile with no errors and run, however when I send data to it from the client it throws a "segmentation fault (core dumped), can anyone shed any light as to why?</p>  <p>THANK YOU</p>  <pre><code>        /*  * server.c */  #include &lt;stdio.h&gt; #include &lt;iostream&gt; #include &lt;strings.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt; #include &lt;netinet/in.h&gt; #include &lt;arpa/inet.h&gt;  #include &lt;netdb.h&gt; #include &lt;cstring&gt; #include &lt;cstdlib&gt;  using namespace std;  #define SERVER_PORT 1617  #define MAX_PENDING 5 #define MAX_LINE 256  int main(int argc, char **argv) {  struct sockaddr_in sin; socklen_t addrlen; char buf[MAX_LINE]; int len; int s; int new_s; char *temp; char fname[32], lname[32], city[32], zip[32], country[32];  /* build address data structure */ bzero((char *)&amp;sin, sizeof(sin)); sin.sin_family = AF_INET; sin.sin_addr.s_addr = INADDR_ANY; sin.sin_port = htons (SERVER_PORT);  /* setup passive open */ if (( s = socket (AF_INET, SOCK_STREAM, 0)) &lt; 0) {     perror("socket");     exit(1); }  if ((bind(s, (struct sockaddr *) &amp;sin, sizeof(sin))) &lt; 0) {     perror("bind");     exit(1); }  listen (s, MAX_PENDING);  addrlen = sizeof(sin); cout &lt;&lt; "The server is up, waiting for connection" &lt;&lt; endl;  /* wait for connection, then receive and print text */ while (1) {     if ((new_s = accept(s, (struct sockaddr *)&amp;sin, &amp;addrlen)) &lt; 0) {         perror("accept");         exit(1);     }     cout &lt;&lt; "new connection from " &lt;&lt; inet_ntoa(sin.sin_addr) &lt;&lt; endl;      while (len = recv(new_s, buf, sizeof(buf), 0)) {          temp = buf;         strcpy(fname, strtok(buf , " "));             strcpy(lname, strtok(NULL, " "));             strcpy(city , strtok(NULL, " "));             strcpy(zip , strtok(NULL, " "));             strcpy(country, strtok(NULL, " "));               printf("%s\n", fname);             printf("%s\n", lname);             printf("%s\n", city);             printf("%s\n", zip);             printf("%s\n", country);           /* send (new_s, temp, strlen(temp) + 1, 0); */     }      close(new_s); } </code></pre>  <p>}                                                                      </p>