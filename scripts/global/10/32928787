<p>I am attempting to destruct a shared_ptr one-by-one, yet when I destruct the last pointer, the use_count() goes nuts. Observe my code:</p>  <pre><code>#include &lt;iostream&gt; #include &lt;memory&gt;   int main() {      int * val = new int(5);     std::shared_ptr&lt;int&gt; myPtr = std::make_shared&lt;int&gt;(*val);      myPtr.~__shared_ptr();  } </code></pre>  <p>Will produce the following output in the debugger:</p>  <pre><code>myPtr value: 5  myPtr.use_count():8787448 // Or some other large int </code></pre>  <p>I was hoping on the final destruction it would set the use_count() to 0 and deallocate the memory for the integer. It appears none of this is happening.</p>  <p>I could if() statement this when the use_count() == 1, but this seems very inelegant. Does anyone know of another solution? </p>