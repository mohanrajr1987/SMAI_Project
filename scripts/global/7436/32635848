<p>I modified a function in objective C to throw errors. I then want to catch these errors in Swift. I implemented the Bridging function, and it looks that everything is in order.  I am getting the error: </p>  <blockquote>   <p>Consecutive statements on a line must be separated by ';'</p> </blockquote>  <p>just right after the command: </p>  <pre><code>try rfduino.send(data) </code></pre>  <p>If I don't use <code>try</code>, it starts asking me for a second parameter. The function worked before I implemented this error handling. I am using XCode 6.4. </p>  <p>I also read in <a href="http://blog.benjamin-encz.de/swift-error-handling-and-objective-c-interop-in-depth/" rel="nofollow">http://blog.benjamin-encz.de/swift-error-handling-and-objective-c-interop-in-depth/</a>  that XCode only translate the function to a Swift-like error throwing function when the function returns a BOOL or an ObjectiveC type. I also tried that. </p>  <p>What can it be? </p>  <p>My .h file looks like: </p>  <pre><code>- (BOOL)send:(NSData *)data        error:(NSError**) errorPtr; </code></pre>  <p>in .m file: </p>  <pre><code>- (BOOL)send:(NSData *)data        error:(NSError**)errorPtr {     if (! loadedService) {          if (errorPtr) {             *errorPtr = [NSError errorWithDomain:NSCocoaErrorDomain                                             code:NSFileNoSuchFileError                                         userInfo:@{NSLocalizedDescriptionKey:  NSLocalizedString(@"No Device Connected.", nil),                                                    NSLocalizedFailureReasonErrorKey: NSLocalizedString(@"The connection is not loaded.", nil),                                                    NSLocalizedRecoverySuggestionErrorKey: NSLocalizedString(@"Try disconnecting and connecting again", nil)                                                    }];         } else {             @throw [NSException exceptionWithName:@"sendDataNoDevice" reason:@"please wait for ready callback" userInfo:nil];         }         return(NO);     }      if ([data length] &gt; max_data) {         if (errorPtr) {             *errorPtr = [NSError errorWithDomain:NSCocoaErrorDomain                                             code:NSFileNoSuchFileError                                         userInfo:@{NSLocalizedDescriptionKey:  NSLocalizedString(@"No Device Connected.", nil),                                                    NSLocalizedFailureReasonErrorKey: NSLocalizedString(@"The connection is not loaded.", nil),                                                    NSLocalizedRecoverySuggestionErrorKey: NSLocalizedString(@"Try disconnecting and connecting again", nil)                                                    }];         } else {             @throw [NSException exceptionWithName:@"sendDataTooLarge" reason:@"max data size exceeded" userInfo:nil];         }         return(NO);     }      [peripheral writeValue:data forCharacteristic:send_characteristic type:CBCharacteristicWriteWithoutResponse];     return(YES); } </code></pre>  <p>thanks! </p>