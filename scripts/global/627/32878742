<p>I realize there are a ton of these posts, but none them, believe it or not, resolve my problem.  </p>  <p>I have the following code here that uses the ManagementEventWatcher class to kill a process from another in house app if it runs too long, which it occasionally does and kills the cpu. </p>  <p>Anyway, it gets this error instantaneously when starting the service. Nothing in the event log. Currently I have it testing with notepad.exe.  </p>  <pre><code>public AppXKiller()         {             InitializeComponent();              this.ServiceName = "AppXKiller";             this.EventLog.Log = "Application";              // These Flags set whether or not to handle that specific             //  type of event. Set to true if you need it, false otherwise.             this.CanHandlePowerEvent = true;             this.CanHandleSessionChangeEvent = true;             this.CanPauseAndContinue = true;             this.CanShutdown = true;             this.CanStop = true;          }          static void Main()         {             ServiceBase.Run(new AppXKiller());         }          protected override void OnStart(string[] args)         {             registerWatcher();         }          protected override void OnContinue()         {             base.OnContinue();         }          public void registerWatcher()         {             string pol = "2";             string appName = "notepad.exe";              string queryString =                 "SELECT *" +                 "  FROM __InstanceOperationEvent " +                 "WITHIN  " + pol +                 " WHERE TargetInstance ISA 'Win32_Process' " +                 "   AND TargetInstance.Name = '" + appName + "'";              // You could replace the dot by a machine name to watch to that machine             string scope = @"\\.\root\CIMV2";              // create the watcher and start to listen             ManagementEventWatcher watcher = new ManagementEventWatcher(scope, queryString);             watcher.EventArrived += new EventArrivedEventHandler(this.OnEventArrived);             watcher.Start();         }          private void OnEventArrived(object sender, EventArrivedEventArgs e)         {             Thread.Sleep(20000);             Process[] localByName = Process.GetProcessesByName("notepad");              if (localByName.Length &gt; 0)             {                 localByName[0].Kill();             }         }          protected override void OnStop()         {          }     } </code></pre>