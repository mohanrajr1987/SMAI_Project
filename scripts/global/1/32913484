<p>Given a database schema with two tables: <code>Company</code> and <code>Employee</code>, where the <code>Employee</code> table has a foreign key to the <code>Company</code> table, what is the correct code to change the company a particular employee is associated with?</p>  <p><strong>Method 1:</strong></p>  <pre><code>company1.Employees.Remove(employee); company2.Employees.Add(employee); </code></pre>  <blockquote>   <p><strong>Problem:</strong></p>      <p>This appears to work but is horribly inefficient as the reference to <code>company1.Employees</code> loads all of the employees for <code>company1</code>, and the reference to <code>company2.Employees</code> loads all of the employees for <code>company2</code>.</p> </blockquote>  <p><strong>Method 2:</strong></p>  <pre><code>employee.Company = company2; </code></pre>  <blockquote>   <p><strong>Problem:</strong></p>      <p>Raises the exception: <em>Multiplicity constraint violated. The role 'Companies' of the relationship 'XXX.FK_Employee_Companies' has multiplicity 1 or 0..1.</em></p> </blockquote>  <p><strong>Method 3:</strong></p>  <pre><code>employee.CompanyId = company2.Id; </code></pre>  <blockquote>   <p><strong>Problem:</strong></p>      <p>For me, this does not change the value of the <code>CompanyId</code> column in the database. It still has the value it had previously.</p> </blockquote>  <p>I'm working with well-tested code in a large application that uses my <em>Method 1</em> and I am trying to optimize it after performance issues have been found. I understand there may be other factors that influence the results I am getting. I am looking for someone with more insight into the inner workings of Entity Framework to suggest how they would approach this.</p>  <hr>  <p><strong>EDIT:</strong></p>  <p>I've now been told by more than one person that my <em>Method 1</em> does not load all related employees. But I have run multiple tests on this that show that it does. I've even created a simple test application. Here is my code.</p>  <pre><code>var website = context.Websites.FirstOrDefault(); var ranking = website.Rankings.FirstOrDefault(); </code></pre>  <p>Seems that some people assume the second line will only load one row from the <code>Rankings</code> table. However, here are the queries generated:</p>  <pre><code>SELECT TOP (1)  [c].[ID] AS [ID],  [c].[Title] AS [Title],  [c].[URL] AS [URL],  [c].[AliasForID] AS [AliasForID],  [c].[ActiveState] AS [ActiveState],  [c].[Alert] AS [Alert] FROM [dbo].[Website] AS [c] </code></pre>  <p>And:</p>  <pre><code>exec sp_executesql N'SELECT  [Extent1].[ID] AS [ID],  [Extent1].[WebsiteID] AS [WebsiteID],  [Extent1].[PageRank] AS [PageRank],  [Extent1].[AlexaRank] AS [AlexaRank],  [Extent1].[AlexaReach] AS [AlexaReach],  [Extent1].[DateAdded] AS [DateAdded] FROM [dbo].[Ranking] AS [Extent1] WHERE [Extent1].[WebsiteID] = @EntityKeyValue1',N'@EntityKeyValue1 int',@EntityKeyValue1=1 </code></pre>  <p>Note the second query. It returns all rows from the <code>Ranking</code> table that are linked to the <code>Website</code> entity. It does not filter to return only the first row. In the same way, accessing <code>company1.Employees</code> to call the <code>Add()</code> method will load all employees related to <code>company1</code> because <code>Website.Rankings</code> is of type <code>ICollection&lt;&gt;</code> and not <code>IQueryable&lt;&gt;</code>.</p>  <p>Lazy loading is completely unrelated. Lazy loading simply means that the collection is not loaded until the code references this collection (or any other property that refers to data from a related table). But once the code references this collection, all related entities are loaded.</p>  <p>I would love someone to show me how this is untrue or how to prevent this. So far, the only people who are saying it is untrue are not willing to back it up and/or just insult me when I asked them to back up their claims. Not understanding how this works can lead to major performance problems.</p>