<p>I run the filesystem with the <code>-d</code> flag, everything goes well, except when a read operation is to be performed, then the filesystem crashes with the error </p>  <blockquote>   <p>139701621372568:error:06065064:digital envelope routines:EVP_DecryptFinal_ex:bad decrypt:evp_enc.c:534:</p> </blockquote>  <p>I am using the same key and IV that I used to encrypt the data. I don't understand as to why I am getting this error.</p>  <p>Read Function:</p>  <pre><code>int csfs_read(const char *path, char *buf, size_t size, off_t offset,     struct fuse_file_info *fi) {     int retstat = 0, p_len, pending = 0;     log_msg(             "\ncsfs_read(path=\"%s\", buf=0x%08x, size=%d, offset=%lld, fi=0x%08x)\n",             path, buf, size, offset, fi);     // no need to get fpath on this one, since I work from fi-&gt;fh not the path     log_fi(fi);     char p_text[size];     retstat = pread(fi-&gt;fh, buf, size, offset);     p_len = csfs_decrypt(&amp;buf, size, &amp;key, &amp;iv, &amp;p_text);     if (p_len != size) {         pending = size - p_len;         pread(fi-&gt;fh, buf, pending, offset+size-1);         p_len += csfs_decrypt(&amp;buf, pending, &amp;key, &amp;iv, &amp;p_text[p_len-1]);     }     memcpy(buf, p_text,p_len);     return retstat; } </code></pre>  <p>Write Function:</p>  <pre><code>int csfs_write(const char *path, const char *buf, size_t size, off_t offset,     struct fuse_file_info *fi) {     int retstat = 0;     int buf_len = 0;     int ebuf_len = 0;     int c_len;     buf_len = (strlen((char*) buf));     const char ebuf[buf_len + (16 - (buf_len) % 16)];     log_msg(             "\ncsfs_write(path=\"%s\", buf=0x%08x, size=%d, offset=%lld, fi=0x%08x)\n",             path, buf, size, offset, fi);     // no need to get fpath on this one, since I work from fi-&gt;fh not the path     log_fi(fi);      c_len = csfs_encrypt(&amp;buf, buf_len, &amp;key, &amp;iv, &amp;ebuf);     retstat = pwrite(fi-&gt;fh, ebuf, c_len, offset);     if (retstat &lt; 0)         retstat = csfs_error("csfs_write pwrite");      return size; } </code></pre>  <p>Decryption function:</p>  <pre><code>int csfs_decrypt(unsigned char *ciphertext, int ciphertext_len, unsigned      char *key, unsigned char *iv, unsigned char *plaintext) {      EVP_CIPHER_CTX *ctx;    int len;    int plaintext_len;    /* Create and initialise the context */   if(!(ctx = EVP_CIPHER_CTX_new())) handleErrors();     if(1 != EVP_DecryptInit_ex(ctx, EVP_aes_256_cbc(), NULL, key, iv))     handleErrors();     if(1 != EVP_DecryptUpdate(ctx, plaintext, &amp;len, ciphertext, ciphertext_len))     handleErrors();   plaintext_len = len;    /* Finalise the decryption. Further plaintext bytes may be written at    * this stage.    */   if(1 != EVP_DecryptFinal_ex(ctx, plaintext + len, &amp;len)) handleErrors();   plaintext_len += len;    /* Clean up */   EVP_CIPHER_CTX_free(ctx);    return plaintext_len; } </code></pre>  <p>Encryption Function:</p>  <pre><code>   int csfs_encrypt(unsigned char *plaintext, int plaintext_len, unsigned char *key,   unsigned char *iv, unsigned char *ciphertext) {   EVP_CIPHER_CTX *ctx;    int len;    int ciphertext_len;    /* Create and initialise the context */   if(!(ctx = EVP_CIPHER_CTX_new())) handleErrors();     if(1 != EVP_EncryptInit_ex(ctx, EVP_aes_256_cbc(), NULL, key, iv))     handleErrors();     if(1 != EVP_EncryptUpdate(ctx, ciphertext, &amp;len, plaintext, plaintext_len))     handleErrors();   ciphertext_len = len;     if(1 != EVP_EncryptFinal_ex(ctx, ciphertext + len, &amp;len)) handleErrors();   ciphertext_len += len;    /* Clean up */   EVP_CIPHER_CTX_free(ctx);   printf("%d\n",ciphertext_len);   return ciphertext_len; } </code></pre>